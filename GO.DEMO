/*

This is sample output from translating the Minimal code for SPITBOL to the declarations
and variables needed to effect interpreation of the abstract target machine MAM.

Thie file is both a stress-test for how Go handles initializers and a demonstration
of the use of Go as an assembler.

That the Go compiler is able to compile the file is, in our view, an impressive feat,
and we here wish to thank the Gophers who made this possible for all their hard work.

*/
package main
const  opcodes (
	nop = iota
	add
	adi
	adr
	anb
	aov
	atn
	bct
	beq
	bev
	bge
	bgt
	bhi
	ble
	blo
	blt
	bne
	bnz
	bod
	bri
	brn
	bsw
	btw
	bze
	call
	ceq
	chk
	chp
	cmb
	cmc
	cmp
	cne
	cos
	csc
	ctb
	ctw
	cvd
	cvm
	dca
	dcv
	dvi
	dvr
	enp
	ent
	erb
	err
	esw
	eti
	etx
	exi
	flc
	ica
	icp
	icv
	ieq
	ige
	igt
	ile
	ilt
	ine
	ino
	inr
	iov
	itr
	jmp
	jsr
	jsrerr
	lch
	lcp
	lct
	lcw
	ldi
	ldr
	lea
	lei
	lnf
	load
	loadcfp
	loadi
	lsh
	lsx
	mcb
	mfi
	mli
	mlr
	mnz
	mov
	move
	mti
	mvc
	mvw
	mwb
	ngi
	ngr
	nzb
	orb
	plc
	pop
	popr
	ppm
	prc
	psc
	push
	pushi
	pushr
	realop
	req
	rge
	rgt
	rle
	rlt
	rmi
	rne
	rno
	rov
	rsh
	rsx
	rti
	rtn
	sbi
	sbr
	sch
	scp
	sin
	sqr
	ssl
	sss
	sti
	stmt
	store
	str
	sub
	sys
	tan
	trc
	wtb
	xob
	zer
	zrb
)
//sec01
//	inr	arref
//	inr	cfunc
//	inr	exfal
//	inr	exint
//	inr	exits
//	inr	exixr
//	inr	exnam
//	inr	exnul
//	inr	exrea
//	inr	exsid
//	inr	exvnm
//	inr	failp
//	inr	flpop
//	inr	indir
//	inr	match
//	inr	retrn
//	inr	stcov
//	inr	stmgo
//	inr	stopr
//	inr	succp
//	inr	sysab
//	inr	systu
const (
	cfp_a = 256
	cfp_b = 8
	cfp_c = 8
	cfp_f = 16
	cfp_i = 1
	cfp_m = 9223372036854775807
	cfp_n = 64
	cfp_r = 1
	cfp_s = 9
	cfp_x = 3
	mxdgs = cfp_s+cfp_x
	nstmx = mxdgs+5
	cfp_u = 128
	e_srs = 100
	e_sts = 1000
	e_cbs = 500
	e_hnb = 257
	e_hnw = 3
	e_fsp = 15
	e_sed = 25
	ch_la = 97
	ch_lb = 98
	ch_lc = 99
	ch_ld = 100
	ch_le = 101
	ch_lf = 102
	ch_lg = 103
	ch_lh = 104
	ch_li = 105
	ch_lj = 106
	ch_lk = 107
	ch_ll = 108
	ch_lm = 109
	ch_ln = 110
	ch_lo = 111
	ch_lp = 112
	ch_lq = 113
	ch_lr = 114
	ch_ls = 115
	ch_lt = 116
	ch_lu = 117
	ch_lv = 118
	ch_lw = 119
	ch_lx = 120
	ch_ly = 121
	ch_l_ = 122
	ch_d0 = 48
	ch_d1 = 49
	ch_d2 = 50
	ch_d3 = 51
	ch_d4 = 52
	ch_d5 = 53
	ch_d6 = 54
	ch_d7 = 55
	ch_d8 = 56
	ch_d9 = 57
	ch_am = 38
	ch_as = 42
	ch_at = 64
	ch_bb = 60
	ch_bl = 32
	ch_br = 124
	ch_cl = 58
	ch_cm = 44
	ch_dl = 36
	ch_dt = 46
	ch_dq = 34
	ch_eq = 61
	ch_ex = 33
	ch_mn = 45
	ch_nm = 35
	ch_nt = 126
	ch_pc = 94
	ch_pl = 43
	ch_pp = 40
	ch_rb = 62
	ch_rp = 41
	ch_qu = 63
	ch_sl = 47
	ch_sm = 59
	ch_sq = 39
	ch_u_ = 95
	ch_ob = 91
	ch_cb = 93
	ch_ht = 9
	ch_ey = 94
	ch_ua = 65
	ch_ub = 66
	ch_uc = 67
	ch_ud = 68
	ch_ue = 69
	ch_uf = 70
	ch_ug = 71
	ch_uh = 72
	ch_ui = 73
	ch_uj = 74
	ch_uk = 75
	ch_ul = 76
	ch_um = 77
	ch_un = 78
	ch_uo = 79
	ch_up = 80
	ch_uq = 81
	ch_ur = 82
	ch_us = 83
	ch_ut = 84
	ch_uu = 85
	ch_uv = 86
	ch_uw = 87
	ch_ux = 88
	ch_uy = 89
	ch_uz = 90
	iodel = 32
	offs1 = 1
	offs2 = 2
	offs3 = 3
	bl_ar = 0
	bl_cd = bl_ar+1
	bl_ex = bl_cd+1
	bl_ic = bl_ex+1
	bl_nm = bl_ic+1
	bl_p0 = bl_nm+1
	bl_p1 = bl_p0+1
	bl_p2 = bl_p1+1
	bl_rc = bl_p2+1
	bl_sc = bl_rc+1
	bl_se = bl_sc+1
	bl_tb = bl_se+1
	bl_vc = bl_tb+1
	bl_xn = bl_vc+1
	bl_xr = bl_xn+1
	bl_bc = bl_xr+1
	bl_pd = bl_bc+1
	bl__d = bl_pd+1
	bl_tr = bl_pd+1
	bl_bf = bl_tr+1
	bl_cc = bl_bf+1
	bl_cm = bl_cc+1
	bl_ct = bl_cm+1
	bl_df = bl_ct+1
	bl_ef = bl_df+1
	bl_ev = bl_ef+1
	bl_ff = bl_ev+1
	bl_kv = bl_ff+1
	bl_pf = bl_kv+1
	bl_te = bl_pf+1
	bl__i = 0
	bl__t = bl_tr+1
	bl___ = bl_te+1
	fcode = 0
	fargs = 1
	idval = 1
	artyp = 0
	arlen = idval+1
	arofs = arlen+1
	arndm = arofs+1
	arlbd = arndm+1
	ardim = arlbd+cfp_i
	arlb2 = ardim+cfp_i
	ardm2 = arlb2+cfp_i
	arpro = ardim+cfp_i
	arvls = arpro+1
	arpr2 = ardm2+cfp_i
	arvl2 = arpr2+1
	arsi_ = arlbd
	ardms = arlb2-arlbd
	cctyp = 0
	cclen = cctyp+1
	ccsln = cclen+1
	ccuse = ccsln+1
	cccod = ccuse+1
	cdjmp = 0
	cdstm = cdjmp+1
	cdsln = cdstm+1
	cdlen = cdsln+1
	cdfal = cdlen+1
	cdcod = cdfal+1
	cdsi_ = cdcod
	cmidn = 0
	cmlen = cmidn+1
	cmtyp = cmlen+1
	cmopn = cmtyp+1
	cmvls = cmopn+1
	cmrop = cmvls
	cmlop = cmvls+1
	cmsi_ = cmvls
	cmus_ = cmsi_+1
	cmbs_ = cmsi_+2
	cmar1 = cmvls+1
	c_arr = 0
	c_fnc = c_arr+1
	c_def = c_fnc+1
	c_ind = c_def+1
	c_key = c_ind+1
	c_ubo = c_key+1
	c_uuo = c_ubo+1
	c_uo_ = c_uuo+1
	c__nm = c_uuo+1
	c_bvl = c_uuo+1
	c_uvl = c_bvl+1
	c_alt = c_uvl+1
	c_cnc = c_alt+1
	c_cnp = c_cnc+1
	c_unm = c_cnp+1
	c_bvn = c_unm+1
	c_ass = c_bvn+1
	c_int = c_ass+1
	c_neg = c_int+1
	c_sel = c_neg+1
	c_pmt = c_sel+1
	c_pr_ = c_bvn
	c__nv = c_pmt+1
	cttyp = 0
	ctchs = cttyp+1
	ctsi_ = ctchs+cfp_a
	dflen = fargs+1
	dfpdl = dflen+1
	dfnam = dfpdl+1
	dffld = dfnam+1
	dfflb = dffld-1
	dfsi_ = dffld
	dvopn = 0
	dvtyp = dvopn+1
	dvlpr = dvtyp+1
	dvrpr = dvlpr+1
	dvus_ = dvlpr+1
	dvbs_ = dvrpr+1
	dvubs = dvus_+dvbs_
	rrass = 10
	llass = 00
	rrpmt = 20
	llpmt = 30
	rramp = 40
	llamp = 50
	rralt = 70
	llalt = 60
	rrcnc = 90
	llcnc = 80
	rrats = 110
	llats = 100
	rrplm = 120
	llplm = 130
	rrnum = 140
	llnum = 150
	rrdvd = 160
	lldvd = 170
	rrmlt = 180
	llmlt = 190
	rrpct = 200
	llpct = 210
	rrexp = 230
	llexp = 220
	rrdld = 240
	lldld = 250
	rrnot = 270
	llnot = 260
	lluno = 999
	eflen = fargs+1
	efuse = eflen+1
	efcod = efuse+1
	efvar = efcod+1
	efrsl = efvar+1
	eftar = efrsl+1
	efsi_ = eftar
	evtyp = 0
	evexp = evtyp+1
	evvar = evexp+1
	evsi_ = evvar+1
	extyp = 0
	exstm = cdstm
	exsln = exstm+1
	exlen = exsln+1
	exflc = exlen+1
	excod = exflc+1
	exsi_ = excod
	ffdfp = fargs+1
	ffnxt = ffdfp+1
	ffofs = ffnxt+1
	ffsi_ = ffofs+1
	icget = 0
	icval = icget+1
	icsi_ = icval+cfp_i
	kvtyp = 0
	kvvar = kvtyp+1
	kvnum = kvvar+1
	kvsi_ = kvnum+1
	nmtyp = 0
	nmbas = nmtyp+1
	nmofs = nmbas+1
	nmsi_ = nmofs+1
	pcode = 0
	pthen = pcode+1
	pasi_ = pthen+1
	parm1 = pthen+1
	pbsi_ = parm1+1
	parm2 = parm1+1
	pcsi_ = parm2+1
	pdtyp = 0
	pddfp = idval+1
	pdfld = pddfp+1
	pdfof = dffld-pdfld
	pdsi_ = pdfld
	pddfs = dfsi_-pdsi_
	pflen = fargs+1
	pfvbl = pflen+1
	pfnlo = pfvbl+1
	pfcod = pfnlo+1
	pfctr = pfcod+1
	pfrtr = pfctr+1
	pfarg = pfrtr+1
	pfagb = pfarg-1
	pfsi_ = pfarg
	rcget = 0
	rcval = rcget+1
	rcsi_ = rcval+cfp_r
	scget = 0
	sclen = scget+1
	schar = sclen+1
	scsi_ = schar
	setyp = 0
	sevar = setyp+1
	sesi_ = sevar+1
	svbit = 0
	svlen = 1
	svchs = 2
	svsi_ = 2
	svpre = 1
	svffc = svpre+svpre
	svckw = svffc+svffc
	svprd = svckw+svckw
	svnbt = 4
	svknm = svprd+svprd
	svfnc = svknm+svknm
	svnar = svfnc+svfnc
	svlbl = svnar+svnar
	svval = svlbl+svlbl
	svfnf = svfnc+svnar
	svfnn = svfnf+svffc
	svfnp = svfnn+svpre
	svfpr = svfnn+svprd
	svfnk = svfnn+svknm
	svkwv = svknm+svval
	svkwc = svckw+svknm
	svkvc = svkwv+svckw
	svkvl = svkvc+svlbl
	svfpk = svfnp+svkvc
	k_abe = 0
	k_anc = k_abe+cfp_b
	k_cod = k_anc+cfp_b
	k_com = k_cod+cfp_b
	k_dmp = k_com+cfp_b
	k_erl = k_dmp+cfp_b
	k_ert = k_erl+cfp_b
	k_ftr = k_ert+cfp_b
	k_fls = k_ftr+cfp_b
	k_inp = k_fls+cfp_b
	k_mxl = k_inp+cfp_b
	k_oup = k_mxl+cfp_b
	k_pfl = k_oup+cfp_b
	k_tra = k_pfl+cfp_b
	k_trm = k_tra+cfp_b
	k_fnc = k_trm+cfp_b
	k_lst = k_fnc+cfp_b
	k_lln = k_lst+cfp_b
	k_lin = k_lln+cfp_b
	k_stn = k_lin+cfp_b
	k_abo = k_stn+cfp_b
	k_arb = k_abo+pasi_
	k_bal = k_arb+pasi_
	k_fal = k_bal+pasi_
	k_fen = k_fal+pasi_
	k_rem = k_fen+pasi_
	k_suc = k_rem+pasi_
	k_alp = k_suc+1
	k_rtn = k_alp+1
	k_stc = k_rtn+1
	k_etx = k_stc+1
	k_fil = k_etx+1
	k_lfl = k_fil+1
	k_stl = k_lfl+1
	k_lcs = k_stl+1
	k_ucs = k_lcs+1
	k__al = k_alp-k_alp
	k__rt = k_rtn-k_alp
	k__sc = k_stc-k_alp
	k__et = k_etx-k_alp
	k__fl = k_fil-k_alp
	k__lf = k_lfl-k_alp
	k__sl = k_stl-k_alp
	k__lc = k_lcs-k_alp
	k__uc = k_ucs-k_alp
	k__n_ = k__uc+1
	k_p__ = k_fnc
	k_v__ = k_abo
	k_s__ = k_alp
	tbtyp = 0
	tblen = offs2
	tbinv = offs3
	tbbuk = tbinv+1
	tbsi_ = tbbuk
	tbnbk = 11
	tetyp = 0
	tesub = tetyp+1
	teval = tesub+1
	tenxt = teval+1
	tesi_ = tenxt+1
	tridn = 0
	trtyp = tridn+1
	trval = trtyp+1
	trnxt = trval
	trlbl = trval
	trkvr = trval
	trtag = trval+1
	trter = trtag
	trtrf = trtag
	trfnc = trtag+1
	trfpt = trfnc
	trsi_ = trfnc+1
	trtin = 0
	trtac = trtin+1
	trtvl = trtac+1
	trtou = trtvl+1
	trtfc = trtou+1
	vctyp = 0
	vclen = offs2
	vcvls = offs3
	vcsi_ = vcvls
	vcvlb = vcvls-1
	vctbd = tbsi_-vcsi_
	vrget = 0
	vrsto = vrget+1
	vrval = vrsto+1
	vrvlo = vrval-vrsto
	vrtra = vrval+1
	vrlbl = vrtra+1
	vrlbo = vrlbl-vrtra
	vrfnc = vrlbl+1
	vrnxt = vrfnc+1
	vrlen = vrnxt+1
	vrchs = vrlen+1
	vrsvp = vrlen+1
	vrsi_ = vrchs+1
	vrsof = vrlen-sclen
	vrsvo = vrsvp-vrsof
	xntyp = 0
	xnlen = xntyp+1
	xndta = xnlen+1
	xnsi_ = xndta
	xrtyp = 0
	xrlen = xrtyp+1
	xrptr = xrlen+1
	xrsi_ = xrptr
	cnvst = 8
	cnvrt = cnvst+1
	cnvbt = cnvrt
	cnvtt = cnvbt+1
	iniln = 1024
	inils = 1024
	ionmb = 2
	ionmo = 4
	mnlen = 1024
	mxern = 329
	num01 = 1
	num02 = 2
	num03 = 3
	num04 = 4
	num05 = 5
	num06 = 6
	num07 = 7
	num08 = 8
	num09 = 9
	num10 = 10
	num25 = 25
	nm320 = 320
	nm321 = 321
	nini8 = 998
	nini9 = 999
	thsnd = 1000
	opbun = 5
	opuun = 6
	prsnf = 13
	prtmf = 21
	rilen = 1024
	stgic = 0
	stgxc = stgic+1
	stgev = stgxc+1
	stgxt = stgev+1
	stgce = stgxt+1
	stgxe = stgce+1
	stgnd = stgce-stgic
	stgee = stgxe+1
	stgno = stgee+1
	stnpd = 8
	t_uop = 0
	t_lpr = t_uop+3
	t_lbr = t_lpr+3
	t_cma = t_lbr+3
	t_fnc = t_cma+3
	t_var = t_fnc+3
	t_con = t_var+3
	t_bop = t_con+3
	t_rpr = t_bop+3
	t_rbr = t_rpr+3
	t_col = t_rbr+3
	t_smc = t_col+3
	t_fgo = t_smc+1
	t_sgo = t_fgo+1
	t_uok = t_fnc
	t_uo0 = t_uop+0
	t_uo1 = t_uop+1
	t_uo2 = t_uop+2
	t_lp0 = t_lpr+0
	t_lp1 = t_lpr+1
	t_lp2 = t_lpr+2
	t_lb0 = t_lbr+0
	t_lb1 = t_lbr+1
	t_lb2 = t_lbr+2
	t_cm0 = t_cma+0
	t_cm1 = t_cma+1
	t_cm2 = t_cma+2
	t_fn0 = t_fnc+0
	t_fn1 = t_fnc+1
	t_fn2 = t_fnc+2
	t_va0 = t_var+0
	t_va1 = t_var+1
	t_va2 = t_var+2
	t_co0 = t_con+0
	t_co1 = t_con+1
	t_co2 = t_con+2
	t_bo0 = t_bop+0
	t_bo1 = t_bop+1
	t_bo2 = t_bop+2
	t_rp0 = t_rpr+0
	t_rp1 = t_rpr+1
	t_rp2 = t_rpr+2
	t_rb0 = t_rbr+0
	t_rb1 = t_rbr+1
	t_rb2 = t_rbr+2
	t_cl0 = t_col+0
	t_cl1 = t_col+1
	t_cl2 = t_col+2
	t_sm0 = t_smc+0
	t_sm1 = t_smc+1
	t_sm2 = t_smc+2
	t_nes = t_sm2+1
	cc_do = 0
	cc_co = cc_do+1
	cc_du = cc_co+1
	cc_cp = cc_du+1
	cc_ej = cc_cp+1
	cc_er = cc_ej+1
	cc_ex = cc_er+1
	cc_fa = cc_ex+1
	cc_in = cc_fa+1
	cc_ln = cc_in+1
	cc_li = cc_ln+1
	cc_nr = cc_li+1
	cc_nx = cc_nr+1
	cc_nf = cc_nx+1
	cc_nl = cc_nf+1
	cc_no = cc_nl+1
	cc_np = cc_no+1
	cc_op = cc_np+1
	cc_pr = cc_op+1
	cc_si = cc_pr+1
	cc_sp = cc_si+1
	cc_st = cc_sp+1
	cc_ti = cc_st+1
	cc_tr = cc_ti+1
	cc_nc = cc_tr+1
	ccnoc = 4
	ccofs = 7
	ccinm = 9
	cmstm = 0
	cmsgo = cmstm+1
	cmfgo = cmsgo+1
	cmcgo = cmfgo+1
	cmpcd = cmcgo+1
	cmffp = cmpcd+1
	cmffc = cmffp+1
	cmsop = cmffc+1
	cmsoc = cmsop+1
	cmlbl = cmsoc+1
	cmtra = cmlbl+1
	cmnen = cmtra+1
	pfpd1 = 8
	pfpd2 = 20
	pfpd3 = 32
	pf_i2 = cfp_i+cfp_i
	rlend = 0
	rladj = rlend+1
	rlstr = rladj+1
	rssi_ = rlstr+1
	rnsi_ = 5
	rldye = 0
	rldya = rldye+1
	rldys = rldya+1
	rlste = rldys+1
	rlsta = rlste+1
	rlsts = rlsta+1
	rlwke = rlsts+1
	rlwka = rlwke+1
	rlwks = rlwka+1
	rlcne = rlwks+1
	rlcna = rlcne+1
	rlcns = rlcna+1
	rlcde = rlcns+1
	rlcda = rlcde+1
	rlcds = rlcda+1
	rlsi_ = rlcds+1
	)
//sec03
var program = []int {
	0,
// c_aaa:
/*     1 */	0       ,
// alfsp:
/*     2 */	e_fsp   ,
// bits0:
/*     3 */	0       ,
// bits1:
/*     4 */	1       ,
// bits2:
/*     5 */	2       ,
// bits3:
/*     6 */	4       ,
// bits4:
/*     7 */	8       ,
// bits5:
/*     8 */	16      ,
// bits6:
/*     9 */	32      ,
// bits7:
/*    10 */	64      ,
// bits8:
/*    11 */	128     ,
// bits9:
/*    12 */	256     ,
// bit10:
/*    13 */	512     ,
// bit11:
/*    14 */	1024    ,
// bit12:
/*    15 */	2048    ,
// bitsm:
/*    16 */	0       ,
// btfnc:
/*    17 */	svfnc   ,
// btknm:
/*    18 */	svknm   ,
// btlbl:
/*    19 */	svlbl   ,
// btffc:
/*    20 */	svffc   ,
// btckw:
/*    21 */	svckw   ,
// btkwv:
/*    22 */	svkwv   ,
// btprd:
/*    23 */	svprd   ,
// btpre:
/*    24 */	svpre   ,
// btval:
/*    25 */	svval   ,
// ccnms:
/*    26 */	'd'     ,
/*    27 */	'o'     ,
/*    28 */	'u'     ,
/*    29 */	'b'     ,
/*    30 */	'c'     ,
/*    31 */	'o'     ,
/*    32 */	'm'     ,
/*    33 */	'p'     ,
/*    34 */	'd'     ,
/*    35 */	'u'     ,
/*    36 */	'm'     ,
/*    37 */	'p'     ,
/*    38 */	'c'     ,
/*    39 */	'o'     ,
/*    40 */	'p'     ,
/*    41 */	'y'     ,
/*    42 */	'e'     ,
/*    43 */	'j'     ,
/*    44 */	'e'     ,
/*    45 */	'c'     ,
/*    46 */	'e'     ,
/*    47 */	'r'     ,
/*    48 */	'r'     ,
/*    49 */	'o'     ,
/*    50 */	'e'     ,
/*    51 */	'x'     ,
/*    52 */	'e'     ,
/*    53 */	'c'     ,
/*    54 */	'f'     ,
/*    55 */	'a'     ,
/*    56 */	'i'     ,
/*    57 */	'l'     ,
/*    58 */	'i'     ,
/*    59 */	'n'     ,
/*    60 */	'c'     ,
/*    61 */	'l'     ,
/*    62 */	'l'     ,
/*    63 */	'i'     ,
/*    64 */	'n'     ,
/*    65 */	'e'     ,
/*    66 */	'l'     ,
/*    67 */	'i'     ,
/*    68 */	's'     ,
/*    69 */	't'     ,
/*    70 */	'n'     ,
/*    71 */	'o'     ,
/*    72 */	'e'     ,
/*    73 */	'r'     ,
/*    74 */	'n'     ,
/*    75 */	'o'     ,
/*    76 */	'e'     ,
/*    77 */	'x'     ,
/*    78 */	'n'     ,
/*    79 */	'o'     ,
/*    80 */	'f'     ,
/*    81 */	'a'     ,
/*    82 */	'n'     ,
/*    83 */	'o'     ,
/*    84 */	'l'     ,
/*    85 */	'i'     ,
/*    86 */	'n'     ,
/*    87 */	'o'     ,
/*    88 */	'o'     ,
/*    89 */	'p'     ,
/*    90 */	'n'     ,
/*    91 */	'o'     ,
/*    92 */	'p'     ,
/*    93 */	'r'     ,
/*    94 */	'o'     ,
/*    95 */	'p'     ,
/*    96 */	't'     ,
/*    97 */	'i'     ,
/*    98 */	'p'     ,
/*    99 */	'r'     ,
/*   100 */	'i'     ,
/*   101 */	'n'     ,
/*   102 */	's'     ,
/*   103 */	'i'     ,
/*   104 */	'n'     ,
/*   105 */	'g'     ,
/*   106 */	's'     ,
/*   107 */	'p'     ,
/*   108 */	'a'     ,
/*   109 */	'c'     ,
/*   110 */	's'     ,
/*   111 */	't'     ,
/*   112 */	'i'     ,
/*   113 */	't'     ,
/*   114 */	't'     ,
/*   115 */	'i'     ,
/*   116 */	't'     ,
/*   117 */	'l'     ,
/*   118 */	't'     ,
/*   119 */	'r'     ,
/*   120 */	'a'     ,
/*   121 */	'c'     ,
// dmhdk:
/*   122 */	b_scl   ,
/*   123 */	22      ,
/*   124 */	'd'     ,
/*   125 */	'u'     ,
/*   126 */	'm'     ,
/*   127 */	'p'     ,
/*   128 */	' '     ,
/*   129 */	'o'     ,
/*   130 */	'f'     ,
/*   131 */	' '     ,
/*   132 */	'k'     ,
/*   133 */	'e'     ,
/*   134 */	'y'     ,
/*   135 */	'w'     ,
/*   136 */	'o'     ,
/*   137 */	'r'     ,
/*   138 */	'd'     ,
/*   139 */	' '     ,
/*   140 */	'v'     ,
/*   141 */	'a'     ,
/*   142 */	'l'     ,
/*   143 */	'u'     ,
/*   144 */	'e'     ,
/*   145 */	's'     ,
// dmhdv:
/*   146 */	b_scl   ,
/*   147 */	25      ,
/*   148 */	'd'     ,
/*   149 */	'u'     ,
/*   150 */	'm'     ,
/*   151 */	'p'     ,
/*   152 */	' '     ,
/*   153 */	'o'     ,
/*   154 */	'f'     ,
/*   155 */	' '     ,
/*   156 */	'n'     ,
/*   157 */	'a'     ,
/*   158 */	't'     ,
/*   159 */	'u'     ,
/*   160 */	'r'     ,
/*   161 */	'a'     ,
/*   162 */	'l'     ,
/*   163 */	' '     ,
/*   164 */	'v'     ,
/*   165 */	'a'     ,
/*   166 */	'r'     ,
/*   167 */	'i'     ,
/*   168 */	'a'     ,
/*   169 */	'b'     ,
/*   170 */	'l'     ,
/*   171 */	'e'     ,
/*   172 */	's'     ,
// encm1:
/*   173 */	b_scl   ,
/*   174 */	19      ,
/*   175 */	'm'     ,
/*   176 */	'e'     ,
/*   177 */	'm'     ,
/*   178 */	'o'     ,
/*   179 */	'r'     ,
/*   180 */	'y'     ,
/*   181 */	' '     ,
/*   182 */	'u'     ,
/*   183 */	's'     ,
/*   184 */	'e'     ,
/*   185 */	'd'     ,
/*   186 */	' '     ,
/*   187 */	'('     ,
/*   188 */	'b'     ,
/*   189 */	'y'     ,
/*   190 */	't'     ,
/*   191 */	'e'     ,
/*   192 */	's'     ,
/*   193 */	')'     ,
// encm2:
/*   194 */	b_scl   ,
/*   195 */	19      ,
/*   196 */	'm'     ,
/*   197 */	'e'     ,
/*   198 */	'm'     ,
/*   199 */	'o'     ,
/*   200 */	'r'     ,
/*   201 */	'y'     ,
/*   202 */	' '     ,
/*   203 */	'l'     ,
/*   204 */	'e'     ,
/*   205 */	'f'     ,
/*   206 */	't'     ,
/*   207 */	' '     ,
/*   208 */	'('     ,
/*   209 */	'b'     ,
/*   210 */	'y'     ,
/*   211 */	't'     ,
/*   212 */	'e'     ,
/*   213 */	's'     ,
/*   214 */	')'     ,
// encm3:
/*   215 */	b_scl   ,
/*   216 */	11      ,
/*   217 */	'c'     ,
/*   218 */	'o'     ,
/*   219 */	'm'     ,
/*   220 */	'p'     ,
/*   221 */	' '     ,
/*   222 */	'e'     ,
/*   223 */	'r'     ,
/*   224 */	'r'     ,
/*   225 */	'o'     ,
/*   226 */	'r'     ,
/*   227 */	's'     ,
// encm4:
/*   228 */	b_scl   ,
/*   229 */	20      ,
/*   230 */	'c'     ,
/*   231 */	'o'     ,
/*   232 */	'm'     ,
/*   233 */	'p'     ,
/*   234 */	' '     ,
/*   235 */	't'     ,
/*   236 */	'i'     ,
/*   237 */	'm'     ,
/*   238 */	'e'     ,
/*   239 */	' '     ,
/*   240 */	'('     ,
/*   241 */	'm'     ,
/*   242 */	'i'     ,
/*   243 */	'c'     ,
/*   244 */	'r'     ,
/*   245 */	'o'     ,
/*   246 */	's'     ,
/*   247 */	'e'     ,
/*   248 */	'c'     ,
/*   249 */	')'     ,
// encm5:
/*   250 */	b_scl   ,
/*   251 */	20      ,
/*   252 */	'e'     ,
/*   253 */	'x'     ,
/*   254 */	'e'     ,
/*   255 */	'c'     ,
/*   256 */	'u'     ,
/*   257 */	't'     ,
/*   258 */	'i'     ,
/*   259 */	'o'     ,
/*   260 */	'n'     ,
/*   261 */	' '     ,
/*   262 */	's'     ,
/*   263 */	'u'     ,
/*   264 */	'p'     ,
/*   265 */	'p'     ,
/*   266 */	'r'     ,
/*   267 */	'e'     ,
/*   268 */	's'     ,
/*   269 */	's'     ,
/*   270 */	'e'     ,
/*   271 */	'd'     ,
// endab:
/*   272 */	b_scl   ,
/*   273 */	12      ,
/*   274 */	'a'     ,
/*   275 */	'b'     ,
/*   276 */	'n'     ,
/*   277 */	'o'     ,
/*   278 */	'r'     ,
/*   279 */	'm'     ,
/*   280 */	'a'     ,
/*   281 */	'l'     ,
/*   282 */	' '     ,
/*   283 */	'e'     ,
/*   284 */	'n'     ,
/*   285 */	'd'     ,
// endmo:
/*   286 */	b_scl   ,
// endml:
/*   287 */	15      ,
/*   288 */	'm'     ,
/*   289 */	'e'     ,
/*   290 */	'm'     ,
/*   291 */	'o'     ,
/*   292 */	'r'     ,
/*   293 */	'y'     ,
/*   294 */	' '     ,
/*   295 */	'o'     ,
/*   296 */	'v'     ,
/*   297 */	'e'     ,
/*   298 */	'r'     ,
/*   299 */	'f'     ,
/*   300 */	'l'     ,
/*   301 */	'o'     ,
/*   302 */	'w'     ,
// endms:
/*   303 */	b_scl   ,
/*   304 */	10      ,
/*   305 */	'n'     ,
/*   306 */	'o'     ,
/*   307 */	'r'     ,
/*   308 */	'm'     ,
/*   309 */	'a'     ,
/*   310 */	'l'     ,
/*   311 */	' '     ,
/*   312 */	'e'     ,
/*   313 */	'n'     ,
/*   314 */	'd'     ,
// endso:
/*   315 */	b_scl   ,
/*   316 */	36      ,
/*   317 */	's'     ,
/*   318 */	't'     ,
/*   319 */	'a'     ,
/*   320 */	'c'     ,
/*   321 */	'k'     ,
/*   322 */	' '     ,
/*   323 */	'o'     ,
/*   324 */	'v'     ,
/*   325 */	'e'     ,
/*   326 */	'r'     ,
/*   327 */	'f'     ,
/*   328 */	'l'     ,
/*   329 */	'o'     ,
/*   330 */	'w'     ,
/*   331 */	' '     ,
/*   332 */	'i'     ,
/*   333 */	'n'     ,
/*   334 */	' '     ,
/*   335 */	'g'     ,
/*   336 */	'a'     ,
/*   337 */	'r'     ,
/*   338 */	'b'     ,
/*   339 */	'a'     ,
/*   340 */	'g'     ,
/*   341 */	'e'     ,
/*   342 */	' '     ,
/*   343 */	'c'     ,
/*   344 */	'o'     ,
/*   345 */	'l'     ,
/*   346 */	'l'     ,
/*   347 */	'e'     ,
/*   348 */	'c'     ,
/*   349 */	't'     ,
/*   350 */	'i'     ,
/*   351 */	'o'     ,
/*   352 */	'n'     ,
// endtu:
/*   353 */	b_scl   ,
/*   354 */	15      ,
/*   355 */	'e'     ,
/*   356 */	'r'     ,
/*   357 */	'r'     ,
/*   358 */	'o'     ,
/*   359 */	'r'     ,
/*   360 */	' '     ,
/*   361 */	'-'     ,
/*   362 */	' '     ,
/*   363 */	't'     ,
/*   364 */	'i'     ,
/*   365 */	'm'     ,
/*   366 */	'e'     ,
/*   367 */	' '     ,
/*   368 */	'u'     ,
/*   369 */	'p'     ,
// ermms:
/*   370 */	b_scl   ,
/*   371 */	5       ,
/*   372 */	'e'     ,
/*   373 */	'r'     ,
/*   374 */	'r'     ,
/*   375 */	'o'     ,
/*   376 */	'r'     ,
// ermns:
/*   377 */	b_scl   ,
/*   378 */	4       ,
/*   379 */	' '     ,
/*   380 */	'-'     ,
/*   381 */	'-'     ,
/*   382 */	' '     ,
// lstms:
/*   383 */	b_scl   ,
/*   384 */	5       ,
/*   385 */	'p'     ,
/*   386 */	'a'     ,
/*   387 */	'g'     ,
/*   388 */	'e'     ,
/*   389 */	' '     ,
// headr:
/*   390 */	b_scl   ,
/*   391 */	25      ,
/*   392 */	'm'     ,
/*   393 */	'a'     ,
/*   394 */	'c'     ,
/*   395 */	'r'     ,
/*   396 */	'o'     ,
/*   397 */	' '     ,
/*   398 */	's'     ,
/*   399 */	'p'     ,
/*   400 */	'i'     ,
/*   401 */	't'     ,
/*   402 */	'b'     ,
/*   403 */	'o'     ,
/*   404 */	'l'     ,
/*   405 */	' '     ,
/*   406 */	'v'     ,
/*   407 */	'e'     ,
/*   408 */	'r'     ,
/*   409 */	's'     ,
/*   410 */	'i'     ,
/*   411 */	'o'     ,
/*   412 */	'n'     ,
/*   413 */	' '     ,
/*   414 */	'4'     ,
/*   415 */	'.'     ,
/*   416 */	'0'     ,
// headv:
/*   417 */	b_scl   ,
/*   418 */	5       ,
/*   419 */	'1'     ,
/*   420 */	'5'     ,
/*   421 */	'.'     ,
/*   422 */	'0'     ,
/*   423 */	'1'     ,
// gbsdp:
/*   424 */	e_sed   ,
// int_r:
/*   425 */	b_icl   ,
// intv0:
/*   426 */	+0      ,
// inton:
/*   427 */	b_icl   ,
// intv1:
/*   428 */	+1      ,
// inttw:
/*   429 */	b_icl   ,
// intv2:
/*   430 */	+2      ,
// intvt:
/*   431 */	+10     ,
// intvh:
/*   432 */	+100    ,
// intth:
/*   433 */	+1000   ,
// intab:
/*   434 */	int_r   ,
/*   435 */	inton   ,
/*   436 */	inttw   ,
// ndabb:
/*   437 */	p_abb   ,
// ndabd:
/*   438 */	p_abd   ,
// ndarc:
/*   439 */	p_arc   ,
// ndexb:
/*   440 */	p_exb   ,
// ndfnb:
/*   441 */	p_fnb   ,
// ndfnd:
/*   442 */	p_fnd   ,
// ndexc:
/*   443 */	p_exc   ,
// ndimb:
/*   444 */	p_imb   ,
// ndimd:
/*   445 */	p_imd   ,
// ndnth:
/*   446 */	p_nth   ,
// ndpab:
/*   447 */	p_pab   ,
// ndpad:
/*   448 */	p_pad   ,
// nduna:
/*   449 */	p_una   ,
// ndabo:
/*   450 */	p_abo   ,
/*   451 */	ndnth   ,
// ndarb:
/*   452 */	p_arb   ,
/*   453 */	ndnth   ,
// ndbal:
/*   454 */	p_bal   ,
/*   455 */	ndnth   ,
// ndfal:
/*   456 */	p_fal   ,
/*   457 */	ndnth   ,
// ndfen:
/*   458 */	p_fen   ,
/*   459 */	ndnth   ,
// ndrem:
/*   460 */	p_rem   ,
/*   461 */	ndnth   ,
// ndsuc:
/*   462 */	p_suc   ,
/*   463 */	ndnth   ,
// nulls:
/*   464 */	b_scl   ,
/*   465 */	0       ,
// nullw:
/*   466 */	' '     ,
/*   467 */	' '     ,
/*   468 */	' '     ,
/*   469 */	' '     ,
/*   470 */	' '     ,
/*   471 */	' '     ,
/*   472 */	' '     ,
/*   473 */	' '     ,
/*   474 */	' '     ,
/*   475 */	' '     ,
// lcase:
/*   476 */	b_scl   ,
/*   477 */	26      ,
/*   478 */	'a'     ,
/*   479 */	'b'     ,
/*   480 */	'c'     ,
/*   481 */	'd'     ,
/*   482 */	'e'     ,
/*   483 */	'f'     ,
/*   484 */	'g'     ,
/*   485 */	'h'     ,
/*   486 */	'i'     ,
/*   487 */	'j'     ,
/*   488 */	'k'     ,
/*   489 */	'l'     ,
/*   490 */	'm'     ,
/*   491 */	'n'     ,
/*   492 */	'o'     ,
/*   493 */	'p'     ,
/*   494 */	'q'     ,
/*   495 */	'r'     ,
/*   496 */	's'     ,
/*   497 */	't'     ,
/*   498 */	'u'     ,
/*   499 */	'v'     ,
/*   500 */	'w'     ,
/*   501 */	'x'     ,
/*   502 */	'y'     ,
/*   503 */	'z'     ,
// ucase:
/*   504 */	b_scl   ,
/*   505 */	26      ,
/*   506 */	'A'     ,
/*   507 */	'B'     ,
/*   508 */	'C'     ,
/*   509 */	'D'     ,
/*   510 */	'E'     ,
/*   511 */	'F'     ,
/*   512 */	'G'     ,
/*   513 */	'H'     ,
/*   514 */	'I'     ,
/*   515 */	'J'     ,
/*   516 */	'K'     ,
/*   517 */	'L'     ,
/*   518 */	'M'     ,
/*   519 */	'N'     ,
/*   520 */	'O'     ,
/*   521 */	'P'     ,
/*   522 */	'Q'     ,
/*   523 */	'R'     ,
/*   524 */	'S'     ,
/*   525 */	'T'     ,
/*   526 */	'U'     ,
/*   527 */	'V'     ,
/*   528 */	'W'     ,
/*   529 */	'X'     ,
/*   530 */	'Y'     ,
/*   531 */	'Z'     ,
// opdvc:
/*   532 */	o_cnc   ,
/*   533 */	c_cnc   ,
/*   534 */	llcnc   ,
/*   535 */	rrcnc   ,
// opdvp:
/*   536 */	o_cnc   ,
/*   537 */	c_cnp   ,
/*   538 */	llcnc   ,
/*   539 */	rrcnc   ,
// opdvs:
/*   540 */	o_ass   ,
/*   541 */	c_ass   ,
/*   542 */	llass   ,
/*   543 */	rrass   ,
/*   544 */	6       ,
/*   545 */	c_uuo   ,
/*   546 */	lluno   ,
/*   547 */	o_pmv   ,
/*   548 */	c_pmt   ,
/*   549 */	llpmt   ,
/*   550 */	rrpmt   ,
/*   551 */	o_int   ,
/*   552 */	c_uvl   ,
/*   553 */	lluno   ,
/*   554 */	1       ,
/*   555 */	c_ubo   ,
/*   556 */	llamp   ,
/*   557 */	rramp   ,
/*   558 */	o_kwv   ,
/*   559 */	c_key   ,
/*   560 */	lluno   ,
/*   561 */	o_alt   ,
/*   562 */	c_alt   ,
/*   563 */	llalt   ,
/*   564 */	rralt   ,
/*   565 */	5       ,
/*   566 */	c_uuo   ,
/*   567 */	lluno   ,
/*   568 */	0       ,
/*   569 */	c_ubo   ,
/*   570 */	llats   ,
/*   571 */	rrats   ,
/*   572 */	o_cas   ,
/*   573 */	c_unm   ,
/*   574 */	lluno   ,
/*   575 */	2       ,
/*   576 */	c_ubo   ,
/*   577 */	llnum   ,
/*   578 */	rrnum   ,
/*   579 */	7       ,
/*   580 */	c_uuo   ,
/*   581 */	lluno   ,
/*   582 */	o_dvd   ,
/*   583 */	c_bvl   ,
/*   584 */	lldvd   ,
/*   585 */	rrdvd   ,
/*   586 */	9       ,
/*   587 */	c_uuo   ,
/*   588 */	lluno   ,
/*   589 */	o_mlt   ,
/*   590 */	c_bvl   ,
/*   591 */	llmlt   ,
/*   592 */	rrmlt   ,
/*   593 */	0       ,
/*   594 */	c_def   ,
/*   595 */	lluno   ,
/*   596 */	3       ,
/*   597 */	c_ubo   ,
/*   598 */	llpct   ,
/*   599 */	rrpct   ,
/*   600 */	8       ,
/*   601 */	c_uuo   ,
/*   602 */	lluno   ,
/*   603 */	o_exp   ,
/*   604 */	c_bvl   ,
/*   605 */	llexp   ,
/*   606 */	rrexp   ,
/*   607 */	10      ,
/*   608 */	c_uuo   ,
/*   609 */	lluno   ,
/*   610 */	o_ima   ,
/*   611 */	c_bvn   ,
/*   612 */	lldld   ,
/*   613 */	rrdld   ,
/*   614 */	o_inv   ,
/*   615 */	c_ind   ,
/*   616 */	lluno   ,
/*   617 */	4       ,
/*   618 */	c_ubo   ,
/*   619 */	llnot   ,
/*   620 */	rrnot   ,
/*   621 */	0       ,
/*   622 */	c_neg   ,
/*   623 */	lluno   ,
/*   624 */	o_sub   ,
/*   625 */	c_bvl   ,
/*   626 */	llplm   ,
/*   627 */	rrplm   ,
/*   628 */	o_com   ,
/*   629 */	c_uvl   ,
/*   630 */	lluno   ,
/*   631 */	o_add   ,
/*   632 */	c_bvl   ,
/*   633 */	llplm   ,
/*   634 */	rrplm   ,
/*   635 */	o_aff   ,
/*   636 */	c_uvl   ,
/*   637 */	lluno   ,
/*   638 */	o_pas   ,
/*   639 */	c_bvn   ,
/*   640 */	lldld   ,
/*   641 */	rrdld   ,
/*   642 */	o_nam   ,
/*   643 */	c_unm   ,
/*   644 */	lluno   ,
// opdvd:
/*   645 */	o_god   ,
/*   646 */	c_uvl   ,
/*   647 */	lluno   ,
// opdvn:
/*   648 */	o_goc   ,
/*   649 */	c_unm   ,
/*   650 */	lluno   ,
// oamn_:
/*   651 */	o_amn   ,
// oamv_:
/*   652 */	o_amv   ,
// oaon_:
/*   653 */	o_aon   ,
// oaov_:
/*   654 */	o_aov   ,
// ocer_:
/*   655 */	o_cer   ,
// ofex_:
/*   656 */	o_fex   ,
// ofif_:
/*   657 */	o_fif   ,
// ofnc_:
/*   658 */	o_fnc   ,
// ofne_:
/*   659 */	o_fne   ,
// ofns_:
/*   660 */	o_fns   ,
// ogof_:
/*   661 */	o_gof   ,
// oinn_:
/*   662 */	o_inn   ,
// okwn_:
/*   663 */	o_kwn   ,
// olex_:
/*   664 */	o_lex   ,
// olpt_:
/*   665 */	o_lpt   ,
// olvn_:
/*   666 */	o_lvn   ,
// onta_:
/*   667 */	o_nta   ,
// ontb_:
/*   668 */	o_ntb   ,
// ontc_:
/*   669 */	o_ntc   ,
// opmn_:
/*   670 */	o_pmn   ,
// opms_:
/*   671 */	o_pms   ,
// opop_:
/*   672 */	o_pop   ,
// ornm_:
/*   673 */	o_rnm   ,
// orpl_:
/*   674 */	o_rpl   ,
// orvl_:
/*   675 */	o_rvl   ,
// osla_:
/*   676 */	o_sla   ,
// oslb_:
/*   677 */	o_slb   ,
// oslc_:
/*   678 */	o_slc   ,
// osld_:
/*   679 */	o_sld   ,
// ostp_:
/*   680 */	o_stp   ,
// ounf_:
/*   681 */	o_unf   ,
// opsnb:
/*   682 */	ch_at   ,
/*   683 */	ch_am   ,
/*   684 */	ch_nm   ,
/*   685 */	ch_pc   ,
/*   686 */	ch_nt   ,
// opnsu:
/*   687 */	ch_br   ,
/*   688 */	ch_eq   ,
/*   689 */	ch_nm   ,
/*   690 */	ch_pc   ,
/*   691 */	ch_sl   ,
/*   692 */	ch_ex   ,
// pfi2a:
/*   693 */	pf_i2   ,
// pfms1:
/*   694 */	b_scl   ,
/*   695 */	15      ,
/*   696 */	'p'     ,
/*   697 */	'r'     ,
/*   698 */	'o'     ,
/*   699 */	'g'     ,
/*   700 */	'r'     ,
/*   701 */	'a'     ,
/*   702 */	'm'     ,
/*   703 */	' '     ,
/*   704 */	'p'     ,
/*   705 */	'r'     ,
/*   706 */	'o'     ,
/*   707 */	'f'     ,
/*   708 */	'i'     ,
/*   709 */	'l'     ,
/*   710 */	'e'     ,
// pfms2:
/*   711 */	b_scl   ,
/*   712 */	42      ,
/*   713 */	's'     ,
/*   714 */	't'     ,
/*   715 */	'm'     ,
/*   716 */	't'     ,
/*   717 */	' '     ,
/*   718 */	' '     ,
/*   719 */	' '     ,
/*   720 */	' '     ,
/*   721 */	'n'     ,
/*   722 */	'u'     ,
/*   723 */	'm'     ,
/*   724 */	'b'     ,
/*   725 */	'e'     ,
/*   726 */	'r'     ,
/*   727 */	' '     ,
/*   728 */	'o'     ,
/*   729 */	'f'     ,
/*   730 */	' '     ,
/*   731 */	' '     ,
/*   732 */	' '     ,
/*   733 */	' '     ,
/*   734 */	' '     ,
/*   735 */	'-'     ,
/*   736 */	'-'     ,
/*   737 */	' '     ,
/*   738 */	'e'     ,
/*   739 */	'x'     ,
/*   740 */	'e'     ,
/*   741 */	'c'     ,
/*   742 */	'u'     ,
/*   743 */	't'     ,
/*   744 */	'i'     ,
/*   745 */	'o'     ,
/*   746 */	'n'     ,
/*   747 */	' '     ,
/*   748 */	't'     ,
/*   749 */	'i'     ,
/*   750 */	'm'     ,
/*   751 */	'e'     ,
/*   752 */	' '     ,
/*   753 */	'-'     ,
/*   754 */	'-'     ,
// pfms3:
/*   755 */	b_scl   ,
/*   756 */	47      ,
/*   757 */	'n'     ,
/*   758 */	'u'     ,
/*   759 */	'm'     ,
/*   760 */	'b'     ,
/*   761 */	'e'     ,
/*   762 */	'r'     ,
/*   763 */	' '     ,
/*   764 */	' '     ,
/*   765 */	'e'     ,
/*   766 */	'x'     ,
/*   767 */	'e'     ,
/*   768 */	'c'     ,
/*   769 */	'u'     ,
/*   770 */	't'     ,
/*   771 */	'i'     ,
/*   772 */	'o'     ,
/*   773 */	'n'     ,
/*   774 */	's'     ,
/*   775 */	' '     ,
/*   776 */	' '     ,
/*   777 */	't'     ,
/*   778 */	'o'     ,
/*   779 */	't'     ,
/*   780 */	'a'     ,
/*   781 */	'l'     ,
/*   782 */	'('     ,
/*   783 */	'm'     ,
/*   784 */	's'     ,
/*   785 */	'e'     ,
/*   786 */	'c'     ,
/*   787 */	')'     ,
/*   788 */	' '     ,
/*   789 */	'p'     ,
/*   790 */	'e'     ,
/*   791 */	'r'     ,
/*   792 */	' '     ,
/*   793 */	'e'     ,
/*   794 */	'x'     ,
/*   795 */	'c'     ,
/*   796 */	'n'     ,
/*   797 */	'('     ,
/*   798 */	'm'     ,
/*   799 */	'c'     ,
/*   800 */	's'     ,
/*   801 */	'e'     ,
/*   802 */	'c'     ,
/*   803 */	')'     ,
// reav0:
/*   804 */	0       ,
// reap1:
/*   805 */	0       ,
// reap5:
/*   806 */	0       ,
// reav1:
/*   807 */	0       ,
// reavt:
/*   808 */	0       ,
/*   809 */	0       ,
/*   810 */	0       ,
/*   811 */	0       ,
/*   812 */	0       ,
/*   813 */	0       ,
/*   814 */	0       ,
/*   815 */	0       ,
/*   816 */	0       ,
// reatt:
/*   817 */	0       ,
// scarr:
/*   818 */	b_scl   ,
/*   819 */	5       ,
/*   820 */	'a'     ,
/*   821 */	'r'     ,
/*   822 */	'r'     ,
/*   823 */	'a'     ,
/*   824 */	'y'     ,
// sccod:
/*   825 */	b_scl   ,
/*   826 */	4       ,
/*   827 */	'c'     ,
/*   828 */	'o'     ,
/*   829 */	'd'     ,
/*   830 */	'e'     ,
// scexp:
/*   831 */	b_scl   ,
/*   832 */	10      ,
/*   833 */	'e'     ,
/*   834 */	'x'     ,
/*   835 */	'p'     ,
/*   836 */	'r'     ,
/*   837 */	'e'     ,
/*   838 */	's'     ,
/*   839 */	's'     ,
/*   840 */	'i'     ,
/*   841 */	'o'     ,
/*   842 */	'n'     ,
// scext:
/*   843 */	b_scl   ,
/*   844 */	8       ,
/*   845 */	'e'     ,
/*   846 */	'x'     ,
/*   847 */	't'     ,
/*   848 */	'e'     ,
/*   849 */	'r'     ,
/*   850 */	'n'     ,
/*   851 */	'a'     ,
/*   852 */	'l'     ,
// scint:
/*   853 */	b_scl   ,
/*   854 */	7       ,
/*   855 */	'i'     ,
/*   856 */	'n'     ,
/*   857 */	't'     ,
/*   858 */	'e'     ,
/*   859 */	'g'     ,
/*   860 */	'e'     ,
/*   861 */	'r'     ,
// scnam:
/*   862 */	b_scl   ,
/*   863 */	4       ,
/*   864 */	'n'     ,
/*   865 */	'a'     ,
/*   866 */	'm'     ,
/*   867 */	'e'     ,
// scnum:
/*   868 */	b_scl   ,
/*   869 */	7       ,
/*   870 */	'n'     ,
/*   871 */	'u'     ,
/*   872 */	'm'     ,
/*   873 */	'e'     ,
/*   874 */	'r'     ,
/*   875 */	'i'     ,
/*   876 */	'c'     ,
// scpat:
/*   877 */	b_scl   ,
/*   878 */	7       ,
/*   879 */	'p'     ,
/*   880 */	'a'     ,
/*   881 */	't'     ,
/*   882 */	't'     ,
/*   883 */	'e'     ,
/*   884 */	'r'     ,
/*   885 */	'n'     ,
// screa:
/*   886 */	b_scl   ,
/*   887 */	4       ,
/*   888 */	'r'     ,
/*   889 */	'e'     ,
/*   890 */	'a'     ,
/*   891 */	'l'     ,
// scstr:
/*   892 */	b_scl   ,
/*   893 */	6       ,
/*   894 */	's'     ,
/*   895 */	't'     ,
/*   896 */	'r'     ,
/*   897 */	'i'     ,
/*   898 */	'n'     ,
/*   899 */	'g'     ,
// sctab:
/*   900 */	b_scl   ,
/*   901 */	5       ,
/*   902 */	't'     ,
/*   903 */	'a'     ,
/*   904 */	'b'     ,
/*   905 */	'l'     ,
/*   906 */	'e'     ,
// scfil:
/*   907 */	b_scl   ,
/*   908 */	4       ,
/*   909 */	'f'     ,
/*   910 */	'i'     ,
/*   911 */	'l'     ,
/*   912 */	'e'     ,
// scfrt:
/*   913 */	b_scl   ,
/*   914 */	7       ,
/*   915 */	'f'     ,
/*   916 */	'r'     ,
/*   917 */	'e'     ,
/*   918 */	't'     ,
/*   919 */	'u'     ,
/*   920 */	'r'     ,
/*   921 */	'n'     ,
// scnrt:
/*   922 */	b_scl   ,
/*   923 */	7       ,
/*   924 */	'n'     ,
/*   925 */	'r'     ,
/*   926 */	'e'     ,
/*   927 */	't'     ,
/*   928 */	'u'     ,
/*   929 */	'r'     ,
/*   930 */	'n'     ,
// scrtn:
/*   931 */	b_scl   ,
/*   932 */	6       ,
/*   933 */	'r'     ,
/*   934 */	'e'     ,
/*   935 */	't'     ,
/*   936 */	'u'     ,
/*   937 */	'r'     ,
/*   938 */	'n'     ,
// scnmt:
/*   939 */	scarr   ,
/*   940 */	sccod   ,
/*   941 */	scexp   ,
/*   942 */	scint   ,
/*   943 */	scnam   ,
/*   944 */	scpat   ,
/*   945 */	scpat   ,
/*   946 */	scpat   ,
/*   947 */	screa   ,
/*   948 */	scstr   ,
/*   949 */	scexp   ,
/*   950 */	sctab   ,
/*   951 */	scarr   ,
/*   952 */	scext   ,
/*   953 */	scext   ,
/*   954 */	nulls   ,
// scre0:
/*   955 */	b_scl   ,
/*   956 */	2       ,
/*   957 */	'0'     ,
/*   958 */	'.'     ,
// stlim:
/*   959 */	+2147483647,
// stndf:
/*   960 */	o_fun   ,
/*   961 */	0       ,
// stndl:
/*   962 */	l_und   ,
// stndo:
/*   963 */	o_oun   ,
/*   964 */	0       ,
// stnvr:
/*   965 */	b_vrl   ,
/*   966 */	b_vrs   ,
/*   967 */	nulls   ,
/*   968 */	b_vrg   ,
/*   969 */	stndl   ,
/*   970 */	stndf   ,
/*   971 */	0       ,
// stpm1:
/*   972 */	b_scl   ,
/*   973 */	12      ,
/*   974 */	'i'     ,
/*   975 */	'n'     ,
/*   976 */	' '     ,
/*   977 */	's'     ,
/*   978 */	't'     ,
/*   979 */	'a'     ,
/*   980 */	't'     ,
/*   981 */	'e'     ,
/*   982 */	'm'     ,
/*   983 */	'e'     ,
/*   984 */	'n'     ,
/*   985 */	't'     ,
// stpm2:
/*   986 */	b_scl   ,
/*   987 */	14      ,
/*   988 */	's'     ,
/*   989 */	't'     ,
/*   990 */	'm'     ,
/*   991 */	't'     ,
/*   992 */	's'     ,
/*   993 */	' '     ,
/*   994 */	'e'     ,
/*   995 */	'x'     ,
/*   996 */	'e'     ,
/*   997 */	'c'     ,
/*   998 */	'u'     ,
/*   999 */	't'     ,
/*  1000 */	'e'     ,
/*  1001 */	'd'     ,
// stpm3:
/*  1002 */	b_scl   ,
/*  1003 */	20      ,
/*  1004 */	'e'     ,
/*  1005 */	'x'     ,
/*  1006 */	'e'     ,
/*  1007 */	'c'     ,
/*  1008 */	'u'     ,
/*  1009 */	't'     ,
/*  1010 */	'i'     ,
/*  1011 */	'o'     ,
/*  1012 */	'n'     ,
/*  1013 */	' '     ,
/*  1014 */	't'     ,
/*  1015 */	'i'     ,
/*  1016 */	'm'     ,
/*  1017 */	'e'     ,
/*  1018 */	' '     ,
/*  1019 */	'm'     ,
/*  1020 */	's'     ,
/*  1021 */	'e'     ,
/*  1022 */	'c'     ,
/*  1023 */	' '     ,
// stpm4:
/*  1024 */	b_scl   ,
/*  1025 */	7       ,
/*  1026 */	'i'     ,
/*  1027 */	'n'     ,
/*  1028 */	' '     ,
/*  1029 */	'l'     ,
/*  1030 */	'i'     ,
/*  1031 */	'n'     ,
/*  1032 */	'e'     ,
// stpm5:
/*  1033 */	b_scl   ,
/*  1034 */	13      ,
/*  1035 */	'r'     ,
/*  1036 */	'e'     ,
/*  1037 */	'g'     ,
/*  1038 */	'e'     ,
/*  1039 */	'n'     ,
/*  1040 */	'e'     ,
/*  1041 */	'r'     ,
/*  1042 */	'a'     ,
/*  1043 */	't'     ,
/*  1044 */	'i'     ,
/*  1045 */	'o'     ,
/*  1046 */	'n'     ,
/*  1047 */	's'     ,
// stpm6:
/*  1048 */	b_scl   ,
/*  1049 */	7       ,
/*  1050 */	'i'     ,
/*  1051 */	'n'     ,
/*  1052 */	' '     ,
/*  1053 */	'f'     ,
/*  1054 */	'i'     ,
/*  1055 */	'l'     ,
/*  1056 */	'e'     ,
// stpm7:
/*  1057 */	b_scl   ,
/*  1058 */	15      ,
/*  1059 */	's'     ,
/*  1060 */	't'     ,
/*  1061 */	'm'     ,
/*  1062 */	't'     ,
/*  1063 */	' '     ,
/*  1064 */	'/'     ,
/*  1065 */	' '     ,
/*  1066 */	'm'     ,
/*  1067 */	'i'     ,
/*  1068 */	'c'     ,
/*  1069 */	'r'     ,
/*  1070 */	'o'     ,
/*  1071 */	's'     ,
/*  1072 */	'e'     ,
/*  1073 */	'c'     ,
// stpm8:
/*  1074 */	b_scl   ,
/*  1075 */	15      ,
/*  1076 */	's'     ,
/*  1077 */	't'     ,
/*  1078 */	'm'     ,
/*  1079 */	't'     ,
/*  1080 */	' '     ,
/*  1081 */	'/'     ,
/*  1082 */	' '     ,
/*  1083 */	'm'     ,
/*  1084 */	'i'     ,
/*  1085 */	'l'     ,
/*  1086 */	'l'     ,
/*  1087 */	'i'     ,
/*  1088 */	's'     ,
/*  1089 */	'e'     ,
/*  1090 */	'c'     ,
// stpm9:
/*  1091 */	b_scl   ,
/*  1092 */	13      ,
/*  1093 */	's'     ,
/*  1094 */	't'     ,
/*  1095 */	'm'     ,
/*  1096 */	't'     ,
/*  1097 */	' '     ,
/*  1098 */	'/'     ,
/*  1099 */	' '     ,
/*  1100 */	's'     ,
/*  1101 */	'e'     ,
/*  1102 */	'c'     ,
/*  1103 */	'o'     ,
/*  1104 */	'n'     ,
/*  1105 */	'd'     ,
// strtu:
/*  1106 */	't'     ,
/*  1107 */	'u'     ,
// svctb:
/*  1108 */	scstr   ,
/*  1109 */	scint   ,
/*  1110 */	scnam   ,
/*  1111 */	scpat   ,
/*  1112 */	scarr   ,
/*  1113 */	sctab   ,
/*  1114 */	scexp   ,
/*  1115 */	sccod   ,
/*  1116 */	scnum   ,
/*  1117 */	screa   ,
/*  1118 */	0       ,
// tmasb:
/*  1119 */	b_scl   ,
/*  1120 */	13      ,
/*  1121 */	'*'     ,
/*  1122 */	'*'     ,
/*  1123 */	'*'     ,
/*  1124 */	'*'     ,
/*  1125 */	'*'     ,
/*  1126 */	'*'     ,
/*  1127 */	'*'     ,
/*  1128 */	'*'     ,
/*  1129 */	'*'     ,
/*  1130 */	'*'     ,
/*  1131 */	'*'     ,
/*  1132 */	'*'     ,
/*  1133 */	' '     ,
// tmbeb:
/*  1134 */	b_scl   ,
/*  1135 */	3       ,
/*  1136 */	' '     ,
/*  1137 */	'='     ,
/*  1138 */	' '     ,
// trbev:
/*  1139 */	b_trt   ,
// trbkv:
/*  1140 */	b_trt   ,
// trxdr:
/*  1141 */	o_txr   ,
// trxdc:
/*  1142 */	trxdr   ,
// v_eqf:
/*  1143 */	svfpr   ,
/*  1144 */	2       ,
/*  1145 */	'e'     ,
/*  1146 */	'q'     ,
/*  1147 */	s_eqf   ,
/*  1148 */	2       ,
// v_gef:
/*  1149 */	svfpr   ,
/*  1150 */	2       ,
/*  1151 */	'g'     ,
/*  1152 */	'e'     ,
/*  1153 */	s_gef   ,
/*  1154 */	2       ,
// v_gtf:
/*  1155 */	svfpr   ,
/*  1156 */	2       ,
/*  1157 */	'g'     ,
/*  1158 */	't'     ,
/*  1159 */	s_gtf   ,
/*  1160 */	2       ,
// v_lef:
/*  1161 */	svfpr   ,
/*  1162 */	2       ,
/*  1163 */	'l'     ,
/*  1164 */	'e'     ,
/*  1165 */	s_lef   ,
/*  1166 */	2       ,
// v_lnf:
/*  1167 */	svfnp   ,
/*  1168 */	2       ,
/*  1169 */	'l'     ,
/*  1170 */	'n'     ,
/*  1171 */	s_lnf   ,
/*  1172 */	1       ,
// v_ltf:
/*  1173 */	svfpr   ,
/*  1174 */	2       ,
/*  1175 */	'l'     ,
/*  1176 */	't'     ,
/*  1177 */	s_ltf   ,
/*  1178 */	2       ,
// v_nef:
/*  1179 */	svfpr   ,
/*  1180 */	2       ,
/*  1181 */	'n'     ,
/*  1182 */	'e'     ,
/*  1183 */	s_nef   ,
/*  1184 */	2       ,
// v_any:
/*  1185 */	svfnp   ,
/*  1186 */	3       ,
/*  1187 */	'a'     ,
/*  1188 */	'n'     ,
/*  1189 */	'y'     ,
/*  1190 */	s_any   ,
/*  1191 */	1       ,
// v_arb:
/*  1192 */	svkvc   ,
/*  1193 */	3       ,
/*  1194 */	'a'     ,
/*  1195 */	'r'     ,
/*  1196 */	'b'     ,
/*  1197 */	k_arb   ,
/*  1198 */	ndarb   ,
// v_arg:
/*  1199 */	svfnn   ,
/*  1200 */	3       ,
/*  1201 */	'a'     ,
/*  1202 */	'r'     ,
/*  1203 */	'g'     ,
/*  1204 */	s_arg   ,
/*  1205 */	2       ,
// v_bal:
/*  1206 */	svkvc   ,
/*  1207 */	3       ,
/*  1208 */	'b'     ,
/*  1209 */	'a'     ,
/*  1210 */	'l'     ,
/*  1211 */	k_bal   ,
/*  1212 */	ndbal   ,
// v_cos:
/*  1213 */	svfnp   ,
/*  1214 */	3       ,
/*  1215 */	'c'     ,
/*  1216 */	'o'     ,
/*  1217 */	's'     ,
/*  1218 */	s_cos   ,
/*  1219 */	1       ,
// v_end:
/*  1220 */	svlbl   ,
/*  1221 */	3       ,
/*  1222 */	'e'     ,
/*  1223 */	'n'     ,
/*  1224 */	'd'     ,
/*  1225 */	l_end   ,
// v_exp:
/*  1226 */	svfnp   ,
/*  1227 */	3       ,
/*  1228 */	'e'     ,
/*  1229 */	'x'     ,
/*  1230 */	'p'     ,
/*  1231 */	s_exp   ,
/*  1232 */	1       ,
// v_len:
/*  1233 */	svfnp   ,
/*  1234 */	3       ,
/*  1235 */	'l'     ,
/*  1236 */	'e'     ,
/*  1237 */	'n'     ,
/*  1238 */	s_len   ,
/*  1239 */	1       ,
// v_leq:
/*  1240 */	svfpr   ,
/*  1241 */	3       ,
/*  1242 */	'l'     ,
/*  1243 */	'e'     ,
/*  1244 */	'q'     ,
/*  1245 */	s_leq   ,
/*  1246 */	2       ,
// v_lge:
/*  1247 */	svfpr   ,
/*  1248 */	3       ,
/*  1249 */	'l'     ,
/*  1250 */	'g'     ,
/*  1251 */	'e'     ,
/*  1252 */	s_lge   ,
/*  1253 */	2       ,
// v_lgt:
/*  1254 */	svfpr   ,
/*  1255 */	3       ,
/*  1256 */	'l'     ,
/*  1257 */	'g'     ,
/*  1258 */	't'     ,
/*  1259 */	s_lgt   ,
/*  1260 */	2       ,
// v_lle:
/*  1261 */	svfpr   ,
/*  1262 */	3       ,
/*  1263 */	'l'     ,
/*  1264 */	'l'     ,
/*  1265 */	'e'     ,
/*  1266 */	s_lle   ,
/*  1267 */	2       ,
// v_llt:
/*  1268 */	svfpr   ,
/*  1269 */	3       ,
/*  1270 */	'l'     ,
/*  1271 */	'l'     ,
/*  1272 */	't'     ,
/*  1273 */	s_llt   ,
/*  1274 */	2       ,
// v_lne:
/*  1275 */	svfpr   ,
/*  1276 */	3       ,
/*  1277 */	'l'     ,
/*  1278 */	'n'     ,
/*  1279 */	'e'     ,
/*  1280 */	s_lne   ,
/*  1281 */	2       ,
// v_pos:
/*  1282 */	svfnp   ,
/*  1283 */	3       ,
/*  1284 */	'p'     ,
/*  1285 */	'o'     ,
/*  1286 */	's'     ,
/*  1287 */	s_pos   ,
/*  1288 */	1       ,
// v_rem:
/*  1289 */	svkvc   ,
/*  1290 */	3       ,
/*  1291 */	'r'     ,
/*  1292 */	'e'     ,
/*  1293 */	'm'     ,
/*  1294 */	k_rem   ,
/*  1295 */	ndrem   ,
// v_set:
/*  1296 */	svfnn   ,
/*  1297 */	3       ,
/*  1298 */	'z'     ,
/*  1299 */	'e'     ,
/*  1300 */	't'     ,
/*  1301 */	s_set   ,
/*  1302 */	3       ,
// v_sin:
/*  1303 */	svfnp   ,
/*  1304 */	3       ,
/*  1305 */	's'     ,
/*  1306 */	'i'     ,
/*  1307 */	'n'     ,
/*  1308 */	s_sin   ,
/*  1309 */	1       ,
// v_tab:
/*  1310 */	svfnp   ,
/*  1311 */	3       ,
/*  1312 */	't'     ,
/*  1313 */	'a'     ,
/*  1314 */	'b'     ,
/*  1315 */	s_tab   ,
/*  1316 */	1       ,
// v_tan:
/*  1317 */	svfnp   ,
/*  1318 */	3       ,
/*  1319 */	't'     ,
/*  1320 */	'a'     ,
/*  1321 */	'n'     ,
/*  1322 */	s_tan   ,
/*  1323 */	1       ,
// v_atn:
/*  1324 */	svfnp   ,
/*  1325 */	4       ,
/*  1326 */	'a'     ,
/*  1327 */	't'     ,
/*  1328 */	'a'     ,
/*  1329 */	'n'     ,
/*  1330 */	s_atn   ,
/*  1331 */	1       ,
// v_chr:
/*  1332 */	svfnp   ,
/*  1333 */	4       ,
/*  1334 */	'c'     ,
/*  1335 */	'h'     ,
/*  1336 */	'a'     ,
/*  1337 */	'r'     ,
/*  1338 */	s_chr   ,
/*  1339 */	1       ,
// v_chp:
/*  1340 */	svfnp   ,
/*  1341 */	4       ,
/*  1342 */	'c'     ,
/*  1343 */	'h'     ,
/*  1344 */	'o'     ,
/*  1345 */	'p'     ,
/*  1346 */	s_chp   ,
/*  1347 */	1       ,
// v_cod:
/*  1348 */	svfnk   ,
/*  1349 */	4       ,
/*  1350 */	'c'     ,
/*  1351 */	'o'     ,
/*  1352 */	'd'     ,
/*  1353 */	'e'     ,
/*  1354 */	k_cod   ,
/*  1355 */	s_cod   ,
/*  1356 */	1       ,
// v_cop:
/*  1357 */	svfnn   ,
/*  1358 */	4       ,
/*  1359 */	'c'     ,
/*  1360 */	'o'     ,
/*  1361 */	'p'     ,
/*  1362 */	'y'     ,
/*  1363 */	s_cop   ,
/*  1364 */	1       ,
// v_dat:
/*  1365 */	svfnn   ,
/*  1366 */	4       ,
/*  1367 */	'd'     ,
/*  1368 */	'a'     ,
/*  1369 */	't'     ,
/*  1370 */	'a'     ,
/*  1371 */	s_dat   ,
/*  1372 */	1       ,
// v_dte:
/*  1373 */	svfnn   ,
/*  1374 */	4       ,
/*  1375 */	'd'     ,
/*  1376 */	'a'     ,
/*  1377 */	't'     ,
/*  1378 */	'e'     ,
/*  1379 */	s_dte   ,
/*  1380 */	1       ,
// v_dmp:
/*  1381 */	svfnk   ,
/*  1382 */	4       ,
/*  1383 */	'd'     ,
/*  1384 */	'u'     ,
/*  1385 */	'm'     ,
/*  1386 */	'p'     ,
/*  1387 */	k_dmp   ,
/*  1388 */	s_dmp   ,
/*  1389 */	1       ,
// v_dup:
/*  1390 */	svfnn   ,
/*  1391 */	4       ,
/*  1392 */	'd'     ,
/*  1393 */	'u'     ,
/*  1394 */	'p'     ,
/*  1395 */	'l'     ,
/*  1396 */	s_dup   ,
/*  1397 */	2       ,
// v_evl:
/*  1398 */	svfnn   ,
/*  1399 */	4       ,
/*  1400 */	'e'     ,
/*  1401 */	'v'     ,
/*  1402 */	'a'     ,
/*  1403 */	'l'     ,
/*  1404 */	s_evl   ,
/*  1405 */	1       ,
// v_ext:
/*  1406 */	svfnn   ,
/*  1407 */	4       ,
/*  1408 */	'e'     ,
/*  1409 */	'x'     ,
/*  1410 */	'i'     ,
/*  1411 */	't'     ,
/*  1412 */	s_ext   ,
/*  1413 */	2       ,
// v_fal:
/*  1414 */	svkvc   ,
/*  1415 */	4       ,
/*  1416 */	'f'     ,
/*  1417 */	'a'     ,
/*  1418 */	'i'     ,
/*  1419 */	'l'     ,
/*  1420 */	k_fal   ,
/*  1421 */	ndfal   ,
// v_fil:
/*  1422 */	svknm   ,
/*  1423 */	4       ,
/*  1424 */	'f'     ,
/*  1425 */	'i'     ,
/*  1426 */	'l'     ,
/*  1427 */	'e'     ,
/*  1428 */	k_fil   ,
// v_hst:
/*  1429 */	svfnn   ,
/*  1430 */	4       ,
/*  1431 */	'h'     ,
/*  1432 */	'o'     ,
/*  1433 */	's'     ,
/*  1434 */	't'     ,
/*  1435 */	s_hst   ,
/*  1436 */	5       ,
// v_itm:
/*  1437 */	svfnf   ,
/*  1438 */	4       ,
/*  1439 */	'i'     ,
/*  1440 */	't'     ,
/*  1441 */	'e'     ,
/*  1442 */	'm'     ,
/*  1443 */	s_itm   ,
/*  1444 */	999     ,
// v_lin:
/*  1445 */	svknm   ,
/*  1446 */	4       ,
/*  1447 */	'l'     ,
/*  1448 */	'i'     ,
/*  1449 */	'n'     ,
/*  1450 */	'e'     ,
/*  1451 */	k_lin   ,
// v_lod:
/*  1452 */	svfnn   ,
/*  1453 */	4       ,
/*  1454 */	'l'     ,
/*  1455 */	'o'     ,
/*  1456 */	'a'     ,
/*  1457 */	'd'     ,
/*  1458 */	s_lod   ,
/*  1459 */	2       ,
// v_lpd:
/*  1460 */	svfnp   ,
/*  1461 */	4       ,
/*  1462 */	'l'     ,
/*  1463 */	'p'     ,
/*  1464 */	'a'     ,
/*  1465 */	'd'     ,
/*  1466 */	s_lpd   ,
/*  1467 */	3       ,
// v_rpd:
/*  1468 */	svfnp   ,
/*  1469 */	4       ,
/*  1470 */	'r'     ,
/*  1471 */	'p'     ,
/*  1472 */	'a'     ,
/*  1473 */	'd'     ,
/*  1474 */	s_rpd   ,
/*  1475 */	3       ,
// v_rps:
/*  1476 */	svfnp   ,
/*  1477 */	4       ,
/*  1478 */	'r'     ,
/*  1479 */	'p'     ,
/*  1480 */	'o'     ,
/*  1481 */	's'     ,
/*  1482 */	s_rps   ,
/*  1483 */	1       ,
// v_rtb:
/*  1484 */	svfnp   ,
/*  1485 */	4       ,
/*  1486 */	'r'     ,
/*  1487 */	't'     ,
/*  1488 */	'a'     ,
/*  1489 */	'b'     ,
/*  1490 */	s_rtb   ,
/*  1491 */	1       ,
// v_si_:
/*  1492 */	svfnp   ,
/*  1493 */	4       ,
/*  1494 */	's'     ,
/*  1495 */	'i'     ,
/*  1496 */	'z'     ,
/*  1497 */	'e'     ,
/*  1498 */	s_si_   ,
/*  1499 */	1       ,
// v_srt:
/*  1500 */	svfnn   ,
/*  1501 */	4       ,
/*  1502 */	's'     ,
/*  1503 */	'o'     ,
/*  1504 */	'r'     ,
/*  1505 */	't'     ,
/*  1506 */	s_srt   ,
/*  1507 */	2       ,
// v_spn:
/*  1508 */	svfnp   ,
/*  1509 */	4       ,
/*  1510 */	's'     ,
/*  1511 */	'p'     ,
/*  1512 */	'a'     ,
/*  1513 */	'n'     ,
/*  1514 */	s_spn   ,
/*  1515 */	1       ,
// v_sqr:
/*  1516 */	svfnp   ,
/*  1517 */	4       ,
/*  1518 */	's'     ,
/*  1519 */	'q'     ,
/*  1520 */	'r'     ,
/*  1521 */	't'     ,
/*  1522 */	s_sqr   ,
/*  1523 */	1       ,
// v_stn:
/*  1524 */	svknm   ,
/*  1525 */	4       ,
/*  1526 */	's'     ,
/*  1527 */	't'     ,
/*  1528 */	'n'     ,
/*  1529 */	'o'     ,
/*  1530 */	k_stn   ,
// v_tim:
/*  1531 */	svfnn   ,
/*  1532 */	4       ,
/*  1533 */	't'     ,
/*  1534 */	'i'     ,
/*  1535 */	'm'     ,
/*  1536 */	'e'     ,
/*  1537 */	s_tim   ,
/*  1538 */	0       ,
// v_trm:
/*  1539 */	svfnk   ,
/*  1540 */	4       ,
/*  1541 */	't'     ,
/*  1542 */	'r'     ,
/*  1543 */	'i'     ,
/*  1544 */	'm'     ,
/*  1545 */	k_trm   ,
/*  1546 */	s_trm   ,
/*  1547 */	1       ,
// v_abe:
/*  1548 */	svknm   ,
/*  1549 */	5       ,
/*  1550 */	'a'     ,
/*  1551 */	'b'     ,
/*  1552 */	'e'     ,
/*  1553 */	'n'     ,
/*  1554 */	'd'     ,
/*  1555 */	k_abe   ,
// v_abo:
/*  1556 */	svkvl   ,
/*  1557 */	5       ,
/*  1558 */	'a'     ,
/*  1559 */	'b'     ,
/*  1560 */	'o'     ,
/*  1561 */	'r'     ,
/*  1562 */	't'     ,
/*  1563 */	k_abo   ,
/*  1564 */	l_abo   ,
/*  1565 */	ndabo   ,
// v_app:
/*  1566 */	svfnf   ,
/*  1567 */	5       ,
/*  1568 */	'a'     ,
/*  1569 */	'p'     ,
/*  1570 */	'p'     ,
/*  1571 */	'l'     ,
/*  1572 */	'y'     ,
/*  1573 */	s_app   ,
/*  1574 */	999     ,
// v_abn:
/*  1575 */	svfnp   ,
/*  1576 */	5       ,
/*  1577 */	'a'     ,
/*  1578 */	'r'     ,
/*  1579 */	'b'     ,
/*  1580 */	'n'     ,
/*  1581 */	'o'     ,
/*  1582 */	s_abn   ,
/*  1583 */	1       ,
// v_arr:
/*  1584 */	svfnn   ,
/*  1585 */	5       ,
/*  1586 */	'a'     ,
/*  1587 */	'r'     ,
/*  1588 */	'r'     ,
/*  1589 */	'a'     ,
/*  1590 */	'y'     ,
/*  1591 */	s_arr   ,
/*  1592 */	2       ,
// v_brk:
/*  1593 */	svfnp   ,
/*  1594 */	5       ,
/*  1595 */	'b'     ,
/*  1596 */	'r'     ,
/*  1597 */	'e'     ,
/*  1598 */	'a'     ,
/*  1599 */	'k'     ,
/*  1600 */	s_brk   ,
/*  1601 */	1       ,
// v_clr:
/*  1602 */	svfnn   ,
/*  1603 */	5       ,
/*  1604 */	'c'     ,
/*  1605 */	'l'     ,
/*  1606 */	'e'     ,
/*  1607 */	'a'     ,
/*  1608 */	'r'     ,
/*  1609 */	s_clr   ,
/*  1610 */	1       ,
// v_ejc:
/*  1611 */	svfnn   ,
/*  1612 */	5       ,
/*  1613 */	'e'     ,
/*  1614 */	'j'     ,
/*  1615 */	'e'     ,
/*  1616 */	'c'     ,
/*  1617 */	't'     ,
/*  1618 */	s_ejc   ,
/*  1619 */	1       ,
// v_fen:
/*  1620 */	svfpk   ,
/*  1621 */	5       ,
/*  1622 */	'f'     ,
/*  1623 */	'e'     ,
/*  1624 */	'n'     ,
/*  1625 */	'c'     ,
/*  1626 */	'e'     ,
/*  1627 */	k_fen   ,
/*  1628 */	s_fnc   ,
/*  1629 */	1       ,
/*  1630 */	ndfen   ,
// v_fld:
/*  1631 */	svfnn   ,
/*  1632 */	5       ,
/*  1633 */	'f'     ,
/*  1634 */	'i'     ,
/*  1635 */	'e'     ,
/*  1636 */	'l'     ,
/*  1637 */	'd'     ,
/*  1638 */	s_fld   ,
/*  1639 */	2       ,
// v_idn:
/*  1640 */	svfpr   ,
/*  1641 */	5       ,
/*  1642 */	'i'     ,
/*  1643 */	'd'     ,
/*  1644 */	'e'     ,
/*  1645 */	'n'     ,
/*  1646 */	't'     ,
/*  1647 */	s_idn   ,
/*  1648 */	2       ,
// v_inp:
/*  1649 */	svfnk   ,
/*  1650 */	5       ,
/*  1651 */	'i'     ,
/*  1652 */	'n'     ,
/*  1653 */	'p'     ,
/*  1654 */	'u'     ,
/*  1655 */	't'     ,
/*  1656 */	k_inp   ,
/*  1657 */	s_inp   ,
/*  1658 */	3       ,
// v_lcs:
/*  1659 */	svkwc   ,
/*  1660 */	5       ,
/*  1661 */	'l'     ,
/*  1662 */	'c'     ,
/*  1663 */	'a'     ,
/*  1664 */	's'     ,
/*  1665 */	'e'     ,
/*  1666 */	k_lcs   ,
// v_loc:
/*  1667 */	svfnn   ,
/*  1668 */	5       ,
/*  1669 */	'l'     ,
/*  1670 */	'o'     ,
/*  1671 */	'c'     ,
/*  1672 */	'a'     ,
/*  1673 */	'l'     ,
/*  1674 */	s_loc   ,
/*  1675 */	2       ,
// v_ops:
/*  1676 */	svfnn   ,
/*  1677 */	5       ,
/*  1678 */	'o'     ,
/*  1679 */	'p'     ,
/*  1680 */	's'     ,
/*  1681 */	'y'     ,
/*  1682 */	'n'     ,
/*  1683 */	s_ops   ,
/*  1684 */	3       ,
// v_rmd:
/*  1685 */	svfnp   ,
/*  1686 */	5       ,
/*  1687 */	'r'     ,
/*  1688 */	'e'     ,
/*  1689 */	'm'     ,
/*  1690 */	'd'     ,
/*  1691 */	'r'     ,
/*  1692 */	s_rmd   ,
/*  1693 */	2       ,
// v_rsr:
/*  1694 */	svfnn   ,
/*  1695 */	5       ,
/*  1696 */	'r'     ,
/*  1697 */	's'     ,
/*  1698 */	'o'     ,
/*  1699 */	'r'     ,
/*  1700 */	't'     ,
/*  1701 */	s_rsr   ,
/*  1702 */	2       ,
// v_tbl:
/*  1703 */	svfnn   ,
/*  1704 */	5       ,
/*  1705 */	't'     ,
/*  1706 */	'a'     ,
/*  1707 */	'b'     ,
/*  1708 */	'l'     ,
/*  1709 */	'e'     ,
/*  1710 */	s_tbl   ,
/*  1711 */	3       ,
// v_tra:
/*  1712 */	svfnk   ,
/*  1713 */	5       ,
/*  1714 */	't'     ,
/*  1715 */	'r'     ,
/*  1716 */	'a'     ,
/*  1717 */	'c'     ,
/*  1718 */	'e'     ,
/*  1719 */	k_tra   ,
/*  1720 */	s_tra   ,
/*  1721 */	4       ,
// v_ucs:
/*  1722 */	svkwc   ,
/*  1723 */	5       ,
/*  1724 */	'u'     ,
/*  1725 */	'c'     ,
/*  1726 */	'a'     ,
/*  1727 */	's'     ,
/*  1728 */	'e'     ,
/*  1729 */	k_ucs   ,
// v_anc:
/*  1730 */	svknm   ,
/*  1731 */	6       ,
/*  1732 */	'a'     ,
/*  1733 */	'n'     ,
/*  1734 */	'c'     ,
/*  1735 */	'h'     ,
/*  1736 */	'o'     ,
/*  1737 */	'r'     ,
/*  1738 */	k_anc   ,
// v_bkx:
/*  1739 */	svfnp   ,
/*  1740 */	6       ,
/*  1741 */	'b'     ,
/*  1742 */	'r'     ,
/*  1743 */	'e'     ,
/*  1744 */	'a'     ,
/*  1745 */	'k'     ,
/*  1746 */	'x'     ,
/*  1747 */	s_bkx   ,
/*  1748 */	1       ,
// v_def:
/*  1749 */	svfnn   ,
/*  1750 */	6       ,
/*  1751 */	'd'     ,
/*  1752 */	'e'     ,
/*  1753 */	'f'     ,
/*  1754 */	'i'     ,
/*  1755 */	'n'     ,
/*  1756 */	'e'     ,
/*  1757 */	s_def   ,
/*  1758 */	2       ,
// v_det:
/*  1759 */	svfnn   ,
/*  1760 */	6       ,
/*  1761 */	'd'     ,
/*  1762 */	'e'     ,
/*  1763 */	't'     ,
/*  1764 */	'a'     ,
/*  1765 */	'c'     ,
/*  1766 */	'h'     ,
/*  1767 */	s_det   ,
/*  1768 */	1       ,
// v_dif:
/*  1769 */	svfpr   ,
/*  1770 */	6       ,
/*  1771 */	'd'     ,
/*  1772 */	'i'     ,
/*  1773 */	'f'     ,
/*  1774 */	'f'     ,
/*  1775 */	'e'     ,
/*  1776 */	'r'     ,
/*  1777 */	s_dif   ,
/*  1778 */	2       ,
// v_ftr:
/*  1779 */	svknm   ,
/*  1780 */	6       ,
/*  1781 */	'f'     ,
/*  1782 */	't'     ,
/*  1783 */	'r'     ,
/*  1784 */	'a'     ,
/*  1785 */	'c'     ,
/*  1786 */	'e'     ,
/*  1787 */	k_ftr   ,
// v_lst:
/*  1788 */	svknm   ,
/*  1789 */	6       ,
/*  1790 */	'l'     ,
/*  1791 */	'a'     ,
/*  1792 */	's'     ,
/*  1793 */	't'     ,
/*  1794 */	'n'     ,
/*  1795 */	'o'     ,
/*  1796 */	k_lst   ,
// v_nay:
/*  1797 */	svfnp   ,
/*  1798 */	6       ,
/*  1799 */	'n'     ,
/*  1800 */	'o'     ,
/*  1801 */	't'     ,
/*  1802 */	'a'     ,
/*  1803 */	'n'     ,
/*  1804 */	'y'     ,
/*  1805 */	s_nay   ,
/*  1806 */	1       ,
// v_oup:
/*  1807 */	svfnk   ,
/*  1808 */	6       ,
/*  1809 */	'o'     ,
/*  1810 */	'u'     ,
/*  1811 */	't'     ,
/*  1812 */	'p'     ,
/*  1813 */	'u'     ,
/*  1814 */	't'     ,
/*  1815 */	k_oup   ,
/*  1816 */	s_oup   ,
/*  1817 */	3       ,
// v_ret:
/*  1818 */	svlbl   ,
/*  1819 */	6       ,
/*  1820 */	'r'     ,
/*  1821 */	'e'     ,
/*  1822 */	't'     ,
/*  1823 */	'u'     ,
/*  1824 */	'r'     ,
/*  1825 */	'n'     ,
/*  1826 */	l_rtn   ,
// v_rew:
/*  1827 */	svfnn   ,
/*  1828 */	6       ,
/*  1829 */	'r'     ,
/*  1830 */	'e'     ,
/*  1831 */	'w'     ,
/*  1832 */	'i'     ,
/*  1833 */	'n'     ,
/*  1834 */	'd'     ,
/*  1835 */	s_rew   ,
/*  1836 */	1       ,
// v_stt:
/*  1837 */	svfnn   ,
/*  1838 */	6       ,
/*  1839 */	's'     ,
/*  1840 */	't'     ,
/*  1841 */	'o'     ,
/*  1842 */	'p'     ,
/*  1843 */	't'     ,
/*  1844 */	'r'     ,
/*  1845 */	s_stt   ,
/*  1846 */	2       ,
// v_sub:
/*  1847 */	svfnn   ,
/*  1848 */	6       ,
/*  1849 */	's'     ,
/*  1850 */	'u'     ,
/*  1851 */	'b'     ,
/*  1852 */	's'     ,
/*  1853 */	't'     ,
/*  1854 */	'r'     ,
/*  1855 */	s_sub   ,
/*  1856 */	3       ,
// v_unl:
/*  1857 */	svfnn   ,
/*  1858 */	6       ,
/*  1859 */	'u'     ,
/*  1860 */	'n'     ,
/*  1861 */	'l'     ,
/*  1862 */	'o'     ,
/*  1863 */	'a'     ,
/*  1864 */	'd'     ,
/*  1865 */	s_unl   ,
/*  1866 */	1       ,
// v_col:
/*  1867 */	svfnn   ,
/*  1868 */	7       ,
/*  1869 */	'c'     ,
/*  1870 */	'o'     ,
/*  1871 */	'l'     ,
/*  1872 */	'l'     ,
/*  1873 */	'e'     ,
/*  1874 */	'c'     ,
/*  1875 */	't'     ,
/*  1876 */	s_col   ,
/*  1877 */	1       ,
// v_com:
/*  1878 */	svknm   ,
/*  1879 */	7       ,
/*  1880 */	'c'     ,
/*  1881 */	'o'     ,
/*  1882 */	'm'     ,
/*  1883 */	'p'     ,
/*  1884 */	'a'     ,
/*  1885 */	'r'     ,
/*  1886 */	'e'     ,
/*  1887 */	k_com   ,
// v_cnv:
/*  1888 */	svfnn   ,
/*  1889 */	7       ,
/*  1890 */	'c'     ,
/*  1891 */	'o'     ,
/*  1892 */	'n'     ,
/*  1893 */	'v'     ,
/*  1894 */	'e'     ,
/*  1895 */	'r'     ,
/*  1896 */	't'     ,
/*  1897 */	s_cnv   ,
/*  1898 */	2       ,
// v_enf:
/*  1899 */	svfnn   ,
/*  1900 */	7       ,
/*  1901 */	'e'     ,
/*  1902 */	'n'     ,
/*  1903 */	'd'     ,
/*  1904 */	'f'     ,
/*  1905 */	'i'     ,
/*  1906 */	'l'     ,
/*  1907 */	'e'     ,
/*  1908 */	s_enf   ,
/*  1909 */	1       ,
// v_etx:
/*  1910 */	svknm   ,
/*  1911 */	7       ,
/*  1912 */	'e'     ,
/*  1913 */	'r'     ,
/*  1914 */	'r'     ,
/*  1915 */	't'     ,
/*  1916 */	'e'     ,
/*  1917 */	'x'     ,
/*  1918 */	't'     ,
/*  1919 */	k_etx   ,
// v_ert:
/*  1920 */	svknm   ,
/*  1921 */	7       ,
/*  1922 */	'e'     ,
/*  1923 */	'r'     ,
/*  1924 */	'r'     ,
/*  1925 */	't'     ,
/*  1926 */	'y'     ,
/*  1927 */	'p'     ,
/*  1928 */	'e'     ,
/*  1929 */	k_ert   ,
// v_frt:
/*  1930 */	svlbl   ,
/*  1931 */	7       ,
/*  1932 */	'f'     ,
/*  1933 */	'r'     ,
/*  1934 */	'e'     ,
/*  1935 */	't'     ,
/*  1936 */	'u'     ,
/*  1937 */	'r'     ,
/*  1938 */	'n'     ,
/*  1939 */	l_frt   ,
// v_int:
/*  1940 */	svfpr   ,
/*  1941 */	7       ,
/*  1942 */	'i'     ,
/*  1943 */	'n'     ,
/*  1944 */	't'     ,
/*  1945 */	'e'     ,
/*  1946 */	'g'     ,
/*  1947 */	'e'     ,
/*  1948 */	'r'     ,
/*  1949 */	s_int   ,
/*  1950 */	1       ,
// v_nrt:
/*  1951 */	svlbl   ,
/*  1952 */	7       ,
/*  1953 */	'n'     ,
/*  1954 */	'r'     ,
/*  1955 */	'e'     ,
/*  1956 */	't'     ,
/*  1957 */	'u'     ,
/*  1958 */	'r'     ,
/*  1959 */	'n'     ,
/*  1960 */	l_nrt   ,
// v_pfl:
/*  1961 */	svknm   ,
/*  1962 */	7       ,
/*  1963 */	'p'     ,
/*  1964 */	'r'     ,
/*  1965 */	'o'     ,
/*  1966 */	'f'     ,
/*  1967 */	'i'     ,
/*  1968 */	'l'     ,
/*  1969 */	'e'     ,
/*  1970 */	k_pfl   ,
// v_rpl:
/*  1971 */	svfnp   ,
/*  1972 */	7       ,
/*  1973 */	'r'     ,
/*  1974 */	'e'     ,
/*  1975 */	'p'     ,
/*  1976 */	'l'     ,
/*  1977 */	'a'     ,
/*  1978 */	'c'     ,
/*  1979 */	'e'     ,
/*  1980 */	s_rpl   ,
/*  1981 */	3       ,
// v_rvs:
/*  1982 */	svfnp   ,
/*  1983 */	7       ,
/*  1984 */	'r'     ,
/*  1985 */	'e'     ,
/*  1986 */	'v'     ,
/*  1987 */	'e'     ,
/*  1988 */	'r'     ,
/*  1989 */	's'     ,
/*  1990 */	'e'     ,
/*  1991 */	s_rvs   ,
/*  1992 */	1       ,
// v_rtn:
/*  1993 */	svknm   ,
/*  1994 */	7       ,
/*  1995 */	'r'     ,
/*  1996 */	't'     ,
/*  1997 */	'n'     ,
/*  1998 */	't'     ,
/*  1999 */	'y'     ,
/*  2000 */	'p'     ,
/*  2001 */	'e'     ,
/*  2002 */	k_rtn   ,
// v_stx:
/*  2003 */	svfnn   ,
/*  2004 */	7       ,
/*  2005 */	's'     ,
/*  2006 */	'e'     ,
/*  2007 */	't'     ,
/*  2008 */	'e'     ,
/*  2009 */	'x'     ,
/*  2010 */	'i'     ,
/*  2011 */	't'     ,
/*  2012 */	s_stx   ,
/*  2013 */	1       ,
// v_stc:
/*  2014 */	svknm   ,
/*  2015 */	7       ,
/*  2016 */	's'     ,
/*  2017 */	't'     ,
/*  2018 */	'c'     ,
/*  2019 */	'o'     ,
/*  2020 */	'u'     ,
/*  2021 */	'n'     ,
/*  2022 */	't'     ,
/*  2023 */	k_stc   ,
// v_stl:
/*  2024 */	svknm   ,
/*  2025 */	7       ,
/*  2026 */	's'     ,
/*  2027 */	't'     ,
/*  2028 */	'l'     ,
/*  2029 */	'i'     ,
/*  2030 */	'm'     ,
/*  2031 */	'i'     ,
/*  2032 */	't'     ,
/*  2033 */	k_stl   ,
// v_suc:
/*  2034 */	svkvc   ,
/*  2035 */	7       ,
/*  2036 */	's'     ,
/*  2037 */	'u'     ,
/*  2038 */	'c'     ,
/*  2039 */	'c'     ,
/*  2040 */	'e'     ,
/*  2041 */	'e'     ,
/*  2042 */	'd'     ,
/*  2043 */	k_suc   ,
/*  2044 */	ndsuc   ,
// v_alp:
/*  2045 */	svkwc   ,
/*  2046 */	8       ,
/*  2047 */	'a'     ,
/*  2048 */	'l'     ,
/*  2049 */	'p'     ,
/*  2050 */	'h'     ,
/*  2051 */	'a'     ,
/*  2052 */	'b'     ,
/*  2053 */	'e'     ,
/*  2054 */	't'     ,
/*  2055 */	k_alp   ,
// v_cnt:
/*  2056 */	svlbl   ,
/*  2057 */	8       ,
/*  2058 */	'c'     ,
/*  2059 */	'o'     ,
/*  2060 */	'n'     ,
/*  2061 */	't'     ,
/*  2062 */	'i'     ,
/*  2063 */	'n'     ,
/*  2064 */	'u'     ,
/*  2065 */	'e'     ,
/*  2066 */	l_cnt   ,
// v_dtp:
/*  2067 */	svfnp   ,
/*  2068 */	8       ,
/*  2069 */	'd'     ,
/*  2070 */	'a'     ,
/*  2071 */	't'     ,
/*  2072 */	'a'     ,
/*  2073 */	't'     ,
/*  2074 */	'y'     ,
/*  2075 */	'p'     ,
/*  2076 */	'e'     ,
/*  2077 */	s_dtp   ,
/*  2078 */	1       ,
// v_erl:
/*  2079 */	svknm   ,
/*  2080 */	8       ,
/*  2081 */	'e'     ,
/*  2082 */	'r'     ,
/*  2083 */	'r'     ,
/*  2084 */	'l'     ,
/*  2085 */	'i'     ,
/*  2086 */	'm'     ,
/*  2087 */	'i'     ,
/*  2088 */	't'     ,
/*  2089 */	k_erl   ,
// v_fnc:
/*  2090 */	svknm   ,
/*  2091 */	8       ,
/*  2092 */	'f'     ,
/*  2093 */	'n'     ,
/*  2094 */	'c'     ,
/*  2095 */	'l'     ,
/*  2096 */	'e'     ,
/*  2097 */	'v'     ,
/*  2098 */	'e'     ,
/*  2099 */	'l'     ,
/*  2100 */	k_fnc   ,
// v_fls:
/*  2101 */	svknm   ,
/*  2102 */	8       ,
/*  2103 */	'f'     ,
/*  2104 */	'u'     ,
/*  2105 */	'l'     ,
/*  2106 */	'l'     ,
/*  2107 */	's'     ,
/*  2108 */	'c'     ,
/*  2109 */	'a'     ,
/*  2110 */	'n'     ,
/*  2111 */	k_fls   ,
// v_lfl:
/*  2112 */	svknm   ,
/*  2113 */	8       ,
/*  2114 */	'l'     ,
/*  2115 */	'a'     ,
/*  2116 */	's'     ,
/*  2117 */	't'     ,
/*  2118 */	'f'     ,
/*  2119 */	'i'     ,
/*  2120 */	'l'     ,
/*  2121 */	'e'     ,
/*  2122 */	k_lfl   ,
// v_lln:
/*  2123 */	svknm   ,
/*  2124 */	8       ,
/*  2125 */	'l'     ,
/*  2126 */	'a'     ,
/*  2127 */	's'     ,
/*  2128 */	't'     ,
/*  2129 */	'l'     ,
/*  2130 */	'i'     ,
/*  2131 */	'n'     ,
/*  2132 */	'e'     ,
/*  2133 */	k_lln   ,
// v_mxl:
/*  2134 */	svknm   ,
/*  2135 */	8       ,
/*  2136 */	'm'     ,
/*  2137 */	'a'     ,
/*  2138 */	'x'     ,
/*  2139 */	'l'     ,
/*  2140 */	'n'     ,
/*  2141 */	'g'     ,
/*  2142 */	't'     ,
/*  2143 */	'h'     ,
/*  2144 */	k_mxl   ,
// v_ter:
/*  2145 */	0       ,
/*  2146 */	8       ,
/*  2147 */	't'     ,
/*  2148 */	'e'     ,
/*  2149 */	'r'     ,
/*  2150 */	'm'     ,
/*  2151 */	'i'     ,
/*  2152 */	'n'     ,
/*  2153 */	'a'     ,
/*  2154 */	'l'     ,
/*  2155 */	0       ,
// v_bsp:
/*  2156 */	svfnn   ,
/*  2157 */	9       ,
/*  2158 */	'b'     ,
/*  2159 */	'a'     ,
/*  2160 */	'c'     ,
/*  2161 */	'k'     ,
/*  2162 */	's'     ,
/*  2163 */	'p'     ,
/*  2164 */	'a'     ,
/*  2165 */	'c'     ,
/*  2166 */	'e'     ,
/*  2167 */	s_bsp   ,
/*  2168 */	1       ,
// v_pro:
/*  2169 */	svfnn   ,
/*  2170 */	9       ,
/*  2171 */	'p'     ,
/*  2172 */	'r'     ,
/*  2173 */	'o'     ,
/*  2174 */	't'     ,
/*  2175 */	'o'     ,
/*  2176 */	't'     ,
/*  2177 */	'y'     ,
/*  2178 */	'p'     ,
/*  2179 */	'e'     ,
/*  2180 */	s_pro   ,
/*  2181 */	1       ,
// v_scn:
/*  2182 */	svlbl   ,
/*  2183 */	9       ,
/*  2184 */	's'     ,
/*  2185 */	'c'     ,
/*  2186 */	'o'     ,
/*  2187 */	'n'     ,
/*  2188 */	't'     ,
/*  2189 */	'i'     ,
/*  2190 */	'n'     ,
/*  2191 */	'u'     ,
/*  2192 */	'e'     ,
/*  2193 */	l_scn   ,
/*  2194 */	0       ,
/*  2195 */	10      ,
// vdmkw:
/*  2196 */	v_anc   ,
/*  2197 */	v_cod   ,
/*  2198 */	1       ,
/*  2199 */	v_dmp   ,
/*  2200 */	v_erl   ,
/*  2201 */	v_etx   ,
/*  2202 */	v_ert   ,
/*  2203 */	v_fil   ,
/*  2204 */	v_fnc   ,
/*  2205 */	v_ftr   ,
/*  2206 */	v_fls   ,
/*  2207 */	v_inp   ,
/*  2208 */	v_lfl   ,
/*  2209 */	v_lln   ,
/*  2210 */	v_lst   ,
/*  2211 */	v_lin   ,
/*  2212 */	v_mxl   ,
/*  2213 */	v_oup   ,
/*  2214 */	v_pfl   ,
/*  2215 */	v_rtn   ,
/*  2216 */	v_stc   ,
/*  2217 */	v_stl   ,
/*  2218 */	v_stn   ,
/*  2219 */	v_tra   ,
/*  2220 */	v_trm   ,
/*  2221 */	0       ,
// vsrch:
/*  2222 */	0       ,
/*  2223 */	v_eqf   ,
/*  2224 */	v_eqf   ,
/*  2225 */	v_any   ,
/*  2226 */	v_atn   ,
/*  2227 */	v_abe   ,
/*  2228 */	v_anc   ,
/*  2229 */	v_col   ,
/*  2230 */	v_alp   ,
/*  2231 */	v_bsp   ,
// c_yyy:
/*  2232 */	0       ,
//sec04
// cmlab:
/*  2233 */	b_scl   ,
/*  2234 */	2       ,
/*  2235 */	' '     ,
/*  2236 */	' '     ,
// w_aaa:
/*  2237 */	0       ,
// actrm:
/*  2238 */	0       ,
// aldyn:
/*  2239 */	0       ,
// allia:
/*  2240 */	+0      ,
// allsv:
/*  2241 */	0       ,
// alsta:
/*  2242 */	0       ,
// arcdm:
/*  2243 */	0       ,
// arnel:
/*  2244 */	+0      ,
// arptr:
/*  2245 */	0       ,
// arsvl:
/*  2246 */	+0      ,
// arfsi:
/*  2247 */	+0      ,
// arfxs:
/*  2248 */	0       ,
// befof:
/*  2249 */	0       ,
// bpfpf:
/*  2250 */	0       ,
// bpfsv:
/*  2251 */	0       ,
// bpfxt:
/*  2252 */	0       ,
// clsvi:
/*  2253 */	+0      ,
// cnscc:
/*  2254 */	0       ,
// cnswc:
/*  2255 */	0       ,
// cnr_t:
/*  2256 */	0       ,
// cnvtp:
/*  2257 */	0       ,
// datdv:
/*  2258 */	0       ,
// datxs:
/*  2259 */	0       ,
// deflb:
/*  2260 */	0       ,
// defna:
/*  2261 */	0       ,
// defvr:
/*  2262 */	0       ,
// defxs:
/*  2263 */	0       ,
// dmarg:
/*  2264 */	0       ,
// dmpsa:
/*  2265 */	0       ,
// dmpsb:
/*  2266 */	0       ,
// dmpsv:
/*  2267 */	0       ,
// dmvch:
/*  2268 */	0       ,
// dmpch:
/*  2269 */	0       ,
// dmpkb:
/*  2270 */	0       ,
// dmpkt:
/*  2271 */	0       ,
// dmpkn:
/*  2272 */	0       ,
// dtcnb:
/*  2273 */	0       ,
// dtcnm:
/*  2274 */	0       ,
// dupsi:
/*  2275 */	+0      ,
// enfch:
/*  2276 */	0       ,
// ertwa:
/*  2277 */	0       ,
// ertwb:
/*  2278 */	0       ,
// evlin:
/*  2279 */	0       ,
// evlis:
/*  2280 */	0       ,
// evliv:
/*  2281 */	0       ,
// evlio:
/*  2282 */	0       ,
// evlif:
/*  2283 */	0       ,
// expsv:
/*  2284 */	0       ,
// gbcfl:
/*  2285 */	0       ,
// gbclm:
/*  2286 */	0       ,
// gbcnm:
/*  2287 */	0       ,
// gbcns:
/*  2288 */	0       ,
// gbcmk:
/*  2289 */	0       ,
// gbcia:
/*  2290 */	+0      ,
// gbcsd:
/*  2291 */	0       ,
// gbcsf:
/*  2292 */	0       ,
// gbsva:
/*  2293 */	0       ,
// gbsvb:
/*  2294 */	0       ,
// gbsvc:
/*  2295 */	0       ,
// gnvhe:
/*  2296 */	0       ,
// gnvnw:
/*  2297 */	0       ,
// gnvsa:
/*  2298 */	0       ,
// gnvsb:
/*  2299 */	0       ,
// gnvsp:
/*  2300 */	0       ,
// gnvst:
/*  2301 */	0       ,
// gtawa:
/*  2302 */	0       ,
// gtina:
/*  2303 */	0       ,
// gtinb:
/*  2304 */	0       ,
// gtnnf:
/*  2305 */	0       ,
// gtnsi:
/*  2306 */	+0      ,
// gtndf:
/*  2307 */	0       ,
// gtnes:
/*  2308 */	0       ,
// gtnex:
/*  2309 */	+0      ,
// gtnsc:
/*  2310 */	0       ,
// gtnsr:
/*  2311 */	0       ,
// gtnrd:
/*  2312 */	0       ,
// gtpsb:
/*  2313 */	0       ,
// gtssf:
/*  2314 */	0       ,
// gtsvc:
/*  2315 */	0       ,
// gtsvb:
/*  2316 */	0       ,
// gtses:
/*  2317 */	0       ,
// gtsrs:
/*  2318 */	0       ,
// gtvrc:
/*  2319 */	0       ,
// ioptt:
/*  2320 */	0       ,
// lodfn:
/*  2321 */	0       ,
// lodna:
/*  2322 */	0       ,
// mxint:
/*  2323 */	0       ,
// pfsvw:
/*  2324 */	0       ,
// prnsi:
/*  2325 */	+0      ,
// prsna:
/*  2326 */	0       ,
// prsva:
/*  2327 */	0       ,
// prsvb:
/*  2328 */	0       ,
// prsvc:
/*  2329 */	0       ,
// prtsa:
/*  2330 */	0       ,
// prtsb:
/*  2331 */	0       ,
// prvsi:
/*  2332 */	0       ,
// psave:
/*  2333 */	0       ,
// psavc:
/*  2334 */	0       ,
// rlals:
/*  2335 */	0       ,
// rldcd:
/*  2336 */	0       ,
// rldst:
/*  2337 */	0       ,
// rldls:
/*  2338 */	0       ,
// rtnbp:
/*  2339 */	0       ,
// rtnfv:
/*  2340 */	0       ,
// rtnsv:
/*  2341 */	0       ,
// sbssv:
/*  2342 */	0       ,
// scnsa:
/*  2343 */	0       ,
// scnsb:
/*  2344 */	0       ,
// scnsc:
/*  2345 */	0       ,
// scnof:
/*  2346 */	0       ,
// srtdf:
/*  2347 */	0       ,
// srtfd:
/*  2348 */	0       ,
// srtff:
/*  2349 */	0       ,
// srtfo:
/*  2350 */	0       ,
// srtnr:
/*  2351 */	0       ,
// srtof:
/*  2352 */	0       ,
// srtrt:
/*  2353 */	0       ,
// srts1:
/*  2354 */	0       ,
// srts2:
/*  2355 */	0       ,
// srtsc:
/*  2356 */	0       ,
// srtsf:
/*  2357 */	0       ,
// srtsn:
/*  2358 */	0       ,
// srtso:
/*  2359 */	0       ,
// srtsr:
/*  2360 */	0       ,
// srtst:
/*  2361 */	0       ,
// srtwc:
/*  2362 */	0       ,
// stpsi:
/*  2363 */	+0      ,
// stpti:
/*  2364 */	+0      ,
// tfnsi:
/*  2365 */	+0      ,
// xscrt:
/*  2366 */	0       ,
// xscwb:
/*  2367 */	0       ,
// g_aaa:
/*  2368 */	0       ,
// alfsf:
/*  2369 */	+0      ,
// cmerc:
/*  2370 */	0       ,
// cmpln:
/*  2371 */	0       ,
// cmpxs:
/*  2372 */	0       ,
// cmpsn:
/*  2373 */	1       ,
// cnsil:
/*  2374 */	0       ,
// cnind:
/*  2375 */	0       ,
// cnspt:
/*  2376 */	0       ,
// cnttl:
/*  2377 */	0       ,
// cpsts:
/*  2378 */	0       ,
// cswdb:
/*  2379 */	0       ,
// cswer:
/*  2380 */	0       ,
// cswex:
/*  2381 */	0       ,
// cswfl:
/*  2382 */	1       ,
// cswin:
/*  2383 */	iniln   ,
// cswls:
/*  2384 */	1       ,
// cswno:
/*  2385 */	0       ,
// cswpr:
/*  2386 */	0       ,
// ctmsk:
/*  2387 */	0       ,
// curid:
/*  2388 */	0       ,
// cwcof:
/*  2389 */	0       ,
// dnams:
/*  2390 */	0       ,
// erich:
/*  2391 */	0       ,
// erlst:
/*  2392 */	0       ,
// errft:
/*  2393 */	0       ,
// errsp:
/*  2394 */	0       ,
// exsts:
/*  2395 */	0       ,
// flprt:
/*  2396 */	0       ,
// flptr:
/*  2397 */	0       ,
// gbsed:
/*  2398 */	+0      ,
// gbcnt:
/*  2399 */	0       ,
// gtcef:
/*  2400 */	0       ,
// gtsrn:
/*  2401 */	0       ,
// gtssc:
/*  2402 */	0       ,
// gtswk:
/*  2403 */	0       ,
// headp:
/*  2404 */	0       ,
// hshnb:
/*  2405 */	+0      ,
// initr:
/*  2406 */	0       ,
// kvabe:
/*  2407 */	0       ,
// kvanc:
/*  2408 */	1       ,
// kvcod:
/*  2409 */	0       ,
// kvcom:
/*  2410 */	0       ,
// kvdmp:
/*  2411 */	0       ,
// kverl:
/*  2412 */	0       ,
// kvert:
/*  2413 */	0       ,
// kvftr:
/*  2414 */	0       ,
// kvfls:
/*  2415 */	1       ,
// kvinp:
/*  2416 */	1       ,
// kvmxl:
/*  2417 */	5000    ,
// kvoup:
/*  2418 */	1       ,
// kvpfl:
/*  2419 */	0       ,
// kvtra:
/*  2420 */	0       ,
// kvtrm:
/*  2421 */	1       ,
// kvfnc:
/*  2422 */	0       ,
// kvlst:
/*  2423 */	0       ,
// kvlln:
/*  2424 */	0       ,
// kvlin:
/*  2425 */	0       ,
// kvstn:
/*  2426 */	0       ,
// kvalp:
/*  2427 */	0       ,
// kvrtn:
/*  2428 */	nulls   ,
// kvstl:
/*  2429 */	+2147483647,
// kvstc:
/*  2430 */	+2147483647,
// lstid:
/*  2431 */	0       ,
// lstlc:
/*  2432 */	0       ,
// lstnp:
/*  2433 */	0       ,
// lstpf:
/*  2434 */	1       ,
// lstpg:
/*  2435 */	0       ,
// lstpo:
/*  2436 */	0       ,
// lstsn:
/*  2437 */	0       ,
// mxlen:
/*  2438 */	0       ,
// noxeq:
/*  2439 */	0       ,
// pfdmp:
/*  2440 */	0       ,
// pffnc:
/*  2441 */	0       ,
// pfstm:
/*  2442 */	+0      ,
// pfetm:
/*  2443 */	+0      ,
// pfnte:
/*  2444 */	0       ,
// pfste:
/*  2445 */	+0      ,
// pmdfl:
/*  2446 */	0       ,
// pmhbs:
/*  2447 */	0       ,
// pmssl:
/*  2448 */	0       ,
// polcs:
/*  2449 */	1       ,
// polct:
/*  2450 */	1       ,
// prich:
/*  2451 */	0       ,
// prstd:
/*  2452 */	0       ,
// prsto:
/*  2453 */	0       ,
// prbuf:
/*  2454 */	0       ,
// precl:
/*  2455 */	0       ,
// prlen:
/*  2456 */	0       ,
// prlnw:
/*  2457 */	0       ,
// profs:
/*  2458 */	0       ,
// prtef:
/*  2459 */	0       ,
// rdcln:
/*  2460 */	0       ,
// rdnln:
/*  2461 */	0       ,
// rsmem:
/*  2462 */	0       ,
// stmcs:
/*  2463 */	1       ,
// stmct:
/*  2464 */	1       ,
// a_aaa:
/*  2465 */	0       ,
// cmpss:
/*  2466 */	0       ,
// dnamb:
/*  2467 */	0       ,
// dnamp:
/*  2468 */	0       ,
// dname:
/*  2469 */	0       ,
// hshtb:
/*  2470 */	0       ,
// hshte:
/*  2471 */	0       ,
// iniss:
/*  2472 */	0       ,
// pftbl:
/*  2473 */	0       ,
// prnmv:
/*  2474 */	0       ,
// statb:
/*  2475 */	0       ,
// state:
/*  2476 */	0       ,
// stxvr:
/*  2477 */	nulls   ,
// r_aaa:
/*  2478 */	0       ,
// r_arf:
/*  2479 */	0       ,
// r_ccb:
/*  2480 */	0       ,
// r_cim:
/*  2481 */	0       ,
// r_cmp:
/*  2482 */	0       ,
// r_cni:
/*  2483 */	0       ,
// r_cnt:
/*  2484 */	0       ,
// r_cod:
/*  2485 */	0       ,
// r_ctp:
/*  2486 */	0       ,
// r_cts:
/*  2487 */	0       ,
// r_ert:
/*  2488 */	0       ,
// r_etx:
/*  2489 */	nulls   ,
// r_exs:
/*  2490 */	0       ,
// r_fcb:
/*  2491 */	0       ,
// r_fnc:
/*  2492 */	0       ,
// r_gtc:
/*  2493 */	0       ,
// r_ici:
/*  2494 */	0       ,
// r_ifa:
/*  2495 */	0       ,
// r_ifl:
/*  2496 */	0       ,
// r_ifn:
/*  2497 */	0       ,
// r_inc:
/*  2498 */	0       ,
// r_io1:
/*  2499 */	0       ,
// r_io2:
/*  2500 */	0       ,
// r_iof:
/*  2501 */	0       ,
// r_ion:
/*  2502 */	0       ,
// r_iop:
/*  2503 */	0       ,
// r_iot:
/*  2504 */	0       ,
// r_pms:
/*  2505 */	0       ,
// r_ra2:
/*  2506 */	0       ,
// r_ra3:
/*  2507 */	0       ,
// r_rpt:
/*  2508 */	0       ,
// r_scp:
/*  2509 */	0       ,
// r_sfc:
/*  2510 */	nulls   ,
// r_sfn:
/*  2511 */	0       ,
// r_sxl:
/*  2512 */	0       ,
// r_sxr:
/*  2513 */	0       ,
// r_stc:
/*  2514 */	0       ,
// r_stl:
/*  2515 */	0       ,
// r_sxc:
/*  2516 */	0       ,
// r_ttl:
/*  2517 */	nulls   ,
// r_xsc:
/*  2518 */	0       ,
// r_uba:
/*  2519 */	stndo   ,
// r_ubm:
/*  2520 */	stndo   ,
// r_ubn:
/*  2521 */	stndo   ,
// r_ubp:
/*  2522 */	stndo   ,
// r_ubt:
/*  2523 */	stndo   ,
// r_uub:
/*  2524 */	stndo   ,
// r_uue:
/*  2525 */	stndo   ,
// r_uun:
/*  2526 */	stndo   ,
// r_uup:
/*  2527 */	stndo   ,
// r_uus:
/*  2528 */	stndo   ,
// r_uux:
/*  2529 */	stndo   ,
// r_yyy:
/*  2530 */	0       ,
// scnbl:
/*  2531 */	0       ,
// scncc:
/*  2532 */	0       ,
// scngo:
/*  2533 */	0       ,
// scnil:
/*  2534 */	0       ,
// scnpt:
/*  2535 */	0       ,
// scnrs:
/*  2536 */	0       ,
// scnse:
/*  2537 */	0       ,
// scntp:
/*  2538 */	0       ,
// stage:
/*  2539 */	0       ,
// stbas:
/*  2540 */	0       ,
// stxoc:
/*  2541 */	0       ,
// stxof:
/*  2542 */	0       ,
// timsx:
/*  2543 */	+0      ,
// timup:
/*  2544 */	0       ,
// xsofs:
/*  2545 */	0       ,
// w_yyy:
/*  2546 */	0       ,
/*  2547 */	bl__i   ,
// s_aaa:
// relaj:
/*  2548 */	stmt    | 1      << off_ ,	//relaj	prc e 0  entry point
/*  2549 */	stmt    | 2      << off_ ,	//	mov -(xs) xr  save xr
/*  2550 */	dca     | xs     << dst_ ,
/*  2551 */	store   | xr     << dst_ | xs     << src_ ,
/*  2552 */	stmt    | 3      << off_ ,	//	mov -(xs) wa  save wa
/*  2553 */	dca     | xs     << dst_ ,
/*  2554 */	store   | wa     << dst_ | xs     << src_ ,
/*  2555 */	stmt    | 4      << off_ ,	//	mov rlals xl  save ptr to list of bounds
/*  2556 */	store   | xl     << dst_ | rlals  << off_ ,
/*  2557 */	stmt    | 5      << off_ ,	//	mov xr wb  ptr to first pointer to process
/*  2558 */	move    | xr     << dst_ | wb     << src_ ,
// rlaj0:
/*  2559 */	stmt    | 6      << off_ ,	//rlaj0	mov xl rlals  restore xl
/*  2560 */	load    | xl     << dst_ | rlals  << off_ ,
/*  2561 */	stmt    | 7      << off_ ,	//	bne xr (xs) rlaj1 proceed if more to do
/*  2562 */	load    | r2     << dst_ | xs     << src_ ,
/*  2563 */	bne     | xr     << dst_ | r2     << src_ | rlaj1  << off_ ,
/*  2564 */	stmt    | 8      << off_ ,	//	mov wa (xs)+  restore wa
/*  2565 */	load    | wa     << dst_ | xs     << src_ ,
/*  2566 */	ica     | xs     << dst_ ,
/*  2567 */	stmt    | 9      << off_ ,	//	mov xr (xs)+  restore xr
/*  2568 */	load    | xr     << dst_ | xs     << src_ ,
/*  2569 */	ica     | xs     << dst_ ,
/*  2570 */	stmt    | 10     << off_ ,	//	exi    return to caller
/*  2571 */	exi     | 0      << off_ ,
// rlaj1:
/*  2572 */	stmt    | 11     << off_ ,	//rlaj1	mov wa (xr)  load next pointer on list
/*  2573 */	load    | wa     << dst_ | xr     << src_ ,
/*  2574 */	stmt    | 12     << off_ ,	//	lct wb =rnsi_  number of sections of adjusters
/*  2575 */	loadi   | wb     << dst_ | rnsi_  << off_ ,
// rlaj2:
/*  2576 */	stmt    | 13     << off_ ,	//rlaj2	bgt wa rlend(xl) rlaj3 ok if past end of section
/*  2577 */	load    | r2     << dst_ | xl     << src_ | rlend  << off_ ,
/*  2578 */	bgt     | wa     << dst_ | r2     << src_ | rlaj3  << off_ ,
/*  2579 */	stmt    | 14     << off_ ,	//	blt wa rlstr(xl) rlaj3 or if before start of section
/*  2580 */	load    | r2     << dst_ | xl     << src_ | rlstr  << off_ ,
/*  2581 */	blt     | wa     << dst_ | r2     << src_ | rlaj3  << off_ ,
/*  2582 */	stmt    | 15     << off_ ,	//	add wa rladj(xl)  within section, add adjustment
/*  2583 */	load    | r2     << dst_ | xl     << src_ | rladj  << off_ ,
/*  2584 */	add     | wa     << dst_ | r2     << src_ ,
/*  2585 */	stmt    | 16     << off_ ,	//	mov (xr) wa  return updated ptr to memory
/*  2586 */	store   | wa     << dst_ | xr     << src_ ,
/*  2587 */	stmt    | 17     << off_ ,	//	brn rlaj4   done with this pointer
/*  2588 */	brn     | rlaj4  << off_ ,
// rlaj3:
/*  2589 */	stmt    | 18     << off_ ,	//rlaj3	add xl *rssi_  advance to next section
/*  2590 */	loadi   | r2     << dst_ | rssi_  << off_ ,
/*  2591 */	add     | xl     << dst_ | r2     << src_ ,
/*  2592 */	stmt    | 19     << off_ ,	//	bct wb rlaj2  jump if more to go
/*  2593 */	bct     | wb     << dst_ | rlaj2  << off_ ,
// rlaj4:
/*  2594 */	stmt    | 20     << off_ ,	//rlaj4	ica xr   increment to next ptr on list
/*  2595 */	ica     | xr     << dst_ ,
/*  2596 */	stmt    | 21     << off_ ,	//	brn rlaj0   jump to check  for completion
/*  2597 */	brn     | rlaj0  << off_ ,
// relcr:
/*  2598 */	stmt    | 22     << off_ ,	//relcr	prc e 0  entry point
/*  2599 */	stmt    | 23     << off_ ,	//	add xl *rlsi_  point past build area
/*  2600 */	loadi   | r2     << dst_ | rlsi_  << off_ ,
/*  2601 */	add     | xl     << dst_ | r2     << src_ ,
/*  2602 */	stmt    | 24     << off_ ,	//	mov -(xl) wa  save original code address
/*  2603 */	dca     | xl     << dst_ ,
/*  2604 */	store   | wa     << dst_ | xl     << src_ ,
/*  2605 */	stmt    | 25     << off_ ,	//	mov wa =s_aaa  compute adjustment
/*  2606 */	loadi   | wa     << dst_ | s_aaa  << off_ ,
/*  2607 */	stmt    | 26     << off_ ,	//	sub wa (xl)  as new s_aaa minus original s_aaa
/*  2608 */	load    | r2     << dst_ | xl     << src_ ,
/*  2609 */	sub     | wa     << dst_ | r2     << src_ ,
/*  2610 */	stmt    | 27     << off_ ,	//	mov -(xl) wa  save code adjustment
/*  2611 */	dca     | xl     << dst_ ,
/*  2612 */	store   | wa     << dst_ | xl     << src_ ,
/*  2613 */	stmt    | 28     << off_ ,	//	mov wa =s_yyy  end of target code section
/*  2614 */	loadi   | wa     << dst_ | s_yyy  << off_ ,
/*  2615 */	stmt    | 29     << off_ ,	//	sub wa =s_aaa  length of code section
/*  2616 */	loadi   | r2     << dst_ | s_aaa  << off_ ,
/*  2617 */	sub     | wa     << dst_ | r2     << src_ ,
/*  2618 */	stmt    | 30     << off_ ,	//	add wa num01(xl)  plus original start address
/*  2619 */	load    | r2     << dst_ | xl     << src_ | num01  << off_ ,
/*  2620 */	add     | wa     << dst_ | r2     << src_ ,
/*  2621 */	stmt    | 31     << off_ ,	//	mov -(xl) wa  end of original code section
/*  2622 */	dca     | xl     << dst_ ,
/*  2623 */	store   | wa     << dst_ | xl     << src_ ,
/*  2624 */	stmt    | 32     << off_ ,	//	mov -(xl) wb  save constant section address
/*  2625 */	dca     | xl     << dst_ ,
/*  2626 */	store   | wb     << dst_ | xl     << src_ ,
/*  2627 */	stmt    | 33     << off_ ,	//	mov wb =c_aaa  start of constants section
/*  2628 */	loadi   | wb     << dst_ | c_aaa  << off_ ,
/*  2629 */	stmt    | 34     << off_ ,	//	mov wa =c_yyy  end of constants section
/*  2630 */	loadi   | wa     << dst_ | c_yyy  << off_ ,
/*  2631 */	stmt    | 35     << off_ ,	//	sub wa wb  length of constants section
/*  2632 */	sub     | wa     << dst_ | wb     << src_ ,
/*  2633 */	stmt    | 36     << off_ ,	//	sub wb (xl)  new c_aaa minus original c_aaa
/*  2634 */	load    | r2     << dst_ | xl     << src_ ,
/*  2635 */	sub     | wb     << dst_ | r2     << src_ ,
/*  2636 */	stmt    | 37     << off_ ,	//	mov -(xl) wb  save constant adjustment
/*  2637 */	dca     | xl     << dst_ ,
/*  2638 */	store   | wb     << dst_ | xl     << src_ ,
/*  2639 */	stmt    | 38     << off_ ,	//	add wa num01(xl)  length plus original start adr
/*  2640 */	load    | r2     << dst_ | xl     << src_ | num01  << off_ ,
/*  2641 */	add     | wa     << dst_ | r2     << src_ ,
/*  2642 */	stmt    | 39     << off_ ,	//	mov -(xl) wa  save as end of original constants
/*  2643 */	dca     | xl     << dst_ ,
/*  2644 */	store   | wa     << dst_ | xl     << src_ ,
/*  2645 */	stmt    | 40     << off_ ,	//	mov -(xl) wc  save working globals address
/*  2646 */	dca     | xl     << dst_ ,
/*  2647 */	store   | wc     << dst_ | xl     << src_ ,
/*  2648 */	stmt    | 41     << off_ ,	//	mov wc =g_aaa  start of working globals section
/*  2649 */	loadi   | wc     << dst_ | g_aaa  << off_ ,
/*  2650 */	stmt    | 42     << off_ ,	//	mov wa =w_yyy  end of working section
/*  2651 */	loadi   | wa     << dst_ | w_yyy  << off_ ,
/*  2652 */	stmt    | 43     << off_ ,	//	sub wa wc  length of working globals
/*  2653 */	sub     | wa     << dst_ | wc     << src_ ,
/*  2654 */	stmt    | 44     << off_ ,	//	sub wc (xl)  new g_aaa minus original g_aaa
/*  2655 */	load    | r2     << dst_ | xl     << src_ ,
/*  2656 */	sub     | wc     << dst_ | r2     << src_ ,
/*  2657 */	stmt    | 45     << off_ ,	//	mov -(xl) wc  save working globals adjustment
/*  2658 */	dca     | xl     << dst_ ,
/*  2659 */	store   | wc     << dst_ | xl     << src_ ,
/*  2660 */	stmt    | 46     << off_ ,	//	add wa num01(xl)  length plus original start adr
/*  2661 */	load    | r2     << dst_ | xl     << src_ | num01  << off_ ,
/*  2662 */	add     | wa     << dst_ | r2     << src_ ,
/*  2663 */	stmt    | 47     << off_ ,	//	mov -(xl) wa  save as end of working globals
/*  2664 */	dca     | xl     << dst_ ,
/*  2665 */	store   | wa     << dst_ | xl     << src_ ,
/*  2666 */	stmt    | 48     << off_ ,	//	mov wb statb  old start of static region
/*  2667 */	load    | wb     << dst_ | statb  << off_ ,
/*  2668 */	stmt    | 49     << off_ ,	//	mov -(xl) wb  save
/*  2669 */	dca     | xl     << dst_ ,
/*  2670 */	store   | wb     << dst_ | xl     << src_ ,
/*  2671 */	stmt    | 50     << off_ ,	//	sub xr wb  compute adjustment
/*  2672 */	sub     | xr     << dst_ | wb     << src_ ,
/*  2673 */	stmt    | 51     << off_ ,	//	mov -(xl) xr  save new statb minus old statb
/*  2674 */	dca     | xl     << dst_ ,
/*  2675 */	store   | xr     << dst_ | xl     << src_ ,
/*  2676 */	stmt    | 52     << off_ ,	//	mov -(xl) state  old end of static region
/*  2677 */	load    | r1     << dst_ | state  << off_ ,
/*  2678 */	dca     | xl     << dst_ ,
/*  2679 */	store   | r1     << dst_ | xl     << src_ ,
/*  2680 */	stmt    | 53     << off_ ,	//	mov wb dnamb  old start of dynamic region
/*  2681 */	load    | wb     << dst_ | dnamb  << off_ ,
/*  2682 */	stmt    | 54     << off_ ,	//	mov -(xl) wb  save
/*  2683 */	dca     | xl     << dst_ ,
/*  2684 */	store   | wb     << dst_ | xl     << src_ ,
/*  2685 */	stmt    | 55     << off_ ,	//	scp wa   new start of dynamic
/*  2686 */	scp     | wa     << dst_ ,
/*  2687 */	stmt    | 56     << off_ ,	//	sub wa wb  compute adjustment
/*  2688 */	sub     | wa     << dst_ | wb     << src_ ,
/*  2689 */	stmt    | 57     << off_ ,	//	mov -(xl) wa  save new dnamb minus old dnamb
/*  2690 */	dca     | xl     << dst_ ,
/*  2691 */	store   | wa     << dst_ | xl     << src_ ,
/*  2692 */	stmt    | 58     << off_ ,	//	mov wc dnamp  old end of dynamic region in use
/*  2693 */	load    | wc     << dst_ | dnamp  << off_ ,
/*  2694 */	stmt    | 59     << off_ ,	//	mov -(xl) wc  save as end of old dynamic region
/*  2695 */	dca     | xl     << dst_ ,
/*  2696 */	store   | wc     << dst_ | xl     << src_ ,
/*  2697 */	stmt    | 60     << off_ ,	//	exi
/*  2698 */	exi     | 0      << off_ ,
// reldn:
/*  2699 */	stmt    | 61     << off_ ,	//reldn	prc e 0  entry point
/*  2700 */	stmt    | 62     << off_ ,	//	mov rldcd rlcda(xl)  save code adjustment
/*  2701 */	load    | r1     << dst_ | xl     << src_ | rlcda  << off_ ,
/*  2702 */	store   | r1     << dst_ | rldcd  << off_ ,
/*  2703 */	stmt    | 63     << off_ ,	//	mov rldst rlsta(xl)  save static adjustment
/*  2704 */	load    | r1     << dst_ | xl     << src_ | rlsta  << off_ ,
/*  2705 */	store   | r1     << dst_ | rldst  << off_ ,
/*  2706 */	stmt    | 64     << off_ ,	//	mov rldls xl  save list pointer
/*  2707 */	store   | xl     << dst_ | rldls  << off_ ,
// rld01:
/*  2708 */	stmt    | 65     << off_ ,	//rld01	add (xr) rldcd  adjust block type word
/*  2709 */	load    | r1     << dst_ | xr     << src_ ,
/*  2710 */	load    | r2     << dst_ | rldcd  << off_ ,
/*  2711 */	add     | r1     << dst_ | r2     << src_ ,
/*  2712 */	store   | r1     << dst_ | xr     << src_ ,
/*  2713 */	stmt    | 66     << off_ ,	//	mov xl (xr)  load block type word
/*  2714 */	load    | xl     << dst_ | xr     << src_ ,
/*  2715 */	stmt    | 67     << off_ ,	//	lei xl   load entry point id (bl_xx)
/*  2716 */	lei     | xl     << dst_ ,
/*  2717 */	stmt    | 68     << off_ ,	//	bsw xl bl___  switch on block type
/*  2718 */	loadi   | r1     << dst_ | bl___  << off_ ,
/*  2719 */	bsw     | xl     << dst_ | r1     << src_ ,
/*  2720 */	rld03   ,
/*  2721 */	rld07   ,
/*  2722 */	rld10   ,
/*  2723 */	rld05   ,
/*  2724 */	rld13   ,
/*  2725 */	rld13   ,
/*  2726 */	rld14   ,
/*  2727 */	rld14   ,
/*  2728 */	rld05   ,
/*  2729 */	rld05   ,
/*  2730 */	rld13   ,
/*  2731 */	rld17   ,
/*  2732 */	rld17   ,
/*  2733 */	rld05   ,
/*  2734 */	rld20   ,
/*  2735 */	rld05   ,
/*  2736 */	rld15   ,
/*  2737 */	rld19   ,
/*  2738 */	rld05   ,
/*  2739 */	rld05   ,
/*  2740 */	rld05   ,
/*  2741 */	rld05   ,
/*  2742 */	rld05   ,
/*  2743 */	rld08   ,
/*  2744 */	rld09   ,
/*  2745 */	rld11   ,
/*  2746 */	rld13   ,
/*  2747 */	rld16   ,
/*  2748 */	rld18   ,
// rld03:
/*  2749 */	stmt    | 69     << off_ ,	//rld03	mov wa arlen(xr)  load length
/*  2750 */	load    | wa     << dst_ | xr     << src_ | arlen  << off_ ,
/*  2751 */	stmt    | 70     << off_ ,	//	mov wb arofs(xr)  set offset to 1st reloc fld (arpro)
/*  2752 */	load    | wb     << dst_ | xr     << src_ | arofs  << off_ ,
// rld04:
/*  2753 */	stmt    | 71     << off_ ,	//rld04	add wa xr  point past last reloc field
/*  2754 */	add     | wa     << dst_ | xr     << src_ ,
/*  2755 */	stmt    | 72     << off_ ,	//	add wb xr  point to first reloc field
/*  2756 */	add     | wb     << dst_ | xr     << src_ ,
/*  2757 */	stmt    | 73     << off_ ,	//	mov xl rldls  point to list of bounds
/*  2758 */	load    | xl     << dst_ | rldls  << off_ ,
/*  2759 */	stmt    | 74     << off_ ,	//	jsr relaj   adjust pointers
/*  2760 */	call    | relaj  << off_ ,
// rld05:
/*  2761 */	stmt    | 75     << off_ ,	//rld05	mov wa (xr)  block type word
/*  2762 */	load    | wa     << dst_ | xr     << src_ ,
/*  2763 */	stmt    | 76     << off_ ,	//	jsr blkln   get length of block
/*  2764 */	call    | blkln  << off_ ,
/*  2765 */	stmt    | 77     << off_ ,	//	add xr wa  point to next block
/*  2766 */	add     | xr     << dst_ | wa     << src_ ,
/*  2767 */	stmt    | 78     << off_ ,	//	blt xr wc rld01 continue if more to process
/*  2768 */	blt     | xr     << dst_ | wc     << src_ | rld01  << off_ ,
/*  2769 */	stmt    | 79     << off_ ,	//	mov xl rldls  restore xl
/*  2770 */	load    | xl     << dst_ | rldls  << off_ ,
/*  2771 */	stmt    | 80     << off_ ,	//	exi    return to caller if done
/*  2772 */	exi     | 0      << off_ ,
// rld07:
/*  2773 */	stmt    | 81     << off_ ,	//rld07	mov wa cdlen(xr)  load length
/*  2774 */	load    | wa     << dst_ | xr     << src_ | cdlen  << off_ ,
/*  2775 */	stmt    | 82     << off_ ,	//	mov wb *cdfal  set offset
/*  2776 */	loadi   | wb     << dst_ | cdfal  << off_ ,
/*  2777 */	stmt    | 83     << off_ ,	//	bne (xr) =b_cdc rld04 jump back if not complex goto
/*  2778 */	load    | r1     << dst_ | xr     << src_ ,
/*  2779 */	loadi   | r2     << dst_ | b_cdc  << off_ ,
/*  2780 */	bne     | r1     << dst_ | r2     << src_ | rld04  << off_ ,
/*  2781 */	stmt    | 84     << off_ ,	//	mov wb *cdcod  do not process cdfal word
/*  2782 */	loadi   | wb     << dst_ | cdcod  << off_ ,
/*  2783 */	stmt    | 85     << off_ ,	//	brn rld04   jump back
/*  2784 */	brn     | rld04  << off_ ,
// rld08:
/*  2785 */	stmt    | 86     << off_ ,	//rld08	mov wa *efrsl  set length
/*  2786 */	loadi   | wa     << dst_ | efrsl  << off_ ,
/*  2787 */	stmt    | 87     << off_ ,	//	mov wb *efcod  and offset
/*  2788 */	loadi   | wb     << dst_ | efcod  << off_ ,
/*  2789 */	stmt    | 88     << off_ ,	//	brn rld04   all set
/*  2790 */	brn     | rld04  << off_ ,
// rld09:
/*  2791 */	stmt    | 89     << off_ ,	//rld09	mov wa *offs3  point past third field
/*  2792 */	loadi   | wa     << dst_ | offs3  << off_ ,
/*  2793 */	stmt    | 90     << off_ ,	//	mov wb *evexp  set offset
/*  2794 */	loadi   | wb     << dst_ | evexp  << off_ ,
/*  2795 */	stmt    | 91     << off_ ,	//	brn rld04   all set
/*  2796 */	brn     | rld04  << off_ ,
// rld10:
/*  2797 */	stmt    | 92     << off_ ,	//rld10	mov wa exlen(xr)  load length
/*  2798 */	load    | wa     << dst_ | xr     << src_ | exlen  << off_ ,
/*  2799 */	stmt    | 93     << off_ ,	//	mov wb *exflc  set offset
/*  2800 */	loadi   | wb     << dst_ | exflc  << off_ ,
/*  2801 */	stmt    | 94     << off_ ,	//	brn rld04   jump back
/*  2802 */	brn     | rld04  << off_ ,
// rld11:
/*  2803 */	stmt    | 95     << off_ ,	//rld11	bne ffofs(xr) *pdfld rld12 skip dfblk if not first field
/*  2804 */	load    | r1     << dst_ | xr     << src_ | ffofs  << off_ ,
/*  2805 */	loadi   | r2     << dst_ | pdfld  << off_ ,
/*  2806 */	bne     | r1     << dst_ | r2     << src_ | rld12  << off_ ,
/*  2807 */	stmt    | 96     << off_ ,	//	mov -(xs) xr  save xr
/*  2808 */	dca     | xs     << dst_ ,
/*  2809 */	store   | xr     << dst_ | xs     << src_ ,
/*  2810 */	stmt    | 97     << off_ ,	//	mov xr ffdfp(xr)  load old ptr to dfblk
/*  2811 */	load    | xr     << dst_ | xr     << src_ | ffdfp  << off_ ,
/*  2812 */	stmt    | 98     << off_ ,	//	add xr rldst  current location of dfblk
/*  2813 */	load    | r2     << dst_ | rldst  << off_ ,
/*  2814 */	add     | xr     << dst_ | r2     << src_ ,
/*  2815 */	stmt    | 99     << off_ ,	//	add (xr) rldcd  adjust dfblk type word
/*  2816 */	load    | r1     << dst_ | xr     << src_ ,
/*  2817 */	load    | r2     << dst_ | rldcd  << off_ ,
/*  2818 */	add     | r1     << dst_ | r2     << src_ ,
/*  2819 */	store   | r1     << dst_ | xr     << src_ ,
/*  2820 */	stmt    | 100    << off_ ,	//	mov wa dflen(xr)  length of dfblk
/*  2821 */	load    | wa     << dst_ | xr     << src_ | dflen  << off_ ,
/*  2822 */	stmt    | 101    << off_ ,	//	mov wb *dfnam  offset to dfnam field
/*  2823 */	loadi   | wb     << dst_ | dfnam  << off_ ,
/*  2824 */	stmt    | 102    << off_ ,	//	add wa xr  point past last reloc field
/*  2825 */	add     | wa     << dst_ | xr     << src_ ,
/*  2826 */	stmt    | 103    << off_ ,	//	add wb xr  point to first reloc field
/*  2827 */	add     | wb     << dst_ | xr     << src_ ,
/*  2828 */	stmt    | 104    << off_ ,	//	mov xl rldls  point to list of bounds
/*  2829 */	load    | xl     << dst_ | rldls  << off_ ,
/*  2830 */	stmt    | 105    << off_ ,	//	jsr relaj   adjust pointers
/*  2831 */	call    | relaj  << off_ ,
/*  2832 */	stmt    | 106    << off_ ,	//	mov xr dfnam(xr)  pointer to static scblk
/*  2833 */	load    | xr     << dst_ | xr     << src_ | dfnam  << off_ ,
/*  2834 */	stmt    | 107    << off_ ,	//	add (xr) rldcd  adjust scblk type word
/*  2835 */	load    | r1     << dst_ | xr     << src_ ,
/*  2836 */	load    | r2     << dst_ | rldcd  << off_ ,
/*  2837 */	add     | r1     << dst_ | r2     << src_ ,
/*  2838 */	store   | r1     << dst_ | xr     << src_ ,
/*  2839 */	stmt    | 108    << off_ ,	//	mov xr (xs)+  restore ffblk pointer
/*  2840 */	load    | xr     << dst_ | xs     << src_ ,
/*  2841 */	ica     | xs     << dst_ ,
// rld12:
/*  2842 */	stmt    | 109    << off_ ,	//rld12	mov wa *ffofs  set length
/*  2843 */	loadi   | wa     << dst_ | ffofs  << off_ ,
/*  2844 */	stmt    | 110    << off_ ,	//	mov wb *ffdfp  set offset
/*  2845 */	loadi   | wb     << dst_ | ffdfp  << off_ ,
/*  2846 */	stmt    | 111    << off_ ,	//	brn rld04   all set
/*  2847 */	brn     | rld04  << off_ ,
// rld13:
/*  2848 */	stmt    | 112    << off_ ,	//rld13	mov wa *offs2  point past second field
/*  2849 */	loadi   | wa     << dst_ | offs2  << off_ ,
/*  2850 */	stmt    | 113    << off_ ,	//	mov wb *offs1  offset is one (only reloc fld is 2)
/*  2851 */	loadi   | wb     << dst_ | offs1  << off_ ,
/*  2852 */	stmt    | 114    << off_ ,	//	brn rld04   all set
/*  2853 */	brn     | rld04  << off_ ,
// rld14:
/*  2854 */	stmt    | 115    << off_ ,	//rld14	mov wa *parm2  length (parm2 is non-relocatable)
/*  2855 */	loadi   | wa     << dst_ | parm2  << off_ ,
/*  2856 */	stmt    | 116    << off_ ,	//	mov wb *pthen  set offset
/*  2857 */	loadi   | wb     << dst_ | pthen  << off_ ,
/*  2858 */	stmt    | 117    << off_ ,	//	brn rld04   all set
/*  2859 */	brn     | rld04  << off_ ,
// rld15:
/*  2860 */	stmt    | 118    << off_ ,	//rld15	mov xl pddfp(xr)  load ptr to dfblk
/*  2861 */	load    | xl     << dst_ | xr     << src_ | pddfp  << off_ ,
/*  2862 */	stmt    | 119    << off_ ,	//	add xl rldst  adjust for static relocation
/*  2863 */	load    | r2     << dst_ | rldst  << off_ ,
/*  2864 */	add     | xl     << dst_ | r2     << src_ ,
/*  2865 */	stmt    | 120    << off_ ,	//	mov wa dfpdl(xl)  get pdblk length
/*  2866 */	load    | wa     << dst_ | xl     << src_ | dfpdl  << off_ ,
/*  2867 */	stmt    | 121    << off_ ,	//	mov wb *pddfp  set offset
/*  2868 */	loadi   | wb     << dst_ | pddfp  << off_ ,
/*  2869 */	stmt    | 122    << off_ ,	//	brn rld04   all set
/*  2870 */	brn     | rld04  << off_ ,
// rld16:
/*  2871 */	stmt    | 123    << off_ ,	//rld16	add pfvbl(xr) rldst  adjust non-contiguous field
/*  2872 */	load    | r1     << dst_ | xr     << src_ | pfvbl  << off_ ,
/*  2873 */	load    | r2     << dst_ | rldst  << off_ ,
/*  2874 */	add     | r1     << dst_ | r2     << src_ ,
/*  2875 */	store   | r1     << dst_ | xr     << src_ | pfvbl  << off_ ,
/*  2876 */	stmt    | 124    << off_ ,	//	mov wa pflen(xr)  get pfblk length
/*  2877 */	load    | wa     << dst_ | xr     << src_ | pflen  << off_ ,
/*  2878 */	stmt    | 125    << off_ ,	//	mov wb *pfcod  offset to first reloc
/*  2879 */	loadi   | wb     << dst_ | pfcod  << off_ ,
/*  2880 */	stmt    | 126    << off_ ,	//	brn rld04   all set
/*  2881 */	brn     | rld04  << off_ ,
// rld17:
/*  2882 */	stmt    | 127    << off_ ,	//rld17	mov wa offs2(xr)  load length
/*  2883 */	load    | wa     << dst_ | xr     << src_ | offs2  << off_ ,
/*  2884 */	stmt    | 128    << off_ ,	//	mov wb *offs3  set offset
/*  2885 */	loadi   | wb     << dst_ | offs3  << off_ ,
/*  2886 */	stmt    | 129    << off_ ,	//	brn rld04   jump back
/*  2887 */	brn     | rld04  << off_ ,
// rld18:
/*  2888 */	stmt    | 130    << off_ ,	//rld18	mov wa *tesi_  set length
/*  2889 */	loadi   | wa     << dst_ | tesi_  << off_ ,
/*  2890 */	stmt    | 131    << off_ ,	//	mov wb *tesub  and offset
/*  2891 */	loadi   | wb     << dst_ | tesub  << off_ ,
/*  2892 */	stmt    | 132    << off_ ,	//	brn rld04   all set
/*  2893 */	brn     | rld04  << off_ ,
// rld19:
/*  2894 */	stmt    | 133    << off_ ,	//rld19	mov wa *trsi_  set length
/*  2895 */	loadi   | wa     << dst_ | trsi_  << off_ ,
/*  2896 */	stmt    | 134    << off_ ,	//	mov wb *trval  and offset
/*  2897 */	loadi   | wb     << dst_ | trval  << off_ ,
/*  2898 */	stmt    | 135    << off_ ,	//	brn rld04   all set
/*  2899 */	brn     | rld04  << off_ ,
// rld20:
/*  2900 */	stmt    | 136    << off_ ,	//rld20	mov wa xrlen(xr)  load length
/*  2901 */	load    | wa     << dst_ | xr     << src_ | xrlen  << off_ ,
/*  2902 */	stmt    | 137    << off_ ,	//	mov wb *xrptr  set offset
/*  2903 */	loadi   | wb     << dst_ | xrptr  << off_ ,
/*  2904 */	stmt    | 138    << off_ ,	//	brn rld04   jump back
/*  2905 */	brn     | rld04  << off_ ,
// reloc:
/*  2906 */	stmt    | 139    << off_ ,	//reloc	prc e 0  entry point
/*  2907 */	stmt    | 140    << off_ ,	//	mov xr rldys(xl)  old start of dynamic
/*  2908 */	load    | xr     << dst_ | xl     << src_ | rldys  << off_ ,
/*  2909 */	stmt    | 141    << off_ ,	//	mov wc rldye(xl)  old end of dynamic
/*  2910 */	load    | wc     << dst_ | xl     << src_ | rldye  << off_ ,
/*  2911 */	stmt    | 142    << off_ ,	//	add xr rldya(xl)  create new start of dynamic
/*  2912 */	load    | r2     << dst_ | xl     << src_ | rldya  << off_ ,
/*  2913 */	add     | xr     << dst_ | r2     << src_ ,
/*  2914 */	stmt    | 143    << off_ ,	//	add wc rldya(xl)  create new end of dynamic
/*  2915 */	load    | r2     << dst_ | xl     << src_ | rldya  << off_ ,
/*  2916 */	add     | wc     << dst_ | r2     << src_ ,
/*  2917 */	stmt    | 144    << off_ ,	//	jsr reldn   relocate pointers in dynamic
/*  2918 */	call    | reldn  << off_ ,
/*  2919 */	stmt    | 145    << off_ ,	//	jsr relws   relocate pointers in working sect
/*  2920 */	call    | relws  << off_ ,
/*  2921 */	stmt    | 146    << off_ ,	//	jsr relst   relocate pointers in static
/*  2922 */	call    | relst  << off_ ,
/*  2923 */	stmt    | 147    << off_ ,	//	exi    return to caller
/*  2924 */	exi     | 0      << off_ ,
// relst:
/*  2925 */	stmt    | 148    << off_ ,	//relst	prc e 0  entry point
/*  2926 */	stmt    | 149    << off_ ,	//	mov xr pftbl  profile table
/*  2927 */	load    | xr     << dst_ | pftbl  << off_ ,
/*  2928 */	stmt    | 150    << off_ ,	//	bze xr rls01  branch if no table allocated
/*  2929 */	bze     | xr     << dst_ | rls01  << off_ ,
/*  2930 */	stmt    | 151    << off_ ,	//	add (xr) rlcda(xl)  adjust block type word
/*  2931 */	load    | r1     << dst_ | xr     << src_ ,
/*  2932 */	load    | r2     << dst_ | xl     << src_ | rlcda  << off_ ,
/*  2933 */	add     | r1     << dst_ | r2     << src_ ,
/*  2934 */	store   | r1     << dst_ | xr     << src_ ,
// rls01:
/*  2935 */	stmt    | 152    << off_ ,	//rls01	mov wc hshtb  point to start of hash table
/*  2936 */	load    | wc     << dst_ | hshtb  << off_ ,
/*  2937 */	stmt    | 153    << off_ ,	//	mov wb wc  point to first hash bucket
/*  2938 */	move    | wb     << dst_ | wc     << src_ ,
/*  2939 */	stmt    | 154    << off_ ,	//	mov wa hshte  point beyond hash table
/*  2940 */	load    | wa     << dst_ | hshte  << off_ ,
/*  2941 */	stmt    | 155    << off_ ,	//	jsr relaj   adjust bucket pointers
/*  2942 */	call    | relaj  << off_ ,
// rls02:
/*  2943 */	stmt    | 156    << off_ ,	//rls02	beq wc hshte rls05 done if none left
/*  2944 */	load    | r2     << dst_ | hshte  << off_ ,
/*  2945 */	beq     | wc     << dst_ | r2     << src_ | rls05  << off_ ,
/*  2946 */	stmt    | 157    << off_ ,	//	mov xr wc  else copy slot pointer
/*  2947 */	move    | xr     << dst_ | wc     << src_ ,
/*  2948 */	stmt    | 158    << off_ ,	//	ica wc   bump slot pointer
/*  2949 */	ica     | wc     << dst_ ,
/*  2950 */	stmt    | 159    << off_ ,	//	sub xr *vrnxt  set offset to merge into loop
/*  2951 */	loadi   | r2     << dst_ | vrnxt  << off_ ,
/*  2952 */	sub     | xr     << dst_ | r2     << src_ ,
// rls03:
/*  2953 */	stmt    | 160    << off_ ,	//rls03	mov xr vrnxt(xr)  point to next vrblk on chain
/*  2954 */	load    | xr     << dst_ | xr     << src_ | vrnxt  << off_ ,
/*  2955 */	stmt    | 161    << off_ ,	//	bze xr rls02  jump for next bucket if chain end
/*  2956 */	bze     | xr     << dst_ | rls02  << off_ ,
/*  2957 */	stmt    | 162    << off_ ,	//	mov wa *vrlen  offset of first loc past ptr fields
/*  2958 */	loadi   | wa     << dst_ | vrlen  << off_ ,
/*  2959 */	stmt    | 163    << off_ ,	//	mov wb *vrget  offset of first location in vrblk
/*  2960 */	loadi   | wb     << dst_ | vrget  << off_ ,
/*  2961 */	stmt    | 164    << off_ ,	//	bnz vrlen(xr) rls04  jump if not system variable
/*  2962 */	load    | r1     << dst_ | xr     << src_ | vrlen  << off_ ,
/*  2963 */	bnz     | r1     << dst_ | rls04  << off_ ,
/*  2964 */	stmt    | 165    << off_ ,	//	mov wa *vrsi_  offset to include vrsvp field
/*  2965 */	loadi   | wa     << dst_ | vrsi_  << off_ ,
// rls04:
/*  2966 */	stmt    | 166    << off_ ,	//rls04	add wa xr  create end ptr
/*  2967 */	add     | wa     << dst_ | xr     << src_ ,
/*  2968 */	stmt    | 167    << off_ ,	//	add wb xr  create start ptr
/*  2969 */	add     | wb     << dst_ | xr     << src_ ,
/*  2970 */	stmt    | 168    << off_ ,	//	jsr relaj   adjust pointers in vrblk
/*  2971 */	call    | relaj  << off_ ,
/*  2972 */	stmt    | 169    << off_ ,	//	brn rls03   check for another vrblk on chain
/*  2973 */	brn     | rls03  << off_ ,
// rls05:
/*  2974 */	stmt    | 170    << off_ ,	//rls05	exi    return to caller
/*  2975 */	exi     | 0      << off_ ,
// relws:
/*  2976 */	stmt    | 171    << off_ ,	//relws	prc e 0  entry point
/*  2977 */	stmt    | 172    << off_ ,	//	mov wb =a_aaa  point to start of adjustables
/*  2978 */	loadi   | wb     << dst_ | a_aaa  << off_ ,
/*  2979 */	stmt    | 173    << off_ ,	//	mov wa =r_yyy  point to end of adjustables
/*  2980 */	loadi   | wa     << dst_ | r_yyy  << off_ ,
/*  2981 */	stmt    | 174    << off_ ,	//	jsr relaj   relocate adjustable pointers
/*  2982 */	call    | relaj  << off_ ,
/*  2983 */	stmt    | 175    << off_ ,	//	add dname rldya(xl)  adjust ptr missed by relaj
/*  2984 */	load    | r1     << dst_ | dname  << off_ ,
/*  2985 */	load    | r2     << dst_ | xl     << src_ | rldya  << off_ ,
/*  2986 */	add     | r1     << dst_ | r2     << src_ ,
/*  2987 */	store   | r1     << dst_ | dname  << off_ ,
/*  2988 */	stmt    | 176    << off_ ,	//	mov wb =kvrtn  case of kvrtn
/*  2989 */	loadi   | wb     << dst_ | kvrtn  << off_ ,
/*  2990 */	stmt    | 177    << off_ ,	//	mov wa wb  handled specially
/*  2991 */	move    | wa     << dst_ | wb     << src_ ,
/*  2992 */	stmt    | 178    << off_ ,	//	ica wa   one value to adjust
/*  2993 */	ica     | wa     << dst_ ,
/*  2994 */	stmt    | 179    << off_ ,	//	jsr relaj   adjust kvrtn
/*  2995 */	call    | relaj  << off_ ,
/*  2996 */	stmt    | 180    << off_ ,	//	exi    return to caller
/*  2997 */	exi     | 0      << off_ ,
// start:
/*  2998 */	stmt    | 181    << off_ ,	//start	prc e 0  entry point
/*  2999 */	stmt    | 182    << off_ ,	//	mov mxint wb
/*  3000 */	store   | wb     << dst_ | mxint  << off_ ,
/*  3001 */	stmt    | 183    << off_ ,	//	mov 4,bitsm wb
/*  3002 */	store   | wb     << dst_ | bitsm  << off_ ,
/*  3003 */	stmt    | 184    << off_ ,	//	zer wb
/*  3004 */	move    | wb     << dst_ ,
/*  3005 */	stmt    | 185    << off_ ,	//	mov xs wa  discard return
/*  3006 */	move    | xs     << dst_ | wa     << src_ ,
/*  3007 */	stmt    | 186    << off_ ,	//	jsr systm   initialise timer
/*  3008 */	sys     | systm_ << off_ ,
/*  3009 */	stmt    | 187    << off_ ,	//	sti timsx   store time
/*  3010 */	store   | ia     << dst_ | timsx  << off_ ,
/*  3011 */	stmt    | 188    << off_ ,	//	mov statb xr  start address of static
/*  3012 */	store   | xr     << dst_ | statb  << off_ ,
/*  3013 */	stmt    | 189    << off_ ,	//	mov rsmem *e_srs  reserve memory
/*  3014 */	loadi   | r1     << dst_ | e_srs  << off_ ,
/*  3015 */	store   | r1     << dst_ | rsmem  << off_ ,
/*  3016 */	stmt    | 190    << off_ ,	//	mov stbas xs  store stack base
/*  3017 */	store   | xs     << dst_ | stbas  << off_ ,
/*  3018 */	stmt    | 191    << off_ ,	//	sss iniss   save s-r stack ptr
/*  3019 */	stmt    | 192    << off_ ,	//	ldi 4,intvh   get 100
/*  3020 */	load    | r1     << dst_ | intvh  << off_ ,
/*  3021 */	ldi     | r1     << dst_ ,
/*  3022 */	stmt    | 193    << off_ ,	//	dvi 4,alfsp   form 100 / alfsp
/*  3023 */	load    | r1     << dst_ | alfsp  << off_ ,
/*  3024 */	dvi     | r1     << dst_ ,
/*  3025 */	stmt    | 194    << off_ ,	//	sti alfsf   store the factor
/*  3026 */	store   | ia     << dst_ | alfsf  << off_ ,
/*  3027 */	stmt    | 195    << off_ ,	//	ldi 4,intvh   get 100
/*  3028 */	load    | r1     << dst_ | intvh  << off_ ,
/*  3029 */	ldi     | r1     << dst_ ,
/*  3030 */	stmt    | 196    << off_ ,	//	dvi 4,gbsdp   form 100 / gbsdp
/*  3031 */	load    | r1     << dst_ | gbsdp  << off_ ,
/*  3032 */	dvi     | r1     << dst_ ,
/*  3033 */	stmt    | 197    << off_ ,	//	sti gbsed   store the factor
/*  3034 */	store   | ia     << dst_ | gbsed  << off_ ,
/*  3035 */	stmt    | 198    << off_ ,	//	lct wb =cfp_s  load counter for significant digits
/*  3036 */	loadi   | wb     << dst_ | cfp_s  << off_ ,
/*  3037 */	stmt    | 199    << off_ ,	//	ldr 4,reav1   load 1.0
/*  3038 */	load    | r1     << dst_ | reav1  << off_ ,
/*  3039 */	ldr     | r1     << dst_ ,
// ini03:
/*  3040 */	stmt    | 200    << off_ ,	//ini03	mlr 4,reavt   * 10.0
/*  3041 */	load    | r1     << dst_ | reavt  << off_ ,
/*  3042 */	mlr     | r1     << dst_ ,
/*  3043 */	stmt    | 201    << off_ ,	//	bct wb ini03  loop till done
/*  3044 */	bct     | wb     << dst_ | ini03  << off_ ,
/*  3045 */	stmt    | 202    << off_ ,	//	str gtssc   store 10**(max sig digits)
/*  3046 */	store   | ra     << dst_ | gtssc  << off_ ,
/*  3047 */	stmt    | 203    << off_ ,	//	ldr 4,reap5   load 0.5
/*  3048 */	load    | r1     << dst_ | reap5  << off_ ,
/*  3049 */	ldr     | r1     << dst_ ,
/*  3050 */	stmt    | 204    << off_ ,	//	dvr gtssc   compute 0.5*10**(max sig digits)
/*  3051 */	load    | r1     << dst_ | gtssc  << off_ ,
/*  3052 */	dvr     | r1     << dst_ ,
/*  3053 */	stmt    | 205    << off_ ,	//	str gtsrn   store as rounding bias
/*  3054 */	store   | ra     << dst_ | gtsrn  << off_ ,
/*  3055 */	stmt    | 206    << off_ ,	//	zer wc   set to read parameters
/*  3056 */	move    | wc     << dst_ ,
/*  3057 */	stmt    | 207    << off_ ,	//	jsr prpar   read them
/*  3058 */	call    | prpar  << off_ ,
/*  3059 */	stmt    | 208    << off_ ,	//	sub xl *e_srs  allow for reserve memory
/*  3060 */	loadi   | r2     << dst_ | e_srs  << off_ ,
/*  3061 */	sub     | xl     << dst_ | r2     << src_ ,
/*  3062 */	stmt    | 209    << off_ ,	//	mov wa prlen  get print buffer length
/*  3063 */	load    | wa     << dst_ | prlen  << off_ ,
/*  3064 */	stmt    | 210    << off_ ,	//	add wa =cfp_a  add no. of chars in alphabet
/*  3065 */	loadi   | r2     << dst_ | cfp_a  << off_ ,
/*  3066 */	add     | wa     << dst_ | r2     << src_ ,
/*  3067 */	stmt    | 211    << off_ ,	//	add wa =nstmx  add chars for gtstg bfr
/*  3068 */	loadi   | r2     << dst_ | nstmx  << off_ ,
/*  3069 */	add     | wa     << dst_ | r2     << src_ ,
/*  3070 */	stmt    | 212    << off_ ,	//	ctb wa 8  convert to bytes, allowing a margin
/*  3071 */	ctb     | wa     << dst_ | 8      << off_ ,
/*  3072 */	stmt    | 213    << off_ ,	//	mov xr statb  point to static base
/*  3073 */	load    | xr     << dst_ | statb  << off_ ,
/*  3074 */	stmt    | 214    << off_ ,	//	add xr wa  increment for above buffers
/*  3075 */	add     | xr     << dst_ | wa     << src_ ,
/*  3076 */	stmt    | 215    << off_ ,	//	add xr *e_hnb  increment for hash table
/*  3077 */	loadi   | r2     << dst_ | e_hnb  << off_ ,
/*  3078 */	add     | xr     << dst_ | r2     << src_ ,
/*  3079 */	stmt    | 216    << off_ ,	//	add xr *e_sts  bump for initial static block
/*  3080 */	loadi   | r2     << dst_ | e_sts  << off_ ,
/*  3081 */	add     | xr     << dst_ | r2     << src_ ,
/*  3082 */	stmt    | 217    << off_ ,	//	jsr sysmx   get mxlen
/*  3083 */	sys     | sysmx_ << off_ ,
/*  3084 */	stmt    | 218    << off_ ,	//	mov kvmxl wa  provisionally store as maxlngth
/*  3085 */	store   | wa     << dst_ | kvmxl  << off_ ,
/*  3086 */	stmt    | 219    << off_ ,	//	mov mxlen wa  and as mxlen
/*  3087 */	store   | wa     << dst_ | mxlen  << off_ ,
/*  3088 */	stmt    | 220    << off_ ,	//	bgt xr wa ini06 skip if static hi exceeds mxlen
/*  3089 */	bgt     | xr     << dst_ | wa     << src_ | ini06  << off_ ,
/*  3090 */	stmt    | 221    << off_ ,	//	ctb wa 1  round up and make bigger than mxlen
/*  3091 */	ctb     | wa     << dst_ | 1      << off_ ,
/*  3092 */	stmt    | 222    << off_ ,	//	mov xr wa  use it instead
/*  3093 */	move    | xr     << dst_ | wa     << src_ ,
// ini06:
/*  3094 */	stmt    | 223    << off_ ,	//ini06	mov dnamb xr  dynamic base adrs
/*  3095 */	store   | xr     << dst_ | dnamb  << off_ ,
/*  3096 */	stmt    | 224    << off_ ,	//	mov dnamp xr  dynamic ptr
/*  3097 */	store   | xr     << dst_ | dnamp  << off_ ,
/*  3098 */	stmt    | 225    << off_ ,	//	bnz wa ini07  skip if non-zero mxlen
/*  3099 */	bnz     | wa     << dst_ | ini07  << off_ ,
/*  3100 */	stmt    | 226    << off_ ,	//	dca xr   point a word in front
/*  3101 */	dca     | xr     << dst_ ,
/*  3102 */	stmt    | 227    << off_ ,	//	mov kvmxl xr  use as maxlngth
/*  3103 */	store   | xr     << dst_ | kvmxl  << off_ ,
/*  3104 */	stmt    | 228    << off_ ,	//	mov mxlen xr  and as mxlen
/*  3105 */	store   | xr     << dst_ | mxlen  << off_ ,
// ini07:
/*  3106 */	stmt    | 229    << off_ ,	//ini07	mov dname xl  store dynamic end address
/*  3107 */	store   | xl     << dst_ | dname  << off_ ,
/*  3108 */	stmt    | 230    << off_ ,	//	blt dnamb xl ini09 skip if high enough
/*  3109 */	load    | r1     << dst_ | dnamb  << off_ ,
/*  3110 */	blt     | r1     << dst_ | xl     << src_ | ini09  << off_ ,
/*  3111 */	stmt    | 231    << off_ ,	//	jsr sysmm   request more memory
/*  3112 */	sys     | sysmm_ << off_ ,
/*  3113 */	stmt    | 232    << off_ ,	//	wtb xr   get as baus (sgd05)
/*  3114 */	stmt    | 233    << off_ ,	//	add xl xr  bump by amount obtained
/*  3115 */	add     | xl     << dst_ | xr     << src_ ,
/*  3116 */	stmt    | 234    << off_ ,	//	bnz xr ini07  try again
/*  3117 */	bnz     | xr     << dst_ | ini07  << off_ ,
/*  3118 */	stmt    | 235    << off_ ,	//	mov wa =mxern  insufficient memory for maxlength
/*  3119 */	loadi   | wa     << dst_ | mxern  << off_ ,
/*  3120 */	stmt    | 236    << off_ ,	//	zer wb   no column number info
/*  3121 */	move    | wb     << dst_ ,
/*  3122 */	stmt    | 237    << off_ ,	//	zer wc   no line number info
/*  3123 */	move    | wc     << dst_ ,
/*  3124 */	stmt    | 238    << off_ ,	//	mov xr =stgic  initial compile stage
/*  3125 */	loadi   | xr     << dst_ | stgic  << off_ ,
/*  3126 */	stmt    | 239    << off_ ,	//	mov xl =nulls  no file name
/*  3127 */	loadi   | xl     << dst_ | nulls  << off_ ,
/*  3128 */	stmt    | 240    << off_ ,	//	jsr sysea   advise of error
/*  3129 */	sys     | sysea_ << off_ ,
/*  3130 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3131 */	ppm     | ini08  << off_ ,
/*  3132 */	stmt    | 241    << off_ ,	//	brn ini08   force termination
/*  3133 */	brn     | ini08  << off_ ,
/*  3134 */	stmt    | 242    << off_ ,	//	erb 329 requested maxlngth too large
/*  3135 */	erb     | 329    << off_ ,
// ini08:
/*  3136 */	stmt    | 243    << off_ ,	//ini08	mov xr =endmo  point to failure message
/*  3137 */	loadi   | xr     << dst_ | endmo  << off_ ,
/*  3138 */	stmt    | 244    << off_ ,	//	mov wa 4,endml  message length
/*  3139 */	load    | wa     << dst_ | endml  << off_ ,
/*  3140 */	stmt    | 245    << off_ ,	//	jsr syspr   print it (prtst not yet usable)
/*  3141 */	sys     | syspr_ << off_ ,
/*  3142 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3143 */	ppm     ,
/*  3144 */	stmt    | 246    << off_ ,	//	zer xl   no fcb chain yet
/*  3145 */	move    | xl     << dst_ ,
/*  3146 */	stmt    | 247    << off_ ,	//	mov wb =num10  set special code value
/*  3147 */	loadi   | wb     << dst_ | num10  << off_ ,
/*  3148 */	stmt    | 248    << off_ ,	//	jsr sysej   pack up (stopr not yet usable)
/*  3149 */	sys     | sysej_ << off_ ,
// ini09:
/*  3150 */	stmt    | 249    << off_ ,	//ini09	mov xr statb  point to static again
/*  3151 */	load    | xr     << dst_ | statb  << off_ ,
/*  3152 */	stmt    | 250    << off_ ,	//	jsr insta   initialize static
/*  3153 */	call    | insta  << off_ ,
/*  3154 */	stmt    | 251    << off_ ,	//	mov wa =e_hnb  get number of hash headers
/*  3155 */	loadi   | wa     << dst_ | e_hnb  << off_ ,
/*  3156 */	stmt    | 252    << off_ ,	//	mti wa   convert to integer
/*  3157 */	move    | ia     << dst_ | wa     << src_ ,
/*  3158 */	stmt    | 253    << off_ ,	//	sti hshnb   store for use by gtnvr procedure
/*  3159 */	store   | ia     << dst_ | hshnb  << off_ ,
/*  3160 */	stmt    | 254    << off_ ,	//	lct wa wa  counter for clearing hash table
/*  3161 */	stmt    | 255    << off_ ,	//	mov hshtb xr  pointer to hash table
/*  3162 */	store   | xr     << dst_ | hshtb  << off_ ,
// ini11:
/*  3163 */	stmt    | 256    << off_ ,	//ini11	zer (xr)+   blank a word
/*  3164 */	store   | r0     << dst_ | xr     << src_ ,
/*  3165 */	ica     | xr     << dst_ ,
/*  3166 */	stmt    | 257    << off_ ,	//	bct wa ini11  loop
/*  3167 */	bct     | wa     << dst_ | ini11  << off_ ,
/*  3168 */	stmt    | 258    << off_ ,	//	mov hshte xr  end of hash table adrs is kept
/*  3169 */	store   | xr     << dst_ | hshte  << off_ ,
/*  3170 */	stmt    | 259    << off_ ,	//	mov state xr  store static end address
/*  3171 */	store   | xr     << dst_ | state  << off_ ,
/*  3172 */	stmt    | 260    << off_ ,	//	mov wc =num01  table will have only one bucket
/*  3173 */	loadi   | wc     << dst_ | num01  << off_ ,
/*  3174 */	stmt    | 261    << off_ ,	//	mov xl =nulls  default table value
/*  3175 */	loadi   | xl     << dst_ | nulls  << off_ ,
/*  3176 */	stmt    | 262    << off_ ,	//	mov r_sfc xl  current source file name
/*  3177 */	store   | xl     << dst_ | r_sfc  << off_ ,
/*  3178 */	stmt    | 263    << off_ ,	//	jsr tmake   create table
/*  3179 */	call    | tmake  << off_ ,
/*  3180 */	stmt    | 264    << off_ ,	//	mov r_sfn xr  save ptr to table
/*  3181 */	store   | xr     << dst_ | r_sfn  << off_ ,
/*  3182 */	stmt    | 265    << off_ ,	//	mov wc =num01  table will have only one bucket
/*  3183 */	loadi   | wc     << dst_ | num01  << off_ ,
/*  3184 */	stmt    | 266    << off_ ,	//	mov xl =nulls  default table value
/*  3185 */	loadi   | xl     << dst_ | nulls  << off_ ,
/*  3186 */	stmt    | 267    << off_ ,	//	jsr tmake   create table
/*  3187 */	call    | tmake  << off_ ,
/*  3188 */	stmt    | 268    << off_ ,	//	mov r_inc xr  save ptr to table
/*  3189 */	store   | xr     << dst_ | r_inc  << off_ ,
/*  3190 */	stmt    | 269    << off_ ,	//	mov wa =ccinm  maximum nesting level
/*  3191 */	loadi   | wa     << dst_ | ccinm  << off_ ,
/*  3192 */	stmt    | 270    << off_ ,	//	mov xl =nulls  null string default value
/*  3193 */	loadi   | xl     << dst_ | nulls  << off_ ,
/*  3194 */	stmt    | 271    << off_ ,	//	jsr vmake   create array
/*  3195 */	call    | vmake  << off_ ,
/*  3196 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3197 */	ppm     ,
/*  3198 */	stmt    | 272    << off_ ,	//	mov r_ifa xr  save ptr to array
/*  3199 */	store   | xr     << dst_ | r_ifa  << off_ ,
/*  3200 */	stmt    | 273    << off_ ,	//	mov wa =ccinm  maximum nesting level
/*  3201 */	loadi   | wa     << dst_ | ccinm  << off_ ,
/*  3202 */	stmt    | 274    << off_ ,	//	mov xl =inton  integer one default value
/*  3203 */	loadi   | xl     << dst_ | inton  << off_ ,
/*  3204 */	stmt    | 275    << off_ ,	//	jsr vmake   create array
/*  3205 */	call    | vmake  << off_ ,
/*  3206 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3207 */	ppm     ,
/*  3208 */	stmt    | 276    << off_ ,	//	mov r_ifl xr  save ptr to array
/*  3209 */	store   | xr     << dst_ | r_ifl  << off_ ,
/*  3210 */	stmt    | 277    << off_ ,	//	mov xl =v_inp  point to string /input/
/*  3211 */	loadi   | xl     << dst_ | v_inp  << off_ ,
/*  3212 */	stmt    | 278    << off_ ,	//	mov wb =trtin  trblk type for input
/*  3213 */	loadi   | wb     << dst_ | trtin  << off_ ,
/*  3214 */	stmt    | 279    << off_ ,	//	jsr inout   perform input association
/*  3215 */	call    | inout  << off_ ,
/*  3216 */	stmt    | 280    << off_ ,	//	mov xl =v_oup  point to string /output/
/*  3217 */	loadi   | xl     << dst_ | v_oup  << off_ ,
/*  3218 */	stmt    | 281    << off_ ,	//	mov wb =trtou  trblk type for output
/*  3219 */	loadi   | wb     << dst_ | trtou  << off_ ,
/*  3220 */	stmt    | 282    << off_ ,	//	jsr inout   perform output association
/*  3221 */	call    | inout  << off_ ,
/*  3222 */	stmt    | 283    << off_ ,	//	mov wc initr  terminal flag
/*  3223 */	load    | wc     << dst_ | initr  << off_ ,
/*  3224 */	stmt    | 284    << off_ ,	//	bze wc ini13  skip if no terminal
/*  3225 */	bze     | wc     << dst_ | ini13  << off_ ,
/*  3226 */	stmt    | 285    << off_ ,	//	jsr prpar   associate terminal
/*  3227 */	call    | prpar  << off_ ,
// ini13:
/*  3228 */	stmt    | 286    << off_ ,	//ini13	jsr sysdc   call date check
/*  3229 */	sys     | sysdc_ << off_ ,
/*  3230 */	stmt    | 287    << off_ ,	//	mov flptr xs  in case stack overflows in compiler
/*  3231 */	store   | xs     << dst_ | flptr  << off_ ,
/*  3232 */	stmt    | 288    << off_ ,	//	jsr cmpil   call compiler
/*  3233 */	call    | cmpil  << off_ ,
/*  3234 */	stmt    | 289    << off_ ,	//	mov r_cod xr  set ptr to first code block
/*  3235 */	store   | xr     << dst_ | r_cod  << off_ ,
/*  3236 */	stmt    | 290    << off_ ,	//	mov r_ttl =nulls  forget title
/*  3237 */	loadi   | r1     << dst_ | nulls  << off_ ,
/*  3238 */	store   | r1     << dst_ | r_ttl  << off_ ,
/*  3239 */	stmt    | 291    << off_ ,	//	mov r_stl =nulls  forget sub-title
/*  3240 */	loadi   | r1     << dst_ | nulls  << off_ ,
/*  3241 */	store   | r1     << dst_ | r_stl  << off_ ,
/*  3242 */	stmt    | 292    << off_ ,	//	zer r_cim   forget compiler input image
/*  3243 */	store   | r0     << dst_ | r_cim  << off_ ,
/*  3244 */	stmt    | 293    << off_ ,	//	zer r_ccb   forget interim code block
/*  3245 */	store   | r0     << dst_ | r_ccb  << off_ ,
/*  3246 */	stmt    | 294    << off_ ,	//	zer cnind   in case end occurred with include
/*  3247 */	store   | r0     << dst_ | cnind  << off_ ,
/*  3248 */	stmt    | 295    << off_ ,	//	zer lstid   listing include depth
/*  3249 */	store   | r0     << dst_ | lstid  << off_ ,
/*  3250 */	stmt    | 296    << off_ ,	//	zer xl   clear dud value
/*  3251 */	move    | xl     << dst_ ,
/*  3252 */	stmt    | 297    << off_ ,	//	zer wb   dont shift dynamic store up
/*  3253 */	move    | wb     << dst_ ,
/*  3254 */	stmt    | 298    << off_ ,	//	zer dnams   collect sediment too
/*  3255 */	store   | r0     << dst_ | dnams  << off_ ,
/*  3256 */	stmt    | 299    << off_ ,	//	jsr gbcol   clear garbage left from compile
/*  3257 */	call    | gbcol  << off_ ,
/*  3258 */	stmt    | 300    << off_ ,	//	mov dnams xr  record new sediment size
/*  3259 */	store   | xr     << dst_ | dnams  << off_ ,
/*  3260 */	stmt    | 301    << off_ ,	//	bnz cpsts inix0  skip if no listing of comp stats
/*  3261 */	load    | r1     << dst_ | cpsts  << off_ ,
/*  3262 */	bnz     | r1     << dst_ | inix0  << off_ ,
/*  3263 */	stmt    | 302    << off_ ,	//	jsr prtpg   eject page
/*  3264 */	call    | prtpg  << off_ ,
/*  3265 */	stmt    | 303    << off_ ,	//	jsr prtmm   print memory usage
/*  3266 */	call    | prtmm  << off_ ,
/*  3267 */	stmt    | 304    << off_ ,	//	mti cmerc   get count of errors as integer
/*  3268 */	load    | ia     << dst_ | cmerc  << off_ ,
/*  3269 */	stmt    | 305    << off_ ,	//	mov xr =encm3  point to /compile errors/
/*  3270 */	loadi   | xr     << dst_ | encm3  << off_ ,
/*  3271 */	stmt    | 306    << off_ ,	//	jsr prtmi   print it
/*  3272 */	call    | prtmi  << off_ ,
/*  3273 */	stmt    | 307    << off_ ,	//	mti gbcnt   garbage collection count
/*  3274 */	load    | ia     << dst_ | gbcnt  << off_ ,
/*  3275 */	stmt    | 308    << off_ ,	//	sbi 4,intv1   adjust for unavoidable collect
/*  3276 */	load    | r1     << dst_ | intv1  << off_ ,
/*  3277 */	sbi     | r1     << dst_ ,
/*  3278 */	stmt    | 309    << off_ ,	//	mov xr =stpm5  point to /storage regenerations/
/*  3279 */	loadi   | xr     << dst_ | stpm5  << off_ ,
/*  3280 */	stmt    | 310    << off_ ,	//	jsr prtmi   print gbcol count
/*  3281 */	call    | prtmi  << off_ ,
/*  3282 */	stmt    | 311    << off_ ,	//	jsr systm   get time
/*  3283 */	sys     | systm_ << off_ ,
/*  3284 */	stmt    | 312    << off_ ,	//	sbi timsx   get compilation time
/*  3285 */	load    | r1     << dst_ | timsx  << off_ ,
/*  3286 */	sbi     | r1     << dst_ ,
/*  3287 */	stmt    | 313    << off_ ,	//	mov xr =encm4  point to compilation time (msec)/
/*  3288 */	loadi   | xr     << dst_ | encm4  << off_ ,
/*  3289 */	stmt    | 314    << off_ ,	//	jsr prtmi   print message
/*  3290 */	call    | prtmi  << off_ ,
/*  3291 */	stmt    | 315    << off_ ,	//	add lstlc =num05  bump line count
/*  3292 */	load    | r1     << dst_ | lstlc  << off_ ,
/*  3293 */	loadi   | r2     << dst_ | num05  << off_ ,
/*  3294 */	add     | r1     << dst_ | r2     << src_ ,
/*  3295 */	store   | r1     << dst_ | lstlc  << off_ ,
/*  3296 */	stmt    | 316    << off_ ,	//	bze headp inix0  no eject if nothing printed
/*  3297 */	load    | r1     << dst_ | headp  << off_ ,
/*  3298 */	bze     | r1     << dst_ | inix0  << off_ ,
/*  3299 */	stmt    | 317    << off_ ,	//	jsr prtpg   eject printer
/*  3300 */	call    | prtpg  << off_ ,
// inix0:
/*  3301 */	stmt    | 318    << off_ ,	//inix0	bgt cswin =iniln inix1 skip if not default -in72 used
/*  3302 */	load    | r1     << dst_ | cswin  << off_ ,
/*  3303 */	loadi   | r2     << dst_ | iniln  << off_ ,
/*  3304 */	bgt     | r1     << dst_ | r2     << src_ | inix1  << off_ ,
/*  3305 */	stmt    | 319    << off_ ,	//	mov cswin =inils  else use default record length
/*  3306 */	loadi   | r1     << dst_ | inils  << off_ ,
/*  3307 */	store   | r1     << dst_ | cswin  << off_ ,
// inix1:
/*  3308 */	stmt    | 320    << off_ ,	//inix1	jsr systm   get time again
/*  3309 */	sys     | systm_ << off_ ,
/*  3310 */	stmt    | 321    << off_ ,	//	sti timsx   store for end run processing
/*  3311 */	store   | ia     << dst_ | timsx  << off_ ,
/*  3312 */	stmt    | 322    << off_ ,	//	zer gbcnt   initialise collect count
/*  3313 */	store   | r0     << dst_ | gbcnt  << off_ ,
/*  3314 */	stmt    | 323    << off_ ,	//	jsr sysbx   call before starting execution
/*  3315 */	sys     | sysbx_ << off_ ,
/*  3316 */	stmt    | 324    << off_ ,	//	add noxeq cswex  add -noexecute flag
/*  3317 */	load    | r1     << dst_ | noxeq  << off_ ,
/*  3318 */	load    | r2     << dst_ | cswex  << off_ ,
/*  3319 */	add     | r1     << dst_ | r2     << src_ ,
/*  3320 */	store   | r1     << dst_ | noxeq  << off_ ,
/*  3321 */	stmt    | 325    << off_ ,	//	bnz noxeq inix2  jump if execution suppressed
/*  3322 */	load    | r1     << dst_ | noxeq  << off_ ,
/*  3323 */	bnz     | r1     << dst_ | inix2  << off_ ,
// iniy0:
/*  3324 */	stmt    | 326    << off_ ,	//iniy0	mnz headp   mark headers out regardless
/*  3325 */	store   | xs     << dst_ | headp  << off_ ,
/*  3326 */	stmt    | 327    << off_ ,	//	zer -(xs)   set failure location on stack
/*  3327 */	dca     | xs     << dst_ ,
/*  3328 */	store   | r0     << dst_ | xs     << src_ ,
/*  3329 */	stmt    | 328    << off_ ,	//	mov flptr xs  save ptr to failure offset word
/*  3330 */	store   | xs     << dst_ | flptr  << off_ ,
/*  3331 */	stmt    | 329    << off_ ,	//	mov xr r_cod  load ptr to entry code block
/*  3332 */	load    | xr     << dst_ | r_cod  << off_ ,
/*  3333 */	stmt    | 330    << off_ ,	//	mov stage =stgxt  set stage for execute time
/*  3334 */	loadi   | r1     << dst_ | stgxt  << off_ ,
/*  3335 */	store   | r1     << dst_ | stage  << off_ ,
/*  3336 */	stmt    | 331    << off_ ,	//	mov polcs =num01  reset interface polling interval
/*  3337 */	loadi   | r1     << dst_ | num01  << off_ ,
/*  3338 */	store   | r1     << dst_ | polcs  << off_ ,
/*  3339 */	stmt    | 332    << off_ ,	//	mov polct =num01  reset interface polling interval
/*  3340 */	loadi   | r1     << dst_ | num01  << off_ ,
/*  3341 */	store   | r1     << dst_ | polct  << off_ ,
/*  3342 */	stmt    | 333    << off_ ,	//	mov pfnte cmpsn  copy stmts compiled count in case
/*  3343 */	load    | r1     << dst_ | cmpsn  << off_ ,
/*  3344 */	store   | r1     << dst_ | pfnte  << off_ ,
/*  3345 */	stmt    | 334    << off_ ,	//	mov pfdmp kvpfl  start profiling if &profile set
/*  3346 */	load    | r1     << dst_ | kvpfl  << off_ ,
/*  3347 */	store   | r1     << dst_ | pfdmp  << off_ ,
/*  3348 */	stmt    | 335    << off_ ,	//	jsr systm   time yet again
/*  3349 */	sys     | systm_ << off_ ,
/*  3350 */	stmt    | 336    << off_ ,	//	sti pfstm
/*  3351 */	store   | ia     << dst_ | pfstm  << off_ ,
/*  3352 */	stmt    | 337    << off_ ,	//	jsr stgcc   compute stmgo countdown counters
/*  3353 */	call    | stgcc  << off_ ,
/*  3354 */	stmt    | 338    << off_ ,	//	bri (xr)   start xeq with first statement
/*  3355 */	load    | r1     << dst_ | xr     << src_ ,
/*  3356 */	bri     | r1     << dst_ ,
// inix2:
/*  3357 */	stmt    | 339    << off_ ,	//inix2	zer wa   set abend value to zero
/*  3358 */	move    | wa     << dst_ ,
/*  3359 */	stmt    | 340    << off_ ,	//	mov wb =nini9  set special code value
/*  3360 */	loadi   | wb     << dst_ | nini9  << off_ ,
/*  3361 */	stmt    | 341    << off_ ,	//	zer xl   no fcb chain
/*  3362 */	move    | xl     << dst_ ,
/*  3363 */	stmt    | 342    << off_ ,	//	jsr sysej   end of job, exit to system
/*  3364 */	sys     | sysej_ << off_ ,
// rstrt:
/*  3365 */	stmt    | 343    << off_ ,	//rstrt	prc e 0  entry point
/*  3366 */	stmt    | 344    << off_ ,	//	mov xs stbas  discard return
/*  3367 */	load    | xs     << dst_ | stbas  << off_ ,
/*  3368 */	stmt    | 345    << off_ ,	//	zer xl   clear xl
/*  3369 */	move    | xl     << dst_ ,
/*  3370 */	stmt    | 346    << off_ ,	//	brn iniy0   resume execution
/*  3371 */	brn     | iniy0  << off_ ,
/*  3372 */	0       ,
// o_add:
/*  3373 */	stmt    | 347    << off_ ,	//	jsr arith   fetch arithmetic operands
/*  3374 */	call    | arith  << off_ ,
/*  3375 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  3376 */	err     | 1      << off_ ,
/*  3377 */	err     | 2      << off_ ,
/*  3378 */	ppm     | oadd1  << off_ ,
/*  3379 */	stmt    | 348    << off_ ,	//	adi icval(xl)   add right operand to left
/*  3380 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/*  3381 */	adi     | r1     << dst_ ,
/*  3382 */	stmt    | 349    << off_ ,	//	ino exint   return integer if no overflow
/*  3383 */	ino     | exint  << off_ ,
/*  3384 */	stmt    | 350    << off_ ,	//	erb 003 addition caused integer overflow
/*  3385 */	erb     | 3      << off_ ,
// oadd1:
/*  3386 */	stmt    | 351    << off_ ,	//oadd1	adr rcval(xl)   add right operand to left
/*  3387 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/*  3388 */	adr     | r1     << dst_ ,
/*  3389 */	stmt    | 352    << off_ ,	//	rno exrea   return real if no overflow
/*  3390 */	rno     | exrea  << off_ ,
/*  3391 */	stmt    | 353    << off_ ,	//	erb 261 addition caused real overflow
/*  3392 */	erb     | 261    << off_ ,
/*  3393 */	0       ,
// o_aff:
/*  3394 */	stmt    | 354    << off_ ,	//	mov xr (xs)+  load operand
/*  3395 */	load    | xr     << dst_ | xs     << src_ ,
/*  3396 */	ica     | xs     << dst_ ,
/*  3397 */	stmt    | 355    << off_ ,	//	jsr gtnum   convert to numeric
/*  3398 */	call    | gtnum  << off_ ,
/*  3399 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3400 */	err     | 4      << off_ ,
/*  3401 */	stmt    | 356    << off_ ,	//	mov -(xs) xr  result if converted to numeric
/*  3402 */	dca     | xs     << dst_ ,
/*  3403 */	store   | xr     << dst_ | xs     << src_ ,
/*  3404 */	stmt    | 357    << off_ ,	//	lcw xr   get next code word
/*  3405 */	lcw     | xr     << dst_ ,
/*  3406 */	stmt    | 358    << off_ ,	//	bri (xr)   execute it
/*  3407 */	load    | r1     << dst_ | xr     << src_ ,
/*  3408 */	bri     | r1     << dst_ ,
/*  3409 */	0       ,
// o_alt:
/*  3410 */	stmt    | 359    << off_ ,	//	mov xr (xs)+  load right operand
/*  3411 */	load    | xr     << dst_ | xs     << src_ ,
/*  3412 */	ica     | xs     << dst_ ,
/*  3413 */	stmt    | 360    << off_ ,	//	jsr gtpat   convert to pattern
/*  3414 */	call    | gtpat  << off_ ,
/*  3415 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3416 */	err     | 5      << off_ ,
// oalt1:
/*  3417 */	stmt    | 361    << off_ ,	//oalt1	mov wb =p_alt  set pcode for alternative node
/*  3418 */	loadi   | wb     << dst_ | p_alt  << off_ ,
/*  3419 */	stmt    | 362    << off_ ,	//	jsr pbild   build alternative node
/*  3420 */	call    | pbild  << off_ ,
/*  3421 */	stmt    | 363    << off_ ,	//	mov xl xr  save address of alternative node
/*  3422 */	move    | xl     << dst_ | xr     << src_ ,
/*  3423 */	stmt    | 364    << off_ ,	//	mov xr (xs)+  load left operand
/*  3424 */	load    | xr     << dst_ | xs     << src_ ,
/*  3425 */	ica     | xs     << dst_ ,
/*  3426 */	stmt    | 365    << off_ ,	//	jsr gtpat   convert to pattern
/*  3427 */	call    | gtpat  << off_ ,
/*  3428 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3429 */	err     | 6      << off_ ,
/*  3430 */	stmt    | 366    << off_ ,	//	beq xr =p_alt oalt2 jump if left arg is alternation
/*  3431 */	loadi   | r2     << dst_ | p_alt  << off_ ,
/*  3432 */	beq     | xr     << dst_ | r2     << src_ | oalt2  << off_ ,
/*  3433 */	stmt    | 367    << off_ ,	//	mov pthen(xl) xr  set left operand as successor
/*  3434 */	store   | xr     << dst_ | xl     << src_ | pthen  << off_ ,
/*  3435 */	stmt    | 368    << off_ ,	//	mov -(xs) xl  stack result
/*  3436 */	dca     | xs     << dst_ ,
/*  3437 */	store   | xl     << dst_ | xs     << src_ ,
/*  3438 */	stmt    | 369    << off_ ,	//	lcw xr   get next code word
/*  3439 */	lcw     | xr     << dst_ ,
/*  3440 */	stmt    | 370    << off_ ,	//	bri (xr)   execute it
/*  3441 */	load    | r1     << dst_ | xr     << src_ ,
/*  3442 */	bri     | r1     << dst_ ,
// oalt2:
/*  3443 */	stmt    | 371    << off_ ,	//oalt2	mov pthen(xl) parm1(xr)  build the (b / c) node
/*  3444 */	load    | r1     << dst_ | xr     << src_ | parm1  << off_ ,
/*  3445 */	store   | r1     << dst_ | xl     << src_ | pthen  << off_ ,
/*  3446 */	stmt    | 372    << off_ ,	//	mov -(xs) pthen(xr)  set a as new left arg
/*  3447 */	load    | r1     << dst_ | xr     << src_ | pthen  << off_ ,
/*  3448 */	dca     | xs     << dst_ ,
/*  3449 */	store   | r1     << dst_ | xs     << src_ ,
/*  3450 */	stmt    | 373    << off_ ,	//	mov xr xl  set (b / c) as new right arg
/*  3451 */	move    | xr     << dst_ | xl     << src_ ,
/*  3452 */	stmt    | 374    << off_ ,	//	brn oalt1   merge back to build a / (b / c)
/*  3453 */	brn     | oalt1  << off_ ,
/*  3454 */	0       ,
// o_amn:
/*  3455 */	stmt    | 375    << off_ ,	//	lcw xr   load number of subscripts
/*  3456 */	lcw     | xr     << dst_ ,
/*  3457 */	stmt    | 376    << off_ ,	//	mov wb xr  set flag for by name
/*  3458 */	move    | wb     << dst_ | xr     << src_ ,
/*  3459 */	stmt    | 377    << off_ ,	//	brn arref   jump to array reference routine
/*  3460 */	brn     | arref  << off_ ,
/*  3461 */	0       ,
// o_amv:
/*  3462 */	stmt    | 378    << off_ ,	//	lcw xr   load number of subscripts
/*  3463 */	lcw     | xr     << dst_ ,
/*  3464 */	stmt    | 379    << off_ ,	//	zer wb   set flag for by value
/*  3465 */	move    | wb     << dst_ ,
/*  3466 */	stmt    | 380    << off_ ,	//	brn arref   jump to array reference routine
/*  3467 */	brn     | arref  << off_ ,
/*  3468 */	0       ,
// o_aon:
/*  3469 */	stmt    | 381    << off_ ,	//	mov xr (xs)  load subscript value
/*  3470 */	load    | xr     << dst_ | xs     << src_ ,
/*  3471 */	stmt    | 382    << off_ ,	//	mov xl num01(xs)  load array value
/*  3472 */	load    | xl     << dst_ | xs     << src_ | num01  << off_ ,
/*  3473 */	stmt    | 383    << off_ ,	//	mov wa (xl)  load first word of array operand
/*  3474 */	load    | wa     << dst_ | xl     << src_ ,
/*  3475 */	stmt    | 384    << off_ ,	//	beq wa =b_vct oaon2 jump if vector reference
/*  3476 */	loadi   | r2     << dst_ | b_vct  << off_ ,
/*  3477 */	beq     | wa     << dst_ | r2     << src_ | oaon2  << off_ ,
/*  3478 */	stmt    | 385    << off_ ,	//	beq wa =b_tbt oaon3 jump if table reference
/*  3479 */	loadi   | r2     << dst_ | b_tbt  << off_ ,
/*  3480 */	beq     | wa     << dst_ | r2     << src_ | oaon3  << off_ ,
// oaon1:
/*  3481 */	stmt    | 386    << off_ ,	//oaon1	mov xr =num01  set number of subscripts to one
/*  3482 */	loadi   | xr     << dst_ | num01  << off_ ,
/*  3483 */	stmt    | 387    << off_ ,	//	mov wb xr  set flag for by name
/*  3484 */	move    | wb     << dst_ | xr     << src_ ,
/*  3485 */	stmt    | 388    << off_ ,	//	brn arref   jump to array reference routine
/*  3486 */	brn     | arref  << off_ ,
// oaon2:
/*  3487 */	stmt    | 389    << off_ ,	//oaon2	bne (xr) =b_icl oaon1 use long routine if not integer
/*  3488 */	load    | r1     << dst_ | xr     << src_ ,
/*  3489 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/*  3490 */	bne     | r1     << dst_ | r2     << src_ | oaon1  << off_ ,
/*  3491 */	stmt    | 390    << off_ ,	//	ldi icval(xr)   load integer subscript value
/*  3492 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  3493 */	ldi     | r1     << dst_ ,
/*  3494 */	stmt    | 391    << off_ ,	//	mfi wa exfal  copy as address int, fail if ovflo
/*  3495 */	move    | wa     << dst_ | ia     << src_ ,
/*  3496 */	mfi     | exfal  << off_ ,
/*  3497 */	stmt    | 392    << off_ ,	//	bze wa exfal  fail if zero
/*  3498 */	bze     | wa     << dst_ | exfal  << off_ ,
/*  3499 */	stmt    | 393    << off_ ,	//	add wa =vcvlb  compute offset in words
/*  3500 */	loadi   | r2     << dst_ | vcvlb  << off_ ,
/*  3501 */	add     | wa     << dst_ | r2     << src_ ,
/*  3502 */	stmt    | 394    << off_ ,	//	wtb wa   convert to bytes
/*  3503 */	stmt    | 395    << off_ ,	//	mov (xs) wa  complete name on stack
/*  3504 */	store   | wa     << dst_ | xs     << src_ ,
/*  3505 */	stmt    | 396    << off_ ,	//	blt wa vclen(xl) oaon4 exit if subscript not too large
/*  3506 */	load    | r2     << dst_ | xl     << src_ | vclen  << off_ ,
/*  3507 */	blt     | wa     << dst_ | r2     << src_ | oaon4  << off_ ,
/*  3508 */	stmt    | 397    << off_ ,	//	brn exfal   else fail
/*  3509 */	brn     | exfal  << off_ ,
// oaon3:
/*  3510 */	stmt    | 398    << off_ ,	//oaon3	mnz wb   set flag for name reference
/*  3511 */	move    | wb     << dst_ | xs     << src_ ,
/*  3512 */	stmt    | 399    << off_ ,	//	jsr tfind   locate/create table element
/*  3513 */	call    | tfind  << off_ ,
/*  3514 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3515 */	ppm     | exfal  << off_ ,
/*  3516 */	stmt    | 400    << off_ ,	//	mov num01(xs) xl  store name base on stack
/*  3517 */	store   | xl     << dst_ | xs     << src_ | num01  << off_ ,
/*  3518 */	stmt    | 401    << off_ ,	//	mov (xs) wa  store name offset on stack
/*  3519 */	store   | wa     << dst_ | xs     << src_ ,
// oaon4:
/*  3520 */	stmt    | 402    << off_ ,	//oaon4	lcw xr   result on stack, get code word
/*  3521 */	lcw     | xr     << dst_ ,
/*  3522 */	stmt    | 403    << off_ ,	//	bri (xr)   execute next code word
/*  3523 */	load    | r1     << dst_ | xr     << src_ ,
/*  3524 */	bri     | r1     << dst_ ,
/*  3525 */	0       ,
// o_aov:
/*  3526 */	stmt    | 404    << off_ ,	//	mov xr (xs)+  load subscript value
/*  3527 */	load    | xr     << dst_ | xs     << src_ ,
/*  3528 */	ica     | xs     << dst_ ,
/*  3529 */	stmt    | 405    << off_ ,	//	mov xl (xs)+  load array value
/*  3530 */	load    | xl     << dst_ | xs     << src_ ,
/*  3531 */	ica     | xs     << dst_ ,
/*  3532 */	stmt    | 406    << off_ ,	//	mov wa (xl)  load first word of array operand
/*  3533 */	load    | wa     << dst_ | xl     << src_ ,
/*  3534 */	stmt    | 407    << off_ ,	//	beq wa =b_vct oaov2 jump if vector reference
/*  3535 */	loadi   | r2     << dst_ | b_vct  << off_ ,
/*  3536 */	beq     | wa     << dst_ | r2     << src_ | oaov2  << off_ ,
/*  3537 */	stmt    | 408    << off_ ,	//	beq wa =b_tbt oaov3 jump if table reference
/*  3538 */	loadi   | r2     << dst_ | b_tbt  << off_ ,
/*  3539 */	beq     | wa     << dst_ | r2     << src_ | oaov3  << off_ ,
// oaov1:
/*  3540 */	stmt    | 409    << off_ ,	//oaov1	mov -(xs) xl  restack array value
/*  3541 */	dca     | xs     << dst_ ,
/*  3542 */	store   | xl     << dst_ | xs     << src_ ,
/*  3543 */	stmt    | 410    << off_ ,	//	mov -(xs) xr  restack subscript
/*  3544 */	dca     | xs     << dst_ ,
/*  3545 */	store   | xr     << dst_ | xs     << src_ ,
/*  3546 */	stmt    | 411    << off_ ,	//	mov xr =num01  set number of subscripts to one
/*  3547 */	loadi   | xr     << dst_ | num01  << off_ ,
/*  3548 */	stmt    | 412    << off_ ,	//	zer wb   set flag for value call
/*  3549 */	move    | wb     << dst_ ,
/*  3550 */	stmt    | 413    << off_ ,	//	brn arref   jump to array reference routine
/*  3551 */	brn     | arref  << off_ ,
// oaov2:
/*  3552 */	stmt    | 414    << off_ ,	//oaov2	bne (xr) =b_icl oaov1 use long routine if not integer
/*  3553 */	load    | r1     << dst_ | xr     << src_ ,
/*  3554 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/*  3555 */	bne     | r1     << dst_ | r2     << src_ | oaov1  << off_ ,
/*  3556 */	stmt    | 415    << off_ ,	//	ldi icval(xr)   load integer subscript value
/*  3557 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  3558 */	ldi     | r1     << dst_ ,
/*  3559 */	stmt    | 416    << off_ ,	//	mfi wa exfal  move as one word int, fail if ovflo
/*  3560 */	move    | wa     << dst_ | ia     << src_ ,
/*  3561 */	mfi     | exfal  << off_ ,
/*  3562 */	stmt    | 417    << off_ ,	//	bze wa exfal  fail if zero
/*  3563 */	bze     | wa     << dst_ | exfal  << off_ ,
/*  3564 */	stmt    | 418    << off_ ,	//	add wa =vcvlb  compute offset in words
/*  3565 */	loadi   | r2     << dst_ | vcvlb  << off_ ,
/*  3566 */	add     | wa     << dst_ | r2     << src_ ,
/*  3567 */	stmt    | 419    << off_ ,	//	wtb wa   convert to bytes
/*  3568 */	stmt    | 420    << off_ ,	//	bge wa vclen(xl) exfal fail if subscript too large
/*  3569 */	load    | r2     << dst_ | xl     << src_ | vclen  << off_ ,
/*  3570 */	bge     | wa     << dst_ | r2     << src_ | exfal  << off_ ,
/*  3571 */	stmt    | 421    << off_ ,	//	jsr acess   access value
/*  3572 */	call    | acess  << off_ ,
/*  3573 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3574 */	ppm     | exfal  << off_ ,
/*  3575 */	stmt    | 422    << off_ ,	//	mov -(xs) xr  stack result
/*  3576 */	dca     | xs     << dst_ ,
/*  3577 */	store   | xr     << dst_ | xs     << src_ ,
/*  3578 */	stmt    | 423    << off_ ,	//	lcw xr   get next code word
/*  3579 */	lcw     | xr     << dst_ ,
/*  3580 */	stmt    | 424    << off_ ,	//	bri (xr)   execute it
/*  3581 */	load    | r1     << dst_ | xr     << src_ ,
/*  3582 */	bri     | r1     << dst_ ,
// oaov3:
/*  3583 */	stmt    | 425    << off_ ,	//oaov3	zer wb   set flag for value reference
/*  3584 */	move    | wb     << dst_ ,
/*  3585 */	stmt    | 426    << off_ ,	//	jsr tfind   call table search routine
/*  3586 */	call    | tfind  << off_ ,
/*  3587 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3588 */	ppm     | exfal  << off_ ,
/*  3589 */	stmt    | 427    << off_ ,	//	mov -(xs) xr  stack result
/*  3590 */	dca     | xs     << dst_ ,
/*  3591 */	store   | xr     << dst_ | xs     << src_ ,
/*  3592 */	stmt    | 428    << off_ ,	//	lcw xr   get next code word
/*  3593 */	lcw     | xr     << dst_ ,
/*  3594 */	stmt    | 429    << off_ ,	//	bri (xr)   execute it
/*  3595 */	load    | r1     << dst_ | xr     << src_ ,
/*  3596 */	bri     | r1     << dst_ ,
/*  3597 */	0       ,
// o_ass:
// oass0:
/*  3598 */	stmt    | 430    << off_ ,	//oass0	mov wb (xs)+  load value to be assigned
/*  3599 */	load    | wb     << dst_ | xs     << src_ ,
/*  3600 */	ica     | xs     << dst_ ,
/*  3601 */	stmt    | 431    << off_ ,	//	mov wa (xs)+  load name offset
/*  3602 */	load    | wa     << dst_ | xs     << src_ ,
/*  3603 */	ica     | xs     << dst_ ,
/*  3604 */	stmt    | 432    << off_ ,	//	mov xl (xs)  load name base
/*  3605 */	load    | xl     << dst_ | xs     << src_ ,
/*  3606 */	stmt    | 433    << off_ ,	//	mov (xs) wb  store assigned value as result
/*  3607 */	store   | wb     << dst_ | xs     << src_ ,
/*  3608 */	stmt    | 434    << off_ ,	//	jsr asign   perform assignment
/*  3609 */	call    | asign  << off_ ,
/*  3610 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3611 */	ppm     | exfal  << off_ ,
/*  3612 */	stmt    | 435    << off_ ,	//	lcw xr   result on stack, get code word
/*  3613 */	lcw     | xr     << dst_ ,
/*  3614 */	stmt    | 436    << off_ ,	//	bri (xr)   execute next code word
/*  3615 */	load    | r1     << dst_ | xr     << src_ ,
/*  3616 */	bri     | r1     << dst_ ,
/*  3617 */	0       ,
// o_cer:
/*  3618 */	stmt    | 437    << off_ ,	//	erb 007 compilation error encountered during execution
/*  3619 */	erb     | 7      << off_ ,
/*  3620 */	0       ,
// o_cas:
/*  3621 */	stmt    | 438    << off_ ,	//	mov wc (xs)+  load name offset (parm2)
/*  3622 */	load    | wc     << dst_ | xs     << src_ ,
/*  3623 */	ica     | xs     << dst_ ,
/*  3624 */	stmt    | 439    << off_ ,	//	mov xr (xs)+  load name base (parm1)
/*  3625 */	load    | xr     << dst_ | xs     << src_ ,
/*  3626 */	ica     | xs     << dst_ ,
/*  3627 */	stmt    | 440    << off_ ,	//	mov wb =p_cas  set pcode for cursor assignment
/*  3628 */	loadi   | wb     << dst_ | p_cas  << off_ ,
/*  3629 */	stmt    | 441    << off_ ,	//	jsr pbild   build node
/*  3630 */	call    | pbild  << off_ ,
/*  3631 */	stmt    | 442    << off_ ,	//	mov -(xs) xr  stack result
/*  3632 */	dca     | xs     << dst_ ,
/*  3633 */	store   | xr     << dst_ | xs     << src_ ,
/*  3634 */	stmt    | 443    << off_ ,	//	lcw xr   get next code word
/*  3635 */	lcw     | xr     << dst_ ,
/*  3636 */	stmt    | 444    << off_ ,	//	bri (xr)   execute it
/*  3637 */	load    | r1     << dst_ | xr     << src_ ,
/*  3638 */	bri     | r1     << dst_ ,
/*  3639 */	0       ,
// o_cnc:
/*  3640 */	stmt    | 445    << off_ ,	//	mov xr (xs)  load right argument
/*  3641 */	load    | xr     << dst_ | xs     << src_ ,
/*  3642 */	stmt    | 446    << off_ ,	//	beq xr =nulls ocnc3 jump if right arg is null
/*  3643 */	loadi   | r2     << dst_ | nulls  << off_ ,
/*  3644 */	beq     | xr     << dst_ | r2     << src_ | ocnc3  << off_ ,
/*  3645 */	stmt    | 447    << off_ ,	//	mov xl 1(xs)  load left argument
/*  3646 */	load    | xl     << dst_ | xs     << src_ | 1      << off_ ,
/*  3647 */	stmt    | 448    << off_ ,	//	beq xl =nulls ocnc4 jump if left argument is null
/*  3648 */	loadi   | r2     << dst_ | nulls  << off_ ,
/*  3649 */	beq     | xl     << dst_ | r2     << src_ | ocnc4  << off_ ,
/*  3650 */	stmt    | 449    << off_ ,	//	mov wa =b_scl  get constant to test for string
/*  3651 */	loadi   | wa     << dst_ | b_scl  << off_ ,
/*  3652 */	stmt    | 450    << off_ ,	//	bne wa (xl) ocnc2 jump if left arg not a string
/*  3653 */	load    | r2     << dst_ | xl     << src_ ,
/*  3654 */	bne     | wa     << dst_ | r2     << src_ | ocnc2  << off_ ,
/*  3655 */	stmt    | 451    << off_ ,	//	bne wa (xr) ocnc2 jump if right arg not a string
/*  3656 */	load    | r2     << dst_ | xr     << src_ ,
/*  3657 */	bne     | wa     << dst_ | r2     << src_ | ocnc2  << off_ ,
// ocnc1:
/*  3658 */	stmt    | 452    << off_ ,	//ocnc1	mov wa sclen(xl)  load left argument length
/*  3659 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/*  3660 */	stmt    | 453    << off_ ,	//	add wa sclen(xr)  compute result length
/*  3661 */	load    | r2     << dst_ | xr     << src_ | sclen  << off_ ,
/*  3662 */	add     | wa     << dst_ | r2     << src_ ,
/*  3663 */	stmt    | 454    << off_ ,	//	jsr alocs   allocate scblk for result
/*  3664 */	call    | alocs  << off_ ,
/*  3665 */	stmt    | 455    << off_ ,	//	mov 1(xs) xr  store result ptr over left argument
/*  3666 */	store   | xr     << dst_ | xs     << src_ | 1      << off_ ,
/*  3667 */	stmt    | 456    << off_ ,	//	psc xr   prepare to store chars of result
/*  3668 */	psc     | xr     << dst_ ,
/*  3669 */	stmt    | 457    << off_ ,	//	mov wa sclen(xl)  get number of chars in left arg
/*  3670 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/*  3671 */	stmt    | 458    << off_ ,	//	plc xl   prepare to load left arg chars
/*  3672 */	plc     | xl     << dst_ ,
/*  3673 */	stmt    | 459    << off_ ,	//	mvc    move characters of left argument
/*  3674 */	mvc     ,
/*  3675 */	stmt    | 460    << off_ ,	//	mov xl (xs)+  load right arg pointer, pop stack
/*  3676 */	load    | xl     << dst_ | xs     << src_ ,
/*  3677 */	ica     | xs     << dst_ ,
/*  3678 */	stmt    | 461    << off_ ,	//	mov wa sclen(xl)  load number of chars in right arg
/*  3679 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/*  3680 */	stmt    | 462    << off_ ,	//	plc xl   prepare to load right arg chars
/*  3681 */	plc     | xl     << dst_ ,
/*  3682 */	stmt    | 463    << off_ ,	//	mvc    move characters of right argument
/*  3683 */	mvc     ,
/*  3684 */	stmt    | 464    << off_ ,	//	zer xl   clear garbage value in xl
/*  3685 */	move    | xl     << dst_ ,
/*  3686 */	stmt    | 465    << off_ ,	//	lcw xr   result on stack, get code word
/*  3687 */	lcw     | xr     << dst_ ,
/*  3688 */	stmt    | 466    << off_ ,	//	bri (xr)   execute next code word
/*  3689 */	load    | r1     << dst_ | xr     << src_ ,
/*  3690 */	bri     | r1     << dst_ ,
// ocnc2:
/*  3691 */	stmt    | 467    << off_ ,	//ocnc2	jsr gtstg   convert right arg to string
/*  3692 */	call    | gtstg  << off_ ,
/*  3693 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3694 */	ppm     | ocnc5  << off_ ,
/*  3695 */	stmt    | 468    << off_ ,	//	mov xl xr  save right arg ptr
/*  3696 */	move    | xl     << dst_ | xr     << src_ ,
/*  3697 */	stmt    | 469    << off_ ,	//	jsr gtstg   convert left arg to string
/*  3698 */	call    | gtstg  << off_ ,
/*  3699 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3700 */	ppm     | ocnc6  << off_ ,
/*  3701 */	stmt    | 470    << off_ ,	//	mov -(xs) xr  stack left argument
/*  3702 */	dca     | xs     << dst_ ,
/*  3703 */	store   | xr     << dst_ | xs     << src_ ,
/*  3704 */	stmt    | 471    << off_ ,	//	mov -(xs) xl  stack right argument
/*  3705 */	dca     | xs     << dst_ ,
/*  3706 */	store   | xl     << dst_ | xs     << src_ ,
/*  3707 */	stmt    | 472    << off_ ,	//	mov xl xr  move left arg to proper reg
/*  3708 */	move    | xl     << dst_ | xr     << src_ ,
/*  3709 */	stmt    | 473    << off_ ,	//	mov xr (xs)  move right arg to proper reg
/*  3710 */	load    | xr     << dst_ | xs     << src_ ,
/*  3711 */	stmt    | 474    << off_ ,	//	brn ocnc1   merge back to concatenate strings
/*  3712 */	brn     | ocnc1  << off_ ,
// ocnc3:
/*  3713 */	stmt    | 475    << off_ ,	//ocnc3	ica xs   remove right arg from stack
/*  3714 */	ica     | xs     << dst_ ,
/*  3715 */	stmt    | 476    << off_ ,	//	lcw xr   left argument on stack
/*  3716 */	lcw     | xr     << dst_ ,
/*  3717 */	stmt    | 477    << off_ ,	//	bri (xr)   execute next code word
/*  3718 */	load    | r1     << dst_ | xr     << src_ ,
/*  3719 */	bri     | r1     << dst_ ,
// ocnc4:
/*  3720 */	stmt    | 478    << off_ ,	//ocnc4	ica xs   unstack one argument
/*  3721 */	ica     | xs     << dst_ ,
/*  3722 */	stmt    | 479    << off_ ,	//	mov (xs) xr  store right argument
/*  3723 */	store   | xr     << dst_ | xs     << src_ ,
/*  3724 */	stmt    | 480    << off_ ,	//	lcw xr   result on stack, get code word
/*  3725 */	lcw     | xr     << dst_ ,
/*  3726 */	stmt    | 481    << off_ ,	//	bri (xr)   execute next code word
/*  3727 */	load    | r1     << dst_ | xr     << src_ ,
/*  3728 */	bri     | r1     << dst_ ,
// ocnc5:
/*  3729 */	stmt    | 482    << off_ ,	//ocnc5	mov xl xr  move right argument ptr
/*  3730 */	move    | xl     << dst_ | xr     << src_ ,
/*  3731 */	stmt    | 483    << off_ ,	//	mov xr (xs)+  load left arg pointer
/*  3732 */	load    | xr     << dst_ | xs     << src_ ,
/*  3733 */	ica     | xs     << dst_ ,
// ocnc6:
/*  3734 */	stmt    | 484    << off_ ,	//ocnc6	jsr gtpat   convert left arg to pattern
/*  3735 */	call    | gtpat  << off_ ,
/*  3736 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3737 */	err     | 8      << off_ ,
/*  3738 */	stmt    | 485    << off_ ,	//	mov -(xs) xr  save result on stack
/*  3739 */	dca     | xs     << dst_ ,
/*  3740 */	store   | xr     << dst_ | xs     << src_ ,
/*  3741 */	stmt    | 486    << off_ ,	//	mov xr xl  point to right operand
/*  3742 */	move    | xr     << dst_ | xl     << src_ ,
/*  3743 */	stmt    | 487    << off_ ,	//	jsr gtpat   convert to pattern
/*  3744 */	call    | gtpat  << off_ ,
/*  3745 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3746 */	err     | 9      << off_ ,
/*  3747 */	stmt    | 488    << off_ ,	//	mov xl xr  move for pconc
/*  3748 */	move    | xl     << dst_ | xr     << src_ ,
/*  3749 */	stmt    | 489    << off_ ,	//	mov xr (xs)+  reload left operand ptr
/*  3750 */	load    | xr     << dst_ | xs     << src_ ,
/*  3751 */	ica     | xs     << dst_ ,
/*  3752 */	stmt    | 490    << off_ ,	//	jsr pconc   concatenate patterns
/*  3753 */	call    | pconc  << off_ ,
/*  3754 */	stmt    | 491    << off_ ,	//	mov -(xs) xr  stack result
/*  3755 */	dca     | xs     << dst_ ,
/*  3756 */	store   | xr     << dst_ | xs     << src_ ,
/*  3757 */	stmt    | 492    << off_ ,	//	lcw xr   get next code word
/*  3758 */	lcw     | xr     << dst_ ,
/*  3759 */	stmt    | 493    << off_ ,	//	bri (xr)   execute it
/*  3760 */	load    | r1     << dst_ | xr     << src_ ,
/*  3761 */	bri     | r1     << dst_ ,
/*  3762 */	0       ,
// o_com:
/*  3763 */	stmt    | 494    << off_ ,	//	mov xr (xs)+  load operand
/*  3764 */	load    | xr     << dst_ | xs     << src_ ,
/*  3765 */	ica     | xs     << dst_ ,
/*  3766 */	stmt    | 495    << off_ ,	//	mov wa (xr)  load type word
/*  3767 */	load    | wa     << dst_ | xr     << src_ ,
// ocom1:
/*  3768 */	stmt    | 496    << off_ ,	//ocom1	beq wa =b_icl ocom2 jump if integer
/*  3769 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/*  3770 */	beq     | wa     << dst_ | r2     << src_ | ocom2  << off_ ,
/*  3771 */	stmt    | 497    << off_ ,	//	beq wa =b_rcl ocom3 jump if real
/*  3772 */	loadi   | r2     << dst_ | b_rcl  << off_ ,
/*  3773 */	beq     | wa     << dst_ | r2     << src_ | ocom3  << off_ ,
/*  3774 */	stmt    | 498    << off_ ,	//	jsr gtnum   else convert to numeric
/*  3775 */	call    | gtnum  << off_ ,
/*  3776 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3777 */	err     | 10     << off_ ,
/*  3778 */	stmt    | 499    << off_ ,	//	brn ocom1   back to check cases
/*  3779 */	brn     | ocom1  << off_ ,
// ocom2:
/*  3780 */	stmt    | 500    << off_ ,	//ocom2	ldi icval(xr)   load integer value
/*  3781 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  3782 */	ldi     | r1     << dst_ ,
/*  3783 */	stmt    | 501    << off_ ,	//	ngi    negate
/*  3784 */	ngi     ,
/*  3785 */	stmt    | 502    << off_ ,	//	ino exint   return integer if no overflow
/*  3786 */	ino     | exint  << off_ ,
/*  3787 */	stmt    | 503    << off_ ,	//	erb 011 negation caused integer overflow
/*  3788 */	erb     | 11     << off_ ,
// ocom3:
/*  3789 */	stmt    | 504    << off_ ,	//ocom3	ldr rcval(xr)   load real value
/*  3790 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  3791 */	ldr     | r1     << dst_ ,
/*  3792 */	stmt    | 505    << off_ ,	//	ngr    negate
/*  3793 */	ngr     ,
/*  3794 */	stmt    | 506    << off_ ,	//	brn exrea   return real result
/*  3795 */	brn     | exrea  << off_ ,
/*  3796 */	0       ,
// o_dvd:
/*  3797 */	stmt    | 507    << off_ ,	//	jsr arith   fetch arithmetic operands
/*  3798 */	call    | arith  << off_ ,
/*  3799 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  3800 */	err     | 12     << off_ ,
/*  3801 */	err     | 13     << off_ ,
/*  3802 */	ppm     | odvd2  << off_ ,
/*  3803 */	stmt    | 508    << off_ ,	//	dvi icval(xl)   divide left operand by right
/*  3804 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/*  3805 */	dvi     | r1     << dst_ ,
/*  3806 */	stmt    | 509    << off_ ,	//	ino exint   result ok if no overflow
/*  3807 */	ino     | exint  << off_ ,
/*  3808 */	stmt    | 510    << off_ ,	//	erb 014 division caused integer overflow
/*  3809 */	erb     | 14     << off_ ,
// odvd2:
/*  3810 */	stmt    | 511    << off_ ,	//odvd2	dvr rcval(xl)   divide left operand by right
/*  3811 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/*  3812 */	dvr     | r1     << dst_ ,
/*  3813 */	stmt    | 512    << off_ ,	//	rno exrea   return real if no overflow
/*  3814 */	rno     | exrea  << off_ ,
/*  3815 */	stmt    | 513    << off_ ,	//	erb 262 division caused real overflow
/*  3816 */	erb     | 262    << off_ ,
/*  3817 */	0       ,
// o_exp:
/*  3818 */	stmt    | 514    << off_ ,	//	mov xr (xs)+  load exponent
/*  3819 */	load    | xr     << dst_ | xs     << src_ ,
/*  3820 */	ica     | xs     << dst_ ,
/*  3821 */	stmt    | 515    << off_ ,	//	jsr gtnum   convert to number
/*  3822 */	call    | gtnum  << off_ ,
/*  3823 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3824 */	err     | 15     << off_ ,
/*  3825 */	stmt    | 516    << off_ ,	//	mov xl xr  move exponent to xl
/*  3826 */	move    | xl     << dst_ | xr     << src_ ,
/*  3827 */	stmt    | 517    << off_ ,	//	mov xr (xs)+  load base
/*  3828 */	load    | xr     << dst_ | xs     << src_ ,
/*  3829 */	ica     | xs     << dst_ ,
/*  3830 */	stmt    | 518    << off_ ,	//	jsr gtnum   convert to numeric
/*  3831 */	call    | gtnum  << off_ ,
/*  3832 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  3833 */	err     | 16     << off_ ,
/*  3834 */	stmt    | 519    << off_ ,	//	beq (xl) =b_rcl oexp7 jump if real exponent
/*  3835 */	load    | r1     << dst_ | xl     << src_ ,
/*  3836 */	loadi   | r2     << dst_ | b_rcl  << off_ ,
/*  3837 */	beq     | r1     << dst_ | r2     << src_ | oexp7  << off_ ,
/*  3838 */	stmt    | 520    << off_ ,	//	ldi icval(xl)   load exponent
/*  3839 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/*  3840 */	ldi     | r1     << dst_ ,
/*  3841 */	stmt    | 521    << off_ ,	//	ilt oex12   jump if negative exponent
/*  3842 */	ilt     | oex12  << off_ ,
/*  3843 */	stmt    | 522    << off_ ,	//	beq wa =b_rcl oexp3 jump if base is real
/*  3844 */	loadi   | r2     << dst_ | b_rcl  << off_ ,
/*  3845 */	beq     | wa     << dst_ | r2     << src_ | oexp3  << off_ ,
/*  3846 */	stmt    | 523    << off_ ,	//	mfi wa oexp2  convert exponent to 1 word integer
/*  3847 */	move    | wa     << dst_ | ia     << src_ ,
/*  3848 */	mfi     | oexp2  << off_ ,
/*  3849 */	stmt    | 524    << off_ ,	//	lct wa wa  set loop counter
/*  3850 */	stmt    | 525    << off_ ,	//	ldi icval(xr)   load base as initial value
/*  3851 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  3852 */	ldi     | r1     << dst_ ,
/*  3853 */	stmt    | 526    << off_ ,	//	bnz wa oexp1  jump into loop if non-zero exponent
/*  3854 */	bnz     | wa     << dst_ | oexp1  << off_ ,
/*  3855 */	stmt    | 527    << off_ ,	//	ieq oexp4   error if 0**0
/*  3856 */	ieq     | oexp4  << off_ ,
/*  3857 */	stmt    | 528    << off_ ,	//	ldi 4,intv1   nonzero**0
/*  3858 */	load    | r1     << dst_ | intv1  << off_ ,
/*  3859 */	ldi     | r1     << dst_ ,
/*  3860 */	stmt    | 529    << off_ ,	//	brn exint   give one as result for nonzero**0
/*  3861 */	brn     | exint  << off_ ,
// oex13:
/*  3862 */	stmt    | 530    << off_ ,	//oex13	mli icval(xr)   multiply by base
/*  3863 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  3864 */	mli     | r1     << dst_ ,
/*  3865 */	stmt    | 531    << off_ ,	//	iov oexp2   jump if overflow
/*  3866 */	iov     | oexp2  << off_ ,
// oexp1:
/*  3867 */	stmt    | 532    << off_ ,	//oexp1	bct wa oex13  loop if more to go
/*  3868 */	bct     | wa     << dst_ | oex13  << off_ ,
/*  3869 */	stmt    | 533    << off_ ,	//	brn exint   else return integer result
/*  3870 */	brn     | exint  << off_ ,
// oexp2:
/*  3871 */	stmt    | 534    << off_ ,	//oexp2	erb 017 exponentiation caused integer overflow
/*  3872 */	erb     | 17     << off_ ,
// oexp3:
/*  3873 */	stmt    | 535    << off_ ,	//oexp3	mfi wa oexp6  convert exponent to one word
/*  3874 */	move    | wa     << dst_ | ia     << src_ ,
/*  3875 */	mfi     | oexp6  << off_ ,
/*  3876 */	stmt    | 536    << off_ ,	//	lct wa wa  set loop counter
/*  3877 */	stmt    | 537    << off_ ,	//	ldr rcval(xr)   load base as initial value
/*  3878 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  3879 */	ldr     | r1     << dst_ ,
/*  3880 */	stmt    | 538    << off_ ,	//	bnz wa oexp5  jump into loop if non-zero exponent
/*  3881 */	bnz     | wa     << dst_ | oexp5  << off_ ,
/*  3882 */	stmt    | 539    << off_ ,	//	req oexp4   error if 0.0**0
/*  3883 */	req     | oexp4  << off_ ,
/*  3884 */	stmt    | 540    << off_ ,	//	ldr 4,reav1   nonzero**0
/*  3885 */	load    | r1     << dst_ | reav1  << off_ ,
/*  3886 */	ldr     | r1     << dst_ ,
/*  3887 */	stmt    | 541    << off_ ,	//	brn exrea   return 1.0 if nonzero**zero
/*  3888 */	brn     | exrea  << off_ ,
// oexp4:
/*  3889 */	stmt    | 542    << off_ ,	//oexp4	erb 018 exponentiation result is undefined
/*  3890 */	erb     | 18     << off_ ,
// oex14:
/*  3891 */	stmt    | 543    << off_ ,	//oex14	mlr rcval(xr)   multiply by base
/*  3892 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  3893 */	mlr     | r1     << dst_ ,
/*  3894 */	stmt    | 544    << off_ ,	//	rov oexp6   jump if overflow
/*  3895 */	rov     | oexp6  << off_ ,
// oexp5:
/*  3896 */	stmt    | 545    << off_ ,	//oexp5	bct wa oex14  loop till computation complete
/*  3897 */	bct     | wa     << dst_ | oex14  << off_ ,
/*  3898 */	stmt    | 546    << off_ ,	//	brn exrea   then return real result
/*  3899 */	brn     | exrea  << off_ ,
// oexp6:
/*  3900 */	stmt    | 547    << off_ ,	//oexp6	erb 266 exponentiation caused real overflow
/*  3901 */	erb     | 266    << off_ ,
// oexp7:
/*  3902 */	stmt    | 548    << off_ ,	//oexp7	beq (xr) =b_rcl oexp8 jump if base real
/*  3903 */	load    | r1     << dst_ | xr     << src_ ,
/*  3904 */	loadi   | r2     << dst_ | b_rcl  << off_ ,
/*  3905 */	beq     | r1     << dst_ | r2     << src_ | oexp8  << off_ ,
/*  3906 */	stmt    | 549    << off_ ,	//	ldi icval(xr)   load integer base
/*  3907 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  3908 */	ldi     | r1     << dst_ ,
/*  3909 */	stmt    | 550    << off_ ,	//	itr    convert to real
/*  3910 */	itr     ,
/*  3911 */	stmt    | 551    << off_ ,	//	jsr rcbld   create real in (xr)
/*  3912 */	call    | rcbld  << off_ ,
// oexp8:
/*  3913 */	stmt    | 552    << off_ ,	//oexp8	zer wb   set positive result flag
/*  3914 */	move    | wb     << dst_ ,
/*  3915 */	stmt    | 553    << off_ ,	//	ldr rcval(xr)   load base to ra
/*  3916 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  3917 */	ldr     | r1     << dst_ ,
/*  3918 */	stmt    | 554    << off_ ,	//	rne oexp9   jump if base non-zero
/*  3919 */	rne     | oexp9  << off_ ,
/*  3920 */	stmt    | 555    << off_ ,	//	ldr rcval(xl)   base is zero.  check exponent
/*  3921 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/*  3922 */	ldr     | r1     << dst_ ,
/*  3923 */	stmt    | 556    << off_ ,	//	req oexp4   jump if 0.0 ** 0.0
/*  3924 */	req     | oexp4  << off_ ,
/*  3925 */	stmt    | 557    << off_ ,	//	ldr 4,reav0   0.0 to non-zero exponent yields 0.0
/*  3926 */	load    | r1     << dst_ | reav0  << off_ ,
/*  3927 */	ldr     | r1     << dst_ ,
/*  3928 */	stmt    | 558    << off_ ,	//	brn exrea   return zero result
/*  3929 */	brn     | exrea  << off_ ,
// oexp9:
/*  3930 */	stmt    | 559    << off_ ,	//oexp9	rgt oex10   jump if base gt 0.0
/*  3931 */	rgt     | oex10  << off_ ,
/*  3932 */	stmt    | 560    << off_ ,	//	ngr    make base positive
/*  3933 */	ngr     ,
/*  3934 */	stmt    | 561    << off_ ,	//	jsr rcbld   create positive base in (xr)
/*  3935 */	call    | rcbld  << off_ ,
/*  3936 */	stmt    | 562    << off_ ,	//	ldr rcval(xl)   examine exponent
/*  3937 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/*  3938 */	ldr     | r1     << dst_ ,
/*  3939 */	stmt    | 563    << off_ ,	//	chp    chop to integral value
/*  3940 */	realop  | chp    << off_ ,
/*  3941 */	stmt    | 564    << off_ ,	//	rti oexp6   convert to integer, br if too large
/*  3942 */	rti     | oexp6  << off_ ,
/*  3943 */	stmt    | 565    << off_ ,	//	sbr rcval(xl)   chop(exponent) - exponent
/*  3944 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/*  3945 */	sbr     | r1     << dst_ ,
/*  3946 */	stmt    | 566    << off_ ,	//	rne oex11   non-integral power with neg base
/*  3947 */	rne     | oex11  << off_ ,
/*  3948 */	stmt    | 567    << off_ ,	//	mfi wb   record even/odd exponent
/*  3949 */	move    | wb     << dst_ | ia     << src_ ,
/*  3950 */	stmt    | 568    << off_ ,	//	anb wb 4,bits1  odd exponent yields negative result
/*  3951 */	load    | r2     << dst_ | bits1  << off_ ,
/*  3952 */	anb     | wb     << dst_ | r2     << src_ ,
/*  3953 */	stmt    | 569    << off_ ,	//	ldr rcval(xr)   restore base to ra
/*  3954 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  3955 */	ldr     | r1     << dst_ ,
// oex10:
/*  3956 */	stmt    | 570    << off_ ,	//oex10	lnf    log of base
/*  3957 */	realop  | lnf    << off_ ,
/*  3958 */	stmt    | 571    << off_ ,	//	rov oexp6   too large
/*  3959 */	rov     | oexp6  << off_ ,
/*  3960 */	stmt    | 572    << off_ ,	//	mlr rcval(xl)   times exponent
/*  3961 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/*  3962 */	mlr     | r1     << dst_ ,
/*  3963 */	stmt    | 573    << off_ ,	//	rov oexp6   too large
/*  3964 */	rov     | oexp6  << off_ ,
/*  3965 */	stmt    | 574    << off_ ,	//	etx    e ** (exponent * ln(base))
/*  3966 */	realop  | etx    << off_ ,
/*  3967 */	stmt    | 575    << off_ ,	//	rov oexp6   too large
/*  3968 */	rov     | oexp6  << off_ ,
/*  3969 */	stmt    | 576    << off_ ,	//	bze wb exrea  if no sign fixup required
/*  3970 */	bze     | wb     << dst_ | exrea  << off_ ,
/*  3971 */	stmt    | 577    << off_ ,	//	ngr    negative result needed
/*  3972 */	ngr     ,
/*  3973 */	stmt    | 578    << off_ ,	//	brn exrea
/*  3974 */	brn     | exrea  << off_ ,
// oex11:
/*  3975 */	stmt    | 579    << off_ ,	//oex11	erb 311 exponentiation of negative base to non-integral power
/*  3976 */	erb     | 311    << off_ ,
// oex12:
/*  3977 */	stmt    | 580    << off_ ,	//oex12	mov -(xs) xr  stack base
/*  3978 */	dca     | xs     << dst_ ,
/*  3979 */	store   | xr     << dst_ | xs     << src_ ,
/*  3980 */	stmt    | 581    << off_ ,	//	itr    convert to real exponent
/*  3981 */	itr     ,
/*  3982 */	stmt    | 582    << off_ ,	//	jsr rcbld   real negative exponent in (xr)
/*  3983 */	call    | rcbld  << off_ ,
/*  3984 */	stmt    | 583    << off_ ,	//	mov xl xr  put exponent in xl
/*  3985 */	move    | xl     << dst_ | xr     << src_ ,
/*  3986 */	stmt    | 584    << off_ ,	//	mov xr (xs)+  restore base value
/*  3987 */	load    | xr     << dst_ | xs     << src_ ,
/*  3988 */	ica     | xs     << dst_ ,
/*  3989 */	stmt    | 585    << off_ ,	//	brn oexp7   process real exponent
/*  3990 */	brn     | oexp7  << off_ ,
/*  3991 */	0       ,
// o_fex:
/*  3992 */	stmt    | 586    << off_ ,	//	brn evlx6   jump to failure loc in evalx
/*  3993 */	brn     | evlx6  << off_ ,
/*  3994 */	0       ,
// o_fif:
/*  3995 */	stmt    | 587    << off_ ,	//	erb 020 goto evaluation failure
/*  3996 */	erb     | 20     << off_ ,
/*  3997 */	0       ,
// o_fnc:
/*  3998 */	stmt    | 588    << off_ ,	//	lcw wa   load number of arguments
/*  3999 */	lcw     | wa     << dst_ ,
/*  4000 */	stmt    | 589    << off_ ,	//	lcw xr   load function vrblk pointer
/*  4001 */	lcw     | xr     << dst_ ,
/*  4002 */	stmt    | 590    << off_ ,	//	mov xl vrfnc(xr)  load function pointer
/*  4003 */	load    | xl     << dst_ | xr     << src_ | vrfnc  << off_ ,
/*  4004 */	stmt    | 591    << off_ ,	//	bne wa fargs(xl) cfunc use central routine if wrong num
/*  4005 */	load    | r2     << dst_ | xl     << src_ | fargs  << off_ ,
/*  4006 */	bne     | wa     << dst_ | r2     << src_ | cfunc  << off_ ,
/*  4007 */	stmt    | 592    << off_ ,	//	bri (xl)   jump to function if arg count ok
/*  4008 */	load    | r1     << dst_ | xl     << src_ ,
/*  4009 */	bri     | r1     << dst_ ,
/*  4010 */	0       ,
// o_fne:
/*  4011 */	stmt    | 593    << off_ ,	//	lcw wa   get next code word
/*  4012 */	lcw     | wa     << dst_ ,
/*  4013 */	stmt    | 594    << off_ ,	//	bne wa =ornm_ ofne1 fail if not evaluating expression
/*  4014 */	loadi   | r2     << dst_ | ornm_  << off_ ,
/*  4015 */	bne     | wa     << dst_ | r2     << src_ | ofne1  << off_ ,
/*  4016 */	stmt    | 595    << off_ ,	//	bze num02(xs) evlx3  ok if expr. was wanted by value
/*  4017 */	load    | r1     << dst_ | xs     << src_ | num02  << off_ ,
/*  4018 */	bze     | r1     << dst_ | evlx3  << off_ ,
// ofne1:
/*  4019 */	stmt    | 596    << off_ ,	//ofne1	erb 021 function called by name returned a value
/*  4020 */	erb     | 21     << off_ ,
/*  4021 */	0       ,
// o_fns:
/*  4022 */	stmt    | 597    << off_ ,	//	lcw xr   load function vrblk pointer
/*  4023 */	lcw     | xr     << dst_ ,
/*  4024 */	stmt    | 598    << off_ ,	//	mov wa =num01  set number of arguments to one
/*  4025 */	loadi   | wa     << dst_ | num01  << off_ ,
/*  4026 */	stmt    | 599    << off_ ,	//	mov xl vrfnc(xr)  load function pointer
/*  4027 */	load    | xl     << dst_ | xr     << src_ | vrfnc  << off_ ,
/*  4028 */	stmt    | 600    << off_ ,	//	bne wa fargs(xl) cfunc use central routine if wrong num
/*  4029 */	load    | r2     << dst_ | xl     << src_ | fargs  << off_ ,
/*  4030 */	bne     | wa     << dst_ | r2     << src_ | cfunc  << off_ ,
/*  4031 */	stmt    | 601    << off_ ,	//	bri (xl)   jump to function if arg count ok
/*  4032 */	load    | r1     << dst_ | xl     << src_ ,
/*  4033 */	bri     | r1     << dst_ ,
/*  4034 */	0       ,
// o_fun:
/*  4035 */	stmt    | 602    << off_ ,	//	erb 022 undefined function called
/*  4036 */	erb     | 22     << off_ ,
/*  4037 */	0       ,
// o_goc:
/*  4038 */	stmt    | 603    << off_ ,	//	mov xr num01(xs)  load name base pointer
/*  4039 */	load    | xr     << dst_ | xs     << src_ | num01  << off_ ,
/*  4040 */	stmt    | 604    << off_ ,	//	bhi xr state ogoc1 jump if not natural variable
/*  4041 */	load    | r2     << dst_ | state  << off_ ,
/*  4042 */	bhi     | xr     << dst_ | r2     << src_ | ogoc1  << off_ ,
/*  4043 */	stmt    | 605    << off_ ,	//	add xr *vrtra  else point to vrtra field
/*  4044 */	loadi   | r2     << dst_ | vrtra  << off_ ,
/*  4045 */	add     | xr     << dst_ | r2     << src_ ,
/*  4046 */	stmt    | 606    << off_ ,	//	bri (xr)   and jump through it
/*  4047 */	load    | r1     << dst_ | xr     << src_ ,
/*  4048 */	bri     | r1     << dst_ ,
// ogoc1:
/*  4049 */	stmt    | 607    << off_ ,	//ogoc1	erb 023 goto operand is not a natural variable
/*  4050 */	erb     | 23     << off_ ,
/*  4051 */	0       ,
// o_god:
/*  4052 */	stmt    | 608    << off_ ,	//	mov xr (xs)  load operand
/*  4053 */	load    | xr     << dst_ | xs     << src_ ,
/*  4054 */	stmt    | 609    << off_ ,	//	mov wa (xr)  load first word
/*  4055 */	load    | wa     << dst_ | xr     << src_ ,
/*  4056 */	stmt    | 610    << off_ ,	//	beq wa =b_cds bcds0 jump if code block to code routine
/*  4057 */	loadi   | r2     << dst_ | b_cds  << off_ ,
/*  4058 */	beq     | wa     << dst_ | r2     << src_ | bcds0  << off_ ,
/*  4059 */	stmt    | 611    << off_ ,	//	beq wa =b_cdc bcdc0 jump if code block to code routine
/*  4060 */	loadi   | r2     << dst_ | b_cdc  << off_ ,
/*  4061 */	beq     | wa     << dst_ | r2     << src_ | bcdc0  << off_ ,
/*  4062 */	stmt    | 612    << off_ ,	//	erb 024 goto operand in direct goto is not code
/*  4063 */	erb     | 24     << off_ ,
/*  4064 */	0       ,
// o_gof:
/*  4065 */	stmt    | 613    << off_ ,	//	mov xr flptr  point to fail offset on stack
/*  4066 */	load    | xr     << dst_ | flptr  << off_ ,
/*  4067 */	stmt    | 614    << off_ ,	//	ica (xr)   point failure to o_fif word
/*  4068 */	load    | r1     << dst_ | xr     << src_ ,
/*  4069 */	ica     | r1     << dst_ ,
/*  4070 */	store   | r1     << dst_ | xr     << src_ ,
/*  4071 */	stmt    | 615    << off_ ,	//	icp    point to next code word
/*  4072 */	icp     ,
/*  4073 */	stmt    | 616    << off_ ,	//	lcw xr   fetch next code word
/*  4074 */	lcw     | xr     << dst_ ,
/*  4075 */	stmt    | 617    << off_ ,	//	bri (xr)   execute it
/*  4076 */	load    | r1     << dst_ | xr     << src_ ,
/*  4077 */	bri     | r1     << dst_ ,
/*  4078 */	0       ,
// o_ima:
/*  4079 */	stmt    | 618    << off_ ,	//	mov wb =p_imc  set pcode for last node
/*  4080 */	loadi   | wb     << dst_ | p_imc  << off_ ,
/*  4081 */	stmt    | 619    << off_ ,	//	mov wc (xs)+  pop name offset (parm2)
/*  4082 */	load    | wc     << dst_ | xs     << src_ ,
/*  4083 */	ica     | xs     << dst_ ,
/*  4084 */	stmt    | 620    << off_ ,	//	mov xr (xs)+  pop name base (parm1)
/*  4085 */	load    | xr     << dst_ | xs     << src_ ,
/*  4086 */	ica     | xs     << dst_ ,
/*  4087 */	stmt    | 621    << off_ ,	//	jsr pbild   build p_imc node
/*  4088 */	call    | pbild  << off_ ,
/*  4089 */	stmt    | 622    << off_ ,	//	mov xl xr  save ptr to node
/*  4090 */	move    | xl     << dst_ | xr     << src_ ,
/*  4091 */	stmt    | 623    << off_ ,	//	mov xr (xs)  load left argument
/*  4092 */	load    | xr     << dst_ | xs     << src_ ,
/*  4093 */	stmt    | 624    << off_ ,	//	jsr gtpat   convert to pattern
/*  4094 */	call    | gtpat  << off_ ,
/*  4095 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  4096 */	err     | 25     << off_ ,
/*  4097 */	stmt    | 625    << off_ ,	//	mov (xs) xr  save ptr to left operand pattern
/*  4098 */	store   | xr     << dst_ | xs     << src_ ,
/*  4099 */	stmt    | 626    << off_ ,	//	mov wb =p_ima  set pcode for first node
/*  4100 */	loadi   | wb     << dst_ | p_ima  << off_ ,
/*  4101 */	stmt    | 627    << off_ ,	//	jsr pbild   build p_ima node
/*  4102 */	call    | pbild  << off_ ,
/*  4103 */	stmt    | 628    << off_ ,	//	mov pthen(xr) (xs)+  set left operand as p_ima successor
/*  4104 */	load    | r1     << dst_ | xs     << src_ ,
/*  4105 */	ica     | xs     << dst_ ,
/*  4106 */	store   | r1     << dst_ | xr     << src_ | pthen  << off_ ,
/*  4107 */	stmt    | 629    << off_ ,	//	jsr pconc   concatenate to form final pattern
/*  4108 */	call    | pconc  << off_ ,
/*  4109 */	stmt    | 630    << off_ ,	//	mov -(xs) xr  stack result
/*  4110 */	dca     | xs     << dst_ ,
/*  4111 */	store   | xr     << dst_ | xs     << src_ ,
/*  4112 */	stmt    | 631    << off_ ,	//	lcw xr   get next code word
/*  4113 */	lcw     | xr     << dst_ ,
/*  4114 */	stmt    | 632    << off_ ,	//	bri (xr)   execute it
/*  4115 */	load    | r1     << dst_ | xr     << src_ ,
/*  4116 */	bri     | r1     << dst_ ,
/*  4117 */	0       ,
// o_inn:
/*  4118 */	stmt    | 633    << off_ ,	//	mnz wb   set flag for result by name
/*  4119 */	move    | wb     << dst_ | xs     << src_ ,
/*  4120 */	stmt    | 634    << off_ ,	//	brn indir   jump to common routine
/*  4121 */	brn     | indir  << off_ ,
/*  4122 */	0       ,
// o_int:
/*  4123 */	stmt    | 635    << off_ ,	//	mov (xs) =nulls  replace operand with null
/*  4124 */	loadi   | r1     << dst_ | nulls  << off_ ,
/*  4125 */	store   | r1     << dst_ | xs     << src_ ,
/*  4126 */	stmt    | 636    << off_ ,	//	lcw xr   get next code word
/*  4127 */	lcw     | xr     << dst_ ,
/*  4128 */	stmt    | 637    << off_ ,	//	bri (xr)   execute next code word
/*  4129 */	load    | r1     << dst_ | xr     << src_ ,
/*  4130 */	bri     | r1     << dst_ ,
/*  4131 */	0       ,
// o_inv:
/*  4132 */	stmt    | 638    << off_ ,	//	zer wb   set flag for by value
/*  4133 */	move    | wb     << dst_ ,
/*  4134 */	stmt    | 639    << off_ ,	//	brn indir   jump to common routine
/*  4135 */	brn     | indir  << off_ ,
/*  4136 */	0       ,
// o_kwn:
/*  4137 */	stmt    | 640    << off_ ,	//	jsr kwnam   get keyword name
/*  4138 */	call    | kwnam  << off_ ,
/*  4139 */	stmt    | 641    << off_ ,	//	brn exnam   exit with result name
/*  4140 */	brn     | exnam  << off_ ,
/*  4141 */	0       ,
// o_kwv:
/*  4142 */	stmt    | 642    << off_ ,	//	jsr kwnam   get keyword name
/*  4143 */	call    | kwnam  << off_ ,
/*  4144 */	stmt    | 643    << off_ ,	//	mov dnamp xr  delete kvblk
/*  4145 */	store   | xr     << dst_ | dnamp  << off_ ,
/*  4146 */	stmt    | 644    << off_ ,	//	jsr acess   access value
/*  4147 */	call    | acess  << off_ ,
/*  4148 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  4149 */	ppm     | exnul  << off_ ,
/*  4150 */	stmt    | 645    << off_ ,	//	mov -(xs) xr  stack result
/*  4151 */	dca     | xs     << dst_ ,
/*  4152 */	store   | xr     << dst_ | xs     << src_ ,
/*  4153 */	stmt    | 646    << off_ ,	//	lcw xr   get next code word
/*  4154 */	lcw     | xr     << dst_ ,
/*  4155 */	stmt    | 647    << off_ ,	//	bri (xr)   execute it
/*  4156 */	load    | r1     << dst_ | xr     << src_ ,
/*  4157 */	bri     | r1     << dst_ ,
/*  4158 */	0       ,
// o_lex:
/*  4159 */	stmt    | 648    << off_ ,	//	mov wa *evsi_  set size of evblk
/*  4160 */	loadi   | wa     << dst_ | evsi_  << off_ ,
/*  4161 */	stmt    | 649    << off_ ,	//	jsr alloc   allocate space for evblk
/*  4162 */	call    | alloc  << off_ ,
/*  4163 */	stmt    | 650    << off_ ,	//	mov (xr) =b_evt  set type word
/*  4164 */	loadi   | r1     << dst_ | b_evt  << off_ ,
/*  4165 */	store   | r1     << dst_ | xr     << src_ ,
/*  4166 */	stmt    | 651    << off_ ,	//	mov evvar(xr) =trbev  set dummy trblk pointer
/*  4167 */	loadi   | r1     << dst_ | trbev  << off_ ,
/*  4168 */	store   | r1     << dst_ | xr     << src_ | evvar  << off_ ,
/*  4169 */	stmt    | 652    << off_ ,	//	lcw wa   load exblk pointer
/*  4170 */	lcw     | wa     << dst_ ,
/*  4171 */	stmt    | 653    << off_ ,	//	mov evexp(xr) wa  set exblk pointer
/*  4172 */	store   | wa     << dst_ | xr     << src_ | evexp  << off_ ,
/*  4173 */	stmt    | 654    << off_ ,	//	mov xl xr  move name base to proper reg
/*  4174 */	move    | xl     << dst_ | xr     << src_ ,
/*  4175 */	stmt    | 655    << off_ ,	//	mov wa *evvar  set name offset = zero
/*  4176 */	loadi   | wa     << dst_ | evvar  << off_ ,
/*  4177 */	stmt    | 656    << off_ ,	//	brn exnam   exit with name in (xl,wa)
/*  4178 */	brn     | exnam  << off_ ,
/*  4179 */	0       ,
// o_lpt:
/*  4180 */	stmt    | 657    << off_ ,	//	lcw xr   load pattern pointer
/*  4181 */	lcw     | xr     << dst_ ,
/*  4182 */	stmt    | 658    << off_ ,	//	mov -(xs) xr  stack result
/*  4183 */	dca     | xs     << dst_ ,
/*  4184 */	store   | xr     << dst_ | xs     << src_ ,
/*  4185 */	stmt    | 659    << off_ ,	//	lcw xr   get next code word
/*  4186 */	lcw     | xr     << dst_ ,
/*  4187 */	stmt    | 660    << off_ ,	//	bri (xr)   execute it
/*  4188 */	load    | r1     << dst_ | xr     << src_ ,
/*  4189 */	bri     | r1     << dst_ ,
/*  4190 */	0       ,
// o_lvn:
/*  4191 */	stmt    | 661    << off_ ,	//	lcw wa   load vrblk pointer
/*  4192 */	lcw     | wa     << dst_ ,
/*  4193 */	stmt    | 662    << off_ ,	//	mov -(xs) wa  stack vrblk ptr (name base)
/*  4194 */	dca     | xs     << dst_ ,
/*  4195 */	store   | wa     << dst_ | xs     << src_ ,
/*  4196 */	stmt    | 663    << off_ ,	//	mov -(xs) *vrval  stack name offset
/*  4197 */	loadi   | r1     << dst_ | vrval  << off_ ,
/*  4198 */	dca     | xs     << dst_ ,
/*  4199 */	store   | r1     << dst_ | xs     << src_ ,
/*  4200 */	stmt    | 664    << off_ ,	//	lcw xr   get next code word
/*  4201 */	lcw     | xr     << dst_ ,
/*  4202 */	stmt    | 665    << off_ ,	//	bri (xr)   execute next code word
/*  4203 */	load    | r1     << dst_ | xr     << src_ ,
/*  4204 */	bri     | r1     << dst_ ,
/*  4205 */	0       ,
// o_mlt:
/*  4206 */	stmt    | 666    << off_ ,	//	jsr arith   fetch arithmetic operands
/*  4207 */	call    | arith  << off_ ,
/*  4208 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  4209 */	err     | 26     << off_ ,
/*  4210 */	err     | 27     << off_ ,
/*  4211 */	ppm     | omlt1  << off_ ,
/*  4212 */	stmt    | 667    << off_ ,	//	mli icval(xl)   multiply left operand by right
/*  4213 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/*  4214 */	mli     | r1     << dst_ ,
/*  4215 */	stmt    | 668    << off_ ,	//	ino exint   return integer if no overflow
/*  4216 */	ino     | exint  << off_ ,
/*  4217 */	stmt    | 669    << off_ ,	//	erb 028 multiplication caused integer overflow
/*  4218 */	erb     | 28     << off_ ,
// omlt1:
/*  4219 */	stmt    | 670    << off_ ,	//omlt1	mlr rcval(xl)   multiply left operand by right
/*  4220 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/*  4221 */	mlr     | r1     << dst_ ,
/*  4222 */	stmt    | 671    << off_ ,	//	rno exrea   return real if no overflow
/*  4223 */	rno     | exrea  << off_ ,
/*  4224 */	stmt    | 672    << off_ ,	//	erb 263 multiplication caused real overflow
/*  4225 */	erb     | 263    << off_ ,
/*  4226 */	0       ,
// o_nam:
/*  4227 */	stmt    | 673    << off_ ,	//	mov wa *nmsi_  set length of nmblk
/*  4228 */	loadi   | wa     << dst_ | nmsi_  << off_ ,
/*  4229 */	stmt    | 674    << off_ ,	//	jsr alloc   allocate nmblk
/*  4230 */	call    | alloc  << off_ ,
/*  4231 */	stmt    | 675    << off_ ,	//	mov (xr) =b_nml  set name block code
/*  4232 */	loadi   | r1     << dst_ | b_nml  << off_ ,
/*  4233 */	store   | r1     << dst_ | xr     << src_ ,
/*  4234 */	stmt    | 676    << off_ ,	//	mov nmofs(xr) (xs)+  set name offset from operand
/*  4235 */	load    | r1     << dst_ | xs     << src_ ,
/*  4236 */	ica     | xs     << dst_ ,
/*  4237 */	store   | r1     << dst_ | xr     << src_ | nmofs  << off_ ,
/*  4238 */	stmt    | 677    << off_ ,	//	mov nmbas(xr) (xs)+  set name base from operand
/*  4239 */	load    | r1     << dst_ | xs     << src_ ,
/*  4240 */	ica     | xs     << dst_ ,
/*  4241 */	store   | r1     << dst_ | xr     << src_ | nmbas  << off_ ,
/*  4242 */	stmt    | 678    << off_ ,	//	mov -(xs) xr  stack result
/*  4243 */	dca     | xs     << dst_ ,
/*  4244 */	store   | xr     << dst_ | xs     << src_ ,
/*  4245 */	stmt    | 679    << off_ ,	//	lcw xr   get next code word
/*  4246 */	lcw     | xr     << dst_ ,
/*  4247 */	stmt    | 680    << off_ ,	//	bri (xr)   execute it
/*  4248 */	load    | r1     << dst_ | xr     << src_ ,
/*  4249 */	bri     | r1     << dst_ ,
/*  4250 */	0       ,
// o_nta:
/*  4251 */	stmt    | 681    << off_ ,	//	lcw wa   load new failure offset
/*  4252 */	lcw     | wa     << dst_ ,
/*  4253 */	stmt    | 682    << off_ ,	//	mov -(xs) flptr  stack old failure pointer
/*  4254 */	load    | r1     << dst_ | flptr  << off_ ,
/*  4255 */	dca     | xs     << dst_ ,
/*  4256 */	store   | r1     << dst_ | xs     << src_ ,
/*  4257 */	stmt    | 683    << off_ ,	//	mov -(xs) wa  stack new failure offset
/*  4258 */	dca     | xs     << dst_ ,
/*  4259 */	store   | wa     << dst_ | xs     << src_ ,
/*  4260 */	stmt    | 684    << off_ ,	//	mov flptr xs  set new failure pointer
/*  4261 */	store   | xs     << dst_ | flptr  << off_ ,
/*  4262 */	stmt    | 685    << off_ ,	//	lcw xr   get next code word
/*  4263 */	lcw     | xr     << dst_ ,
/*  4264 */	stmt    | 686    << off_ ,	//	bri (xr)   execute next code word
/*  4265 */	load    | r1     << dst_ | xr     << src_ ,
/*  4266 */	bri     | r1     << dst_ ,
/*  4267 */	0       ,
// o_ntb:
/*  4268 */	stmt    | 687    << off_ ,	//	mov flptr num02(xs)  restore old failure pointer
/*  4269 */	load    | r1     << dst_ | xs     << src_ | num02  << off_ ,
/*  4270 */	store   | r1     << dst_ | flptr  << off_ ,
/*  4271 */	stmt    | 688    << off_ ,	//	brn exfal   and fail
/*  4272 */	brn     | exfal  << off_ ,
/*  4273 */	0       ,
// o_ntc:
/*  4274 */	stmt    | 689    << off_ ,	//	ica xs   pop failure offset
/*  4275 */	ica     | xs     << dst_ ,
/*  4276 */	stmt    | 690    << off_ ,	//	mov flptr (xs)+  restore old failure pointer
/*  4277 */	load    | r1     << dst_ | xs     << src_ ,
/*  4278 */	ica     | xs     << dst_ ,
/*  4279 */	store   | r1     << dst_ | flptr  << off_ ,
/*  4280 */	stmt    | 691    << off_ ,	//	brn exnul   exit giving null result
/*  4281 */	brn     | exnul  << off_ ,
/*  4282 */	0       ,
// o_oun:
/*  4283 */	stmt    | 692    << off_ ,	//	erb 029 undefined operator referenced
/*  4284 */	erb     | 29     << off_ ,
/*  4285 */	0       ,
// o_pas:
/*  4286 */	stmt    | 693    << off_ ,	//	mov wb =p_pac  load pcode for p_pac node
/*  4287 */	loadi   | wb     << dst_ | p_pac  << off_ ,
/*  4288 */	stmt    | 694    << off_ ,	//	mov wc (xs)+  load name offset (parm2)
/*  4289 */	load    | wc     << dst_ | xs     << src_ ,
/*  4290 */	ica     | xs     << dst_ ,
/*  4291 */	stmt    | 695    << off_ ,	//	mov xr (xs)+  load name base (parm1)
/*  4292 */	load    | xr     << dst_ | xs     << src_ ,
/*  4293 */	ica     | xs     << dst_ ,
/*  4294 */	stmt    | 696    << off_ ,	//	jsr pbild   build p_pac node
/*  4295 */	call    | pbild  << off_ ,
/*  4296 */	stmt    | 697    << off_ ,	//	mov xl xr  save ptr to node
/*  4297 */	move    | xl     << dst_ | xr     << src_ ,
/*  4298 */	stmt    | 698    << off_ ,	//	mov xr (xs)  load left operand
/*  4299 */	load    | xr     << dst_ | xs     << src_ ,
/*  4300 */	stmt    | 699    << off_ ,	//	jsr gtpat   convert to pattern
/*  4301 */	call    | gtpat  << off_ ,
/*  4302 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  4303 */	err     | 30     << off_ ,
/*  4304 */	stmt    | 700    << off_ ,	//	mov (xs) xr  save ptr to left operand pattern
/*  4305 */	store   | xr     << dst_ | xs     << src_ ,
/*  4306 */	stmt    | 701    << off_ ,	//	mov wb =p_paa  set pcode for p_paa node
/*  4307 */	loadi   | wb     << dst_ | p_paa  << off_ ,
/*  4308 */	stmt    | 702    << off_ ,	//	jsr pbild   build p_paa node
/*  4309 */	call    | pbild  << off_ ,
/*  4310 */	stmt    | 703    << off_ ,	//	mov pthen(xr) (xs)+  set left operand as p_paa successor
/*  4311 */	load    | r1     << dst_ | xs     << src_ ,
/*  4312 */	ica     | xs     << dst_ ,
/*  4313 */	store   | r1     << dst_ | xr     << src_ | pthen  << off_ ,
/*  4314 */	stmt    | 704    << off_ ,	//	jsr pconc   concatenate to form final pattern
/*  4315 */	call    | pconc  << off_ ,
/*  4316 */	stmt    | 705    << off_ ,	//	mov -(xs) xr  stack result
/*  4317 */	dca     | xs     << dst_ ,
/*  4318 */	store   | xr     << dst_ | xs     << src_ ,
/*  4319 */	stmt    | 706    << off_ ,	//	lcw xr   get next code word
/*  4320 */	lcw     | xr     << dst_ ,
/*  4321 */	stmt    | 707    << off_ ,	//	bri (xr)   execute it
/*  4322 */	load    | r1     << dst_ | xr     << src_ ,
/*  4323 */	bri     | r1     << dst_ ,
/*  4324 */	0       ,
// o_pmn:
/*  4325 */	stmt    | 708    << off_ ,	//	zer wb   set type code for match by name
/*  4326 */	move    | wb     << dst_ ,
/*  4327 */	stmt    | 709    << off_ ,	//	brn match   jump to routine to start match
/*  4328 */	brn     | match  << off_ ,
/*  4329 */	0       ,
// o_pms:
/*  4330 */	stmt    | 710    << off_ ,	//	mov wb =num02  set flag for statement to match
/*  4331 */	loadi   | wb     << dst_ | num02  << off_ ,
/*  4332 */	stmt    | 711    << off_ ,	//	brn match   jump to routine to start match
/*  4333 */	brn     | match  << off_ ,
/*  4334 */	0       ,
// o_pmv:
/*  4335 */	stmt    | 712    << off_ ,	//	mov wb =num01  set type code for value match
/*  4336 */	loadi   | wb     << dst_ | num01  << off_ ,
/*  4337 */	stmt    | 713    << off_ ,	//	brn match   jump to routine to start match
/*  4338 */	brn     | match  << off_ ,
/*  4339 */	0       ,
// o_pop:
/*  4340 */	stmt    | 714    << off_ ,	//	ica xs   pop top stack entry
/*  4341 */	ica     | xs     << dst_ ,
/*  4342 */	stmt    | 715    << off_ ,	//	lcw xr   get next code word
/*  4343 */	lcw     | xr     << dst_ ,
/*  4344 */	stmt    | 716    << off_ ,	//	bri (xr)   execute next code word
/*  4345 */	load    | r1     << dst_ | xr     << src_ ,
/*  4346 */	bri     | r1     << dst_ ,
/*  4347 */	0       ,
// o_stp:
/*  4348 */	stmt    | 717    << off_ ,	//	brn lend0   jump to end circuit
/*  4349 */	brn     | lend0  << off_ ,
/*  4350 */	0       ,
// o_rnm:
/*  4351 */	stmt    | 718    << off_ ,	//	brn evlx4   return to evalx procedure
/*  4352 */	brn     | evlx4  << off_ ,
/*  4353 */	0       ,
// o_rpl:
/*  4354 */	stmt    | 719    << off_ ,	//	jsr gtstg   convert replacement val to string
/*  4355 */	call    | gtstg  << off_ ,
/*  4356 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  4357 */	err     | 31     << off_ ,
/*  4358 */	stmt    | 720    << off_ ,	//	mov xl (xs)  load subject string pointer
/*  4359 */	load    | xl     << dst_ | xs     << src_ ,
/*  4360 */	stmt    | 721    << off_ ,	//	add wa sclen(xl)  add subject string length
/*  4361 */	load    | r2     << dst_ | xl     << src_ | sclen  << off_ ,
/*  4362 */	add     | wa     << dst_ | r2     << src_ ,
/*  4363 */	stmt    | 722    << off_ ,	//	add wa num02(xs)  add starting cursor
/*  4364 */	load    | r2     << dst_ | xs     << src_ | num02  << off_ ,
/*  4365 */	add     | wa     << dst_ | r2     << src_ ,
/*  4366 */	stmt    | 723    << off_ ,	//	sub wa num01(xs)  minus final cursor = total length
/*  4367 */	load    | r2     << dst_ | xs     << src_ | num01  << off_ ,
/*  4368 */	sub     | wa     << dst_ | r2     << src_ ,
/*  4369 */	stmt    | 724    << off_ ,	//	bze wa orpl3  jump if result is null
/*  4370 */	bze     | wa     << dst_ | orpl3  << off_ ,
/*  4371 */	stmt    | 725    << off_ ,	//	mov -(xs) xr  restack replacement string
/*  4372 */	dca     | xs     << dst_ ,
/*  4373 */	store   | xr     << dst_ | xs     << src_ ,
/*  4374 */	stmt    | 726    << off_ ,	//	jsr alocs   allocate scblk for result
/*  4375 */	call    | alocs  << off_ ,
/*  4376 */	stmt    | 727    << off_ ,	//	mov wa num03(xs)  get initial cursor (part 1 len)
/*  4377 */	load    | wa     << dst_ | xs     << src_ | num03  << off_ ,
/*  4378 */	stmt    | 728    << off_ ,	//	mov num03(xs) xr  stack result pointer
/*  4379 */	store   | xr     << dst_ | xs     << src_ | num03  << off_ ,
/*  4380 */	stmt    | 729    << off_ ,	//	psc xr   point to characters of result
/*  4381 */	psc     | xr     << dst_ ,
/*  4382 */	stmt    | 730    << off_ ,	//	bze wa orpl1  jump if first part is null
/*  4383 */	bze     | wa     << dst_ | orpl1  << off_ ,
/*  4384 */	stmt    | 731    << off_ ,	//	mov xl num01(xs)  else point to subject string
/*  4385 */	load    | xl     << dst_ | xs     << src_ | num01  << off_ ,
/*  4386 */	stmt    | 732    << off_ ,	//	plc xl   point to subject string chars
/*  4387 */	plc     | xl     << dst_ ,
/*  4388 */	stmt    | 733    << off_ ,	//	mvc    move first part to result
/*  4389 */	mvc     ,
// orpl1:
/*  4390 */	stmt    | 734    << off_ ,	//orpl1	mov xl (xs)+  load replacement string, pop
/*  4391 */	load    | xl     << dst_ | xs     << src_ ,
/*  4392 */	ica     | xs     << dst_ ,
/*  4393 */	stmt    | 735    << off_ ,	//	mov wa sclen(xl)  load length
/*  4394 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/*  4395 */	stmt    | 736    << off_ ,	//	bze wa orpl2  jump if null replacement
/*  4396 */	bze     | wa     << dst_ | orpl2  << off_ ,
/*  4397 */	stmt    | 737    << off_ ,	//	plc xl   else point to chars of replacement
/*  4398 */	plc     | xl     << dst_ ,
/*  4399 */	stmt    | 738    << off_ ,	//	mvc    move in chars (part 2)
/*  4400 */	mvc     ,
// orpl2:
/*  4401 */	stmt    | 739    << off_ ,	//orpl2	mov xl (xs)+  load subject string pointer, pop
/*  4402 */	load    | xl     << dst_ | xs     << src_ ,
/*  4403 */	ica     | xs     << dst_ ,
/*  4404 */	stmt    | 740    << off_ ,	//	mov wc (xs)+  load final cursor, pop
/*  4405 */	load    | wc     << dst_ | xs     << src_ ,
/*  4406 */	ica     | xs     << dst_ ,
/*  4407 */	stmt    | 741    << off_ ,	//	mov wa sclen(xl)  load subject string length
/*  4408 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/*  4409 */	stmt    | 742    << off_ ,	//	sub wa wc  minus final cursor = part 3 length
/*  4410 */	sub     | wa     << dst_ | wc     << src_ ,
/*  4411 */	stmt    | 743    << off_ ,	//	bze wa oass0  jump to assign if part 3 is null
/*  4412 */	bze     | wa     << dst_ | oass0  << off_ ,
/*  4413 */	stmt    | 744    << off_ ,	//	plc xl wc  else point to last part of string
/*  4414 */	plc     | xl     << dst_ | wc     << src_ ,
/*  4415 */	stmt    | 745    << off_ ,	//	mvc    move part 3 to result
/*  4416 */	mvc     ,
/*  4417 */	stmt    | 746    << off_ ,	//	brn oass0   jump to perform assignment
/*  4418 */	brn     | oass0  << off_ ,
// orpl3:
/*  4419 */	stmt    | 747    << off_ ,	//orpl3	add xs *num02  pop subject str ptr, final cursor
/*  4420 */	loadi   | r2     << dst_ | num02  << off_ ,
/*  4421 */	add     | xs     << dst_ | r2     << src_ ,
/*  4422 */	stmt    | 748    << off_ ,	//	mov (xs) =nulls  set null result
/*  4423 */	loadi   | r1     << dst_ | nulls  << off_ ,
/*  4424 */	store   | r1     << dst_ | xs     << src_ ,
/*  4425 */	stmt    | 749    << off_ ,	//	brn oass0   jump to assign null value
/*  4426 */	brn     | oass0  << off_ ,
/*  4427 */	0       ,
// o_rvl:
/*  4428 */	stmt    | 750    << off_ ,	//	brn evlx3   return to evalx procedure
/*  4429 */	brn     | evlx3  << off_ ,
/*  4430 */	0       ,
// o_sla:
/*  4431 */	stmt    | 751    << off_ ,	//	lcw wa   load new failure offset
/*  4432 */	lcw     | wa     << dst_ ,
/*  4433 */	stmt    | 752    << off_ ,	//	mov -(xs) flptr  stack old failure pointer
/*  4434 */	load    | r1     << dst_ | flptr  << off_ ,
/*  4435 */	dca     | xs     << dst_ ,
/*  4436 */	store   | r1     << dst_ | xs     << src_ ,
/*  4437 */	stmt    | 753    << off_ ,	//	mov -(xs) wa  stack new failure offset
/*  4438 */	dca     | xs     << dst_ ,
/*  4439 */	store   | wa     << dst_ | xs     << src_ ,
/*  4440 */	stmt    | 754    << off_ ,	//	mov flptr xs  set new failure pointer
/*  4441 */	store   | xs     << dst_ | flptr  << off_ ,
/*  4442 */	stmt    | 755    << off_ ,	//	lcw xr   get next code word
/*  4443 */	lcw     | xr     << dst_ ,
/*  4444 */	stmt    | 756    << off_ ,	//	bri (xr)   execute next code word
/*  4445 */	load    | r1     << dst_ | xr     << src_ ,
/*  4446 */	bri     | r1     << dst_ ,
/*  4447 */	0       ,
// o_slb:
/*  4448 */	stmt    | 757    << off_ ,	//	mov xr (xs)+  load result
/*  4449 */	load    | xr     << dst_ | xs     << src_ ,
/*  4450 */	ica     | xs     << dst_ ,
/*  4451 */	stmt    | 758    << off_ ,	//	ica xs   pop fail offset
/*  4452 */	ica     | xs     << dst_ ,
/*  4453 */	stmt    | 759    << off_ ,	//	mov flptr (xs)  restore old failure pointer
/*  4454 */	load    | r1     << dst_ | xs     << src_ ,
/*  4455 */	store   | r1     << dst_ | flptr  << off_ ,
/*  4456 */	stmt    | 760    << off_ ,	//	mov (xs) xr  restack result
/*  4457 */	store   | xr     << dst_ | xs     << src_ ,
/*  4458 */	stmt    | 761    << off_ ,	//	lcw wa   load new code offset
/*  4459 */	lcw     | wa     << dst_ ,
/*  4460 */	stmt    | 762    << off_ ,	//	add wa r_cod  point to absolute code location
/*  4461 */	load    | r2     << dst_ | r_cod  << off_ ,
/*  4462 */	add     | wa     << dst_ | r2     << src_ ,
/*  4463 */	stmt    | 763    << off_ ,	//	lcp wa   set new code pointer
/*  4464 */	lcp     | wa     << dst_ ,
/*  4465 */	stmt    | 764    << off_ ,	//	lcw xr   get next code word
/*  4466 */	lcw     | xr     << dst_ ,
/*  4467 */	stmt    | 765    << off_ ,	//	bri (xr)   execute next code word
/*  4468 */	load    | r1     << dst_ | xr     << src_ ,
/*  4469 */	bri     | r1     << dst_ ,
/*  4470 */	0       ,
// o_slc:
/*  4471 */	stmt    | 766    << off_ ,	//	lcw wa   load new fail offset
/*  4472 */	lcw     | wa     << dst_ ,
/*  4473 */	stmt    | 767    << off_ ,	//	mov (xs) wa  store new fail offset
/*  4474 */	store   | wa     << dst_ | xs     << src_ ,
/*  4475 */	stmt    | 768    << off_ ,	//	lcw xr   get next code word
/*  4476 */	lcw     | xr     << dst_ ,
/*  4477 */	stmt    | 769    << off_ ,	//	bri (xr)   execute next code word
/*  4478 */	load    | r1     << dst_ | xr     << src_ ,
/*  4479 */	bri     | r1     << dst_ ,
/*  4480 */	0       ,
// o_sld:
/*  4481 */	stmt    | 770    << off_ ,	//	ica xs   pop failure offset
/*  4482 */	ica     | xs     << dst_ ,
/*  4483 */	stmt    | 771    << off_ ,	//	mov flptr (xs)+  restore old failure pointer
/*  4484 */	load    | r1     << dst_ | xs     << src_ ,
/*  4485 */	ica     | xs     << dst_ ,
/*  4486 */	store   | r1     << dst_ | flptr  << off_ ,
/*  4487 */	stmt    | 772    << off_ ,	//	lcw xr   get next code word
/*  4488 */	lcw     | xr     << dst_ ,
/*  4489 */	stmt    | 773    << off_ ,	//	bri (xr)   execute next code word
/*  4490 */	load    | r1     << dst_ | xr     << src_ ,
/*  4491 */	bri     | r1     << dst_ ,
/*  4492 */	0       ,
// o_sub:
/*  4493 */	stmt    | 774    << off_ ,	//	jsr arith   fetch arithmetic operands
/*  4494 */	call    | arith  << off_ ,
/*  4495 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  4496 */	err     | 32     << off_ ,
/*  4497 */	err     | 33     << off_ ,
/*  4498 */	ppm     | osub1  << off_ ,
/*  4499 */	stmt    | 775    << off_ ,	//	sbi icval(xl)   subtract right operand from left
/*  4500 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/*  4501 */	sbi     | r1     << dst_ ,
/*  4502 */	stmt    | 776    << off_ ,	//	ino exint   return integer if no overflow
/*  4503 */	ino     | exint  << off_ ,
/*  4504 */	stmt    | 777    << off_ ,	//	erb 034 subtraction caused integer overflow
/*  4505 */	erb     | 34     << off_ ,
// osub1:
/*  4506 */	stmt    | 778    << off_ ,	//osub1	sbr rcval(xl)   subtract right operand from left
/*  4507 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/*  4508 */	sbr     | r1     << dst_ ,
/*  4509 */	stmt    | 779    << off_ ,	//	rno exrea   return real if no overflow
/*  4510 */	rno     | exrea  << off_ ,
/*  4511 */	stmt    | 780    << off_ ,	//	erb 264 subtraction caused real overflow
/*  4512 */	erb     | 264    << off_ ,
/*  4513 */	0       ,
// o_txr:
/*  4514 */	stmt    | 781    << off_ ,	//	brn trxq1   jump into trxeq procedure
/*  4515 */	brn     | trxq1  << off_ ,
/*  4516 */	0       ,
// o_unf:
/*  4517 */	stmt    | 782    << off_ ,	//	erb 035 unexpected failure in -nofail mode
/*  4518 */	erb     | 35     << off_ ,
/*  4519 */	bl__i   ,
// b_aaa:
/*  4520 */	bl_ex   ,
// b_exl:
/*  4521 */	stmt    | 783    << off_ ,	//	mov -(xs) xr  stack result
/*  4522 */	dca     | xs     << dst_ ,
/*  4523 */	store   | xr     << dst_ | xs     << src_ ,
/*  4524 */	stmt    | 784    << off_ ,	//	lcw xr   get next code word
/*  4525 */	lcw     | xr     << dst_ ,
/*  4526 */	stmt    | 785    << off_ ,	//	bri (xr)   execute it
/*  4527 */	load    | r1     << dst_ | xr     << src_ ,
/*  4528 */	bri     | r1     << dst_ ,
/*  4529 */	bl_se   ,
// b_sel:
/*  4530 */	stmt    | 786    << off_ ,	//	mov -(xs) xr  stack result
/*  4531 */	dca     | xs     << dst_ ,
/*  4532 */	store   | xr     << dst_ | xs     << src_ ,
/*  4533 */	stmt    | 787    << off_ ,	//	lcw xr   get next code word
/*  4534 */	lcw     | xr     << dst_ ,
/*  4535 */	stmt    | 788    << off_ ,	//	bri (xr)   execute it
/*  4536 */	load    | r1     << dst_ | xr     << src_ ,
/*  4537 */	bri     | r1     << dst_ ,
/*  4538 */	bl__i   ,
// b_e__:
/*  4539 */	bl_tr   ,
// b_trt:
/*  4540 */	bl__i   ,
// b_t__:
/*  4541 */	bl_ar   ,
// b_art:
/*  4542 */	bl_bc   ,
// b_bct:
/*  4543 */	bl_bf   ,
// b_bft:
/*  4544 */	bl_cc   ,
// b_cct:
/*  4545 */	bl_cd   ,
// b_cdc:
// bcdc0:
/*  4546 */	stmt    | 789    << off_ ,	//bcdc0	mov xs flptr  pop garbage off stack
/*  4547 */	load    | xs     << dst_ | flptr  << off_ ,
/*  4548 */	stmt    | 790    << off_ ,	//	mov (xs) cdfal(xr)  set failure offset
/*  4549 */	load    | r1     << dst_ | xr     << src_ | cdfal  << off_ ,
/*  4550 */	store   | r1     << dst_ | xs     << src_ ,
/*  4551 */	stmt    | 791    << off_ ,	//	brn stmgo   enter stmt
/*  4552 */	brn     | stmgo  << off_ ,
/*  4553 */	bl_cd   ,
// b_cds:
// bcds0:
/*  4554 */	stmt    | 792    << off_ ,	//bcds0	mov xs flptr  pop garbage off stack
/*  4555 */	load    | xs     << dst_ | flptr  << off_ ,
/*  4556 */	stmt    | 793    << off_ ,	//	mov (xs) *cdfal  set failure offset
/*  4557 */	loadi   | r1     << dst_ | cdfal  << off_ ,
/*  4558 */	store   | r1     << dst_ | xs     << src_ ,
/*  4559 */	stmt    | 794    << off_ ,	//	brn stmgo   enter stmt
/*  4560 */	brn     | stmgo  << off_ ,
/*  4561 */	bl_cm   ,
// b_cmt:
/*  4562 */	bl_ct   ,
// b_ctt:
/*  4563 */	bl_df   ,
// b_dfc:
/*  4564 */	stmt    | 795    << off_ ,	//	mov wa dfpdl(xl)  load length of pdblk
/*  4565 */	load    | wa     << dst_ | xl     << src_ | dfpdl  << off_ ,
/*  4566 */	stmt    | 796    << off_ ,	//	jsr alloc   allocate pdblk
/*  4567 */	call    | alloc  << off_ ,
/*  4568 */	stmt    | 797    << off_ ,	//	mov (xr) =b_pdt  store type word
/*  4569 */	loadi   | r1     << dst_ | b_pdt  << off_ ,
/*  4570 */	store   | r1     << dst_ | xr     << src_ ,
/*  4571 */	stmt    | 798    << off_ ,	//	mov pddfp(xr) xl  store dfblk pointer
/*  4572 */	store   | xl     << dst_ | xr     << src_ | pddfp  << off_ ,
/*  4573 */	stmt    | 799    << off_ ,	//	mov wc xr  save pointer to pdblk
/*  4574 */	move    | wc     << dst_ | xr     << src_ ,
/*  4575 */	stmt    | 800    << off_ ,	//	add xr wa  point past pdblk
/*  4576 */	add     | xr     << dst_ | wa     << src_ ,
/*  4577 */	stmt    | 801    << off_ ,	//	lct wa fargs(xl)  set to count fields
/*  4578 */	load    | wa     << dst_ | xl     << src_ | fargs  << off_ ,
// bdfc1:
/*  4579 */	stmt    | 802    << off_ ,	//bdfc1	mov -(xr) (xs)+  move a field value
/*  4580 */	load    | r1     << dst_ | xs     << src_ ,
/*  4581 */	ica     | xs     << dst_ ,
/*  4582 */	dca     | xr     << dst_ ,
/*  4583 */	store   | r1     << dst_ | xr     << src_ ,
/*  4584 */	stmt    | 803    << off_ ,	//	bct wa bdfc1  loop till all moved
/*  4585 */	bct     | wa     << dst_ | bdfc1  << off_ ,
/*  4586 */	stmt    | 804    << off_ ,	//	mov xr wc  recall pointer to pdblk
/*  4587 */	move    | xr     << dst_ | wc     << src_ ,
/*  4588 */	stmt    | 805    << off_ ,	//	brn exsid   exit setting id field
/*  4589 */	brn     | exsid  << off_ ,
/*  4590 */	bl_ef   ,
// b_efc:
/*  4591 */	stmt    | 806    << off_ ,	//	mov wc fargs(xl)  load number of arguments
/*  4592 */	load    | wc     << dst_ | xl     << src_ | fargs  << off_ ,
/*  4593 */	stmt    | 807    << off_ ,	//	wtb wc   convert to offset
/*  4594 */	stmt    | 808    << off_ ,	//	mov -(xs) xl  save pointer to efblk
/*  4595 */	dca     | xs     << dst_ ,
/*  4596 */	store   | xl     << dst_ | xs     << src_ ,
/*  4597 */	stmt    | 809    << off_ ,	//	mov xt xs  copy pointer to arguments
/*  4598 */	move    | xt     << dst_ | xs     << src_ ,
// befc1:
/*  4599 */	stmt    | 810    << off_ ,	//befc1	ica xt   point to next entry
/*  4600 */	ica     | xt     << dst_ ,
/*  4601 */	stmt    | 811    << off_ ,	//	mov xr (xs)  load pointer to efblk
/*  4602 */	load    | xr     << dst_ | xs     << src_ ,
/*  4603 */	stmt    | 812    << off_ ,	//	dca wc   decrement eftar offset
/*  4604 */	dca     | wc     << dst_ ,
/*  4605 */	stmt    | 813    << off_ ,	//	add xr wc  point to next eftar entry
/*  4606 */	add     | xr     << dst_ | wc     << src_ ,
/*  4607 */	stmt    | 814    << off_ ,	//	mov xr eftar(xr)  load eftar entry
/*  4608 */	load    | xr     << dst_ | xr     << src_ | eftar  << off_ ,
/*  4609 */	stmt    | 815    << off_ ,	//	bsw xr 5  switch on type
/*  4610 */	loadi   | r1     << dst_ | 5      << off_ ,
/*  4611 */	bsw     | xr     << dst_ | r1     << src_ ,
/*  4612 */	befc7   ,
/*  4613 */	befc2   ,
/*  4614 */	befc3   ,
/*  4615 */	befc4   ,
/*  4616 */	beff1   ,
// beff1:
/*  4617 */	stmt    | 816    << off_ ,	//beff1	mov -(xs) xt  save entry pointer
/*  4618 */	dca     | xs     << dst_ ,
/*  4619 */	store   | xt     << dst_ | xs     << src_ ,
/*  4620 */	stmt    | 817    << off_ ,	//	mov befof wc  save offset
/*  4621 */	store   | wc     << dst_ | befof  << off_ ,
/*  4622 */	stmt    | 818    << off_ ,	//	mov -(xs) (xt)  stack arg pointer
/*  4623 */	load    | r1     << dst_ | xt     << src_ ,
/*  4624 */	dca     | xs     << dst_ ,
/*  4625 */	store   | r1     << dst_ | xs     << src_ ,
/*  4626 */	stmt    | 819    << off_ ,	//	jsr iofcb   convert to fcb
/*  4627 */	call    | iofcb  << off_ ,
/*  4628 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  4629 */	err     | 298    << off_ ,
/*  4630 */	err     | 298    << off_ ,
/*  4631 */	err     | 298    << off_ ,
/*  4632 */	stmt    | 820    << off_ ,	//	mov xr wa  point to fcb
/*  4633 */	move    | xr     << dst_ | wa     << src_ ,
/*  4634 */	stmt    | 821    << off_ ,	//	mov xt (xs)+  reload entry pointer
/*  4635 */	load    | xt     << dst_ | xs     << src_ ,
/*  4636 */	ica     | xs     << dst_ ,
/*  4637 */	stmt    | 822    << off_ ,	//	brn befc5   jump to merge
/*  4638 */	brn     | befc5  << off_ ,
// befc2:
/*  4639 */	stmt    | 823    << off_ ,	//befc2	mov -(xs) (xt)  stack arg ptr
/*  4640 */	load    | r1     << dst_ | xt     << src_ ,
/*  4641 */	dca     | xs     << dst_ ,
/*  4642 */	store   | r1     << dst_ | xs     << src_ ,
/*  4643 */	stmt    | 824    << off_ ,	//	jsr gtstg   convert argument to string
/*  4644 */	call    | gtstg  << off_ ,
/*  4645 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  4646 */	err     | 39     << off_ ,
/*  4647 */	stmt    | 825    << off_ ,	//	brn befc6   jump to merge
/*  4648 */	brn     | befc6  << off_ ,
// befc3:
/*  4649 */	stmt    | 826    << off_ ,	//befc3	mov xr (xt)  load next argument
/*  4650 */	load    | xr     << dst_ | xt     << src_ ,
/*  4651 */	stmt    | 827    << off_ ,	//	mov befof wc  save offset
/*  4652 */	store   | wc     << dst_ | befof  << off_ ,
/*  4653 */	stmt    | 828    << off_ ,	//	jsr gtint   convert to integer
/*  4654 */	call    | gtint  << off_ ,
/*  4655 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  4656 */	err     | 40     << off_ ,
/*  4657 */	stmt    | 829    << off_ ,	//	brn befc5   merge with real case
/*  4658 */	brn     | befc5  << off_ ,
// befc4:
/*  4659 */	stmt    | 830    << off_ ,	//befc4	mov xr (xt)  load next argument
/*  4660 */	load    | xr     << dst_ | xt     << src_ ,
/*  4661 */	stmt    | 831    << off_ ,	//	mov befof wc  save offset
/*  4662 */	store   | wc     << dst_ | befof  << off_ ,
/*  4663 */	stmt    | 832    << off_ ,	//	jsr gtrea   convert to real
/*  4664 */	call    | gtrea  << off_ ,
/*  4665 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  4666 */	err     | 265    << off_ ,
// befc5:
/*  4667 */	stmt    | 833    << off_ ,	//befc5	mov wc befof  restore offset
/*  4668 */	load    | wc     << dst_ | befof  << off_ ,
// befc6:
/*  4669 */	stmt    | 834    << off_ ,	//befc6	mov (xt) xr  store converted result
/*  4670 */	store   | xr     << dst_ | xt     << src_ ,
// befc7:
/*  4671 */	stmt    | 835    << off_ ,	//befc7	bnz wc befc1  loop back if more to go
/*  4672 */	bnz     | wc     << dst_ | befc1  << off_ ,
/*  4673 */	stmt    | 836    << off_ ,	//	mov xl (xs)+  restore efblk pointer
/*  4674 */	load    | xl     << dst_ | xs     << src_ ,
/*  4675 */	ica     | xs     << dst_ ,
/*  4676 */	stmt    | 837    << off_ ,	//	mov wa fargs(xl)  get number of args
/*  4677 */	load    | wa     << dst_ | xl     << src_ | fargs  << off_ ,
/*  4678 */	stmt    | 838    << off_ ,	//	jsr sysex   call routine to call external fnc
/*  4679 */	sys     | sysex_ << off_ ,
/*  4680 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  4681 */	ppm     | exfal  << off_ ,
/*  4682 */	err     | 327    << off_ ,
/*  4683 */	err     | 326    << off_ ,
/*  4684 */	stmt    | 839    << off_ ,	//	wtb wa   convert number of args to bytes
/*  4685 */	stmt    | 840    << off_ ,	//	add xs wa  remove arguments from stack
/*  4686 */	add     | xs     << dst_ | wa     << src_ ,
/*  4687 */	stmt    | 841    << off_ ,	//	mov wb efrsl(xl)  get result type id
/*  4688 */	load    | wb     << dst_ | xl     << src_ | efrsl  << off_ ,
/*  4689 */	stmt    | 842    << off_ ,	//	bnz wb befa8  branch if not unconverted
/*  4690 */	bnz     | wb     << dst_ | befa8  << off_ ,
/*  4691 */	stmt    | 843    << off_ ,	//	bne (xr) =b_scl befc8 jump if not a string
/*  4692 */	load    | r1     << dst_ | xr     << src_ ,
/*  4693 */	loadi   | r2     << dst_ | b_scl  << off_ ,
/*  4694 */	bne     | r1     << dst_ | r2     << src_ | befc8  << off_ ,
/*  4695 */	stmt    | 844    << off_ ,	//	bze sclen(xr) exnul  return null if null
/*  4696 */	load    | r1     << dst_ | xr     << src_ | sclen  << off_ ,
/*  4697 */	bze     | r1     << dst_ | exnul  << off_ ,
// befa8:
/*  4698 */	stmt    | 845    << off_ ,	//befa8	bne wb =num01 befc8 jump if not a string
/*  4699 */	loadi   | r2     << dst_ | num01  << off_ ,
/*  4700 */	bne     | wb     << dst_ | r2     << src_ | befc8  << off_ ,
/*  4701 */	stmt    | 846    << off_ ,	//	bze sclen(xr) exnul  return null if null
/*  4702 */	load    | r1     << dst_ | xr     << src_ | sclen  << off_ ,
/*  4703 */	bze     | r1     << dst_ | exnul  << off_ ,
// befc8:
/*  4704 */	stmt    | 847    << off_ ,	//befc8	blt xr dnamb befc9 jump if not in dynamic storage
/*  4705 */	load    | r2     << dst_ | dnamb  << off_ ,
/*  4706 */	blt     | xr     << dst_ | r2     << src_ | befc9  << off_ ,
/*  4707 */	stmt    | 848    << off_ ,	//	ble xr dnamp exixr return result if already dynamic
/*  4708 */	load    | r2     << dst_ | dnamp  << off_ ,
/*  4709 */	ble     | xr     << dst_ | r2     << src_ | exixr  << off_ ,
// befc9:
/*  4710 */	stmt    | 849    << off_ ,	//befc9	mov wa (xr)  get possible type word
/*  4711 */	load    | wa     << dst_ | xr     << src_ ,
/*  4712 */	stmt    | 850    << off_ ,	//	bze wb bef11  jump if unconverted result
/*  4713 */	bze     | wb     << dst_ | bef11  << off_ ,
/*  4714 */	stmt    | 851    << off_ ,	//	mov wa =b_scl  string
/*  4715 */	loadi   | wa     << dst_ | b_scl  << off_ ,
/*  4716 */	stmt    | 852    << off_ ,	//	beq wb =num01 bef10 yes jump
/*  4717 */	loadi   | r2     << dst_ | num01  << off_ ,
/*  4718 */	beq     | wb     << dst_ | r2     << src_ | bef10  << off_ ,
/*  4719 */	stmt    | 853    << off_ ,	//	mov wa =b_icl  integer
/*  4720 */	loadi   | wa     << dst_ | b_icl  << off_ ,
/*  4721 */	stmt    | 854    << off_ ,	//	beq wb =num02 bef10 yes jump
/*  4722 */	loadi   | r2     << dst_ | num02  << off_ ,
/*  4723 */	beq     | wb     << dst_ | r2     << src_ | bef10  << off_ ,
/*  4724 */	stmt    | 855    << off_ ,	//	mov wa =b_rcl  real
/*  4725 */	loadi   | wa     << dst_ | b_rcl  << off_ ,
// bef10:
/*  4726 */	stmt    | 856    << off_ ,	//bef10	mov (xr) wa  stored before copying to dynamic
/*  4727 */	store   | wa     << dst_ | xr     << src_ ,
// bef11:
/*  4728 */	stmt    | 857    << off_ ,	//bef11	beq (xr) =b_scl bef12 branch if string result
/*  4729 */	load    | r1     << dst_ | xr     << src_ ,
/*  4730 */	loadi   | r2     << dst_ | b_scl  << off_ ,
/*  4731 */	beq     | r1     << dst_ | r2     << src_ | bef12  << off_ ,
/*  4732 */	stmt    | 858    << off_ ,	//	jsr blkln   get length of block
/*  4733 */	call    | blkln  << off_ ,
/*  4734 */	stmt    | 859    << off_ ,	//	mov xl xr  copy address of old block
/*  4735 */	move    | xl     << dst_ | xr     << src_ ,
/*  4736 */	stmt    | 860    << off_ ,	//	jsr alloc   allocate dynamic block same size
/*  4737 */	call    | alloc  << off_ ,
/*  4738 */	stmt    | 861    << off_ ,	//	mov -(xs) xr  set pointer to new block as result
/*  4739 */	dca     | xs     << dst_ ,
/*  4740 */	store   | xr     << dst_ | xs     << src_ ,
/*  4741 */	stmt    | 862    << off_ ,	//	mvw    copy old block to dynamic block
/*  4742 */	mvw     ,
/*  4743 */	stmt    | 863    << off_ ,	//	zer xl   clear garbage value
/*  4744 */	move    | xl     << dst_ ,
/*  4745 */	stmt    | 864    << off_ ,	//	lcw xr   get next code word
/*  4746 */	lcw     | xr     << dst_ ,
/*  4747 */	stmt    | 865    << off_ ,	//	bri (xr)   execute next code word
/*  4748 */	load    | r1     << dst_ | xr     << src_ ,
/*  4749 */	bri     | r1     << dst_ ,
// bef12:
/*  4750 */	stmt    | 866    << off_ ,	//bef12	mov xl xr  save source string pointer
/*  4751 */	move    | xl     << dst_ | xr     << src_ ,
/*  4752 */	stmt    | 867    << off_ ,	//	mov wa sclen(xr)  fetch string length
/*  4753 */	load    | wa     << dst_ | xr     << src_ | sclen  << off_ ,
/*  4754 */	stmt    | 868    << off_ ,	//	bze wa exnul  return null string if length zero
/*  4755 */	bze     | wa     << dst_ | exnul  << off_ ,
/*  4756 */	stmt    | 869    << off_ ,	//	jsr alocs   allocate space for string
/*  4757 */	call    | alocs  << off_ ,
/*  4758 */	stmt    | 870    << off_ ,	//	mov -(xs) xr  save as result pointer
/*  4759 */	dca     | xs     << dst_ ,
/*  4760 */	store   | xr     << dst_ | xs     << src_ ,
/*  4761 */	stmt    | 871    << off_ ,	//	psc xr   prepare to store chars of result
/*  4762 */	psc     | xr     << dst_ ,
/*  4763 */	stmt    | 872    << off_ ,	//	plc xl   point to chars in source string
/*  4764 */	plc     | xl     << dst_ ,
/*  4765 */	stmt    | 873    << off_ ,	//	mov wa wc  number of characters to copy
/*  4766 */	move    | wa     << dst_ | wc     << src_ ,
/*  4767 */	stmt    | 874    << off_ ,	//	mvc    move characters to result string
/*  4768 */	mvc     ,
/*  4769 */	stmt    | 875    << off_ ,	//	zer xl   clear garbage value
/*  4770 */	move    | xl     << dst_ ,
/*  4771 */	stmt    | 876    << off_ ,	//	lcw xr   get next code word
/*  4772 */	lcw     | xr     << dst_ ,
/*  4773 */	stmt    | 877    << off_ ,	//	bri (xr)   execute next code word
/*  4774 */	load    | r1     << dst_ | xr     << src_ ,
/*  4775 */	bri     | r1     << dst_ ,
/*  4776 */	bl_ev   ,
// b_evt:
/*  4777 */	bl_ff   ,
// b_ffc:
/*  4778 */	stmt    | 878    << off_ ,	//	mov xr xl  copy ffblk pointer
/*  4779 */	move    | xr     << dst_ | xl     << src_ ,
/*  4780 */	stmt    | 879    << off_ ,	//	lcw wc   load next code word
/*  4781 */	lcw     | wc     << dst_ ,
/*  4782 */	stmt    | 880    << off_ ,	//	mov xl (xs)  load pdblk pointer
/*  4783 */	load    | xl     << dst_ | xs     << src_ ,
/*  4784 */	stmt    | 881    << off_ ,	//	bne (xl) =b_pdt bffc2 jump if not pdblk at all
/*  4785 */	load    | r1     << dst_ | xl     << src_ ,
/*  4786 */	loadi   | r2     << dst_ | b_pdt  << off_ ,
/*  4787 */	bne     | r1     << dst_ | r2     << src_ | bffc2  << off_ ,
/*  4788 */	stmt    | 882    << off_ ,	//	mov wa pddfp(xl)  load dfblk pointer from pdblk
/*  4789 */	load    | wa     << dst_ | xl     << src_ | pddfp  << off_ ,
// bffc1:
/*  4790 */	stmt    | 883    << off_ ,	//bffc1	beq wa ffdfp(xr) bffc3 jump if this is the correct ffblk
/*  4791 */	load    | r2     << dst_ | xr     << src_ | ffdfp  << off_ ,
/*  4792 */	beq     | wa     << dst_ | r2     << src_ | bffc3  << off_ ,
/*  4793 */	stmt    | 884    << off_ ,	//	mov xr ffnxt(xr)  else link to next ffblk on chain
/*  4794 */	load    | xr     << dst_ | xr     << src_ | ffnxt  << off_ ,
/*  4795 */	stmt    | 885    << off_ ,	//	bnz xr bffc1  loop back if another entry to check
/*  4796 */	bnz     | xr     << dst_ | bffc1  << off_ ,
// bffc2:
/*  4797 */	stmt    | 886    << off_ ,	//bffc2	erb 041 field function argument is wrong datatype
/*  4798 */	erb     | 41     << off_ ,
// bffc3:
/*  4799 */	stmt    | 887    << off_ ,	//bffc3	mov wa ffofs(xr)  load field offset
/*  4800 */	load    | wa     << dst_ | xr     << src_ | ffofs  << off_ ,
/*  4801 */	stmt    | 888    << off_ ,	//	beq wc =ofne_ bffc5 jump if called by name
/*  4802 */	loadi   | r2     << dst_ | ofne_  << off_ ,
/*  4803 */	beq     | wc     << dst_ | r2     << src_ | bffc5  << off_ ,
/*  4804 */	stmt    | 889    << off_ ,	//	add xl wa  else point to value field
/*  4805 */	add     | xl     << dst_ | wa     << src_ ,
/*  4806 */	stmt    | 890    << off_ ,	//	mov xr (xl)  load value
/*  4807 */	load    | xr     << dst_ | xl     << src_ ,
/*  4808 */	stmt    | 891    << off_ ,	//	bne (xr) =b_trt bffc4 jump if not trapped
/*  4809 */	load    | r1     << dst_ | xr     << src_ ,
/*  4810 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/*  4811 */	bne     | r1     << dst_ | r2     << src_ | bffc4  << off_ ,
/*  4812 */	stmt    | 892    << off_ ,	//	sub xl wa  else restore name base,offset
/*  4813 */	sub     | xl     << dst_ | wa     << src_ ,
/*  4814 */	stmt    | 893    << off_ ,	//	mov (xs) wc  save next code word over pdblk ptr
/*  4815 */	store   | wc     << dst_ | xs     << src_ ,
/*  4816 */	stmt    | 894    << off_ ,	//	jsr acess   access value
/*  4817 */	call    | acess  << off_ ,
/*  4818 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  4819 */	ppm     | exfal  << off_ ,
/*  4820 */	stmt    | 895    << off_ ,	//	mov wc (xs)  restore next code word
/*  4821 */	load    | wc     << dst_ | xs     << src_ ,
// bffc4:
/*  4822 */	stmt    | 896    << off_ ,	//bffc4	mov (xs) xr  store value on stack (over pdblk)
/*  4823 */	store   | xr     << dst_ | xs     << src_ ,
/*  4824 */	stmt    | 897    << off_ ,	//	mov xr wc  copy next code word
/*  4825 */	move    | xr     << dst_ | wc     << src_ ,
/*  4826 */	stmt    | 898    << off_ ,	//	mov xl (xr)  load entry address
/*  4827 */	load    | xl     << dst_ | xr     << src_ ,
/*  4828 */	stmt    | 899    << off_ ,	//	bri xl   jump to routine for next code word
/*  4829 */	bri     | xl     << dst_ ,
// bffc5:
/*  4830 */	stmt    | 900    << off_ ,	//bffc5	mov -(xs) wa  store name offset (base is set)
/*  4831 */	dca     | xs     << dst_ ,
/*  4832 */	store   | wa     << dst_ | xs     << src_ ,
/*  4833 */	stmt    | 901    << off_ ,	//	lcw xr   get next code word
/*  4834 */	lcw     | xr     << dst_ ,
/*  4835 */	stmt    | 902    << off_ ,	//	bri (xr)   execute next code word
/*  4836 */	load    | r1     << dst_ | xr     << src_ ,
/*  4837 */	bri     | r1     << dst_ ,
/*  4838 */	bl_ic   ,
// b_icl:
/*  4839 */	stmt    | 903    << off_ ,	//	mov -(xs) xr  stack result
/*  4840 */	dca     | xs     << dst_ ,
/*  4841 */	store   | xr     << dst_ | xs     << src_ ,
/*  4842 */	stmt    | 904    << off_ ,	//	lcw xr   get next code word
/*  4843 */	lcw     | xr     << dst_ ,
/*  4844 */	stmt    | 905    << off_ ,	//	bri (xr)   execute it
/*  4845 */	load    | r1     << dst_ | xr     << src_ ,
/*  4846 */	bri     | r1     << dst_ ,
/*  4847 */	bl_kv   ,
// b_kvt:
/*  4848 */	bl_nm   ,
// b_nml:
/*  4849 */	stmt    | 906    << off_ ,	//	mov -(xs) xr  stack result
/*  4850 */	dca     | xs     << dst_ ,
/*  4851 */	store   | xr     << dst_ | xs     << src_ ,
/*  4852 */	stmt    | 907    << off_ ,	//	lcw xr   get next code word
/*  4853 */	lcw     | xr     << dst_ ,
/*  4854 */	stmt    | 908    << off_ ,	//	bri (xr)   execute it
/*  4855 */	load    | r1     << dst_ | xr     << src_ ,
/*  4856 */	bri     | r1     << dst_ ,
/*  4857 */	bl_pd   ,
// b_pdt:
/*  4858 */	bl_pf   ,
// b_pfc:
/*  4859 */	stmt    | 909    << off_ ,	//	mov bpfpf xl  save pfblk ptr (need not be reloc)
/*  4860 */	store   | xl     << dst_ | bpfpf  << off_ ,
/*  4861 */	stmt    | 910    << off_ ,	//	mov xr xl  copy for the moment
/*  4862 */	move    | xr     << dst_ | xl     << src_ ,
/*  4863 */	stmt    | 911    << off_ ,	//	mov xl pfvbl(xr)  point to vrblk for function
/*  4864 */	load    | xl     << dst_ | xr     << src_ | pfvbl  << off_ ,
// bpf01:
/*  4865 */	stmt    | 912    << off_ ,	//bpf01	mov wb xl  save pointer
/*  4866 */	move    | wb     << dst_ | xl     << src_ ,
/*  4867 */	stmt    | 913    << off_ ,	//	mov xl vrval(xl)  load value
/*  4868 */	load    | xl     << dst_ | xl     << src_ | vrval  << off_ ,
/*  4869 */	stmt    | 914    << off_ ,	//	beq (xl) =b_trt bpf01 loop if trblk
/*  4870 */	load    | r1     << dst_ | xl     << src_ ,
/*  4871 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/*  4872 */	beq     | r1     << dst_ | r2     << src_ | bpf01  << off_ ,
/*  4873 */	stmt    | 915    << off_ ,	//	mov bpfsv xl  save old value
/*  4874 */	store   | xl     << dst_ | bpfsv  << off_ ,
/*  4875 */	stmt    | 916    << off_ ,	//	mov xl wb  point back to block with value
/*  4876 */	move    | xl     << dst_ | wb     << src_ ,
/*  4877 */	stmt    | 917    << off_ ,	//	mov vrval(xl) =nulls  set value to null
/*  4878 */	loadi   | r1     << dst_ | nulls  << off_ ,
/*  4879 */	store   | r1     << dst_ | xl     << src_ | vrval  << off_ ,
/*  4880 */	stmt    | 918    << off_ ,	//	mov wa fargs(xr)  load number of arguments
/*  4881 */	load    | wa     << dst_ | xr     << src_ | fargs  << off_ ,
/*  4882 */	stmt    | 919    << off_ ,	//	add xr *pfarg  point to pfarg entries
/*  4883 */	loadi   | r2     << dst_ | pfarg  << off_ ,
/*  4884 */	add     | xr     << dst_ | r2     << src_ ,
/*  4885 */	stmt    | 920    << off_ ,	//	bze wa bpf04  jump if no arguments
/*  4886 */	bze     | wa     << dst_ | bpf04  << off_ ,
/*  4887 */	stmt    | 921    << off_ ,	//	mov xt xs  ptr to last arg
/*  4888 */	move    | xt     << dst_ | xs     << src_ ,
/*  4889 */	stmt    | 922    << off_ ,	//	wtb wa   convert no. of args to bytes offset
/*  4890 */	stmt    | 923    << off_ ,	//	add xt wa  point before first arg
/*  4891 */	add     | xt     << dst_ | wa     << src_ ,
/*  4892 */	stmt    | 924    << off_ ,	//	mov bpfxt xt  remember arg pointer
/*  4893 */	store   | xt     << dst_ | bpfxt  << off_ ,
// bpf02:
/*  4894 */	stmt    | 925    << off_ ,	//bpf02	mov xl (xr)+  load vrblk ptr for next argument
/*  4895 */	load    | xl     << dst_ | xr     << src_ ,
/*  4896 */	ica     | xr     << dst_ ,
// bpf03:
/*  4897 */	stmt    | 926    << off_ ,	//bpf03	mov wc xl  save pointer
/*  4898 */	move    | wc     << dst_ | xl     << src_ ,
/*  4899 */	stmt    | 927    << off_ ,	//	mov xl vrval(xl)  load next value
/*  4900 */	load    | xl     << dst_ | xl     << src_ | vrval  << off_ ,
/*  4901 */	stmt    | 928    << off_ ,	//	beq (xl) =b_trt bpf03 loop back if trblk
/*  4902 */	load    | r1     << dst_ | xl     << src_ ,
/*  4903 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/*  4904 */	beq     | r1     << dst_ | r2     << src_ | bpf03  << off_ ,
/*  4905 */	stmt    | 929    << off_ ,	//	mov wa xl  keep old value
/*  4906 */	move    | wa     << dst_ | xl     << src_ ,
/*  4907 */	stmt    | 930    << off_ ,	//	mov xt bpfxt  point before next stacked arg
/*  4908 */	load    | xt     << dst_ | bpfxt  << off_ ,
/*  4909 */	stmt    | 931    << off_ ,	//	mov wb -(xt)  load argument (new value)
/*  4910 */	dca     | xt     << dst_ ,
/*  4911 */	load    | wb     << dst_ | xt     << src_ ,
/*  4912 */	stmt    | 932    << off_ ,	//	mov (xt) wa  save old value
/*  4913 */	store   | wa     << dst_ | xt     << src_ ,
/*  4914 */	stmt    | 933    << off_ ,	//	mov bpfxt xt  keep arg ptr for next time
/*  4915 */	store   | xt     << dst_ | bpfxt  << off_ ,
/*  4916 */	stmt    | 934    << off_ ,	//	mov xl wc  point back to block with value
/*  4917 */	move    | xl     << dst_ | wc     << src_ ,
/*  4918 */	stmt    | 935    << off_ ,	//	mov vrval(xl) wb  set new value
/*  4919 */	store   | wb     << dst_ | xl     << src_ | vrval  << off_ ,
/*  4920 */	stmt    | 936    << off_ ,	//	bne xs bpfxt bpf02 loop if not all done
/*  4921 */	load    | r2     << dst_ | bpfxt  << off_ ,
/*  4922 */	bne     | xs     << dst_ | r2     << src_ | bpf02  << off_ ,
// bpf04:
/*  4923 */	stmt    | 937    << off_ ,	//bpf04	mov xl bpfpf  restore pfblk pointer
/*  4924 */	load    | xl     << dst_ | bpfpf  << off_ ,
/*  4925 */	stmt    | 938    << off_ ,	//	mov wa pfnlo(xl)  load number of locals
/*  4926 */	load    | wa     << dst_ | xl     << src_ | pfnlo  << off_ ,
/*  4927 */	stmt    | 939    << off_ ,	//	bze wa bpf07  jump if no locals
/*  4928 */	bze     | wa     << dst_ | bpf07  << off_ ,
/*  4929 */	stmt    | 940    << off_ ,	//	mov wb =nulls  get null constant
/*  4930 */	loadi   | wb     << dst_ | nulls  << off_ ,
/*  4931 */	stmt    | 941    << off_ ,	//	lct wa wa  set local counter
// bpf05:
/*  4932 */	stmt    | 942    << off_ ,	//bpf05	mov xl (xr)+  load vrblk ptr for next local
/*  4933 */	load    | xl     << dst_ | xr     << src_ ,
/*  4934 */	ica     | xr     << dst_ ,
// bpf06:
/*  4935 */	stmt    | 943    << off_ ,	//bpf06	mov wc xl  save pointer
/*  4936 */	move    | wc     << dst_ | xl     << src_ ,
/*  4937 */	stmt    | 944    << off_ ,	//	mov xl vrval(xl)  load next value
/*  4938 */	load    | xl     << dst_ | xl     << src_ | vrval  << off_ ,
/*  4939 */	stmt    | 945    << off_ ,	//	beq (xl) =b_trt bpf06 loop back if trblk
/*  4940 */	load    | r1     << dst_ | xl     << src_ ,
/*  4941 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/*  4942 */	beq     | r1     << dst_ | r2     << src_ | bpf06  << off_ ,
/*  4943 */	stmt    | 946    << off_ ,	//	mov -(xs) xl  stack old value
/*  4944 */	dca     | xs     << dst_ ,
/*  4945 */	store   | xl     << dst_ | xs     << src_ ,
/*  4946 */	stmt    | 947    << off_ ,	//	mov xl wc  point back to block with value
/*  4947 */	move    | xl     << dst_ | wc     << src_ ,
/*  4948 */	stmt    | 948    << off_ ,	//	mov vrval(xl) wb  set null as new value
/*  4949 */	store   | wb     << dst_ | xl     << src_ | vrval  << off_ ,
/*  4950 */	stmt    | 949    << off_ ,	//	bct wa bpf05  loop till all locals processed
/*  4951 */	bct     | wa     << dst_ | bpf05  << off_ ,
// bpf07:
/*  4952 */	stmt    | 950    << off_ ,	//bpf07	zer xr   zero reg xr in case
/*  4953 */	move    | xr     << dst_ ,
/*  4954 */	stmt    | 951    << off_ ,	//	bze kvpfl bpf7c  skip if profiling is off
/*  4955 */	load    | r1     << dst_ | kvpfl  << off_ ,
/*  4956 */	bze     | r1     << dst_ | bpf7c  << off_ ,
/*  4957 */	stmt    | 952    << off_ ,	//	beq kvpfl =num02 bpf7a branch on type of profile
/*  4958 */	load    | r1     << dst_ | kvpfl  << off_ ,
/*  4959 */	loadi   | r2     << dst_ | num02  << off_ ,
/*  4960 */	beq     | r1     << dst_ | r2     << src_ | bpf7a  << off_ ,
/*  4961 */	stmt    | 953    << off_ ,	//	jsr systm   get current time
/*  4962 */	sys     | systm_ << off_ ,
/*  4963 */	stmt    | 954    << off_ ,	//	sti pfetm   save for a sec
/*  4964 */	store   | ia     << dst_ | pfetm  << off_ ,
/*  4965 */	stmt    | 955    << off_ ,	//	sbi pfstm   find time used by caller
/*  4966 */	load    | r1     << dst_ | pfstm  << off_ ,
/*  4967 */	sbi     | r1     << dst_ ,
/*  4968 */	stmt    | 956    << off_ ,	//	jsr icbld   build into an icblk
/*  4969 */	call    | icbld  << off_ ,
/*  4970 */	stmt    | 957    << off_ ,	//	ldi pfetm   reload current time
/*  4971 */	load    | r1     << dst_ | pfetm  << off_ ,
/*  4972 */	ldi     | r1     << dst_ ,
/*  4973 */	stmt    | 958    << off_ ,	//	brn bpf7b   merge
/*  4974 */	brn     | bpf7b  << off_ ,
// bpf7a:
/*  4975 */	stmt    | 959    << off_ ,	//bpf7a	ldi pfstm   get start time of calling stmt
/*  4976 */	load    | r1     << dst_ | pfstm  << off_ ,
/*  4977 */	ldi     | r1     << dst_ ,
/*  4978 */	stmt    | 960    << off_ ,	//	jsr icbld   assemble an icblk round it
/*  4979 */	call    | icbld  << off_ ,
/*  4980 */	stmt    | 961    << off_ ,	//	jsr systm   get now time
/*  4981 */	sys     | systm_ << off_ ,
// bpf7b:
/*  4982 */	stmt    | 962    << off_ ,	//bpf7b	sti pfstm   set start time of 1st func stmt
/*  4983 */	store   | ia     << dst_ | pfstm  << off_ ,
/*  4984 */	stmt    | 963    << off_ ,	//	mnz pffnc   flag function entry
/*  4985 */	store   | xs     << dst_ | pffnc  << off_ ,
// bpf7c:
/*  4986 */	stmt    | 964    << off_ ,	//bpf7c	mov -(xs) xr  stack icblk ptr (or zero)
/*  4987 */	dca     | xs     << dst_ ,
/*  4988 */	store   | xr     << dst_ | xs     << src_ ,
/*  4989 */	stmt    | 965    << off_ ,	//	mov wa r_cod  load old code block pointer
/*  4990 */	load    | wa     << dst_ | r_cod  << off_ ,
/*  4991 */	stmt    | 966    << off_ ,	//	scp wb   get code pointer
/*  4992 */	scp     | wb     << dst_ ,
/*  4993 */	stmt    | 967    << off_ ,	//	sub wb wa  make code pointer into offset
/*  4994 */	sub     | wb     << dst_ | wa     << src_ ,
/*  4995 */	stmt    | 968    << off_ ,	//	mov xl bpfpf  recall pfblk pointer
/*  4996 */	load    | xl     << dst_ | bpfpf  << off_ ,
/*  4997 */	stmt    | 969    << off_ ,	//	mov -(xs) bpfsv  stack old value of function name
/*  4998 */	load    | r1     << dst_ | bpfsv  << off_ ,
/*  4999 */	dca     | xs     << dst_ ,
/*  5000 */	store   | r1     << dst_ | xs     << src_ ,
/*  5001 */	stmt    | 970    << off_ ,	//	mov -(xs) wa  stack code block pointer
/*  5002 */	dca     | xs     << dst_ ,
/*  5003 */	store   | wa     << dst_ | xs     << src_ ,
/*  5004 */	stmt    | 971    << off_ ,	//	mov -(xs) wb  stack code offset
/*  5005 */	dca     | xs     << dst_ ,
/*  5006 */	store   | wb     << dst_ | xs     << src_ ,
/*  5007 */	stmt    | 972    << off_ ,	//	mov -(xs) flprt  stack old flprt
/*  5008 */	load    | r1     << dst_ | flprt  << off_ ,
/*  5009 */	dca     | xs     << dst_ ,
/*  5010 */	store   | r1     << dst_ | xs     << src_ ,
/*  5011 */	stmt    | 973    << off_ ,	//	mov -(xs) flptr  stack old failure pointer
/*  5012 */	load    | r1     << dst_ | flptr  << off_ ,
/*  5013 */	dca     | xs     << dst_ ,
/*  5014 */	store   | r1     << dst_ | xs     << src_ ,
/*  5015 */	stmt    | 974    << off_ ,	//	mov -(xs) xl  stack pointer to pfblk
/*  5016 */	dca     | xs     << dst_ ,
/*  5017 */	store   | xl     << dst_ | xs     << src_ ,
/*  5018 */	stmt    | 975    << off_ ,	//	zer -(xs)   dummy zero entry for fail return
/*  5019 */	dca     | xs     << dst_ ,
/*  5020 */	store   | r0     << dst_ | xs     << src_ ,
/*  5021 */	stmt    | 976    << off_ ,	//	chk    check for stack overflow
/*  5022 */	chk     ,
/*  5023 */	stmt    | 977    << off_ ,	//	mov flptr xs  set new fail return value
/*  5024 */	store   | xs     << dst_ | flptr  << off_ ,
/*  5025 */	stmt    | 978    << off_ ,	//	mov flprt xs  set new flprt
/*  5026 */	store   | xs     << dst_ | flprt  << off_ ,
/*  5027 */	stmt    | 979    << off_ ,	//	mov wa kvtra  load trace value
/*  5028 */	load    | wa     << dst_ | kvtra  << off_ ,
/*  5029 */	stmt    | 980    << off_ ,	//	add wa kvftr  add ftrace value
/*  5030 */	load    | r2     << dst_ | kvftr  << off_ ,
/*  5031 */	add     | wa     << dst_ | r2     << src_ ,
/*  5032 */	stmt    | 981    << off_ ,	//	bnz wa bpf09  jump if tracing possible
/*  5033 */	bnz     | wa     << dst_ | bpf09  << off_ ,
/*  5034 */	stmt    | 982    << off_ ,	//	icv kvfnc   else bump fnclevel
/*  5035 */	load    | r1     << dst_ | kvfnc  << off_ ,
/*  5036 */	icv     | r1     << dst_ ,
/*  5037 */	store   | r1     << dst_ | kvfnc  << off_ ,
// bpf08:
/*  5038 */	stmt    | 983    << off_ ,	//bpf08	mov xr pfcod(xl)  point to vrblk of entry label
/*  5039 */	load    | xr     << dst_ | xl     << src_ | pfcod  << off_ ,
/*  5040 */	stmt    | 984    << off_ ,	//	mov xr vrlbl(xr)  point to target code
/*  5041 */	load    | xr     << dst_ | xr     << src_ | vrlbl  << off_ ,
/*  5042 */	stmt    | 985    << off_ ,	//	beq xr =stndl bpf17 test for undefined label
/*  5043 */	loadi   | r2     << dst_ | stndl  << off_ ,
/*  5044 */	beq     | xr     << dst_ | r2     << src_ | bpf17  << off_ ,
/*  5045 */	stmt    | 986    << off_ ,	//	bne (xr) =b_trt bpf8a jump if not trapped
/*  5046 */	load    | r1     << dst_ | xr     << src_ ,
/*  5047 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/*  5048 */	bne     | r1     << dst_ | r2     << src_ | bpf8a  << off_ ,
/*  5049 */	stmt    | 987    << off_ ,	//	mov xr trlbl(xr)  else load ptr to real label code
/*  5050 */	load    | xr     << dst_ | xr     << src_ | trlbl  << off_ ,
// bpf8a:
/*  5051 */	stmt    | 988    << off_ ,	//bpf8a	bri (xr)   off to execute function
/*  5052 */	load    | r1     << dst_ | xr     << src_ ,
/*  5053 */	bri     | r1     << dst_ ,
// bpf09:
/*  5054 */	stmt    | 989    << off_ ,	//bpf09	mov xr pfctr(xl)  load possible call trace trblk
/*  5055 */	load    | xr     << dst_ | xl     << src_ | pfctr  << off_ ,
/*  5056 */	stmt    | 990    << off_ ,	//	mov xl pfvbl(xl)  load vrblk pointer for function
/*  5057 */	load    | xl     << dst_ | xl     << src_ | pfvbl  << off_ ,
/*  5058 */	stmt    | 991    << off_ ,	//	mov wa *vrval  set name offset for variable
/*  5059 */	loadi   | wa     << dst_ | vrval  << off_ ,
/*  5060 */	stmt    | 992    << off_ ,	//	bze kvtra bpf10  jump if trace mode is off
/*  5061 */	load    | r1     << dst_ | kvtra  << off_ ,
/*  5062 */	bze     | r1     << dst_ | bpf10  << off_ ,
/*  5063 */	stmt    | 993    << off_ ,	//	bze xr bpf10  or if there is no call trace
/*  5064 */	bze     | xr     << dst_ | bpf10  << off_ ,
/*  5065 */	stmt    | 994    << off_ ,	//	dcv kvtra   decrement trace count
/*  5066 */	load    | r1     << dst_ | kvtra  << off_ ,
/*  5067 */	dcv     | r1     << dst_ ,
/*  5068 */	store   | r1     << dst_ | kvtra  << off_ ,
/*  5069 */	stmt    | 995    << off_ ,	//	bze trfnc(xr) bpf11  jump if print trace
/*  5070 */	load    | r1     << dst_ | xr     << src_ | trfnc  << off_ ,
/*  5071 */	bze     | r1     << dst_ | bpf11  << off_ ,
/*  5072 */	stmt    | 996    << off_ ,	//	jsr trxeq   execute function type trace
/*  5073 */	call    | trxeq  << off_ ,
// bpf10:
/*  5074 */	stmt    | 997    << off_ ,	//bpf10	bze kvftr bpf16  jump if ftrace is off
/*  5075 */	load    | r1     << dst_ | kvftr  << off_ ,
/*  5076 */	bze     | r1     << dst_ | bpf16  << off_ ,
/*  5077 */	stmt    | 998    << off_ ,	//	dcv kvftr   else decrement ftrace
/*  5078 */	load    | r1     << dst_ | kvftr  << off_ ,
/*  5079 */	dcv     | r1     << dst_ ,
/*  5080 */	store   | r1     << dst_ | kvftr  << off_ ,
// bpf11:
/*  5081 */	stmt    | 999    << off_ ,	//bpf11	jsr prtsn   print statement number
/*  5082 */	call    | prtsn  << off_ ,
/*  5083 */	stmt    | 1000   << off_ ,	//	jsr prtnm   print function name
/*  5084 */	call    | prtnm  << off_ ,
/*  5085 */	stmt    | 1001   << off_ ,	//	mov wa =ch_pp  load left paren
/*  5086 */	loadi   | wa     << dst_ | ch_pp  << off_ ,
/*  5087 */	stmt    | 1002   << off_ ,	//	jsr prtch   print left paren
/*  5088 */	call    | prtch  << off_ ,
/*  5089 */	stmt    | 1003   << off_ ,	//	mov xl num01(xs)  recover pfblk pointer
/*  5090 */	load    | xl     << dst_ | xs     << src_ | num01  << off_ ,
/*  5091 */	stmt    | 1004   << off_ ,	//	bze fargs(xl) bpf15  skip if no arguments
/*  5092 */	load    | r1     << dst_ | xl     << src_ | fargs  << off_ ,
/*  5093 */	bze     | r1     << dst_ | bpf15  << off_ ,
/*  5094 */	stmt    | 1005   << off_ ,	//	zer wb   else set argument counter
/*  5095 */	move    | wb     << dst_ ,
/*  5096 */	stmt    | 1006   << off_ ,	//	brn bpf13   jump into loop
/*  5097 */	brn     | bpf13  << off_ ,
// bpf12:
/*  5098 */	stmt    | 1007   << off_ ,	//bpf12	mov wa =ch_cm  load comma
/*  5099 */	loadi   | wa     << dst_ | ch_cm  << off_ ,
/*  5100 */	stmt    | 1008   << off_ ,	//	jsr prtch   print to separate from last arg
/*  5101 */	call    | prtch  << off_ ,
// bpf13:
/*  5102 */	stmt    | 1009   << off_ ,	//bpf13	mov (xs) wb  save arg ctr (over failoffs is ok)
/*  5103 */	store   | wb     << dst_ | xs     << src_ ,
/*  5104 */	stmt    | 1010   << off_ ,	//	wtb wb   convert to byte offset
/*  5105 */	stmt    | 1011   << off_ ,	//	add xl wb  point to next argument pointer
/*  5106 */	add     | xl     << dst_ | wb     << src_ ,
/*  5107 */	stmt    | 1012   << off_ ,	//	mov xr pfarg(xl)  load next argument vrblk ptr
/*  5108 */	load    | xr     << dst_ | xl     << src_ | pfarg  << off_ ,
/*  5109 */	stmt    | 1013   << off_ ,	//	sub xl wb  restore pfblk pointer
/*  5110 */	sub     | xl     << dst_ | wb     << src_ ,
/*  5111 */	stmt    | 1014   << off_ ,	//	mov xr vrval(xr)  load next value
/*  5112 */	load    | xr     << dst_ | xr     << src_ | vrval  << off_ ,
/*  5113 */	stmt    | 1015   << off_ ,	//	jsr prtvl   print argument value
/*  5114 */	call    | prtvl  << off_ ,
/*  5115 */	stmt    | 1016   << off_ ,	//	mov wb (xs)  restore argument counter
/*  5116 */	load    | wb     << dst_ | xs     << src_ ,
/*  5117 */	stmt    | 1017   << off_ ,	//	icv wb   increment argument counter
/*  5118 */	icv     | wb     << dst_ ,
/*  5119 */	stmt    | 1018   << off_ ,	//	blt wb fargs(xl) bpf12 loop if more to print
/*  5120 */	load    | r2     << dst_ | xl     << src_ | fargs  << off_ ,
/*  5121 */	blt     | wb     << dst_ | r2     << src_ | bpf12  << off_ ,
// bpf15:
/*  5122 */	stmt    | 1019   << off_ ,	//bpf15	mov wa =ch_rp  load right paren
/*  5123 */	loadi   | wa     << dst_ | ch_rp  << off_ ,
/*  5124 */	stmt    | 1020   << off_ ,	//	jsr prtch   print to terminate output
/*  5125 */	call    | prtch  << off_ ,
/*  5126 */	stmt    | 1021   << off_ ,	//	jsr prtnl   terminate print line
/*  5127 */	call    | prtnl  << off_ ,
// bpf16:
/*  5128 */	stmt    | 1022   << off_ ,	//bpf16	icv kvfnc   increment fnclevel
/*  5129 */	load    | r1     << dst_ | kvfnc  << off_ ,
/*  5130 */	icv     | r1     << dst_ ,
/*  5131 */	store   | r1     << dst_ | kvfnc  << off_ ,
/*  5132 */	stmt    | 1023   << off_ ,	//	mov xl r_fnc  load ptr to possible trblk
/*  5133 */	load    | xl     << dst_ | r_fnc  << off_ ,
/*  5134 */	stmt    | 1024   << off_ ,	//	jsr ktrex   call keyword trace routine
/*  5135 */	call    | ktrex  << off_ ,
/*  5136 */	stmt    | 1025   << off_ ,	//	mov xl num01(xs)  restore pfblk pointer
/*  5137 */	load    | xl     << dst_ | xs     << src_ | num01  << off_ ,
/*  5138 */	stmt    | 1026   << off_ ,	//	brn bpf08   jump back to execute function
/*  5139 */	brn     | bpf08  << off_ ,
// bpf17:
/*  5140 */	stmt    | 1027   << off_ ,	//bpf17	mov flptr num02(xs)  reset so exfal can return to evalx
/*  5141 */	load    | r1     << dst_ | xs     << src_ | num02  << off_ ,
/*  5142 */	store   | r1     << dst_ | flptr  << off_ ,
/*  5143 */	stmt    | 1028   << off_ ,	//	erb 286 function call to undefined entry label
/*  5144 */	erb     | 286    << off_ ,
/*  5145 */	bl_rc   ,
// b_rcl:
/*  5146 */	stmt    | 1029   << off_ ,	//	mov -(xs) xr  stack result
/*  5147 */	dca     | xs     << dst_ ,
/*  5148 */	store   | xr     << dst_ | xs     << src_ ,
/*  5149 */	stmt    | 1030   << off_ ,	//	lcw xr   get next code word
/*  5150 */	lcw     | xr     << dst_ ,
/*  5151 */	stmt    | 1031   << off_ ,	//	bri (xr)   execute it
/*  5152 */	load    | r1     << dst_ | xr     << src_ ,
/*  5153 */	bri     | r1     << dst_ ,
/*  5154 */	bl_sc   ,
// b_scl:
/*  5155 */	stmt    | 1032   << off_ ,	//	mov -(xs) xr  stack result
/*  5156 */	dca     | xs     << dst_ ,
/*  5157 */	store   | xr     << dst_ | xs     << src_ ,
/*  5158 */	stmt    | 1033   << off_ ,	//	lcw xr   get next code word
/*  5159 */	lcw     | xr     << dst_ ,
/*  5160 */	stmt    | 1034   << off_ ,	//	bri (xr)   execute it
/*  5161 */	load    | r1     << dst_ | xr     << src_ ,
/*  5162 */	bri     | r1     << dst_ ,
/*  5163 */	bl_tb   ,
// b_tbt:
/*  5164 */	bl_te   ,
// b_tet:
/*  5165 */	bl_vc   ,
// b_vct:
/*  5166 */	bl__i   ,
// b_vr_:
/*  5167 */	bl__i   ,
// b_vra:
/*  5168 */	stmt    | 1035   << off_ ,	//	mov xl xr  copy name base (vrget = 0)
/*  5169 */	move    | xl     << dst_ | xr     << src_ ,
/*  5170 */	stmt    | 1036   << off_ ,	//	mov wa *vrval  set name offset
/*  5171 */	loadi   | wa     << dst_ | vrval  << off_ ,
/*  5172 */	stmt    | 1037   << off_ ,	//	jsr acess   access value
/*  5173 */	call    | acess  << off_ ,
/*  5174 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  5175 */	ppm     | exfal  << off_ ,
/*  5176 */	stmt    | 1038   << off_ ,	//	mov -(xs) xr  stack result
/*  5177 */	dca     | xs     << dst_ ,
/*  5178 */	store   | xr     << dst_ | xs     << src_ ,
/*  5179 */	stmt    | 1039   << off_ ,	//	lcw xr   get next code word
/*  5180 */	lcw     | xr     << dst_ ,
/*  5181 */	stmt    | 1040   << off_ ,	//	bri (xr)   execute it
/*  5182 */	load    | r1     << dst_ | xr     << src_ ,
/*  5183 */	bri     | r1     << dst_ ,
/*  5184 */	0       ,
// b_vre:
/*  5185 */	stmt    | 1041   << off_ ,	//	erb 042 attempt to change value of protected variable
/*  5186 */	erb     | 42     << off_ ,
/*  5187 */	0       ,
// b_vrg:
/*  5188 */	stmt    | 1042   << off_ ,	//	mov xr vrlbo(xr)  load code pointer
/*  5189 */	load    | xr     << dst_ | xr     << src_ | vrlbo  << off_ ,
/*  5190 */	stmt    | 1043   << off_ ,	//	mov xl (xr)  load entry address
/*  5191 */	load    | xl     << dst_ | xr     << src_ ,
/*  5192 */	stmt    | 1044   << off_ ,	//	bri xl   jump to routine for next code word
/*  5193 */	bri     | xl     << dst_ ,
/*  5194 */	0       ,
// b_vrl:
/*  5195 */	stmt    | 1045   << off_ ,	//	mov -(xs) vrval(xr)  load value onto stack (vrget = 0)
/*  5196 */	load    | r1     << dst_ | xr     << src_ | vrval  << off_ ,
/*  5197 */	dca     | xs     << dst_ ,
/*  5198 */	store   | r1     << dst_ | xs     << src_ ,
/*  5199 */	stmt    | 1046   << off_ ,	//	lcw xr   get next code word
/*  5200 */	lcw     | xr     << dst_ ,
/*  5201 */	stmt    | 1047   << off_ ,	//	bri (xr)   execute next code word
/*  5202 */	load    | r1     << dst_ | xr     << src_ ,
/*  5203 */	bri     | r1     << dst_ ,
/*  5204 */	0       ,
// b_vrs:
/*  5205 */	stmt    | 1048   << off_ ,	//	mov vrvlo(xr) (xs)  store value, leave on stack
/*  5206 */	load    | r1     << dst_ | xs     << src_ ,
/*  5207 */	store   | r1     << dst_ | xr     << src_ | vrvlo  << off_ ,
/*  5208 */	stmt    | 1049   << off_ ,	//	lcw xr   get next code word
/*  5209 */	lcw     | xr     << dst_ ,
/*  5210 */	stmt    | 1050   << off_ ,	//	bri (xr)   execute next code word
/*  5211 */	load    | r1     << dst_ | xr     << src_ ,
/*  5212 */	bri     | r1     << dst_ ,
/*  5213 */	0       ,
// b_vrt:
/*  5214 */	stmt    | 1051   << off_ ,	//	sub xr *vrtra  point back to start of vrblk
/*  5215 */	loadi   | r2     << dst_ | vrtra  << off_ ,
/*  5216 */	sub     | xr     << dst_ | r2     << src_ ,
/*  5217 */	stmt    | 1052   << off_ ,	//	mov xl xr  copy vrblk pointer
/*  5218 */	move    | xl     << dst_ | xr     << src_ ,
/*  5219 */	stmt    | 1053   << off_ ,	//	mov wa *vrval  set name offset
/*  5220 */	loadi   | wa     << dst_ | vrval  << off_ ,
/*  5221 */	stmt    | 1054   << off_ ,	//	mov xr vrlbl(xl)  load pointer to trblk
/*  5222 */	load    | xr     << dst_ | xl     << src_ | vrlbl  << off_ ,
/*  5223 */	stmt    | 1055   << off_ ,	//	bze kvtra bvrt2  jump if trace is off
/*  5224 */	load    | r1     << dst_ | kvtra  << off_ ,
/*  5225 */	bze     | r1     << dst_ | bvrt2  << off_ ,
/*  5226 */	stmt    | 1056   << off_ ,	//	dcv kvtra   else decrement trace count
/*  5227 */	load    | r1     << dst_ | kvtra  << off_ ,
/*  5228 */	dcv     | r1     << dst_ ,
/*  5229 */	store   | r1     << dst_ | kvtra  << off_ ,
/*  5230 */	stmt    | 1057   << off_ ,	//	bze trfnc(xr) bvrt1  jump if print trace case
/*  5231 */	load    | r1     << dst_ | xr     << src_ | trfnc  << off_ ,
/*  5232 */	bze     | r1     << dst_ | bvrt1  << off_ ,
/*  5233 */	stmt    | 1058   << off_ ,	//	jsr trxeq   else execute full trace
/*  5234 */	call    | trxeq  << off_ ,
/*  5235 */	stmt    | 1059   << off_ ,	//	brn bvrt2   merge to jump to label
/*  5236 */	brn     | bvrt2  << off_ ,
// bvrt1:
/*  5237 */	stmt    | 1060   << off_ ,	//bvrt1	jsr prtsn   print statement number
/*  5238 */	call    | prtsn  << off_ ,
/*  5239 */	stmt    | 1061   << off_ ,	//	mov xr xl  copy vrblk pointer
/*  5240 */	move    | xr     << dst_ | xl     << src_ ,
/*  5241 */	stmt    | 1062   << off_ ,	//	mov wa =ch_cl  colon
/*  5242 */	loadi   | wa     << dst_ | ch_cl  << off_ ,
/*  5243 */	stmt    | 1063   << off_ ,	//	jsr prtch   print it
/*  5244 */	call    | prtch  << off_ ,
/*  5245 */	stmt    | 1064   << off_ ,	//	mov wa =ch_pp  left paren
/*  5246 */	loadi   | wa     << dst_ | ch_pp  << off_ ,
/*  5247 */	stmt    | 1065   << off_ ,	//	jsr prtch   print it
/*  5248 */	call    | prtch  << off_ ,
/*  5249 */	stmt    | 1066   << off_ ,	//	jsr prtvn   print label name
/*  5250 */	call    | prtvn  << off_ ,
/*  5251 */	stmt    | 1067   << off_ ,	//	mov wa =ch_rp  right paren
/*  5252 */	loadi   | wa     << dst_ | ch_rp  << off_ ,
/*  5253 */	stmt    | 1068   << off_ ,	//	jsr prtch   print it
/*  5254 */	call    | prtch  << off_ ,
/*  5255 */	stmt    | 1069   << off_ ,	//	jsr prtnl   terminate line
/*  5256 */	call    | prtnl  << off_ ,
/*  5257 */	stmt    | 1070   << off_ ,	//	mov xr vrlbl(xl)  point back to trblk
/*  5258 */	load    | xr     << dst_ | xl     << src_ | vrlbl  << off_ ,
// bvrt2:
/*  5259 */	stmt    | 1071   << off_ ,	//bvrt2	mov xr trlbl(xr)  load pointer to actual code
/*  5260 */	load    | xr     << dst_ | xr     << src_ | trlbl  << off_ ,
/*  5261 */	stmt    | 1072   << off_ ,	//	bri (xr)   execute statement at label
/*  5262 */	load    | r1     << dst_ | xr     << src_ ,
/*  5263 */	bri     | r1     << dst_ ,
/*  5264 */	0       ,
// b_vrv:
/*  5265 */	stmt    | 1073   << off_ ,	//	mov wb (xs)  load value (leave copy on stack)
/*  5266 */	load    | wb     << dst_ | xs     << src_ ,
/*  5267 */	stmt    | 1074   << off_ ,	//	sub xr *vrsto  point to vrblk
/*  5268 */	loadi   | r2     << dst_ | vrsto  << off_ ,
/*  5269 */	sub     | xr     << dst_ | r2     << src_ ,
/*  5270 */	stmt    | 1075   << off_ ,	//	mov xl xr  copy vrblk pointer
/*  5271 */	move    | xl     << dst_ | xr     << src_ ,
/*  5272 */	stmt    | 1076   << off_ ,	//	mov wa *vrval  set offset
/*  5273 */	loadi   | wa     << dst_ | vrval  << off_ ,
/*  5274 */	stmt    | 1077   << off_ ,	//	jsr asign   call assignment routine
/*  5275 */	call    | asign  << off_ ,
/*  5276 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  5277 */	ppm     | exfal  << off_ ,
/*  5278 */	stmt    | 1078   << off_ ,	//	lcw xr   else get next code word
/*  5279 */	lcw     | xr     << dst_ ,
/*  5280 */	stmt    | 1079   << off_ ,	//	bri (xr)   execute next code word
/*  5281 */	load    | r1     << dst_ | xr     << src_ ,
/*  5282 */	bri     | r1     << dst_ ,
/*  5283 */	bl_xn   ,
// b_xnt:
/*  5284 */	bl_xr   ,
// b_xrt:
/*  5285 */	bl__i   ,
// b_yyy:
/*  5286 */	bl__i   ,
// p_aaa:
/*  5287 */	bl_p0   ,
// p_aba:
/*  5288 */	stmt    | 1080   << off_ ,	//	mov -(xs) wb  stack cursor
/*  5289 */	dca     | xs     << dst_ ,
/*  5290 */	store   | wb     << dst_ | xs     << src_ ,
/*  5291 */	stmt    | 1081   << off_ ,	//	mov -(xs) xr  stack dummy node ptr
/*  5292 */	dca     | xs     << dst_ ,
/*  5293 */	store   | xr     << dst_ | xs     << src_ ,
/*  5294 */	stmt    | 1082   << off_ ,	//	mov -(xs) pmhbs  stack old stack base ptr
/*  5295 */	load    | r1     << dst_ | pmhbs  << off_ ,
/*  5296 */	dca     | xs     << dst_ ,
/*  5297 */	store   | r1     << dst_ | xs     << src_ ,
/*  5298 */	stmt    | 1083   << off_ ,	//	mov -(xs) =ndabb  stack ptr to node ndabb
/*  5299 */	loadi   | r1     << dst_ | ndabb  << off_ ,
/*  5300 */	dca     | xs     << dst_ ,
/*  5301 */	store   | r1     << dst_ | xs     << src_ ,
/*  5302 */	stmt    | 1084   << off_ ,	//	mov pmhbs xs  store new stack base ptr
/*  5303 */	store   | xs     << dst_ | pmhbs  << off_ ,
/*  5304 */	stmt    | 1085   << off_ ,	//	brn succp   succeed
/*  5305 */	brn     | succp  << off_ ,
/*  5306 */	0       ,
// p_abb:
/*  5307 */	stmt    | 1086   << off_ ,	//	mov pmhbs wb  restore history stack base ptr
/*  5308 */	store   | wb     << dst_ | pmhbs  << off_ ,
/*  5309 */	stmt    | 1087   << off_ ,	//	brn flpop   fail and pop dummy node ptr
/*  5310 */	brn     | flpop  << off_ ,
/*  5311 */	bl_p0   ,
// p_abc:
/*  5312 */	stmt    | 1088   << off_ ,	//	mov xt pmhbs  keep p_abb stack base
/*  5313 */	load    | xt     << dst_ | pmhbs  << off_ ,
/*  5314 */	stmt    | 1089   << off_ ,	//	mov wa num03(xt)  load initial cursor
/*  5315 */	load    | wa     << dst_ | xt     << src_ | num03  << off_ ,
/*  5316 */	stmt    | 1090   << off_ ,	//	mov pmhbs num01(xt)  restore outer stack base ptr
/*  5317 */	load    | r1     << dst_ | xt     << src_ | num01  << off_ ,
/*  5318 */	store   | r1     << dst_ | pmhbs  << off_ ,
/*  5319 */	stmt    | 1091   << off_ ,	//	beq xt xs pabc1 jump if no history stack entries
/*  5320 */	beq     | xt     << dst_ | xs     << src_ | pabc1  << off_ ,
/*  5321 */	stmt    | 1092   << off_ ,	//	mov -(xs) xt  else save inner pmhbs entry
/*  5322 */	dca     | xs     << dst_ ,
/*  5323 */	store   | xt     << dst_ | xs     << src_ ,
/*  5324 */	stmt    | 1093   << off_ ,	//	mov -(xs) =ndabd  stack ptr to special node ndabd
/*  5325 */	loadi   | r1     << dst_ | ndabd  << off_ ,
/*  5326 */	dca     | xs     << dst_ ,
/*  5327 */	store   | r1     << dst_ | xs     << src_ ,
/*  5328 */	stmt    | 1094   << off_ ,	//	brn pabc2   merge
/*  5329 */	brn     | pabc2  << off_ ,
// pabc1:
/*  5330 */	stmt    | 1095   << off_ ,	//pabc1	add xs *num04  remove ndabb entry and cursor
/*  5331 */	loadi   | r2     << dst_ | num04  << off_ ,
/*  5332 */	add     | xs     << dst_ | r2     << src_ ,
// pabc2:
/*  5333 */	stmt    | 1096   << off_ ,	//pabc2	bne wa wb succp allow further attempt if non-null
/*  5334 */	bne     | wa     << dst_ | wb     << src_ | succp  << off_ ,
/*  5335 */	stmt    | 1097   << off_ ,	//	mov xr pthen(xr)  bypass alternative node so as to ...
/*  5336 */	load    | xr     << dst_ | xr     << src_ | pthen  << off_ ,
/*  5337 */	stmt    | 1098   << off_ ,	//	brn succp   ... refuse further match attempts
/*  5338 */	brn     | succp  << off_ ,
/*  5339 */	0       ,
// p_abd:
/*  5340 */	stmt    | 1099   << off_ ,	//	mov pmhbs wb  restore inner stack base ptr
/*  5341 */	store   | wb     << dst_ | pmhbs  << off_ ,
/*  5342 */	stmt    | 1100   << off_ ,	//	brn failp   and fail
/*  5343 */	brn     | failp  << off_ ,
/*  5344 */	bl_p0   ,
// p_abo:
/*  5345 */	stmt    | 1101   << off_ ,	//	brn exfal   signal statement failure
/*  5346 */	brn     | exfal  << off_ ,
/*  5347 */	bl_p1   ,
// p_alt:
/*  5348 */	stmt    | 1102   << off_ ,	//	mov -(xs) wb  stack cursor
/*  5349 */	dca     | xs     << dst_ ,
/*  5350 */	store   | wb     << dst_ | xs     << src_ ,
/*  5351 */	stmt    | 1103   << off_ ,	//	mov -(xs) parm1(xr)  stack pointer to alternative
/*  5352 */	load    | r1     << dst_ | xr     << src_ | parm1  << off_ ,
/*  5353 */	dca     | xs     << dst_ ,
/*  5354 */	store   | r1     << dst_ | xs     << src_ ,
/*  5355 */	stmt    | 1104   << off_ ,	//	chk    check for stack overflow
/*  5356 */	chk     ,
/*  5357 */	stmt    | 1105   << off_ ,	//	brn succp   if all ok, then succeed
/*  5358 */	brn     | succp  << off_ ,
/*  5359 */	bl_p1   ,
// p_ans:
/*  5360 */	stmt    | 1106   << off_ ,	//	beq wb pmssl failp fail if no chars left
/*  5361 */	load    | r2     << dst_ | pmssl  << off_ ,
/*  5362 */	beq     | wb     << dst_ | r2     << src_ | failp  << off_ ,
/*  5363 */	stmt    | 1107   << off_ ,	//	mov xl r_pms  else point to subject string
/*  5364 */	load    | xl     << dst_ | r_pms  << off_ ,
/*  5365 */	stmt    | 1108   << off_ ,	//	plc xl wb  point to current character
/*  5366 */	plc     | xl     << dst_ | wb     << src_ ,
/*  5367 */	stmt    | 1109   << off_ ,	//	lch wa (xl)  load current character
/*  5368 */	load    | wa     << dst_ | xl     << src_ ,
/*  5369 */	stmt    | 1110   << off_ ,	//	bne wa parm1(xr) failp fail if no match
/*  5370 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  5371 */	bne     | wa     << dst_ | r2     << src_ | failp  << off_ ,
/*  5372 */	stmt    | 1111   << off_ ,	//	icv wb   else bump cursor
/*  5373 */	icv     | wb     << dst_ ,
/*  5374 */	stmt    | 1112   << off_ ,	//	brn succp   and succeed
/*  5375 */	brn     | succp  << off_ ,
/*  5376 */	bl_p2   ,
// p_any:
// pany1:
/*  5377 */	stmt    | 1113   << off_ ,	//pany1	beq wb pmssl failp fail if no characters left
/*  5378 */	load    | r2     << dst_ | pmssl  << off_ ,
/*  5379 */	beq     | wb     << dst_ | r2     << src_ | failp  << off_ ,
/*  5380 */	stmt    | 1114   << off_ ,	//	mov xl r_pms  else point to subject string
/*  5381 */	load    | xl     << dst_ | r_pms  << off_ ,
/*  5382 */	stmt    | 1115   << off_ ,	//	plc xl wb  get char ptr to current character
/*  5383 */	plc     | xl     << dst_ | wb     << src_ ,
/*  5384 */	stmt    | 1116   << off_ ,	//	lch wa (xl)  load current character
/*  5385 */	load    | wa     << dst_ | xl     << src_ ,
/*  5386 */	stmt    | 1117   << off_ ,	//	mov xl parm1(xr)  point to ctblk
/*  5387 */	load    | xl     << dst_ | xr     << src_ | parm1  << off_ ,
/*  5388 */	stmt    | 1118   << off_ ,	//	wtb wa   change to byte offset
/*  5389 */	stmt    | 1119   << off_ ,	//	add xl wa  point to entry in ctblk
/*  5390 */	add     | xl     << dst_ | wa     << src_ ,
/*  5391 */	stmt    | 1120   << off_ ,	//	mov wa ctchs(xl)  load word from ctblk
/*  5392 */	load    | wa     << dst_ | xl     << src_ | ctchs  << off_ ,
/*  5393 */	stmt    | 1121   << off_ ,	//	anb wa parm2(xr)  and with selected bit
/*  5394 */	load    | r2     << dst_ | xr     << src_ | parm2  << off_ ,
/*  5395 */	anb     | wa     << dst_ | r2     << src_ ,
/*  5396 */	stmt    | 1122   << off_ ,	//	zrb wa failp  fail if no match
/*  5397 */	zrb     | wa     << dst_ | failp  << off_ ,
/*  5398 */	stmt    | 1123   << off_ ,	//	icv wb   else bump cursor
/*  5399 */	icv     | wb     << dst_ ,
/*  5400 */	stmt    | 1124   << off_ ,	//	brn succp   and succeed
/*  5401 */	brn     | succp  << off_ ,
/*  5402 */	bl_p1   ,
// p_ayd:
/*  5403 */	stmt    | 1125   << off_ ,	//	jsr evals   evaluate string argument
/*  5404 */	call    | evals  << off_ ,
/*  5405 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  5406 */	err     | 43     << off_ ,
/*  5407 */	ppm     | failp  << off_ ,
/*  5408 */	ppm     | pany1  << off_ ,
/*  5409 */	bl_p0   ,
// p_arb:
/*  5410 */	stmt    | 1126   << off_ ,	//	mov xr pthen(xr)  load successor pointer
/*  5411 */	load    | xr     << dst_ | xr     << src_ | pthen  << off_ ,
/*  5412 */	stmt    | 1127   << off_ ,	//	mov -(xs) wb  stack dummy cursor
/*  5413 */	dca     | xs     << dst_ ,
/*  5414 */	store   | wb     << dst_ | xs     << src_ ,
/*  5415 */	stmt    | 1128   << off_ ,	//	mov -(xs) xr  stack successor pointer
/*  5416 */	dca     | xs     << dst_ ,
/*  5417 */	store   | xr     << dst_ | xs     << src_ ,
/*  5418 */	stmt    | 1129   << off_ ,	//	mov -(xs) wb  stack cursor
/*  5419 */	dca     | xs     << dst_ ,
/*  5420 */	store   | wb     << dst_ | xs     << src_ ,
/*  5421 */	stmt    | 1130   << off_ ,	//	mov -(xs) =ndarc  stack ptr to special node ndarc
/*  5422 */	loadi   | r1     << dst_ | ndarc  << off_ ,
/*  5423 */	dca     | xs     << dst_ ,
/*  5424 */	store   | r1     << dst_ | xs     << src_ ,
/*  5425 */	stmt    | 1131   << off_ ,	//	bri (xr)   execute next node matching null
/*  5426 */	load    | r1     << dst_ | xr     << src_ ,
/*  5427 */	bri     | r1     << dst_ ,
/*  5428 */	0       ,
// p_arc:
/*  5429 */	stmt    | 1132   << off_ ,	//	beq wb pmssl flpop fail and pop stack to successor
/*  5430 */	load    | r2     << dst_ | pmssl  << off_ ,
/*  5431 */	beq     | wb     << dst_ | r2     << src_ | flpop  << off_ ,
/*  5432 */	stmt    | 1133   << off_ ,	//	icv wb   else bump cursor
/*  5433 */	icv     | wb     << dst_ ,
/*  5434 */	stmt    | 1134   << off_ ,	//	mov -(xs) wb  stack updated cursor
/*  5435 */	dca     | xs     << dst_ ,
/*  5436 */	store   | wb     << dst_ | xs     << src_ ,
/*  5437 */	stmt    | 1135   << off_ ,	//	mov -(xs) xr  restack pointer to ndarc node
/*  5438 */	dca     | xs     << dst_ ,
/*  5439 */	store   | xr     << dst_ | xs     << src_ ,
/*  5440 */	stmt    | 1136   << off_ ,	//	mov xr num02(xs)  load successor pointer
/*  5441 */	load    | xr     << dst_ | xs     << src_ | num02  << off_ ,
/*  5442 */	stmt    | 1137   << off_ ,	//	bri (xr)   off to reexecute successor node
/*  5443 */	load    | r1     << dst_ | xr     << src_ ,
/*  5444 */	bri     | r1     << dst_ ,
/*  5445 */	bl_p0   ,
// p_bal:
/*  5446 */	stmt    | 1138   << off_ ,	//	zer wc   zero parentheses level counter
/*  5447 */	move    | wc     << dst_ ,
/*  5448 */	stmt    | 1139   << off_ ,	//	mov xl r_pms  point to subject string
/*  5449 */	load    | xl     << dst_ | r_pms  << off_ ,
/*  5450 */	stmt    | 1140   << off_ ,	//	plc xl wb  point to current character
/*  5451 */	plc     | xl     << dst_ | wb     << src_ ,
/*  5452 */	stmt    | 1141   << off_ ,	//	brn pbal2   jump into scan loop
/*  5453 */	brn     | pbal2  << off_ ,
// pbal1:
/*  5454 */	stmt    | 1142   << off_ ,	//pbal1	lch wa (xl)+  load next character, bump pointer
/*  5455 */	load    | wa     << dst_ | xl     << src_ ,
/*  5456 */	ica     | xl     << dst_ ,
/*  5457 */	stmt    | 1143   << off_ ,	//	icv wb   push cursor for character
/*  5458 */	icv     | wb     << dst_ ,
/*  5459 */	stmt    | 1144   << off_ ,	//	beq wa =ch_pp pbal3 jump if left paren
/*  5460 */	loadi   | r2     << dst_ | ch_pp  << off_ ,
/*  5461 */	beq     | wa     << dst_ | r2     << src_ | pbal3  << off_ ,
/*  5462 */	stmt    | 1145   << off_ ,	//	beq wa =ch_rp pbal4 jump if right paren
/*  5463 */	loadi   | r2     << dst_ | ch_rp  << off_ ,
/*  5464 */	beq     | wa     << dst_ | r2     << src_ | pbal4  << off_ ,
/*  5465 */	stmt    | 1146   << off_ ,	//	bze wc pbal5  else succeed if at outer level
/*  5466 */	bze     | wc     << dst_ | pbal5  << off_ ,
// pbal2:
/*  5467 */	stmt    | 1147   << off_ ,	//pbal2	bne wb pmssl pbal1 loop back unless end of string
/*  5468 */	load    | r2     << dst_ | pmssl  << off_ ,
/*  5469 */	bne     | wb     << dst_ | r2     << src_ | pbal1  << off_ ,
/*  5470 */	stmt    | 1148   << off_ ,	//	brn failp   in which case, fail
/*  5471 */	brn     | failp  << off_ ,
// pbal3:
/*  5472 */	stmt    | 1149   << off_ ,	//pbal3	icv wc   bump paren level
/*  5473 */	icv     | wc     << dst_ ,
/*  5474 */	stmt    | 1150   << off_ ,	//	brn pbal2   loop back to check end of string
/*  5475 */	brn     | pbal2  << off_ ,
// pbal4:
/*  5476 */	stmt    | 1151   << off_ ,	//pbal4	bze wc failp  fail if no matching left paren
/*  5477 */	bze     | wc     << dst_ | failp  << off_ ,
/*  5478 */	stmt    | 1152   << off_ ,	//	dcv wc   else decrement level counter
/*  5479 */	dcv     | wc     << dst_ ,
/*  5480 */	stmt    | 1153   << off_ ,	//	bnz wc pbal2  loop back if not at outer level
/*  5481 */	bnz     | wc     << dst_ | pbal2  << off_ ,
// pbal5:
/*  5482 */	stmt    | 1154   << off_ ,	//pbal5	mov -(xs) wb  stack cursor
/*  5483 */	dca     | xs     << dst_ ,
/*  5484 */	store   | wb     << dst_ | xs     << src_ ,
/*  5485 */	stmt    | 1155   << off_ ,	//	mov -(xs) xr  stack ptr to bal node for extend
/*  5486 */	dca     | xs     << dst_ ,
/*  5487 */	store   | xr     << dst_ | xs     << src_ ,
/*  5488 */	stmt    | 1156   << off_ ,	//	brn succp   and succeed
/*  5489 */	brn     | succp  << off_ ,
/*  5490 */	bl_p1   ,
// p_bkd:
/*  5491 */	stmt    | 1157   << off_ ,	//	jsr evals   evaluate string expression
/*  5492 */	call    | evals  << off_ ,
/*  5493 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  5494 */	err     | 44     << off_ ,
/*  5495 */	ppm     | failp  << off_ ,
/*  5496 */	ppm     | pbrk1  << off_ ,
/*  5497 */	bl_p1   ,
// p_bks:
/*  5498 */	stmt    | 1158   << off_ ,	//	mov wc pmssl  get subject string length
/*  5499 */	load    | wc     << dst_ | pmssl  << off_ ,
/*  5500 */	stmt    | 1159   << off_ ,	//	sub wc wb  get number of characters left
/*  5501 */	sub     | wc     << dst_ | wb     << src_ ,
/*  5502 */	stmt    | 1160   << off_ ,	//	bze wc failp  fail if no characters left
/*  5503 */	bze     | wc     << dst_ | failp  << off_ ,
/*  5504 */	stmt    | 1161   << off_ ,	//	lct wc wc  set counter for chars left
/*  5505 */	stmt    | 1162   << off_ ,	//	mov xl r_pms  point to subject string
/*  5506 */	load    | xl     << dst_ | r_pms  << off_ ,
/*  5507 */	stmt    | 1163   << off_ ,	//	plc xl wb  point to current character
/*  5508 */	plc     | xl     << dst_ | wb     << src_ ,
// pbks1:
/*  5509 */	stmt    | 1164   << off_ ,	//pbks1	lch wa (xl)+  load next char, bump pointer
/*  5510 */	load    | wa     << dst_ | xl     << src_ ,
/*  5511 */	ica     | xl     << dst_ ,
/*  5512 */	stmt    | 1165   << off_ ,	//	beq wa parm1(xr) succp succeed if break character found
/*  5513 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  5514 */	beq     | wa     << dst_ | r2     << src_ | succp  << off_ ,
/*  5515 */	stmt    | 1166   << off_ ,	//	icv wb   else push cursor
/*  5516 */	icv     | wb     << dst_ ,
/*  5517 */	stmt    | 1167   << off_ ,	//	bct wc pbks1  loop back if more to go
/*  5518 */	bct     | wc     << dst_ | pbks1  << off_ ,
/*  5519 */	stmt    | 1168   << off_ ,	//	brn failp   fail if end of string, no break chr
/*  5520 */	brn     | failp  << off_ ,
/*  5521 */	bl_p2   ,
// p_brk:
// pbrk1:
/*  5522 */	stmt    | 1169   << off_ ,	//pbrk1	mov wc pmssl  load subject string length
/*  5523 */	load    | wc     << dst_ | pmssl  << off_ ,
/*  5524 */	stmt    | 1170   << off_ ,	//	sub wc wb  get number of characters left
/*  5525 */	sub     | wc     << dst_ | wb     << src_ ,
/*  5526 */	stmt    | 1171   << off_ ,	//	bze wc failp  fail if no characters left
/*  5527 */	bze     | wc     << dst_ | failp  << off_ ,
/*  5528 */	stmt    | 1172   << off_ ,	//	lct wc wc  set counter for characters left
/*  5529 */	stmt    | 1173   << off_ ,	//	mov xl r_pms  else point to subject string
/*  5530 */	load    | xl     << dst_ | r_pms  << off_ ,
/*  5531 */	stmt    | 1174   << off_ ,	//	plc xl wb  point to current character
/*  5532 */	plc     | xl     << dst_ | wb     << src_ ,
/*  5533 */	stmt    | 1175   << off_ ,	//	mov psave xr  save node pointer
/*  5534 */	store   | xr     << dst_ | psave  << off_ ,
// pbrk2:
/*  5535 */	stmt    | 1176   << off_ ,	//pbrk2	lch wa (xl)+  load next char, bump pointer
/*  5536 */	load    | wa     << dst_ | xl     << src_ ,
/*  5537 */	ica     | xl     << dst_ ,
/*  5538 */	stmt    | 1177   << off_ ,	//	mov xr parm1(xr)  load pointer to ctblk
/*  5539 */	load    | xr     << dst_ | xr     << src_ | parm1  << off_ ,
/*  5540 */	stmt    | 1178   << off_ ,	//	wtb wa   convert to byte offset
/*  5541 */	stmt    | 1179   << off_ ,	//	add xr wa  point to ctblk entry
/*  5542 */	add     | xr     << dst_ | wa     << src_ ,
/*  5543 */	stmt    | 1180   << off_ ,	//	mov wa ctchs(xr)  load ctblk word
/*  5544 */	load    | wa     << dst_ | xr     << src_ | ctchs  << off_ ,
/*  5545 */	stmt    | 1181   << off_ ,	//	mov xr psave  restore node pointer
/*  5546 */	load    | xr     << dst_ | psave  << off_ ,
/*  5547 */	stmt    | 1182   << off_ ,	//	anb wa parm2(xr)  and with selected bit
/*  5548 */	load    | r2     << dst_ | xr     << src_ | parm2  << off_ ,
/*  5549 */	anb     | wa     << dst_ | r2     << src_ ,
/*  5550 */	stmt    | 1183   << off_ ,	//	nzb wa succp  succeed if break character found
/*  5551 */	nzb     | wa     << dst_ | succp  << off_ ,
/*  5552 */	stmt    | 1184   << off_ ,	//	icv wb   else push cursor
/*  5553 */	icv     | wb     << dst_ ,
/*  5554 */	stmt    | 1185   << off_ ,	//	bct wc pbrk2  loop back unless end of string
/*  5555 */	bct     | wc     << dst_ | pbrk2  << off_ ,
/*  5556 */	stmt    | 1186   << off_ ,	//	brn failp   fail if end of string, no break chr
/*  5557 */	brn     | failp  << off_ ,
/*  5558 */	bl_p0   ,
// p_bkx:
/*  5559 */	stmt    | 1187   << off_ ,	//	icv wb   step cursor past previous break chr
/*  5560 */	icv     | wb     << dst_ ,
/*  5561 */	stmt    | 1188   << off_ ,	//	brn succp   succeed to rematch break
/*  5562 */	brn     | succp  << off_ ,
/*  5563 */	bl_p1   ,
// p_bxd:
/*  5564 */	stmt    | 1189   << off_ ,	//	jsr evals   evaluate string argument
/*  5565 */	call    | evals  << off_ ,
/*  5566 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  5567 */	err     | 45     << off_ ,
/*  5568 */	ppm     | failp  << off_ ,
/*  5569 */	ppm     | pbrk1  << off_ ,
/*  5570 */	bl_p2   ,
// p_cas:
/*  5571 */	stmt    | 1190   << off_ ,	//	mov -(xs) xr  save node pointer
/*  5572 */	dca     | xs     << dst_ ,
/*  5573 */	store   | xr     << dst_ | xs     << src_ ,
/*  5574 */	stmt    | 1191   << off_ ,	//	mov -(xs) wb  save cursor
/*  5575 */	dca     | xs     << dst_ ,
/*  5576 */	store   | wb     << dst_ | xs     << src_ ,
/*  5577 */	stmt    | 1192   << off_ ,	//	mov xl parm1(xr)  load name base
/*  5578 */	load    | xl     << dst_ | xr     << src_ | parm1  << off_ ,
/*  5579 */	stmt    | 1193   << off_ ,	//	mti wb   load cursor as integer
/*  5580 */	move    | ia     << dst_ | wb     << src_ ,
/*  5581 */	stmt    | 1194   << off_ ,	//	mov wb parm2(xr)  load name offset
/*  5582 */	load    | wb     << dst_ | xr     << src_ | parm2  << off_ ,
/*  5583 */	stmt    | 1195   << off_ ,	//	jsr icbld   get icblk for cursor value
/*  5584 */	call    | icbld  << off_ ,
/*  5585 */	stmt    | 1196   << off_ ,	//	mov wa wb  move name offset
/*  5586 */	move    | wa     << dst_ | wb     << src_ ,
/*  5587 */	stmt    | 1197   << off_ ,	//	mov wb xr  move value to assign
/*  5588 */	move    | wb     << dst_ | xr     << src_ ,
/*  5589 */	stmt    | 1198   << off_ ,	//	jsr asinp   perform assignment
/*  5590 */	call    | asinp  << off_ ,
/*  5591 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  5592 */	ppm     | flpop  << off_ ,
/*  5593 */	stmt    | 1199   << off_ ,	//	mov wb (xs)+  else restore cursor
/*  5594 */	load    | wb     << dst_ | xs     << src_ ,
/*  5595 */	ica     | xs     << dst_ ,
/*  5596 */	stmt    | 1200   << off_ ,	//	mov xr (xs)+  restore node pointer
/*  5597 */	load    | xr     << dst_ | xs     << src_ ,
/*  5598 */	ica     | xs     << dst_ ,
/*  5599 */	stmt    | 1201   << off_ ,	//	brn succp   and succeed matching null
/*  5600 */	brn     | succp  << off_ ,
/*  5601 */	bl_p1   ,
// p_exa:
/*  5602 */	stmt    | 1202   << off_ ,	//	jsr evalp   evaluate expression
/*  5603 */	call    | evalp  << off_ ,
/*  5604 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  5605 */	ppm     | failp  << off_ ,
/*  5606 */	stmt    | 1203   << off_ ,	//	blo wa =p_aaa pexa1 jump if result is not a pattern
/*  5607 */	loadi   | r2     << dst_ | p_aaa  << off_ ,
/*  5608 */	blo     | wa     << dst_ | r2     << src_ | pexa1  << off_ ,
/*  5609 */	stmt    | 1204   << off_ ,	//	mov -(xs) wb  stack dummy cursor
/*  5610 */	dca     | xs     << dst_ ,
/*  5611 */	store   | wb     << dst_ | xs     << src_ ,
/*  5612 */	stmt    | 1205   << off_ ,	//	mov -(xs) xr  stack ptr to p_exa node
/*  5613 */	dca     | xs     << dst_ ,
/*  5614 */	store   | xr     << dst_ | xs     << src_ ,
/*  5615 */	stmt    | 1206   << off_ ,	//	mov -(xs) pmhbs  stack history stack base ptr
/*  5616 */	load    | r1     << dst_ | pmhbs  << off_ ,
/*  5617 */	dca     | xs     << dst_ ,
/*  5618 */	store   | r1     << dst_ | xs     << src_ ,
/*  5619 */	stmt    | 1207   << off_ ,	//	mov -(xs) =ndexb  stack ptr to special node ndexb
/*  5620 */	loadi   | r1     << dst_ | ndexb  << off_ ,
/*  5621 */	dca     | xs     << dst_ ,
/*  5622 */	store   | r1     << dst_ | xs     << src_ ,
/*  5623 */	stmt    | 1208   << off_ ,	//	mov pmhbs xs  store new stack base pointer
/*  5624 */	store   | xs     << dst_ | pmhbs  << off_ ,
/*  5625 */	stmt    | 1209   << off_ ,	//	mov xr xl  copy node pointer
/*  5626 */	move    | xr     << dst_ | xl     << src_ ,
/*  5627 */	stmt    | 1210   << off_ ,	//	bri (xr)   match first node in expression pat
/*  5628 */	load    | r1     << dst_ | xr     << src_ ,
/*  5629 */	bri     | r1     << dst_ ,
// pexa1:
/*  5630 */	stmt    | 1211   << off_ ,	//pexa1	beq wa =b_scl pexa2 jump if it is already a string
/*  5631 */	loadi   | r2     << dst_ | b_scl  << off_ ,
/*  5632 */	beq     | wa     << dst_ | r2     << src_ | pexa2  << off_ ,
/*  5633 */	stmt    | 1212   << off_ ,	//	mov -(xs) xl  else stack result
/*  5634 */	dca     | xs     << dst_ ,
/*  5635 */	store   | xl     << dst_ | xs     << src_ ,
/*  5636 */	stmt    | 1213   << off_ ,	//	mov xl xr  save node pointer
/*  5637 */	move    | xl     << dst_ | xr     << src_ ,
/*  5638 */	stmt    | 1214   << off_ ,	//	jsr gtstg   convert result to string
/*  5639 */	call    | gtstg  << off_ ,
/*  5640 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  5641 */	err     | 46     << off_ ,
/*  5642 */	stmt    | 1215   << off_ ,	//	mov wc xr  copy string pointer
/*  5643 */	move    | wc     << dst_ | xr     << src_ ,
/*  5644 */	stmt    | 1216   << off_ ,	//	mov xr xl  restore node pointer
/*  5645 */	move    | xr     << dst_ | xl     << src_ ,
/*  5646 */	stmt    | 1217   << off_ ,	//	mov xl wc  copy string pointer again
/*  5647 */	move    | xl     << dst_ | wc     << src_ ,
// pexa2:
/*  5648 */	stmt    | 1218   << off_ ,	//pexa2	bze sclen(xl) succp  just succeed if null string
/*  5649 */	load    | r1     << dst_ | xl     << src_ | sclen  << off_ ,
/*  5650 */	bze     | r1     << dst_ | succp  << off_ ,
/*  5651 */	stmt    | 1219   << off_ ,	//	brn pstr1   else merge with string circuit
/*  5652 */	brn     | pstr1  << off_ ,
/*  5653 */	0       ,
// p_exb:
/*  5654 */	stmt    | 1220   << off_ ,	//	mov pmhbs wb  restore outer level stack pointer
/*  5655 */	store   | wb     << dst_ | pmhbs  << off_ ,
/*  5656 */	stmt    | 1221   << off_ ,	//	brn flpop   fail and pop p_exa node ptr
/*  5657 */	brn     | flpop  << off_ ,
/*  5658 */	0       ,
// p_exc:
/*  5659 */	stmt    | 1222   << off_ ,	//	mov pmhbs wb  restore inner stack base pointer
/*  5660 */	store   | wb     << dst_ | pmhbs  << off_ ,
/*  5661 */	stmt    | 1223   << off_ ,	//	brn failp   and fail into expr pattern alternvs
/*  5662 */	brn     | failp  << off_ ,
/*  5663 */	bl_p0   ,
// p_fal:
/*  5664 */	stmt    | 1224   << off_ ,	//	brn failp   just signal failure
/*  5665 */	brn     | failp  << off_ ,
/*  5666 */	bl_p0   ,
// p_fen:
/*  5667 */	stmt    | 1225   << off_ ,	//	mov -(xs) wb  stack dummy cursor
/*  5668 */	dca     | xs     << dst_ ,
/*  5669 */	store   | wb     << dst_ | xs     << src_ ,
/*  5670 */	stmt    | 1226   << off_ ,	//	mov -(xs) =ndabo  stack ptr to abort node
/*  5671 */	loadi   | r1     << dst_ | ndabo  << off_ ,
/*  5672 */	dca     | xs     << dst_ ,
/*  5673 */	store   | r1     << dst_ | xs     << src_ ,
/*  5674 */	stmt    | 1227   << off_ ,	//	brn succp   and succeed matching null
/*  5675 */	brn     | succp  << off_ ,
/*  5676 */	bl_p0   ,
// p_fna:
/*  5677 */	stmt    | 1228   << off_ ,	//	mov -(xs) pmhbs  stack current history stack base
/*  5678 */	load    | r1     << dst_ | pmhbs  << off_ ,
/*  5679 */	dca     | xs     << dst_ ,
/*  5680 */	store   | r1     << dst_ | xs     << src_ ,
/*  5681 */	stmt    | 1229   << off_ ,	//	mov -(xs) =ndfnb  stack indir ptr to p_fnb (failure)
/*  5682 */	loadi   | r1     << dst_ | ndfnb  << off_ ,
/*  5683 */	dca     | xs     << dst_ ,
/*  5684 */	store   | r1     << dst_ | xs     << src_ ,
/*  5685 */	stmt    | 1230   << off_ ,	//	mov pmhbs xs  begin new history stack
/*  5686 */	store   | xs     << dst_ | pmhbs  << off_ ,
/*  5687 */	stmt    | 1231   << off_ ,	//	brn succp   succeed
/*  5688 */	brn     | succp  << off_ ,
/*  5689 */	bl_p0   ,
// p_fnb:
/*  5690 */	stmt    | 1232   << off_ ,	//	mov pmhbs wb  restore outer pmhbs stack base
/*  5691 */	store   | wb     << dst_ | pmhbs  << off_ ,
/*  5692 */	stmt    | 1233   << off_ ,	//	brn failp   ...and fail
/*  5693 */	brn     | failp  << off_ ,
/*  5694 */	bl_p0   ,
// p_fnc:
/*  5695 */	stmt    | 1234   << off_ ,	//	mov xt pmhbs  get inner stack base ptr
/*  5696 */	load    | xt     << dst_ | pmhbs  << off_ ,
/*  5697 */	stmt    | 1235   << off_ ,	//	mov pmhbs num01(xt)  restore outer stack base
/*  5698 */	load    | r1     << dst_ | xt     << src_ | num01  << off_ ,
/*  5699 */	store   | r1     << dst_ | pmhbs  << off_ ,
/*  5700 */	stmt    | 1236   << off_ ,	//	beq xt xs pfnc1 optimize if no alternatives
/*  5701 */	beq     | xt     << dst_ | xs     << src_ | pfnc1  << off_ ,
/*  5702 */	stmt    | 1237   << off_ ,	//	mov -(xs) xt  else stack inner stack base
/*  5703 */	dca     | xs     << dst_ ,
/*  5704 */	store   | xt     << dst_ | xs     << src_ ,
/*  5705 */	stmt    | 1238   << off_ ,	//	mov -(xs) =ndfnd  stack ptr to ndfnd
/*  5706 */	loadi   | r1     << dst_ | ndfnd  << off_ ,
/*  5707 */	dca     | xs     << dst_ ,
/*  5708 */	store   | r1     << dst_ | xs     << src_ ,
/*  5709 */	stmt    | 1239   << off_ ,	//	brn succp   succeed
/*  5710 */	brn     | succp  << off_ ,
// pfnc1:
/*  5711 */	stmt    | 1240   << off_ ,	//pfnc1	add xs *num02  pop off p_fnb entry
/*  5712 */	loadi   | r2     << dst_ | num02  << off_ ,
/*  5713 */	add     | xs     << dst_ | r2     << src_ ,
/*  5714 */	stmt    | 1241   << off_ ,	//	brn succp   succeed
/*  5715 */	brn     | succp  << off_ ,
/*  5716 */	bl_p0   ,
// p_fnd:
/*  5717 */	stmt    | 1242   << off_ ,	//	mov xs wb  pop stack to fence() history base
/*  5718 */	move    | xs     << dst_ | wb     << src_ ,
/*  5719 */	stmt    | 1243   << off_ ,	//	brn flpop   pop base entry and fail
/*  5720 */	brn     | flpop  << off_ ,
/*  5721 */	bl_p0   ,
// p_ima:
/*  5722 */	stmt    | 1244   << off_ ,	//	mov -(xs) wb  stack cursor
/*  5723 */	dca     | xs     << dst_ ,
/*  5724 */	store   | wb     << dst_ | xs     << src_ ,
/*  5725 */	stmt    | 1245   << off_ ,	//	mov -(xs) xr  stack dummy node pointer
/*  5726 */	dca     | xs     << dst_ ,
/*  5727 */	store   | xr     << dst_ | xs     << src_ ,
/*  5728 */	stmt    | 1246   << off_ ,	//	mov -(xs) pmhbs  stack old stack base pointer
/*  5729 */	load    | r1     << dst_ | pmhbs  << off_ ,
/*  5730 */	dca     | xs     << dst_ ,
/*  5731 */	store   | r1     << dst_ | xs     << src_ ,
/*  5732 */	stmt    | 1247   << off_ ,	//	mov -(xs) =ndimb  stack ptr to special node ndimb
/*  5733 */	loadi   | r1     << dst_ | ndimb  << off_ ,
/*  5734 */	dca     | xs     << dst_ ,
/*  5735 */	store   | r1     << dst_ | xs     << src_ ,
/*  5736 */	stmt    | 1248   << off_ ,	//	mov pmhbs xs  store new stack base pointer
/*  5737 */	store   | xs     << dst_ | pmhbs  << off_ ,
/*  5738 */	stmt    | 1249   << off_ ,	//	brn succp   and succeed
/*  5739 */	brn     | succp  << off_ ,
/*  5740 */	0       ,
// p_imb:
/*  5741 */	stmt    | 1250   << off_ ,	//	mov pmhbs wb  restore history stack base ptr
/*  5742 */	store   | wb     << dst_ | pmhbs  << off_ ,
/*  5743 */	stmt    | 1251   << off_ ,	//	brn flpop   fail and pop dummy node ptr
/*  5744 */	brn     | flpop  << off_ ,
/*  5745 */	bl_p2   ,
// p_imc:
/*  5746 */	stmt    | 1252   << off_ ,	//	mov xt pmhbs  load pointer to p_imb entry
/*  5747 */	load    | xt     << dst_ | pmhbs  << off_ ,
/*  5748 */	stmt    | 1253   << off_ ,	//	mov wa wb  copy final cursor
/*  5749 */	move    | wa     << dst_ | wb     << src_ ,
/*  5750 */	stmt    | 1254   << off_ ,	//	mov wb num03(xt)  load initial cursor
/*  5751 */	load    | wb     << dst_ | xt     << src_ | num03  << off_ ,
/*  5752 */	stmt    | 1255   << off_ ,	//	mov pmhbs num01(xt)  restore outer stack base pointer
/*  5753 */	load    | r1     << dst_ | xt     << src_ | num01  << off_ ,
/*  5754 */	store   | r1     << dst_ | pmhbs  << off_ ,
/*  5755 */	stmt    | 1256   << off_ ,	//	beq xt xs pimc1 jump if no history stack entries
/*  5756 */	beq     | xt     << dst_ | xs     << src_ | pimc1  << off_ ,
/*  5757 */	stmt    | 1257   << off_ ,	//	mov -(xs) xt  else save inner pmhbs pointer
/*  5758 */	dca     | xs     << dst_ ,
/*  5759 */	store   | xt     << dst_ | xs     << src_ ,
/*  5760 */	stmt    | 1258   << off_ ,	//	mov -(xs) =ndimd  and a ptr to special node ndimd
/*  5761 */	loadi   | r1     << dst_ | ndimd  << off_ ,
/*  5762 */	dca     | xs     << dst_ ,
/*  5763 */	store   | r1     << dst_ | xs     << src_ ,
/*  5764 */	stmt    | 1259   << off_ ,	//	brn pimc2   merge
/*  5765 */	brn     | pimc2  << off_ ,
// pimc1:
/*  5766 */	stmt    | 1260   << off_ ,	//pimc1	add xs *num04  remove ndimb entry and cursor
/*  5767 */	loadi   | r2     << dst_ | num04  << off_ ,
/*  5768 */	add     | xs     << dst_ | r2     << src_ ,
// pimc2:
/*  5769 */	stmt    | 1261   << off_ ,	//pimc2	mov -(xs) wa  save current (final) cursor
/*  5770 */	dca     | xs     << dst_ ,
/*  5771 */	store   | wa     << dst_ | xs     << src_ ,
/*  5772 */	stmt    | 1262   << off_ ,	//	mov -(xs) xr  save current node pointer
/*  5773 */	dca     | xs     << dst_ ,
/*  5774 */	store   | xr     << dst_ | xs     << src_ ,
/*  5775 */	stmt    | 1263   << off_ ,	//	mov xl r_pms  point to subject string
/*  5776 */	load    | xl     << dst_ | r_pms  << off_ ,
/*  5777 */	stmt    | 1264   << off_ ,	//	sub wa wb  compute substring length
/*  5778 */	sub     | wa     << dst_ | wb     << src_ ,
/*  5779 */	stmt    | 1265   << off_ ,	//	jsr sbstr   build substring
/*  5780 */	call    | sbstr  << off_ ,
/*  5781 */	stmt    | 1266   << off_ ,	//	mov wb xr  move result
/*  5782 */	move    | wb     << dst_ | xr     << src_ ,
/*  5783 */	stmt    | 1267   << off_ ,	//	mov xr (xs)  reload node pointer
/*  5784 */	load    | xr     << dst_ | xs     << src_ ,
/*  5785 */	stmt    | 1268   << off_ ,	//	mov xl parm1(xr)  load name base
/*  5786 */	load    | xl     << dst_ | xr     << src_ | parm1  << off_ ,
/*  5787 */	stmt    | 1269   << off_ ,	//	mov wa parm2(xr)  load name offset
/*  5788 */	load    | wa     << dst_ | xr     << src_ | parm2  << off_ ,
/*  5789 */	stmt    | 1270   << off_ ,	//	jsr asinp   perform assignment
/*  5790 */	call    | asinp  << off_ ,
/*  5791 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  5792 */	ppm     | flpop  << off_ ,
/*  5793 */	stmt    | 1271   << off_ ,	//	mov xr (xs)+  else restore node pointer
/*  5794 */	load    | xr     << dst_ | xs     << src_ ,
/*  5795 */	ica     | xs     << dst_ ,
/*  5796 */	stmt    | 1272   << off_ ,	//	mov wb (xs)+  restore cursor
/*  5797 */	load    | wb     << dst_ | xs     << src_ ,
/*  5798 */	ica     | xs     << dst_ ,
/*  5799 */	stmt    | 1273   << off_ ,	//	brn succp   and succeed
/*  5800 */	brn     | succp  << off_ ,
/*  5801 */	0       ,
// p_imd:
/*  5802 */	stmt    | 1274   << off_ ,	//	mov pmhbs wb  restore inner stack base pointer
/*  5803 */	store   | wb     << dst_ | pmhbs  << off_ ,
/*  5804 */	stmt    | 1275   << off_ ,	//	brn failp   and fail
/*  5805 */	brn     | failp  << off_ ,
/*  5806 */	bl_p1   ,
// p_len:
// plen1:
/*  5807 */	stmt    | 1276   << off_ ,	//plen1	add wb parm1(xr)  push cursor indicated amount
/*  5808 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  5809 */	add     | wb     << dst_ | r2     << src_ ,
/*  5810 */	stmt    | 1277   << off_ ,	//	ble wb pmssl succp succeed if not off end
/*  5811 */	load    | r2     << dst_ | pmssl  << off_ ,
/*  5812 */	ble     | wb     << dst_ | r2     << src_ | succp  << off_ ,
/*  5813 */	stmt    | 1278   << off_ ,	//	brn failp   else fail
/*  5814 */	brn     | failp  << off_ ,
/*  5815 */	bl_p1   ,
// p_lnd:
/*  5816 */	stmt    | 1279   << off_ ,	//	jsr evali   evaluate integer argument
/*  5817 */	call    | evali  << off_ ,
/*  5818 */	jsrerr  | r1     << dst_ | 4      << off_ ,
/*  5819 */	err     | 47     << off_ ,
/*  5820 */	err     | 48     << off_ ,
/*  5821 */	ppm     | failp  << off_ ,
/*  5822 */	ppm     | plen1  << off_ ,
/*  5823 */	bl_p1   ,
// p_nad:
/*  5824 */	stmt    | 1280   << off_ ,	//	jsr evals   evaluate string argument
/*  5825 */	call    | evals  << off_ ,
/*  5826 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  5827 */	err     | 49     << off_ ,
/*  5828 */	ppm     | failp  << off_ ,
/*  5829 */	ppm     | pnay1  << off_ ,
/*  5830 */	bl_p1   ,
// p_nas:
/*  5831 */	stmt    | 1281   << off_ ,	//	beq wb pmssl failp fail if no chars left
/*  5832 */	load    | r2     << dst_ | pmssl  << off_ ,
/*  5833 */	beq     | wb     << dst_ | r2     << src_ | failp  << off_ ,
/*  5834 */	stmt    | 1282   << off_ ,	//	mov xl r_pms  else point to subject string
/*  5835 */	load    | xl     << dst_ | r_pms  << off_ ,
/*  5836 */	stmt    | 1283   << off_ ,	//	plc xl wb  point to current character in strin
/*  5837 */	plc     | xl     << dst_ | wb     << src_ ,
/*  5838 */	stmt    | 1284   << off_ ,	//	lch wa (xl)  load current character
/*  5839 */	load    | wa     << dst_ | xl     << src_ ,
/*  5840 */	stmt    | 1285   << off_ ,	//	beq wa parm1(xr) failp fail if match
/*  5841 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  5842 */	beq     | wa     << dst_ | r2     << src_ | failp  << off_ ,
/*  5843 */	stmt    | 1286   << off_ ,	//	icv wb   else bump cursor
/*  5844 */	icv     | wb     << dst_ ,
/*  5845 */	stmt    | 1287   << off_ ,	//	brn succp   and succeed
/*  5846 */	brn     | succp  << off_ ,
/*  5847 */	bl_p2   ,
// p_nay:
// pnay1:
/*  5848 */	stmt    | 1288   << off_ ,	//pnay1	beq wb pmssl failp fail if no characters left
/*  5849 */	load    | r2     << dst_ | pmssl  << off_ ,
/*  5850 */	beq     | wb     << dst_ | r2     << src_ | failp  << off_ ,
/*  5851 */	stmt    | 1289   << off_ ,	//	mov xl r_pms  else point to subject string
/*  5852 */	load    | xl     << dst_ | r_pms  << off_ ,
/*  5853 */	stmt    | 1290   << off_ ,	//	plc xl wb  point to current character
/*  5854 */	plc     | xl     << dst_ | wb     << src_ ,
/*  5855 */	stmt    | 1291   << off_ ,	//	lch wa (xl)  load current character
/*  5856 */	load    | wa     << dst_ | xl     << src_ ,
/*  5857 */	stmt    | 1292   << off_ ,	//	wtb wa   convert to byte offset
/*  5858 */	stmt    | 1293   << off_ ,	//	mov xl parm1(xr)  load pointer to ctblk
/*  5859 */	load    | xl     << dst_ | xr     << src_ | parm1  << off_ ,
/*  5860 */	stmt    | 1294   << off_ ,	//	add xl wa  point to entry in ctblk
/*  5861 */	add     | xl     << dst_ | wa     << src_ ,
/*  5862 */	stmt    | 1295   << off_ ,	//	mov wa ctchs(xl)  load entry from ctblk
/*  5863 */	load    | wa     << dst_ | xl     << src_ | ctchs  << off_ ,
/*  5864 */	stmt    | 1296   << off_ ,	//	anb wa parm2(xr)  and with selected bit
/*  5865 */	load    | r2     << dst_ | xr     << src_ | parm2  << off_ ,
/*  5866 */	anb     | wa     << dst_ | r2     << src_ ,
/*  5867 */	stmt    | 1297   << off_ ,	//	nzb wa failp  fail if character is matched
/*  5868 */	nzb     | wa     << dst_ | failp  << off_ ,
/*  5869 */	stmt    | 1298   << off_ ,	//	icv wb   else bump cursor
/*  5870 */	icv     | wb     << dst_ ,
/*  5871 */	stmt    | 1299   << off_ ,	//	brn succp   and succeed
/*  5872 */	brn     | succp  << off_ ,
/*  5873 */	bl_p0   ,
// p_nth:
/*  5874 */	stmt    | 1300   << off_ ,	//	mov xt pmhbs  load pointer to base of stack
/*  5875 */	load    | xt     << dst_ | pmhbs  << off_ ,
/*  5876 */	stmt    | 1301   << off_ ,	//	mov wa num01(xt)  load saved pmhbs (or pattern type)
/*  5877 */	load    | wa     << dst_ | xt     << src_ | num01  << off_ ,
/*  5878 */	stmt    | 1302   << off_ ,	//	ble wa =num02 pnth2 jump if outer level (pattern type)
/*  5879 */	loadi   | r2     << dst_ | num02  << off_ ,
/*  5880 */	ble     | wa     << dst_ | r2     << src_ | pnth2  << off_ ,
/*  5881 */	stmt    | 1303   << off_ ,	//	mov pmhbs wa  restore outer stack base pointer
/*  5882 */	store   | wa     << dst_ | pmhbs  << off_ ,
/*  5883 */	stmt    | 1304   << off_ ,	//	mov xr num02(xt)  restore pointer to p_exa node
/*  5884 */	load    | xr     << dst_ | xt     << src_ | num02  << off_ ,
/*  5885 */	stmt    | 1305   << off_ ,	//	beq xt xs pnth1 jump if no history stack entries
/*  5886 */	beq     | xt     << dst_ | xs     << src_ | pnth1  << off_ ,
/*  5887 */	stmt    | 1306   << off_ ,	//	mov -(xs) xt  else stack inner stack base ptr
/*  5888 */	dca     | xs     << dst_ ,
/*  5889 */	store   | xt     << dst_ | xs     << src_ ,
/*  5890 */	stmt    | 1307   << off_ ,	//	mov -(xs) =ndexc  stack ptr to special node ndexc
/*  5891 */	loadi   | r1     << dst_ | ndexc  << off_ ,
/*  5892 */	dca     | xs     << dst_ ,
/*  5893 */	store   | r1     << dst_ | xs     << src_ ,
/*  5894 */	stmt    | 1308   << off_ ,	//	brn succp   and succeed
/*  5895 */	brn     | succp  << off_ ,
// pnth1:
/*  5896 */	stmt    | 1309   << off_ ,	//pnth1	add xs *num04  remove p_exb entry and node ptr
/*  5897 */	loadi   | r2     << dst_ | num04  << off_ ,
/*  5898 */	add     | xs     << dst_ | r2     << src_ ,
/*  5899 */	stmt    | 1310   << off_ ,	//	brn succp   and succeed
/*  5900 */	brn     | succp  << off_ ,
// pnth2:
/*  5901 */	stmt    | 1311   << off_ ,	//pnth2	mov pmssl wb  save final cursor in safe place
/*  5902 */	store   | wb     << dst_ | pmssl  << off_ ,
/*  5903 */	stmt    | 1312   << off_ ,	//	bze pmdfl pnth6  jump if no pattern assignments
/*  5904 */	load    | r1     << dst_ | pmdfl  << off_ ,
/*  5905 */	bze     | r1     << dst_ | pnth6  << off_ ,
// pnth3:
/*  5906 */	stmt    | 1313   << off_ ,	//pnth3	dca xt   point past cursor entry
/*  5907 */	dca     | xt     << dst_ ,
/*  5908 */	stmt    | 1314   << off_ ,	//	mov wa -(xt)  load node pointer
/*  5909 */	dca     | xt     << dst_ ,
/*  5910 */	load    | wa     << dst_ | xt     << src_ ,
/*  5911 */	stmt    | 1315   << off_ ,	//	beq wa =ndpad pnth4 jump if ndpad entry
/*  5912 */	loadi   | r2     << dst_ | ndpad  << off_ ,
/*  5913 */	beq     | wa     << dst_ | r2     << src_ | pnth4  << off_ ,
/*  5914 */	stmt    | 1316   << off_ ,	//	bne wa =ndpab pnth5 jump if not ndpab entry
/*  5915 */	loadi   | r2     << dst_ | ndpab  << off_ ,
/*  5916 */	bne     | wa     << dst_ | r2     << src_ | pnth5  << off_ ,
/*  5917 */	stmt    | 1317   << off_ ,	//	mov -(xs) num01(xt)  stack initial cursor
/*  5918 */	load    | r1     << dst_ | xt     << src_ | num01  << off_ ,
/*  5919 */	dca     | xs     << dst_ ,
/*  5920 */	store   | r1     << dst_ | xs     << src_ ,
/*  5921 */	stmt    | 1318   << off_ ,	//	chk    check for stack overflow
/*  5922 */	chk     ,
/*  5923 */	stmt    | 1319   << off_ ,	//	brn pnth3   loop back if ok
/*  5924 */	brn     | pnth3  << off_ ,
// pnth4:
/*  5925 */	stmt    | 1320   << off_ ,	//pnth4	mov wa num01(xt)  load final cursor
/*  5926 */	load    | wa     << dst_ | xt     << src_ | num01  << off_ ,
/*  5927 */	stmt    | 1321   << off_ ,	//	mov wb (xs)  load initial cursor from stack
/*  5928 */	load    | wb     << dst_ | xs     << src_ ,
/*  5929 */	stmt    | 1322   << off_ ,	//	mov (xs) xt  save history stack scan ptr
/*  5930 */	store   | xt     << dst_ | xs     << src_ ,
/*  5931 */	stmt    | 1323   << off_ ,	//	sub wa wb  compute length of string
/*  5932 */	sub     | wa     << dst_ | wb     << src_ ,
/*  5933 */	stmt    | 1324   << off_ ,	//	mov xl r_pms  point to subject string
/*  5934 */	load    | xl     << dst_ | r_pms  << off_ ,
/*  5935 */	stmt    | 1325   << off_ ,	//	jsr sbstr   construct substring
/*  5936 */	call    | sbstr  << off_ ,
/*  5937 */	stmt    | 1326   << off_ ,	//	mov wb xr  copy substring pointer
/*  5938 */	move    | wb     << dst_ | xr     << src_ ,
/*  5939 */	stmt    | 1327   << off_ ,	//	mov xt (xs)  reload history stack scan ptr
/*  5940 */	load    | xt     << dst_ | xs     << src_ ,
/*  5941 */	stmt    | 1328   << off_ ,	//	mov xl num02(xt)  load pointer to p_pac node with nam
/*  5942 */	load    | xl     << dst_ | xt     << src_ | num02  << off_ ,
/*  5943 */	stmt    | 1329   << off_ ,	//	mov wa parm2(xl)  load name offset
/*  5944 */	load    | wa     << dst_ | xl     << src_ | parm2  << off_ ,
/*  5945 */	stmt    | 1330   << off_ ,	//	mov xl parm1(xl)  load name base
/*  5946 */	load    | xl     << dst_ | xl     << src_ | parm1  << off_ ,
/*  5947 */	stmt    | 1331   << off_ ,	//	jsr asinp   perform assignment
/*  5948 */	call    | asinp  << off_ ,
/*  5949 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  5950 */	ppm     | exfal  << off_ ,
/*  5951 */	stmt    | 1332   << off_ ,	//	mov xt (xs)+  else restore history stack ptr
/*  5952 */	load    | xt     << dst_ | xs     << src_ ,
/*  5953 */	ica     | xs     << dst_ ,
// pnth5:
/*  5954 */	stmt    | 1333   << off_ ,	//pnth5	bne xt xs pnth3 loop if more entries to scan
/*  5955 */	bne     | xt     << dst_ | xs     << src_ | pnth3  << off_ ,
// pnth6:
/*  5956 */	stmt    | 1334   << off_ ,	//pnth6	mov xs pmhbs  wipe out history stack
/*  5957 */	load    | xs     << dst_ | pmhbs  << off_ ,
/*  5958 */	stmt    | 1335   << off_ ,	//	mov wb (xs)+  load initial cursor
/*  5959 */	load    | wb     << dst_ | xs     << src_ ,
/*  5960 */	ica     | xs     << dst_ ,
/*  5961 */	stmt    | 1336   << off_ ,	//	mov wc (xs)+  load match type code
/*  5962 */	load    | wc     << dst_ | xs     << src_ ,
/*  5963 */	ica     | xs     << dst_ ,
/*  5964 */	stmt    | 1337   << off_ ,	//	mov wa pmssl  load final cursor value
/*  5965 */	load    | wa     << dst_ | pmssl  << off_ ,
/*  5966 */	stmt    | 1338   << off_ ,	//	mov xl r_pms  point to subject string
/*  5967 */	load    | xl     << dst_ | r_pms  << off_ ,
/*  5968 */	stmt    | 1339   << off_ ,	//	zer r_pms   clear subject string ptr for gbcol
/*  5969 */	store   | r0     << dst_ | r_pms  << off_ ,
/*  5970 */	stmt    | 1340   << off_ ,	//	bze wc pnth7  jump if call by name
/*  5971 */	bze     | wc     << dst_ | pnth7  << off_ ,
/*  5972 */	stmt    | 1341   << off_ ,	//	beq wc =num02 pnth9 exit if statement level call
/*  5973 */	loadi   | r2     << dst_ | num02  << off_ ,
/*  5974 */	beq     | wc     << dst_ | r2     << src_ | pnth9  << off_ ,
/*  5975 */	stmt    | 1342   << off_ ,	//	sub wa wb  compute length of string
/*  5976 */	sub     | wa     << dst_ | wb     << src_ ,
/*  5977 */	stmt    | 1343   << off_ ,	//	jsr sbstr   build substring
/*  5978 */	call    | sbstr  << off_ ,
/*  5979 */	stmt    | 1344   << off_ ,	//	mov -(xs) xr  stack result
/*  5980 */	dca     | xs     << dst_ ,
/*  5981 */	store   | xr     << dst_ | xs     << src_ ,
/*  5982 */	stmt    | 1345   << off_ ,	//	lcw xr   get next code word
/*  5983 */	lcw     | xr     << dst_ ,
/*  5984 */	stmt    | 1346   << off_ ,	//	bri (xr)   execute it
/*  5985 */	load    | r1     << dst_ | xr     << src_ ,
/*  5986 */	bri     | r1     << dst_ ,
// pnth7:
/*  5987 */	stmt    | 1347   << off_ ,	//pnth7	mov -(xs) wb  stack initial cursor
/*  5988 */	dca     | xs     << dst_ ,
/*  5989 */	store   | wb     << dst_ | xs     << src_ ,
/*  5990 */	stmt    | 1348   << off_ ,	//	mov -(xs) wa  stack final cursor
/*  5991 */	dca     | xs     << dst_ ,
/*  5992 */	store   | wa     << dst_ | xs     << src_ ,
// pnth8:
/*  5993 */	stmt    | 1349   << off_ ,	//pnth8	mov -(xs) xl  stack subject pointer
/*  5994 */	dca     | xs     << dst_ ,
/*  5995 */	store   | xl     << dst_ | xs     << src_ ,
// pnth9:
/*  5996 */	stmt    | 1350   << off_ ,	//pnth9	lcw xr   get next code word
/*  5997 */	lcw     | xr     << dst_ ,
/*  5998 */	stmt    | 1351   << off_ ,	//	bri (xr)   execute next code word
/*  5999 */	load    | r1     << dst_ | xr     << src_ ,
/*  6000 */	bri     | r1     << dst_ ,
/*  6001 */	bl_p1   ,
// p_pos:
/*  6002 */	stmt    | 1352   << off_ ,	//	beq wb parm1(xr) succp succeed if at right location
/*  6003 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6004 */	beq     | wb     << dst_ | r2     << src_ | succp  << off_ ,
/*  6005 */	stmt    | 1353   << off_ ,	//	bnz wb failp  don't look further if cursor not 0
/*  6006 */	bnz     | wb     << dst_ | failp  << off_ ,
/*  6007 */	stmt    | 1354   << off_ ,	//	mov xt pmhbs  get history stack base ptr
/*  6008 */	load    | xt     << dst_ | pmhbs  << off_ ,
/*  6009 */	stmt    | 1355   << off_ ,	//	bne xr -(xt) failp fail if pos is not first node
/*  6010 */	dca     | xt     << dst_ ,
/*  6011 */	load    | r2     << dst_ | xt     << src_ ,
/*  6012 */	bne     | xr     << dst_ | r2     << src_ | failp  << off_ ,
// ppos2:
/*  6013 */	stmt    | 1356   << off_ ,	//ppos2	bne -(xt) =nduna failp fail if not unanchored mode
/*  6014 */	dca     | xt     << dst_ ,
/*  6015 */	load    | r1     << dst_ | xt     << src_ ,
/*  6016 */	loadi   | r2     << dst_ | nduna  << off_ ,
/*  6017 */	bne     | r1     << dst_ | r2     << src_ | failp  << off_ ,
/*  6018 */	stmt    | 1357   << off_ ,	//	mov wb parm1(xr)  get desired cursor position
/*  6019 */	load    | wb     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6020 */	stmt    | 1358   << off_ ,	//	bgt wb pmssl exfal abort if off end
/*  6021 */	load    | r2     << dst_ | pmssl  << off_ ,
/*  6022 */	bgt     | wb     << dst_ | r2     << src_ | exfal  << off_ ,
/*  6023 */	stmt    | 1359   << off_ ,	//	mov num02(xt) wb  fake number of unanchored moves
/*  6024 */	store   | wb     << dst_ | xt     << src_ | num02  << off_ ,
/*  6025 */	stmt    | 1360   << off_ ,	//	brn succp   continue match with adjusted cursor
/*  6026 */	brn     | succp  << off_ ,
/*  6027 */	bl_p1   ,
// p_psd:
/*  6028 */	stmt    | 1361   << off_ ,	//	jsr evali   evaluate integer argument
/*  6029 */	call    | evali  << off_ ,
/*  6030 */	jsrerr  | r1     << dst_ | 4      << off_ ,
/*  6031 */	err     | 50     << off_ ,
/*  6032 */	err     | 51     << off_ ,
/*  6033 */	ppm     | failp  << off_ ,
/*  6034 */	ppm     | ppos1  << off_ ,
// ppos1:
/*  6035 */	stmt    | 1362   << off_ ,	//ppos1	beq wb parm1(xr) succp succeed if at right location
/*  6036 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6037 */	beq     | wb     << dst_ | r2     << src_ | succp  << off_ ,
/*  6038 */	stmt    | 1363   << off_ ,	//	bnz wb failp  don't look further if cursor not 0
/*  6039 */	bnz     | wb     << dst_ | failp  << off_ ,
/*  6040 */	stmt    | 1364   << off_ ,	//	bnz evlif failp  fail if complex argument
/*  6041 */	load    | r1     << dst_ | evlif  << off_ ,
/*  6042 */	bnz     | r1     << dst_ | failp  << off_ ,
/*  6043 */	stmt    | 1365   << off_ ,	//	mov xt pmhbs  get history stack base ptr
/*  6044 */	load    | xt     << dst_ | pmhbs  << off_ ,
/*  6045 */	stmt    | 1366   << off_ ,	//	mov wa evlio  get original node ptr
/*  6046 */	load    | wa     << dst_ | evlio  << off_ ,
/*  6047 */	stmt    | 1367   << off_ ,	//	bne wa -(xt) failp fail if pos is not first node
/*  6048 */	dca     | xt     << dst_ ,
/*  6049 */	load    | r2     << dst_ | xt     << src_ ,
/*  6050 */	bne     | wa     << dst_ | r2     << src_ | failp  << off_ ,
/*  6051 */	stmt    | 1368   << off_ ,	//	brn ppos2   merge with integer argument code
/*  6052 */	brn     | ppos2  << off_ ,
/*  6053 */	bl_p0   ,
// p_paa:
/*  6054 */	stmt    | 1369   << off_ ,	//	mov -(xs) wb  stack initial cursor
/*  6055 */	dca     | xs     << dst_ ,
/*  6056 */	store   | wb     << dst_ | xs     << src_ ,
/*  6057 */	stmt    | 1370   << off_ ,	//	mov -(xs) =ndpab  stack ptr to ndpab special node
/*  6058 */	loadi   | r1     << dst_ | ndpab  << off_ ,
/*  6059 */	dca     | xs     << dst_ ,
/*  6060 */	store   | r1     << dst_ | xs     << src_ ,
/*  6061 */	stmt    | 1371   << off_ ,	//	brn succp   and succeed matching null
/*  6062 */	brn     | succp  << off_ ,
/*  6063 */	0       ,
// p_pab:
/*  6064 */	stmt    | 1372   << off_ ,	//	brn failp   just fail (entry is already popped)
/*  6065 */	brn     | failp  << off_ ,
/*  6066 */	bl_p2   ,
// p_pac:
/*  6067 */	stmt    | 1373   << off_ ,	//	mov -(xs) wb  stack dummy cursor value
/*  6068 */	dca     | xs     << dst_ ,
/*  6069 */	store   | wb     << dst_ | xs     << src_ ,
/*  6070 */	stmt    | 1374   << off_ ,	//	mov -(xs) xr  stack pointer to p_pac node
/*  6071 */	dca     | xs     << dst_ ,
/*  6072 */	store   | xr     << dst_ | xs     << src_ ,
/*  6073 */	stmt    | 1375   << off_ ,	//	mov -(xs) wb  stack final cursor
/*  6074 */	dca     | xs     << dst_ ,
/*  6075 */	store   | wb     << dst_ | xs     << src_ ,
/*  6076 */	stmt    | 1376   << off_ ,	//	mov -(xs) =ndpad  stack ptr to special ndpad node
/*  6077 */	loadi   | r1     << dst_ | ndpad  << off_ ,
/*  6078 */	dca     | xs     << dst_ ,
/*  6079 */	store   | r1     << dst_ | xs     << src_ ,
/*  6080 */	stmt    | 1377   << off_ ,	//	mnz pmdfl   set dot flag non-zero
/*  6081 */	store   | xs     << dst_ | pmdfl  << off_ ,
/*  6082 */	stmt    | 1378   << off_ ,	//	brn succp   and succeed
/*  6083 */	brn     | succp  << off_ ,
/*  6084 */	0       ,
// p_pad:
/*  6085 */	stmt    | 1379   << off_ ,	//	brn flpop   fail and remove p_pac node
/*  6086 */	brn     | flpop  << off_ ,
/*  6087 */	bl_p0   ,
// p_rem:
/*  6088 */	stmt    | 1380   << off_ ,	//	mov wb pmssl  point cursor to end of string
/*  6089 */	load    | wb     << dst_ | pmssl  << off_ ,
/*  6090 */	stmt    | 1381   << off_ ,	//	brn succp   and succeed
/*  6091 */	brn     | succp  << off_ ,
/*  6092 */	bl_p1   ,
// p_rpd:
/*  6093 */	stmt    | 1382   << off_ ,	//	jsr evali   evaluate integer argument
/*  6094 */	call    | evali  << off_ ,
/*  6095 */	jsrerr  | r1     << dst_ | 4      << off_ ,
/*  6096 */	err     | 52     << off_ ,
/*  6097 */	err     | 53     << off_ ,
/*  6098 */	ppm     | failp  << off_ ,
/*  6099 */	ppm     | prps1  << off_ ,
// prps1:
/*  6100 */	stmt    | 1383   << off_ ,	//prps1	mov wc pmssl  get length of string
/*  6101 */	load    | wc     << dst_ | pmssl  << off_ ,
/*  6102 */	stmt    | 1384   << off_ ,	//	sub wc wb  get number of characters remaining
/*  6103 */	sub     | wc     << dst_ | wb     << src_ ,
/*  6104 */	stmt    | 1385   << off_ ,	//	beq wc parm1(xr) succp succeed if at right location
/*  6105 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6106 */	beq     | wc     << dst_ | r2     << src_ | succp  << off_ ,
/*  6107 */	stmt    | 1386   << off_ ,	//	bnz wb failp  don't look further if cursor not 0
/*  6108 */	bnz     | wb     << dst_ | failp  << off_ ,
/*  6109 */	stmt    | 1387   << off_ ,	//	bnz evlif failp  fail if complex argument
/*  6110 */	load    | r1     << dst_ | evlif  << off_ ,
/*  6111 */	bnz     | r1     << dst_ | failp  << off_ ,
/*  6112 */	stmt    | 1388   << off_ ,	//	mov xt pmhbs  get history stack base ptr
/*  6113 */	load    | xt     << dst_ | pmhbs  << off_ ,
/*  6114 */	stmt    | 1389   << off_ ,	//	mov wa evlio  get original node ptr
/*  6115 */	load    | wa     << dst_ | evlio  << off_ ,
/*  6116 */	stmt    | 1390   << off_ ,	//	bne wa -(xt) failp fail if pos is not first node
/*  6117 */	dca     | xt     << dst_ ,
/*  6118 */	load    | r2     << dst_ | xt     << src_ ,
/*  6119 */	bne     | wa     << dst_ | r2     << src_ | failp  << off_ ,
/*  6120 */	stmt    | 1391   << off_ ,	//	brn prps2   merge with integer arg code
/*  6121 */	brn     | prps2  << off_ ,
/*  6122 */	bl_p1   ,
// p_rps:
/*  6123 */	stmt    | 1392   << off_ ,	//	mov wc pmssl  get length of string
/*  6124 */	load    | wc     << dst_ | pmssl  << off_ ,
/*  6125 */	stmt    | 1393   << off_ ,	//	sub wc wb  get number of characters remaining
/*  6126 */	sub     | wc     << dst_ | wb     << src_ ,
/*  6127 */	stmt    | 1394   << off_ ,	//	beq wc parm1(xr) succp succeed if at right location
/*  6128 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6129 */	beq     | wc     << dst_ | r2     << src_ | succp  << off_ ,
/*  6130 */	stmt    | 1395   << off_ ,	//	bnz wb failp  don't look further if cursor not 0
/*  6131 */	bnz     | wb     << dst_ | failp  << off_ ,
/*  6132 */	stmt    | 1396   << off_ ,	//	mov xt pmhbs  get history stack base ptr
/*  6133 */	load    | xt     << dst_ | pmhbs  << off_ ,
/*  6134 */	stmt    | 1397   << off_ ,	//	bne xr -(xt) failp fail if rpos is not first node
/*  6135 */	dca     | xt     << dst_ ,
/*  6136 */	load    | r2     << dst_ | xt     << src_ ,
/*  6137 */	bne     | xr     << dst_ | r2     << src_ | failp  << off_ ,
// prps2:
/*  6138 */	stmt    | 1398   << off_ ,	//prps2	bne -(xt) =nduna failp fail if not unanchored mode
/*  6139 */	dca     | xt     << dst_ ,
/*  6140 */	load    | r1     << dst_ | xt     << src_ ,
/*  6141 */	loadi   | r2     << dst_ | nduna  << off_ ,
/*  6142 */	bne     | r1     << dst_ | r2     << src_ | failp  << off_ ,
/*  6143 */	stmt    | 1399   << off_ ,	//	mov wb pmssl  point to end of string
/*  6144 */	load    | wb     << dst_ | pmssl  << off_ ,
/*  6145 */	stmt    | 1400   << off_ ,	//	blt wb parm1(xr) failp fail if string not long enough
/*  6146 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6147 */	blt     | wb     << dst_ | r2     << src_ | failp  << off_ ,
/*  6148 */	stmt    | 1401   << off_ ,	//	sub wb parm1(xr)  else set new cursor
/*  6149 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6150 */	sub     | wb     << dst_ | r2     << src_ ,
/*  6151 */	stmt    | 1402   << off_ ,	//	mov num02(xt) wb  fake number of unanchored moves
/*  6152 */	store   | wb     << dst_ | xt     << src_ | num02  << off_ ,
/*  6153 */	stmt    | 1403   << off_ ,	//	brn succp   continue match with adjusted cursor
/*  6154 */	brn     | succp  << off_ ,
/*  6155 */	bl_p1   ,
// p_rtb:
// prtb1:
/*  6156 */	stmt    | 1404   << off_ ,	//prtb1	mov wc wb  save initial cursor
/*  6157 */	move    | wc     << dst_ | wb     << src_ ,
/*  6158 */	stmt    | 1405   << off_ ,	//	mov wb pmssl  point to end of string
/*  6159 */	load    | wb     << dst_ | pmssl  << off_ ,
/*  6160 */	stmt    | 1406   << off_ ,	//	blt wb parm1(xr) failp fail if string not long enough
/*  6161 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6162 */	blt     | wb     << dst_ | r2     << src_ | failp  << off_ ,
/*  6163 */	stmt    | 1407   << off_ ,	//	sub wb parm1(xr)  else set new cursor
/*  6164 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6165 */	sub     | wb     << dst_ | r2     << src_ ,
/*  6166 */	stmt    | 1408   << off_ ,	//	bge wb wc succp and succeed if not too far already
/*  6167 */	bge     | wb     << dst_ | wc     << src_ | succp  << off_ ,
/*  6168 */	stmt    | 1409   << off_ ,	//	brn failp   in which case, fail
/*  6169 */	brn     | failp  << off_ ,
/*  6170 */	bl_p1   ,
// p_rtd:
/*  6171 */	stmt    | 1410   << off_ ,	//	jsr evali   evaluate integer argument
/*  6172 */	call    | evali  << off_ ,
/*  6173 */	jsrerr  | r1     << dst_ | 4      << off_ ,
/*  6174 */	err     | 54     << off_ ,
/*  6175 */	err     | 55     << off_ ,
/*  6176 */	ppm     | failp  << off_ ,
/*  6177 */	ppm     | prtb1  << off_ ,
/*  6178 */	bl_p1   ,
// p_spd:
/*  6179 */	stmt    | 1411   << off_ ,	//	jsr evals   evaluate string argument
/*  6180 */	call    | evals  << off_ ,
/*  6181 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  6182 */	err     | 56     << off_ ,
/*  6183 */	ppm     | failp  << off_ ,
/*  6184 */	ppm     | pspn1  << off_ ,
/*  6185 */	bl_p2   ,
// p_spn:
// pspn1:
/*  6186 */	stmt    | 1412   << off_ ,	//pspn1	mov wc pmssl  copy subject string length
/*  6187 */	load    | wc     << dst_ | pmssl  << off_ ,
/*  6188 */	stmt    | 1413   << off_ ,	//	sub wc wb  calculate number of characters left
/*  6189 */	sub     | wc     << dst_ | wb     << src_ ,
/*  6190 */	stmt    | 1414   << off_ ,	//	bze wc failp  fail if no characters left
/*  6191 */	bze     | wc     << dst_ | failp  << off_ ,
/*  6192 */	stmt    | 1415   << off_ ,	//	mov xl r_pms  point to subject string
/*  6193 */	load    | xl     << dst_ | r_pms  << off_ ,
/*  6194 */	stmt    | 1416   << off_ ,	//	plc xl wb  point to current character
/*  6195 */	plc     | xl     << dst_ | wb     << src_ ,
/*  6196 */	stmt    | 1417   << off_ ,	//	mov psavc wb  save initial cursor
/*  6197 */	store   | wb     << dst_ | psavc  << off_ ,
/*  6198 */	stmt    | 1418   << off_ ,	//	mov psave xr  save node pointer
/*  6199 */	store   | xr     << dst_ | psave  << off_ ,
/*  6200 */	stmt    | 1419   << off_ ,	//	lct wc wc  set counter for chars left
// pspn2:
/*  6201 */	stmt    | 1420   << off_ ,	//pspn2	lch wa (xl)+  load next character, bump pointer
/*  6202 */	load    | wa     << dst_ | xl     << src_ ,
/*  6203 */	ica     | xl     << dst_ ,
/*  6204 */	stmt    | 1421   << off_ ,	//	wtb wa   convert to byte offset
/*  6205 */	stmt    | 1422   << off_ ,	//	mov xr parm1(xr)  point to ctblk
/*  6206 */	load    | xr     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6207 */	stmt    | 1423   << off_ ,	//	add xr wa  point to ctblk entry
/*  6208 */	add     | xr     << dst_ | wa     << src_ ,
/*  6209 */	stmt    | 1424   << off_ ,	//	mov wa ctchs(xr)  load ctblk entry
/*  6210 */	load    | wa     << dst_ | xr     << src_ | ctchs  << off_ ,
/*  6211 */	stmt    | 1425   << off_ ,	//	mov xr psave  restore node pointer
/*  6212 */	load    | xr     << dst_ | psave  << off_ ,
/*  6213 */	stmt    | 1426   << off_ ,	//	anb wa parm2(xr)  and with selected bit
/*  6214 */	load    | r2     << dst_ | xr     << src_ | parm2  << off_ ,
/*  6215 */	anb     | wa     << dst_ | r2     << src_ ,
/*  6216 */	stmt    | 1427   << off_ ,	//	zrb wa pspn3  jump if no match
/*  6217 */	zrb     | wa     << dst_ | pspn3  << off_ ,
/*  6218 */	stmt    | 1428   << off_ ,	//	icv wb   else push cursor
/*  6219 */	icv     | wb     << dst_ ,
/*  6220 */	stmt    | 1429   << off_ ,	//	bct wc pspn2  loop back unless end of string
/*  6221 */	bct     | wc     << dst_ | pspn2  << off_ ,
// pspn3:
/*  6222 */	stmt    | 1430   << off_ ,	//pspn3	bne wb psavc succp succeed if chars matched
/*  6223 */	load    | r2     << dst_ | psavc  << off_ ,
/*  6224 */	bne     | wb     << dst_ | r2     << src_ | succp  << off_ ,
/*  6225 */	stmt    | 1431   << off_ ,	//	brn failp   else fail if null string matched
/*  6226 */	brn     | failp  << off_ ,
/*  6227 */	bl_p1   ,
// p_sps:
/*  6228 */	stmt    | 1432   << off_ ,	//	mov wc pmssl  get subject string length
/*  6229 */	load    | wc     << dst_ | pmssl  << off_ ,
/*  6230 */	stmt    | 1433   << off_ ,	//	sub wc wb  calculate number of characters left
/*  6231 */	sub     | wc     << dst_ | wb     << src_ ,
/*  6232 */	stmt    | 1434   << off_ ,	//	bze wc failp  fail if no characters left
/*  6233 */	bze     | wc     << dst_ | failp  << off_ ,
/*  6234 */	stmt    | 1435   << off_ ,	//	mov xl r_pms  else point to subject string
/*  6235 */	load    | xl     << dst_ | r_pms  << off_ ,
/*  6236 */	stmt    | 1436   << off_ ,	//	plc xl wb  point to current character
/*  6237 */	plc     | xl     << dst_ | wb     << src_ ,
/*  6238 */	stmt    | 1437   << off_ ,	//	mov psavc wb  save initial cursor
/*  6239 */	store   | wb     << dst_ | psavc  << off_ ,
/*  6240 */	stmt    | 1438   << off_ ,	//	lct wc wc  set counter for characters left
// psps1:
/*  6241 */	stmt    | 1439   << off_ ,	//psps1	lch wa (xl)+  load next character, bump pointer
/*  6242 */	load    | wa     << dst_ | xl     << src_ ,
/*  6243 */	ica     | xl     << dst_ ,
/*  6244 */	stmt    | 1440   << off_ ,	//	bne wa parm1(xr) psps2 jump if no match
/*  6245 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6246 */	bne     | wa     << dst_ | r2     << src_ | psps2  << off_ ,
/*  6247 */	stmt    | 1441   << off_ ,	//	icv wb   else push cursor
/*  6248 */	icv     | wb     << dst_ ,
/*  6249 */	stmt    | 1442   << off_ ,	//	bct wc psps1  and loop unless end of string
/*  6250 */	bct     | wc     << dst_ | psps1  << off_ ,
// psps2:
/*  6251 */	stmt    | 1443   << off_ ,	//psps2	bne wb psavc succp succeed if chars matched
/*  6252 */	load    | r2     << dst_ | psavc  << off_ ,
/*  6253 */	bne     | wb     << dst_ | r2     << src_ | succp  << off_ ,
/*  6254 */	stmt    | 1444   << off_ ,	//	brn failp   fail if null string matched
/*  6255 */	brn     | failp  << off_ ,
/*  6256 */	bl_p1   ,
// p_str:
/*  6257 */	stmt    | 1445   << off_ ,	//	mov xl parm1(xr)  get pointer to string
/*  6258 */	load    | xl     << dst_ | xr     << src_ | parm1  << off_ ,
// pstr1:
/*  6259 */	stmt    | 1446   << off_ ,	//pstr1	mov psave xr  save node pointer
/*  6260 */	store   | xr     << dst_ | psave  << off_ ,
/*  6261 */	stmt    | 1447   << off_ ,	//	mov xr r_pms  load subject string pointer
/*  6262 */	load    | xr     << dst_ | r_pms  << off_ ,
/*  6263 */	stmt    | 1448   << off_ ,	//	plc xr wb  point to current character
/*  6264 */	plc     | xr     << dst_ | wb     << src_ ,
/*  6265 */	stmt    | 1449   << off_ ,	//	add wb sclen(xl)  compute new cursor position
/*  6266 */	load    | r2     << dst_ | xl     << src_ | sclen  << off_ ,
/*  6267 */	add     | wb     << dst_ | r2     << src_ ,
/*  6268 */	stmt    | 1450   << off_ ,	//	bgt wb pmssl failp fail if past end of string
/*  6269 */	load    | r2     << dst_ | pmssl  << off_ ,
/*  6270 */	bgt     | wb     << dst_ | r2     << src_ | failp  << off_ ,
/*  6271 */	stmt    | 1451   << off_ ,	//	mov psavc wb  save updated cursor
/*  6272 */	store   | wb     << dst_ | psavc  << off_ ,
/*  6273 */	stmt    | 1452   << off_ ,	//	mov wa sclen(xl)  get number of chars to compare
/*  6274 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/*  6275 */	stmt    | 1453   << off_ ,	//	plc xl   point to chars of test string
/*  6276 */	plc     | xl     << dst_ ,
/*  6277 */	stmt    | 1454   << off_ ,	//	cmc failp failp  compare, fail if not equal
/*  6278 */	loadi   | r1     << dst_ | failp  << src_ ,
/*  6279 */	loadi   | r2     << dst_ | failp  << src_ ,
/*  6280 */	cmc     ,
/*  6281 */	stmt    | 1455   << off_ ,	//	mov xr psave  if all matched, restore node ptr
/*  6282 */	load    | xr     << dst_ | psave  << off_ ,
/*  6283 */	stmt    | 1456   << off_ ,	//	mov wb psavc  restore updated cursor
/*  6284 */	load    | wb     << dst_ | psavc  << off_ ,
/*  6285 */	stmt    | 1457   << off_ ,	//	brn succp   and succeed
/*  6286 */	brn     | succp  << off_ ,
/*  6287 */	bl_p0   ,
// p_suc:
/*  6288 */	stmt    | 1458   << off_ ,	//	mov -(xs) wb  stack cursor
/*  6289 */	dca     | xs     << dst_ ,
/*  6290 */	store   | wb     << dst_ | xs     << src_ ,
/*  6291 */	stmt    | 1459   << off_ ,	//	mov -(xs) xr  stack pointer to this node
/*  6292 */	dca     | xs     << dst_ ,
/*  6293 */	store   | xr     << dst_ | xs     << src_ ,
/*  6294 */	stmt    | 1460   << off_ ,	//	brn succp   succeed matching null
/*  6295 */	brn     | succp  << off_ ,
/*  6296 */	bl_p1   ,
// p_tab:
// ptab1:
/*  6297 */	stmt    | 1461   << off_ ,	//ptab1	bgt wb parm1(xr) failp fail if too far already
/*  6298 */	load    | r2     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6299 */	bgt     | wb     << dst_ | r2     << src_ | failp  << off_ ,
/*  6300 */	stmt    | 1462   << off_ ,	//	mov wb parm1(xr)  else set new cursor position
/*  6301 */	load    | wb     << dst_ | xr     << src_ | parm1  << off_ ,
/*  6302 */	stmt    | 1463   << off_ ,	//	ble wb pmssl succp succeed if not off end
/*  6303 */	load    | r2     << dst_ | pmssl  << off_ ,
/*  6304 */	ble     | wb     << dst_ | r2     << src_ | succp  << off_ ,
/*  6305 */	stmt    | 1464   << off_ ,	//	brn failp   else fail
/*  6306 */	brn     | failp  << off_ ,
/*  6307 */	bl_p1   ,
// p_tbd:
/*  6308 */	stmt    | 1465   << off_ ,	//	jsr evali   evaluate integer argument
/*  6309 */	call    | evali  << off_ ,
/*  6310 */	jsrerr  | r1     << dst_ | 4      << off_ ,
/*  6311 */	err     | 57     << off_ ,
/*  6312 */	err     | 58     << off_ ,
/*  6313 */	ppm     | failp  << off_ ,
/*  6314 */	ppm     | ptab1  << off_ ,
/*  6315 */	0       ,
// p_una:
/*  6316 */	stmt    | 1466   << off_ ,	//	mov xr wb  copy initial pattern node pointer
/*  6317 */	move    | xr     << dst_ | wb     << src_ ,
/*  6318 */	stmt    | 1467   << off_ ,	//	mov wb (xs)  get initial cursor
/*  6319 */	load    | wb     << dst_ | xs     << src_ ,
/*  6320 */	stmt    | 1468   << off_ ,	//	beq wb pmssl exfal match fails if at end of string
/*  6321 */	load    | r2     << dst_ | pmssl  << off_ ,
/*  6322 */	beq     | wb     << dst_ | r2     << src_ | exfal  << off_ ,
/*  6323 */	stmt    | 1469   << off_ ,	//	icv wb   else increment cursor
/*  6324 */	icv     | wb     << dst_ ,
/*  6325 */	stmt    | 1470   << off_ ,	//	mov (xs) wb  store incremented cursor
/*  6326 */	store   | wb     << dst_ | xs     << src_ ,
/*  6327 */	stmt    | 1471   << off_ ,	//	mov -(xs) xr  restack initial node ptr
/*  6328 */	dca     | xs     << dst_ ,
/*  6329 */	store   | xr     << dst_ | xs     << src_ ,
/*  6330 */	stmt    | 1472   << off_ ,	//	mov -(xs) =nduna  restack unanchored node
/*  6331 */	loadi   | r1     << dst_ | nduna  << off_ ,
/*  6332 */	dca     | xs     << dst_ ,
/*  6333 */	store   | r1     << dst_ | xs     << src_ ,
/*  6334 */	stmt    | 1473   << off_ ,	//	bri (xr)   rematch first node
/*  6335 */	load    | r1     << dst_ | xr     << src_ ,
/*  6336 */	bri     | r1     << dst_ ,
/*  6337 */	bl__i   ,
// p_yyy:
/*  6338 */	0       ,
// l_abo:
// labo1:
/*  6339 */	stmt    | 1474   << off_ ,	//labo1	mov wa kvert  load error code
/*  6340 */	load    | wa     << dst_ | kvert  << off_ ,
/*  6341 */	stmt    | 1475   << off_ ,	//	bze wa labo3  jump if no error has occured
/*  6342 */	bze     | wa     << dst_ | labo3  << off_ ,
/*  6343 */	stmt    | 1476   << off_ ,	//	jsr sysax   call after execution proc
/*  6344 */	sys     | sysax_ << off_ ,
/*  6345 */	stmt    | 1477   << off_ ,	//	mov wc kvstn  current statement
/*  6346 */	load    | wc     << dst_ | kvstn  << off_ ,
/*  6347 */	stmt    | 1478   << off_ ,	//	jsr filnm   obtain file name for this statement
/*  6348 */	call    | filnm  << off_ ,
/*  6349 */	stmt    | 1479   << off_ ,	//	mov xr r_cod  current code block
/*  6350 */	load    | xr     << dst_ | r_cod  << off_ ,
/*  6351 */	stmt    | 1480   << off_ ,	//	mov wc cdsln(xr)  line number
/*  6352 */	load    | wc     << dst_ | xr     << src_ | cdsln  << off_ ,
/*  6353 */	stmt    | 1481   << off_ ,	//	zer wb   column number
/*  6354 */	move    | wb     << dst_ ,
/*  6355 */	stmt    | 1482   << off_ ,	//	mov xr stage
/*  6356 */	load    | xr     << dst_ | stage  << off_ ,
/*  6357 */	stmt    | 1483   << off_ ,	//	jsr sysea   advise system of error
/*  6358 */	sys     | sysea_ << off_ ,
/*  6359 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6360 */	ppm     | stpr4  << off_ ,
/*  6361 */	stmt    | 1484   << off_ ,	//	jsr prtpg   else eject printer
/*  6362 */	call    | prtpg  << off_ ,
/*  6363 */	stmt    | 1485   << off_ ,	//	bze xr labo2  did sysea request print
/*  6364 */	bze     | xr     << dst_ | labo2  << off_ ,
/*  6365 */	stmt    | 1486   << off_ ,	//	jsr prtst   print text from sysea
/*  6366 */	call    | prtst  << off_ ,
// labo2:
/*  6367 */	stmt    | 1487   << off_ ,	//labo2	jsr ermsg   print error message
/*  6368 */	call    | ermsg  << off_ ,
/*  6369 */	stmt    | 1488   << off_ ,	//	zer xr   indicate no message to print
/*  6370 */	move    | xr     << dst_ ,
/*  6371 */	stmt    | 1489   << off_ ,	//	brn stopr   jump to routine to stop run
/*  6372 */	brn     | stopr  << off_ ,
// labo3:
/*  6373 */	stmt    | 1490   << off_ ,	//labo3	erb 036 goto abort with no preceding error
/*  6374 */	erb     | 36     << off_ ,
/*  6375 */	0       ,
// l_cnt:
// lcnt1:
/*  6376 */	stmt    | 1491   << off_ ,	//lcnt1	mov xr r_cnt  load continuation code block ptr
/*  6377 */	load    | xr     << dst_ | r_cnt  << off_ ,
/*  6378 */	stmt    | 1492   << off_ ,	//	bze xr lcnt3  jump if no previous error
/*  6379 */	bze     | xr     << dst_ | lcnt3  << off_ ,
/*  6380 */	stmt    | 1493   << off_ ,	//	zer r_cnt   clear flag
/*  6381 */	store   | r0     << dst_ | r_cnt  << off_ ,
/*  6382 */	stmt    | 1494   << off_ ,	//	mov r_cod xr  else store as new code block ptr
/*  6383 */	store   | xr     << dst_ | r_cod  << off_ ,
/*  6384 */	stmt    | 1495   << off_ ,	//	bne (xr) =b_cdc lcnt2 jump if not complex go
/*  6385 */	load    | r1     << dst_ | xr     << src_ ,
/*  6386 */	loadi   | r2     << dst_ | b_cdc  << off_ ,
/*  6387 */	bne     | r1     << dst_ | r2     << src_ | lcnt2  << off_ ,
/*  6388 */	stmt    | 1496   << off_ ,	//	mov wa stxoc  get offset of error
/*  6389 */	load    | wa     << dst_ | stxoc  << off_ ,
/*  6390 */	stmt    | 1497   << off_ ,	//	bge wa stxof lcnt4 jump if error in goto evaluation
/*  6391 */	load    | r2     << dst_ | stxof  << off_ ,
/*  6392 */	bge     | wa     << dst_ | r2     << src_ | lcnt4  << off_ ,
// lcnt2:
/*  6393 */	stmt    | 1498   << off_ ,	//lcnt2	add xr stxof  add failure offset
/*  6394 */	load    | r2     << dst_ | stxof  << off_ ,
/*  6395 */	add     | xr     << dst_ | r2     << src_ ,
/*  6396 */	stmt    | 1499   << off_ ,	//	lcp xr   load code pointer
/*  6397 */	lcp     | xr     << dst_ ,
/*  6398 */	stmt    | 1500   << off_ ,	//	mov xs flptr  reset stack pointer
/*  6399 */	load    | xs     << dst_ | flptr  << off_ ,
/*  6400 */	stmt    | 1501   << off_ ,	//	lcw xr   get next code word
/*  6401 */	lcw     | xr     << dst_ ,
/*  6402 */	stmt    | 1502   << off_ ,	//	bri (xr)   execute next code word
/*  6403 */	load    | r1     << dst_ | xr     << src_ ,
/*  6404 */	bri     | r1     << dst_ ,
// lcnt3:
/*  6405 */	stmt    | 1503   << off_ ,	//lcnt3	icv errft   fatal error
/*  6406 */	load    | r1     << dst_ | errft  << off_ ,
/*  6407 */	icv     | r1     << dst_ ,
/*  6408 */	store   | r1     << dst_ | errft  << off_ ,
/*  6409 */	stmt    | 1504   << off_ ,	//	erb 037 goto continue with no preceding error
/*  6410 */	erb     | 37     << off_ ,
// lcnt4:
/*  6411 */	stmt    | 1505   << off_ ,	//lcnt4	icv errft   fatal error
/*  6412 */	load    | r1     << dst_ | errft  << off_ ,
/*  6413 */	icv     | r1     << dst_ ,
/*  6414 */	store   | r1     << dst_ | errft  << off_ ,
/*  6415 */	stmt    | 1506   << off_ ,	//	erb 332 goto continue with error in failure goto
/*  6416 */	erb     | 332    << off_ ,
/*  6417 */	0       ,
// l_end:
// lend0:
/*  6418 */	stmt    | 1507   << off_ ,	//lend0	mov xr =endms  point to message /normal term.../
/*  6419 */	loadi   | xr     << dst_ | endms  << off_ ,
/*  6420 */	stmt    | 1508   << off_ ,	//	brn stopr   jump to routine to stop run
/*  6421 */	brn     | stopr  << off_ ,
/*  6422 */	0       ,
// l_frt:
/*  6423 */	stmt    | 1509   << off_ ,	//	mov wa =scfrt  point to string /freturn/
/*  6424 */	loadi   | wa     << dst_ | scfrt  << off_ ,
/*  6425 */	stmt    | 1510   << off_ ,	//	brn retrn   jump to common return routine
/*  6426 */	brn     | retrn  << off_ ,
/*  6427 */	0       ,
// l_nrt:
/*  6428 */	stmt    | 1511   << off_ ,	//	mov wa =scnrt  point to string /nreturn/
/*  6429 */	loadi   | wa     << dst_ | scnrt  << off_ ,
/*  6430 */	stmt    | 1512   << off_ ,	//	brn retrn   jump to common return routine
/*  6431 */	brn     | retrn  << off_ ,
/*  6432 */	0       ,
// l_rtn:
/*  6433 */	stmt    | 1513   << off_ ,	//	mov wa =scrtn  point to string /return/
/*  6434 */	loadi   | wa     << dst_ | scrtn  << off_ ,
/*  6435 */	stmt    | 1514   << off_ ,	//	brn retrn   jump to common return routine
/*  6436 */	brn     | retrn  << off_ ,
/*  6437 */	0       ,
// l_scn:
/*  6438 */	stmt    | 1515   << off_ ,	//	mov xr r_cnt  load continuation code block ptr
/*  6439 */	load    | xr     << dst_ | r_cnt  << off_ ,
/*  6440 */	stmt    | 1516   << off_ ,	//	bze xr lscn2  jump if no previous error
/*  6441 */	bze     | xr     << dst_ | lscn2  << off_ ,
/*  6442 */	stmt    | 1517   << off_ ,	//	zer r_cnt   clear flag
/*  6443 */	store   | r0     << dst_ | r_cnt  << off_ ,
/*  6444 */	stmt    | 1518   << off_ ,	//	bne kvert =nm320 lscn1 error must be user interrupt
/*  6445 */	load    | r1     << dst_ | kvert  << off_ ,
/*  6446 */	loadi   | r2     << dst_ | nm320  << off_ ,
/*  6447 */	bne     | r1     << dst_ | r2     << src_ | lscn1  << off_ ,
/*  6448 */	stmt    | 1519   << off_ ,	//	beq kvert =nm321 lscn2 detect scontinue loop
/*  6449 */	load    | r1     << dst_ | kvert  << off_ ,
/*  6450 */	loadi   | r2     << dst_ | nm321  << off_ ,
/*  6451 */	beq     | r1     << dst_ | r2     << src_ | lscn2  << off_ ,
/*  6452 */	stmt    | 1520   << off_ ,	//	mov r_cod xr  else store as new code block ptr
/*  6453 */	store   | xr     << dst_ | r_cod  << off_ ,
/*  6454 */	stmt    | 1521   << off_ ,	//	add xr stxoc  add resume offset
/*  6455 */	load    | r2     << dst_ | stxoc  << off_ ,
/*  6456 */	add     | xr     << dst_ | r2     << src_ ,
/*  6457 */	stmt    | 1522   << off_ ,	//	lcp xr   load code pointer
/*  6458 */	lcp     | xr     << dst_ ,
/*  6459 */	stmt    | 1523   << off_ ,	//	lcw xr   get next code word
/*  6460 */	lcw     | xr     << dst_ ,
/*  6461 */	stmt    | 1524   << off_ ,	//	bri (xr)   execute next code word
/*  6462 */	load    | r1     << dst_ | xr     << src_ ,
/*  6463 */	bri     | r1     << dst_ ,
// lscn1:
/*  6464 */	stmt    | 1525   << off_ ,	//lscn1	icv errft   fatal error
/*  6465 */	load    | r1     << dst_ | errft  << off_ ,
/*  6466 */	icv     | r1     << dst_ ,
/*  6467 */	store   | r1     << dst_ | errft  << off_ ,
/*  6468 */	stmt    | 1526   << off_ ,	//	erb 331 goto scontinue with no user interrupt
/*  6469 */	erb     | 331    << off_ ,
// lscn2:
/*  6470 */	stmt    | 1527   << off_ ,	//lscn2	icv errft   fatal error
/*  6471 */	load    | r1     << dst_ | errft  << off_ ,
/*  6472 */	icv     | r1     << dst_ ,
/*  6473 */	store   | r1     << dst_ | errft  << off_ ,
/*  6474 */	stmt    | 1528   << off_ ,	//	erb 321 goto scontinue with no preceding error
/*  6475 */	erb     | 321    << off_ ,
/*  6476 */	0       ,
// l_und:
/*  6477 */	stmt    | 1529   << off_ ,	//	erb 038 goto undefined label
/*  6478 */	erb     | 38     << off_ ,
/*  6479 */	0       ,
// s_any:
/*  6480 */	stmt    | 1530   << off_ ,	//	mov wb =p_ans  set pcode for single char case
/*  6481 */	loadi   | wb     << dst_ | p_ans  << off_ ,
/*  6482 */	stmt    | 1531   << off_ ,	//	mov xl =p_any  pcode for multi-char case
/*  6483 */	loadi   | xl     << dst_ | p_any  << off_ ,
/*  6484 */	stmt    | 1532   << off_ ,	//	mov wc =p_ayd  pcode for expression case
/*  6485 */	loadi   | wc     << dst_ | p_ayd  << off_ ,
/*  6486 */	stmt    | 1533   << off_ ,	//	jsr patst   call common routine to build node
/*  6487 */	call    | patst  << off_ ,
/*  6488 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6489 */	err     | 59     << off_ ,
/*  6490 */	stmt    | 1534   << off_ ,	//	mov -(xs) xr  stack result
/*  6491 */	dca     | xs     << dst_ ,
/*  6492 */	store   | xr     << dst_ | xs     << src_ ,
/*  6493 */	stmt    | 1535   << off_ ,	//	lcw xr   get next code word
/*  6494 */	lcw     | xr     << dst_ ,
/*  6495 */	stmt    | 1536   << off_ ,	//	bri (xr)   execute it
/*  6496 */	load    | r1     << dst_ | xr     << src_ ,
/*  6497 */	bri     | r1     << dst_ ,
/*  6498 */	0       ,
// s_app:
/*  6499 */	stmt    | 1537   << off_ ,	//	bze wa sapp3  jump if no arguments
/*  6500 */	bze     | wa     << dst_ | sapp3  << off_ ,
/*  6501 */	stmt    | 1538   << off_ ,	//	dcv wa   else get applied func arg count
/*  6502 */	dcv     | wa     << dst_ ,
/*  6503 */	stmt    | 1539   << off_ ,	//	mov wb wa  copy
/*  6504 */	move    | wb     << dst_ | wa     << src_ ,
/*  6505 */	stmt    | 1540   << off_ ,	//	wtb wb   convert to bytes
/*  6506 */	stmt    | 1541   << off_ ,	//	mov xt xs  copy stack pointer
/*  6507 */	move    | xt     << dst_ | xs     << src_ ,
/*  6508 */	stmt    | 1542   << off_ ,	//	add xt wb  point to function argument on stack
/*  6509 */	add     | xt     << dst_ | wb     << src_ ,
/*  6510 */	stmt    | 1543   << off_ ,	//	mov xr (xt)  load function ptr (apply 1st arg)
/*  6511 */	load    | xr     << dst_ | xt     << src_ ,
/*  6512 */	stmt    | 1544   << off_ ,	//	bze wa sapp2  jump if no args for applied func
/*  6513 */	bze     | wa     << dst_ | sapp2  << off_ ,
/*  6514 */	stmt    | 1545   << off_ ,	//	lct wb wa  else set counter for loop
/*  6515 */	move    | wb     << dst_ | wa     << src_ ,
// sapp1:
/*  6516 */	stmt    | 1546   << off_ ,	//sapp1	dca xt   point to next argument
/*  6517 */	dca     | xt     << dst_ ,
/*  6518 */	stmt    | 1547   << off_ ,	//	mov num01(xt) (xt)  move argument up
/*  6519 */	load    | r1     << dst_ | xt     << src_ ,
/*  6520 */	store   | r1     << dst_ | xt     << src_ | num01  << off_ ,
/*  6521 */	stmt    | 1548   << off_ ,	//	bct wb sapp1  loop till all moved
/*  6522 */	bct     | wb     << dst_ | sapp1  << off_ ,
// sapp2:
/*  6523 */	stmt    | 1549   << off_ ,	//sapp2	ica xs   adjust stack ptr for apply 1st arg
/*  6524 */	ica     | xs     << dst_ ,
/*  6525 */	stmt    | 1550   << off_ ,	//	jsr gtnvr   get variable block addr for func
/*  6526 */	call    | gtnvr  << off_ ,
/*  6527 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6528 */	ppm     | sapp3  << off_ ,
/*  6529 */	stmt    | 1551   << off_ ,	//	mov xl vrfnc(xr)  else point to function block
/*  6530 */	load    | xl     << dst_ | xr     << src_ | vrfnc  << off_ ,
/*  6531 */	stmt    | 1552   << off_ ,	//	brn cfunc   go call applied function
/*  6532 */	brn     | cfunc  << off_ ,
// sapp3:
/*  6533 */	stmt    | 1553   << off_ ,	//sapp3	erb 060 apply first arg is not natural variable name
/*  6534 */	erb     | 60     << off_ ,
/*  6535 */	0       ,
// s_abn:
/*  6536 */	stmt    | 1554   << off_ ,	//	zer xr   set parm1 = 0 for the moment
/*  6537 */	move    | xr     << dst_ ,
/*  6538 */	stmt    | 1555   << off_ ,	//	mov wb =p_alt  set pcode for alternative node
/*  6539 */	loadi   | wb     << dst_ | p_alt  << off_ ,
/*  6540 */	stmt    | 1556   << off_ ,	//	jsr pbild   build alternative node
/*  6541 */	call    | pbild  << off_ ,
/*  6542 */	stmt    | 1557   << off_ ,	//	mov xl xr  save ptr to alternative pattern
/*  6543 */	move    | xl     << dst_ | xr     << src_ ,
/*  6544 */	stmt    | 1558   << off_ ,	//	mov wb =p_abc  pcode for p_abc
/*  6545 */	loadi   | wb     << dst_ | p_abc  << off_ ,
/*  6546 */	stmt    | 1559   << off_ ,	//	zer xr   p0blk
/*  6547 */	move    | xr     << dst_ ,
/*  6548 */	stmt    | 1560   << off_ ,	//	jsr pbild   build p_abc node
/*  6549 */	call    | pbild  << off_ ,
/*  6550 */	stmt    | 1561   << off_ ,	//	mov pthen(xr) xl  put alternative node as successor
/*  6551 */	store   | xl     << dst_ | xr     << src_ | pthen  << off_ ,
/*  6552 */	stmt    | 1562   << off_ ,	//	mov wa xl  remember alternative node pointer
/*  6553 */	move    | wa     << dst_ | xl     << src_ ,
/*  6554 */	stmt    | 1563   << off_ ,	//	mov xl xr  copy p_abc node ptr
/*  6555 */	move    | xl     << dst_ | xr     << src_ ,
/*  6556 */	stmt    | 1564   << off_ ,	//	mov xr (xs)  load arbno argument
/*  6557 */	load    | xr     << dst_ | xs     << src_ ,
/*  6558 */	stmt    | 1565   << off_ ,	//	mov (xs) wa  stack alternative node pointer
/*  6559 */	store   | wa     << dst_ | xs     << src_ ,
/*  6560 */	stmt    | 1566   << off_ ,	//	jsr gtpat   get arbno argument as pattern
/*  6561 */	call    | gtpat  << off_ ,
/*  6562 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6563 */	err     | 61     << off_ ,
/*  6564 */	stmt    | 1567   << off_ ,	//	jsr pconc   concat arg with p_abc node
/*  6565 */	call    | pconc  << off_ ,
/*  6566 */	stmt    | 1568   << off_ ,	//	mov xl xr  remember ptr to concd patterns
/*  6567 */	move    | xl     << dst_ | xr     << src_ ,
/*  6568 */	stmt    | 1569   << off_ ,	//	mov wb =p_aba  pcode for p_aba
/*  6569 */	loadi   | wb     << dst_ | p_aba  << off_ ,
/*  6570 */	stmt    | 1570   << off_ ,	//	zer xr   p0blk
/*  6571 */	move    | xr     << dst_ ,
/*  6572 */	stmt    | 1571   << off_ ,	//	jsr pbild   build p_aba node
/*  6573 */	call    | pbild  << off_ ,
/*  6574 */	stmt    | 1572   << off_ ,	//	mov pthen(xr) xl  concatenate nodes
/*  6575 */	store   | xl     << dst_ | xr     << src_ | pthen  << off_ ,
/*  6576 */	stmt    | 1573   << off_ ,	//	mov xl (xs)  recall ptr to alternative node
/*  6577 */	load    | xl     << dst_ | xs     << src_ ,
/*  6578 */	stmt    | 1574   << off_ ,	//	mov parm1(xl) xr  point alternative back to argument
/*  6579 */	store   | xr     << dst_ | xl     << src_ | parm1  << off_ ,
/*  6580 */	stmt    | 1575   << off_ ,	//	lcw xr   get next code word
/*  6581 */	lcw     | xr     << dst_ ,
/*  6582 */	stmt    | 1576   << off_ ,	//	bri (xr)   execute next code word
/*  6583 */	load    | r1     << dst_ | xr     << src_ ,
/*  6584 */	bri     | r1     << dst_ ,
/*  6585 */	0       ,
// s_arg:
/*  6586 */	stmt    | 1577   << off_ ,	//	jsr gtsmi   get second arg as small integer
/*  6587 */	call    | gtsmi  << off_ ,
/*  6588 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  6589 */	err     | 62     << off_ ,
/*  6590 */	ppm     | exfal  << off_ ,
/*  6591 */	stmt    | 1578   << off_ ,	//	mov wa xr  save argument number
/*  6592 */	move    | wa     << dst_ | xr     << src_ ,
/*  6593 */	stmt    | 1579   << off_ ,	//	mov xr (xs)+  load first argument
/*  6594 */	load    | xr     << dst_ | xs     << src_ ,
/*  6595 */	ica     | xs     << dst_ ,
/*  6596 */	stmt    | 1580   << off_ ,	//	jsr gtnvr   locate vrblk
/*  6597 */	call    | gtnvr  << off_ ,
/*  6598 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6599 */	ppm     | sarg1  << off_ ,
/*  6600 */	stmt    | 1581   << off_ ,	//	mov xr vrfnc(xr)  else load function block pointer
/*  6601 */	load    | xr     << dst_ | xr     << src_ | vrfnc  << off_ ,
/*  6602 */	stmt    | 1582   << off_ ,	//	bne (xr) =b_pfc sarg1 jump if not program defined
/*  6603 */	load    | r1     << dst_ | xr     << src_ ,
/*  6604 */	loadi   | r2     << dst_ | b_pfc  << off_ ,
/*  6605 */	bne     | r1     << dst_ | r2     << src_ | sarg1  << off_ ,
/*  6606 */	stmt    | 1583   << off_ ,	//	bze wa exfal  fail if arg number is zero
/*  6607 */	bze     | wa     << dst_ | exfal  << off_ ,
/*  6608 */	stmt    | 1584   << off_ ,	//	bgt wa fargs(xr) exfal fail if arg number is too large
/*  6609 */	load    | r2     << dst_ | xr     << src_ | fargs  << off_ ,
/*  6610 */	bgt     | wa     << dst_ | r2     << src_ | exfal  << off_ ,
/*  6611 */	stmt    | 1585   << off_ ,	//	wtb wa   else convert to byte offset
/*  6612 */	stmt    | 1586   << off_ ,	//	add xr wa  point to argument selected
/*  6613 */	add     | xr     << dst_ | wa     << src_ ,
/*  6614 */	stmt    | 1587   << off_ ,	//	mov xr pfagb(xr)  load argument vrblk pointer
/*  6615 */	load    | xr     << dst_ | xr     << src_ | pfagb  << off_ ,
/*  6616 */	stmt    | 1588   << off_ ,	//	brn exvnm   exit to build nmblk
/*  6617 */	brn     | exvnm  << off_ ,
// sarg1:
/*  6618 */	stmt    | 1589   << off_ ,	//sarg1	erb 063 arg first argument is not program function name
/*  6619 */	erb     | 63     << off_ ,
/*  6620 */	0       ,
// s_arr:
/*  6621 */	stmt    | 1590   << off_ ,	//	mov xl (xs)+  load initial element value
/*  6622 */	load    | xl     << dst_ | xs     << src_ ,
/*  6623 */	ica     | xs     << dst_ ,
/*  6624 */	stmt    | 1591   << off_ ,	//	mov xr (xs)+  load first argument
/*  6625 */	load    | xr     << dst_ | xs     << src_ ,
/*  6626 */	ica     | xs     << dst_ ,
/*  6627 */	stmt    | 1592   << off_ ,	//	jsr gtint   convert first arg to integer
/*  6628 */	call    | gtint  << off_ ,
/*  6629 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6630 */	ppm     | sar02  << off_ ,
/*  6631 */	stmt    | 1593   << off_ ,	//	ldi icval(xr)   load integer value
/*  6632 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  6633 */	ldi     | r1     << dst_ ,
/*  6634 */	stmt    | 1594   << off_ ,	//	ile sar10   jump if zero or neg (bad dimension)
/*  6635 */	ile     | sar10  << off_ ,
/*  6636 */	stmt    | 1595   << off_ ,	//	mfi wa sar11  else convert to one word, test ovfl
/*  6637 */	move    | wa     << dst_ | ia     << src_ ,
/*  6638 */	mfi     | sar11  << off_ ,
/*  6639 */	stmt    | 1596   << off_ ,	//	jsr vmake   create vector
/*  6640 */	call    | vmake  << off_ ,
/*  6641 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6642 */	ppm     | sar11  << off_ ,
/*  6643 */	stmt    | 1597   << off_ ,	//	brn exsid   exit setting idval
/*  6644 */	brn     | exsid  << off_ ,
// sar02:
/*  6645 */	stmt    | 1598   << off_ ,	//sar02	mov -(xs) xr  replace argument on stack
/*  6646 */	dca     | xs     << dst_ ,
/*  6647 */	store   | xr     << dst_ | xs     << src_ ,
/*  6648 */	stmt    | 1599   << off_ ,	//	jsr xscni   initialize scan of first argument
/*  6649 */	call    | xscni  << off_ ,
/*  6650 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  6651 */	err     | 64     << off_ ,
/*  6652 */	ppm     | exnul  << off_ ,
/*  6653 */	stmt    | 1600   << off_ ,	//	mov -(xs) r_xsc  save prototype pointer
/*  6654 */	load    | r1     << dst_ | r_xsc  << off_ ,
/*  6655 */	dca     | xs     << dst_ ,
/*  6656 */	store   | r1     << dst_ | xs     << src_ ,
/*  6657 */	stmt    | 1601   << off_ ,	//	mov -(xs) xl  save default value
/*  6658 */	dca     | xs     << dst_ ,
/*  6659 */	store   | xl     << dst_ | xs     << src_ ,
/*  6660 */	stmt    | 1602   << off_ ,	//	zer arcdm   zero count of dimensions
/*  6661 */	store   | r0     << dst_ | arcdm  << off_ ,
/*  6662 */	stmt    | 1603   << off_ ,	//	zer arptr   zero offset to indicate pass one
/*  6663 */	store   | r0     << dst_ | arptr  << off_ ,
/*  6664 */	stmt    | 1604   << off_ ,	//	ldi 4,intv1   load integer one
/*  6665 */	load    | r1     << dst_ | intv1  << off_ ,
/*  6666 */	ldi     | r1     << dst_ ,
/*  6667 */	stmt    | 1605   << off_ ,	//	sti arnel   initialize element count
/*  6668 */	store   | ia     << dst_ | arnel  << off_ ,
// sar03:
/*  6669 */	stmt    | 1606   << off_ ,	//sar03	ldi 4,intv1   load one as default low bound
/*  6670 */	load    | r1     << dst_ | intv1  << off_ ,
/*  6671 */	ldi     | r1     << dst_ ,
/*  6672 */	stmt    | 1607   << off_ ,	//	sti arsvl   save as low bound
/*  6673 */	store   | ia     << dst_ | arsvl  << off_ ,
/*  6674 */	stmt    | 1608   << off_ ,	//	mov wc =ch_cl  set delimiter one = colon
/*  6675 */	loadi   | wc     << dst_ | ch_cl  << off_ ,
/*  6676 */	stmt    | 1609   << off_ ,	//	mov xl =ch_cm  set delimiter two = comma
/*  6677 */	loadi   | xl     << dst_ | ch_cm  << off_ ,
/*  6678 */	stmt    | 1610   << off_ ,	//	zer wa   retain blanks in prototype
/*  6679 */	move    | wa     << dst_ ,
/*  6680 */	stmt    | 1611   << off_ ,	//	jsr xscan   scan next bound
/*  6681 */	call    | xscan  << off_ ,
/*  6682 */	stmt    | 1612   << off_ ,	//	bne wa =num01 sar04 jump if not colon
/*  6683 */	loadi   | r2     << dst_ | num01  << off_ ,
/*  6684 */	bne     | wa     << dst_ | r2     << src_ | sar04  << off_ ,
/*  6685 */	stmt    | 1613   << off_ ,	//	jsr gtint   convert low bound
/*  6686 */	call    | gtint  << off_ ,
/*  6687 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6688 */	err     | 65     << off_ ,
/*  6689 */	stmt    | 1614   << off_ ,	//	ldi icval(xr)   load value of low bound
/*  6690 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  6691 */	ldi     | r1     << dst_ ,
/*  6692 */	stmt    | 1615   << off_ ,	//	sti arsvl   store low bound value
/*  6693 */	store   | ia     << dst_ | arsvl  << off_ ,
/*  6694 */	stmt    | 1616   << off_ ,	//	mov wc =ch_cm  set delimiter one = comma
/*  6695 */	loadi   | wc     << dst_ | ch_cm  << off_ ,
/*  6696 */	stmt    | 1617   << off_ ,	//	mov xl wc  and delimiter two = comma
/*  6697 */	move    | xl     << dst_ | wc     << src_ ,
/*  6698 */	stmt    | 1618   << off_ ,	//	zer wa   retain blanks in prototype
/*  6699 */	move    | wa     << dst_ ,
/*  6700 */	stmt    | 1619   << off_ ,	//	jsr xscan   scan high bound
/*  6701 */	call    | xscan  << off_ ,
// sar04:
/*  6702 */	stmt    | 1620   << off_ ,	//sar04	jsr gtint   convert high bound to integer
/*  6703 */	call    | gtint  << off_ ,
/*  6704 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6705 */	err     | 66     << off_ ,
/*  6706 */	stmt    | 1621   << off_ ,	//	ldi icval(xr)   get high bound
/*  6707 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  6708 */	ldi     | r1     << dst_ ,
/*  6709 */	stmt    | 1622   << off_ ,	//	sbi arsvl   subtract lower bound
/*  6710 */	load    | r1     << dst_ | arsvl  << off_ ,
/*  6711 */	sbi     | r1     << dst_ ,
/*  6712 */	stmt    | 1623   << off_ ,	//	iov sar10   bad dimension if overflow
/*  6713 */	iov     | sar10  << off_ ,
/*  6714 */	stmt    | 1624   << off_ ,	//	ilt sar10   bad dimension if negative
/*  6715 */	ilt     | sar10  << off_ ,
/*  6716 */	stmt    | 1625   << off_ ,	//	adi 4,intv1   add 1 to get dimension
/*  6717 */	load    | r1     << dst_ | intv1  << off_ ,
/*  6718 */	adi     | r1     << dst_ ,
/*  6719 */	stmt    | 1626   << off_ ,	//	iov sar10   bad dimension if overflow
/*  6720 */	iov     | sar10  << off_ ,
/*  6721 */	stmt    | 1627   << off_ ,	//	mov xl arptr  load offset (also pass indicator)
/*  6722 */	load    | xl     << dst_ | arptr  << off_ ,
/*  6723 */	stmt    | 1628   << off_ ,	//	bze xl sar05  jump if first pass
/*  6724 */	bze     | xl     << dst_ | sar05  << off_ ,
/*  6725 */	stmt    | 1629   << off_ ,	//	add xl (xs)  point to current location in arblk
/*  6726 */	load    | r2     << dst_ | xs     << src_ ,
/*  6727 */	add     | xl     << dst_ | r2     << src_ ,
/*  6728 */	stmt    | 1630   << off_ ,	//	sti cfp_i(xl)   store dimension
/*  6729 */	store   | ia     << dst_ | xl     << src_ | cfp_i  << off_ ,
/*  6730 */	stmt    | 1631   << off_ ,	//	ldi arsvl   load low bound
/*  6731 */	load    | r1     << dst_ | arsvl  << off_ ,
/*  6732 */	ldi     | r1     << dst_ ,
/*  6733 */	stmt    | 1632   << off_ ,	//	sti (xl)   store low bound
/*  6734 */	store   | ia     << dst_ | xl     << src_ ,
/*  6735 */	stmt    | 1633   << off_ ,	//	add arptr *ardms  bump offset to next bounds
/*  6736 */	load    | r1     << dst_ | arptr  << off_ ,
/*  6737 */	loadi   | r2     << dst_ | ardms  << off_ ,
/*  6738 */	add     | r1     << dst_ | r2     << src_ ,
/*  6739 */	store   | r1     << dst_ | arptr  << off_ ,
/*  6740 */	stmt    | 1634   << off_ ,	//	brn sar06   jump to check for end of bounds
/*  6741 */	brn     | sar06  << off_ ,
// sar05:
/*  6742 */	stmt    | 1635   << off_ ,	//sar05	icv arcdm   bump dimension count
/*  6743 */	load    | r1     << dst_ | arcdm  << off_ ,
/*  6744 */	icv     | r1     << dst_ ,
/*  6745 */	store   | r1     << dst_ | arcdm  << off_ ,
/*  6746 */	stmt    | 1636   << off_ ,	//	mli arnel   multiply dimension by count so far
/*  6747 */	load    | r1     << dst_ | arnel  << off_ ,
/*  6748 */	mli     | r1     << dst_ ,
/*  6749 */	stmt    | 1637   << off_ ,	//	iov sar11   too large if overflow
/*  6750 */	iov     | sar11  << off_ ,
/*  6751 */	stmt    | 1638   << off_ ,	//	sti arnel   else store updated element count
/*  6752 */	store   | ia     << dst_ | arnel  << off_ ,
// sar06:
/*  6753 */	stmt    | 1639   << off_ ,	//sar06	bnz wa sar03  loop back unless end of bounds
/*  6754 */	bnz     | wa     << dst_ | sar03  << off_ ,
/*  6755 */	stmt    | 1640   << off_ ,	//	bnz arptr sar09  jump if end of pass 2
/*  6756 */	load    | r1     << dst_ | arptr  << off_ ,
/*  6757 */	bnz     | r1     << dst_ | sar09  << off_ ,
/*  6758 */	stmt    | 1641   << off_ ,	//	ldi arnel   get number of elements
/*  6759 */	load    | r1     << dst_ | arnel  << off_ ,
/*  6760 */	ldi     | r1     << dst_ ,
/*  6761 */	stmt    | 1642   << off_ ,	//	mfi wb sar11  get as addr integer, test ovflo
/*  6762 */	move    | wb     << dst_ | ia     << src_ ,
/*  6763 */	mfi     | sar11  << off_ ,
/*  6764 */	stmt    | 1643   << off_ ,	//	wtb wb   else convert to length in bytes
/*  6765 */	stmt    | 1644   << off_ ,	//	mov wa *arsi_  set size of standard fields
/*  6766 */	loadi   | wa     << dst_ | arsi_  << off_ ,
/*  6767 */	stmt    | 1645   << off_ ,	//	lct wc arcdm  set dimension count to control loop
/*  6768 */	load    | wc     << dst_ | arcdm  << off_ ,
// sar07:
/*  6769 */	stmt    | 1646   << off_ ,	//sar07	add wa *ardms  allow space for one set of bounds
/*  6770 */	loadi   | r2     << dst_ | ardms  << off_ ,
/*  6771 */	add     | wa     << dst_ | r2     << src_ ,
/*  6772 */	stmt    | 1647   << off_ ,	//	bct wc sar07  loop back till all accounted for
/*  6773 */	bct     | wc     << dst_ | sar07  << off_ ,
/*  6774 */	stmt    | 1648   << off_ ,	//	mov xl wa  save size (=arofs)
/*  6775 */	move    | xl     << dst_ | wa     << src_ ,
/*  6776 */	stmt    | 1649   << off_ ,	//	add wa wb  add space for elements
/*  6777 */	add     | wa     << dst_ | wb     << src_ ,
/*  6778 */	stmt    | 1650   << off_ ,	//	ica wa   allow for arpro prototype field
/*  6779 */	ica     | wa     << dst_ ,
/*  6780 */	stmt    | 1651   << off_ ,	//	bgt wa mxlen sar11 fail if too large
/*  6781 */	load    | r2     << dst_ | mxlen  << off_ ,
/*  6782 */	bgt     | wa     << dst_ | r2     << src_ | sar11  << off_ ,
/*  6783 */	stmt    | 1652   << off_ ,	//	jsr alloc   else allocate arblk
/*  6784 */	call    | alloc  << off_ ,
/*  6785 */	stmt    | 1653   << off_ ,	//	mov wb (xs)  load default value
/*  6786 */	load    | wb     << dst_ | xs     << src_ ,
/*  6787 */	stmt    | 1654   << off_ ,	//	mov (xs) xr  save arblk pointer
/*  6788 */	store   | xr     << dst_ | xs     << src_ ,
/*  6789 */	stmt    | 1655   << off_ ,	//	mov wc wa  save length in bytes
/*  6790 */	move    | wc     << dst_ | wa     << src_ ,
/*  6791 */	stmt    | 1656   << off_ ,	//	btw wa   convert length back to words
/*  6792 */	stmt    | 1657   << off_ ,	//	lct wa wa  set counter to control loop
// sar08:
/*  6793 */	stmt    | 1658   << off_ ,	//sar08	mov (xr)+ wb  set one word
/*  6794 */	store   | wb     << dst_ | xr     << src_ ,
/*  6795 */	ica     | xr     << dst_ ,
/*  6796 */	stmt    | 1659   << off_ ,	//	bct wa sar08  loop till all set
/*  6797 */	bct     | wa     << dst_ | sar08  << off_ ,
/*  6798 */	stmt    | 1660   << off_ ,	//	mov xr (xs)+  reload arblk pointer
/*  6799 */	load    | xr     << dst_ | xs     << src_ ,
/*  6800 */	ica     | xs     << dst_ ,
/*  6801 */	stmt    | 1661   << off_ ,	//	mov wb (xs)  load prototype
/*  6802 */	load    | wb     << dst_ | xs     << src_ ,
/*  6803 */	stmt    | 1662   << off_ ,	//	mov (xr) =b_art  set type word
/*  6804 */	loadi   | r1     << dst_ | b_art  << off_ ,
/*  6805 */	store   | r1     << dst_ | xr     << src_ ,
/*  6806 */	stmt    | 1663   << off_ ,	//	mov arlen(xr) wc  store length in bytes
/*  6807 */	store   | wc     << dst_ | xr     << src_ | arlen  << off_ ,
/*  6808 */	stmt    | 1664   << off_ ,	//	zer idval(xr)   zero id till we get it built
/*  6809 */	store   | r0     << dst_ | xr     << src_ | idval  << off_ ,
/*  6810 */	stmt    | 1665   << off_ ,	//	mov arofs(xr) xl  set prototype field ptr
/*  6811 */	store   | xl     << dst_ | xr     << src_ | arofs  << off_ ,
/*  6812 */	stmt    | 1666   << off_ ,	//	mov arndm(xr) arcdm  set number of dimensions
/*  6813 */	load    | r1     << dst_ | arcdm  << off_ ,
/*  6814 */	store   | r1     << dst_ | xr     << src_ | arndm  << off_ ,
/*  6815 */	stmt    | 1667   << off_ ,	//	mov wc xr  save arblk pointer
/*  6816 */	move    | wc     << dst_ | xr     << src_ ,
/*  6817 */	stmt    | 1668   << off_ ,	//	add xr xl  point to prototype field
/*  6818 */	add     | xr     << dst_ | xl     << src_ ,
/*  6819 */	stmt    | 1669   << off_ ,	//	mov (xr) wb  store prototype ptr in arblk
/*  6820 */	store   | wb     << dst_ | xr     << src_ ,
/*  6821 */	stmt    | 1670   << off_ ,	//	mov arptr *arlbd  set offset for pass 2 bounds scan
/*  6822 */	loadi   | r1     << dst_ | arlbd  << off_ ,
/*  6823 */	store   | r1     << dst_ | arptr  << off_ ,
/*  6824 */	stmt    | 1671   << off_ ,	//	mov r_xsc wb  reset string pointer for xscan
/*  6825 */	store   | wb     << dst_ | r_xsc  << off_ ,
/*  6826 */	stmt    | 1672   << off_ ,	//	mov (xs) wc  store arblk pointer on stack
/*  6827 */	store   | wc     << dst_ | xs     << src_ ,
/*  6828 */	stmt    | 1673   << off_ ,	//	zer xsofs   reset offset ptr to start of string
/*  6829 */	store   | r0     << dst_ | xsofs  << off_ ,
/*  6830 */	stmt    | 1674   << off_ ,	//	brn sar03   jump back to rescan bounds
/*  6831 */	brn     | sar03  << off_ ,
// sar09:
/*  6832 */	stmt    | 1675   << off_ ,	//sar09	mov xr (xs)+  reload pointer to arblk
/*  6833 */	load    | xr     << dst_ | xs     << src_ ,
/*  6834 */	ica     | xs     << dst_ ,
/*  6835 */	stmt    | 1676   << off_ ,	//	brn exsid   exit setting idval
/*  6836 */	brn     | exsid  << off_ ,
// sar10:
/*  6837 */	stmt    | 1677   << off_ ,	//sar10	erb 067 array dimension is zero, negative or out of range
/*  6838 */	erb     | 67     << off_ ,
// sar11:
/*  6839 */	stmt    | 1678   << off_ ,	//sar11	erb 068 array size exceeds maximum permitted
/*  6840 */	erb     | 68     << off_ ,
/*  6841 */	0       ,
// s_atn:
/*  6842 */	stmt    | 1679   << off_ ,	//	mov xr (xs)+  get argument
/*  6843 */	load    | xr     << dst_ | xs     << src_ ,
/*  6844 */	ica     | xs     << dst_ ,
/*  6845 */	stmt    | 1680   << off_ ,	//	jsr gtrea   convert to real
/*  6846 */	call    | gtrea  << off_ ,
/*  6847 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6848 */	err     | 301    << off_ ,
/*  6849 */	stmt    | 1681   << off_ ,	//	ldr rcval(xr)   load accumulator with argument
/*  6850 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  6851 */	ldr     | r1     << dst_ ,
/*  6852 */	stmt    | 1682   << off_ ,	//	atn    take arctangent
/*  6853 */	realop  | atn    << off_ ,
/*  6854 */	stmt    | 1683   << off_ ,	//	brn exrea   overflow, out of range not possible
/*  6855 */	brn     | exrea  << off_ ,
/*  6856 */	0       ,
// s_bsp:
/*  6857 */	stmt    | 1684   << off_ ,	//	jsr iofcb   call fcblk routine
/*  6858 */	call    | iofcb  << off_ ,
/*  6859 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  6860 */	err     | 316    << off_ ,
/*  6861 */	err     | 316    << off_ ,
/*  6862 */	err     | 317    << off_ ,
/*  6863 */	stmt    | 1685   << off_ ,	//	jsr sysbs   call backspace file function
/*  6864 */	sys     | sysbs_ << off_ ,
/*  6865 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  6866 */	err     | 317    << off_ ,
/*  6867 */	err     | 318    << off_ ,
/*  6868 */	err     | 319    << off_ ,
/*  6869 */	stmt    | 1686   << off_ ,	//	brn exnul   return null as result
/*  6870 */	brn     | exnul  << off_ ,
/*  6871 */	0       ,
// s_brk:
/*  6872 */	stmt    | 1687   << off_ ,	//	mov wb =p_bks  set pcode for single char case
/*  6873 */	loadi   | wb     << dst_ | p_bks  << off_ ,
/*  6874 */	stmt    | 1688   << off_ ,	//	mov xl =p_brk  pcode for multi-char case
/*  6875 */	loadi   | xl     << dst_ | p_brk  << off_ ,
/*  6876 */	stmt    | 1689   << off_ ,	//	mov wc =p_bkd  pcode for expression case
/*  6877 */	loadi   | wc     << dst_ | p_bkd  << off_ ,
/*  6878 */	stmt    | 1690   << off_ ,	//	jsr patst   call common routine to build node
/*  6879 */	call    | patst  << off_ ,
/*  6880 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6881 */	err     | 69     << off_ ,
/*  6882 */	stmt    | 1691   << off_ ,	//	mov -(xs) xr  stack result
/*  6883 */	dca     | xs     << dst_ ,
/*  6884 */	store   | xr     << dst_ | xs     << src_ ,
/*  6885 */	stmt    | 1692   << off_ ,	//	lcw xr   get next code word
/*  6886 */	lcw     | xr     << dst_ ,
/*  6887 */	stmt    | 1693   << off_ ,	//	bri (xr)   execute it
/*  6888 */	load    | r1     << dst_ | xr     << src_ ,
/*  6889 */	bri     | r1     << dst_ ,
/*  6890 */	0       ,
// s_bkx:
/*  6891 */	stmt    | 1694   << off_ ,	//	mov wb =p_bks  pcode for single char argument
/*  6892 */	loadi   | wb     << dst_ | p_bks  << off_ ,
/*  6893 */	stmt    | 1695   << off_ ,	//	mov xl =p_brk  pcode for multi-char argument
/*  6894 */	loadi   | xl     << dst_ | p_brk  << off_ ,
/*  6895 */	stmt    | 1696   << off_ ,	//	mov wc =p_bxd  pcode for expression case
/*  6896 */	loadi   | wc     << dst_ | p_bxd  << off_ ,
/*  6897 */	stmt    | 1697   << off_ ,	//	jsr patst   call common routine to build node
/*  6898 */	call    | patst  << off_ ,
/*  6899 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6900 */	err     | 70     << off_ ,
/*  6901 */	stmt    | 1698   << off_ ,	//	mov -(xs) xr  save ptr to break node
/*  6902 */	dca     | xs     << dst_ ,
/*  6903 */	store   | xr     << dst_ | xs     << src_ ,
/*  6904 */	stmt    | 1699   << off_ ,	//	mov wb =p_bkx  set pcode for breakx node
/*  6905 */	loadi   | wb     << dst_ | p_bkx  << off_ ,
/*  6906 */	stmt    | 1700   << off_ ,	//	jsr pbild   build it
/*  6907 */	call    | pbild  << off_ ,
/*  6908 */	stmt    | 1701   << off_ ,	//	mov pthen(xr) (xs)  set break node as successor
/*  6909 */	load    | r1     << dst_ | xs     << src_ ,
/*  6910 */	store   | r1     << dst_ | xr     << src_ | pthen  << off_ ,
/*  6911 */	stmt    | 1702   << off_ ,	//	mov wb =p_alt  set pcode for alternation node
/*  6912 */	loadi   | wb     << dst_ | p_alt  << off_ ,
/*  6913 */	stmt    | 1703   << off_ ,	//	jsr pbild   build (parm1=alt=breakx node)
/*  6914 */	call    | pbild  << off_ ,
/*  6915 */	stmt    | 1704   << off_ ,	//	mov wa xr  save ptr to alternation node
/*  6916 */	move    | wa     << dst_ | xr     << src_ ,
/*  6917 */	stmt    | 1705   << off_ ,	//	mov xr (xs)  point to break node
/*  6918 */	load    | xr     << dst_ | xs     << src_ ,
/*  6919 */	stmt    | 1706   << off_ ,	//	mov pthen(xr) wa  set alternate node as successor
/*  6920 */	store   | wa     << dst_ | xr     << src_ | pthen  << off_ ,
/*  6921 */	stmt    | 1707   << off_ ,	//	lcw xr   result on stack
/*  6922 */	lcw     | xr     << dst_ ,
/*  6923 */	stmt    | 1708   << off_ ,	//	bri (xr)   execute next code word
/*  6924 */	load    | r1     << dst_ | xr     << src_ ,
/*  6925 */	bri     | r1     << dst_ ,
/*  6926 */	0       ,
// s_chr:
/*  6927 */	stmt    | 1709   << off_ ,	//	jsr gtsmi   convert arg to integer
/*  6928 */	call    | gtsmi  << off_ ,
/*  6929 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  6930 */	err     | 281    << off_ ,
/*  6931 */	ppm     | schr1  << off_ ,
/*  6932 */	stmt    | 1710   << off_ ,	//	bge wc =cfp_a schr1 see if out of range of host set
/*  6933 */	loadi   | r2     << dst_ | cfp_a  << off_ ,
/*  6934 */	bge     | wc     << dst_ | r2     << src_ | schr1  << off_ ,
/*  6935 */	stmt    | 1711   << off_ ,	//	mov wa =num01  if not set scblk allocation
/*  6936 */	loadi   | wa     << dst_ | num01  << off_ ,
/*  6937 */	stmt    | 1712   << off_ ,	//	mov wb wc  save char code
/*  6938 */	move    | wb     << dst_ | wc     << src_ ,
/*  6939 */	stmt    | 1713   << off_ ,	//	jsr alocs   allocate 1 bau scblk
/*  6940 */	call    | alocs  << off_ ,
/*  6941 */	stmt    | 1714   << off_ ,	//	mov xl xr  copy scblk pointer
/*  6942 */	move    | xl     << dst_ | xr     << src_ ,
/*  6943 */	stmt    | 1715   << off_ ,	//	psc xl   get set to stuff char
/*  6944 */	psc     | xl     << dst_ ,
/*  6945 */	stmt    | 1716   << off_ ,	//	sch wb (xl)  stuff it
/*  6946 */	store   | wb     << dst_ | xl     << src_ ,
/*  6947 */	stmt    | 1717   << off_ ,	//	csc xl   complete store character
/*  6948 */	stmt    | 1718   << off_ ,	//	zer xl   clear slop in xl
/*  6949 */	move    | xl     << dst_ ,
/*  6950 */	stmt    | 1719   << off_ ,	//	mov -(xs) xr  stack result
/*  6951 */	dca     | xs     << dst_ ,
/*  6952 */	store   | xr     << dst_ | xs     << src_ ,
/*  6953 */	stmt    | 1720   << off_ ,	//	lcw xr   get next code word
/*  6954 */	lcw     | xr     << dst_ ,
/*  6955 */	stmt    | 1721   << off_ ,	//	bri (xr)   execute it
/*  6956 */	load    | r1     << dst_ | xr     << src_ ,
/*  6957 */	bri     | r1     << dst_ ,
// schr1:
/*  6958 */	stmt    | 1722   << off_ ,	//schr1	erb 282 char argument not in range
/*  6959 */	erb     | 282    << off_ ,
/*  6960 */	0       ,
// s_chp:
/*  6961 */	stmt    | 1723   << off_ ,	//	mov xr (xs)+  get argument
/*  6962 */	load    | xr     << dst_ | xs     << src_ ,
/*  6963 */	ica     | xs     << dst_ ,
/*  6964 */	stmt    | 1724   << off_ ,	//	jsr gtrea   convert to real
/*  6965 */	call    | gtrea  << off_ ,
/*  6966 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6967 */	err     | 302    << off_ ,
/*  6968 */	stmt    | 1725   << off_ ,	//	ldr rcval(xr)   load accumulator with argument
/*  6969 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  6970 */	ldr     | r1     << dst_ ,
/*  6971 */	stmt    | 1726   << off_ ,	//	chp    truncate to integer valued real
/*  6972 */	realop  | chp    << off_ ,
/*  6973 */	stmt    | 1727   << off_ ,	//	brn exrea   no overflow possible
/*  6974 */	brn     | exrea  << off_ ,
/*  6975 */	0       ,
// s_clr:
/*  6976 */	stmt    | 1728   << off_ ,	//	jsr xscni   initialize to scan argument
/*  6977 */	call    | xscni  << off_ ,
/*  6978 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  6979 */	err     | 71     << off_ ,
/*  6980 */	ppm     | sclr2  << off_ ,
// sclr1:
/*  6981 */	stmt    | 1729   << off_ ,	//sclr1	mov wc =ch_cm  set delimiter one = comma
/*  6982 */	loadi   | wc     << dst_ | ch_cm  << off_ ,
/*  6983 */	stmt    | 1730   << off_ ,	//	mov xl wc  delimiter two = comma
/*  6984 */	move    | xl     << dst_ | wc     << src_ ,
/*  6985 */	stmt    | 1731   << off_ ,	//	mnz wa   skip/trim blanks in prototype
/*  6986 */	move    | wa     << dst_ | xs     << src_ ,
/*  6987 */	stmt    | 1732   << off_ ,	//	jsr xscan   scan next variable name
/*  6988 */	call    | xscan  << off_ ,
/*  6989 */	stmt    | 1733   << off_ ,	//	jsr gtnvr   locate vrblk
/*  6990 */	call    | gtnvr  << off_ ,
/*  6991 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  6992 */	err     | 72     << off_ ,
/*  6993 */	stmt    | 1734   << off_ ,	//	zer vrget(xr)   else flag by zeroing vrget field
/*  6994 */	store   | r0     << dst_ | xr     << src_ | vrget  << off_ ,
/*  6995 */	stmt    | 1735   << off_ ,	//	bnz wa sclr1  loop back if stopped by comma
/*  6996 */	bnz     | wa     << dst_ | sclr1  << off_ ,
// sclr2:
/*  6997 */	stmt    | 1736   << off_ ,	//sclr2	mov wb hshtb  point to start of hash table
/*  6998 */	load    | wb     << dst_ | hshtb  << off_ ,
// sclr3:
/*  6999 */	stmt    | 1737   << off_ ,	//sclr3	beq wb hshte exnul exit returning null if none left
/*  7000 */	load    | r2     << dst_ | hshte  << off_ ,
/*  7001 */	beq     | wb     << dst_ | r2     << src_ | exnul  << off_ ,
/*  7002 */	stmt    | 1738   << off_ ,	//	mov xr wb  else copy slot pointer
/*  7003 */	move    | xr     << dst_ | wb     << src_ ,
/*  7004 */	stmt    | 1739   << off_ ,	//	ica wb   bump slot pointer
/*  7005 */	ica     | wb     << dst_ ,
/*  7006 */	stmt    | 1740   << off_ ,	//	sub xr *vrnxt  set offset to merge into loop
/*  7007 */	loadi   | r2     << dst_ | vrnxt  << off_ ,
/*  7008 */	sub     | xr     << dst_ | r2     << src_ ,
// sclr4:
/*  7009 */	stmt    | 1741   << off_ ,	//sclr4	mov xr vrnxt(xr)  point to next vrblk on chain
/*  7010 */	load    | xr     << dst_ | xr     << src_ | vrnxt  << off_ ,
/*  7011 */	stmt    | 1742   << off_ ,	//	bze xr sclr3  jump for next bucket if chain end
/*  7012 */	bze     | xr     << dst_ | sclr3  << off_ ,
/*  7013 */	stmt    | 1743   << off_ ,	//	bnz vrget(xr) sclr5  jump if not flagged
/*  7014 */	load    | r1     << dst_ | xr     << src_ | vrget  << off_ ,
/*  7015 */	bnz     | r1     << dst_ | sclr5  << off_ ,
/*  7016 */	stmt    | 1744   << off_ ,	//	jsr setvr   for flagged var, restore vrget
/*  7017 */	call    | setvr  << off_ ,
/*  7018 */	stmt    | 1745   << off_ ,	//	brn sclr4   and loop back for next vrblk
/*  7019 */	brn     | sclr4  << off_ ,
// sclr5:
/*  7020 */	stmt    | 1746   << off_ ,	//sclr5	beq vrsto(xr) =b_vre sclr4 check for protected variable
/*  7021 */	load    | r1     << dst_ | xr     << src_ | vrsto  << off_ ,
/*  7022 */	loadi   | r2     << dst_ | b_vre  << off_ ,
/*  7023 */	beq     | r1     << dst_ | r2     << src_ | sclr4  << off_ ,
/*  7024 */	stmt    | 1747   << off_ ,	//	mov xl xr  copy vrblk pointer
/*  7025 */	move    | xl     << dst_ | xr     << src_ ,
// sclr6:
/*  7026 */	stmt    | 1748   << off_ ,	//sclr6	mov wa xl  save block pointer
/*  7027 */	move    | wa     << dst_ | xl     << src_ ,
/*  7028 */	stmt    | 1749   << off_ ,	//	mov xl vrval(xl)  load next value field
/*  7029 */	load    | xl     << dst_ | xl     << src_ | vrval  << off_ ,
/*  7030 */	stmt    | 1750   << off_ ,	//	beq (xl) =b_trt sclr6 loop back if trapped
/*  7031 */	load    | r1     << dst_ | xl     << src_ ,
/*  7032 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/*  7033 */	beq     | r1     << dst_ | r2     << src_ | sclr6  << off_ ,
/*  7034 */	stmt    | 1751   << off_ ,	//	mov xl wa  restore block pointer
/*  7035 */	move    | xl     << dst_ | wa     << src_ ,
/*  7036 */	stmt    | 1752   << off_ ,	//	mov vrval(xl) =nulls  store null constant value
/*  7037 */	loadi   | r1     << dst_ | nulls  << off_ ,
/*  7038 */	store   | r1     << dst_ | xl     << src_ | vrval  << off_ ,
/*  7039 */	stmt    | 1753   << off_ ,	//	brn sclr4   loop back for next vrblk
/*  7040 */	brn     | sclr4  << off_ ,
/*  7041 */	0       ,
// s_cod:
/*  7042 */	stmt    | 1754   << off_ ,	//	mov xr (xs)+  load argument
/*  7043 */	load    | xr     << dst_ | xs     << src_ ,
/*  7044 */	ica     | xs     << dst_ ,
/*  7045 */	stmt    | 1755   << off_ ,	//	jsr gtcod   convert to code
/*  7046 */	call    | gtcod  << off_ ,
/*  7047 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7048 */	ppm     | exfal  << off_ ,
/*  7049 */	stmt    | 1756   << off_ ,	//	mov -(xs) xr  stack result
/*  7050 */	dca     | xs     << dst_ ,
/*  7051 */	store   | xr     << dst_ | xs     << src_ ,
/*  7052 */	stmt    | 1757   << off_ ,	//	zer r_ccb   forget interim code block
/*  7053 */	store   | r0     << dst_ | r_ccb  << off_ ,
/*  7054 */	stmt    | 1758   << off_ ,	//	lcw xr   get next code word
/*  7055 */	lcw     | xr     << dst_ ,
/*  7056 */	stmt    | 1759   << off_ ,	//	bri (xr)   execute it
/*  7057 */	load    | r1     << dst_ | xr     << src_ ,
/*  7058 */	bri     | r1     << dst_ ,
/*  7059 */	0       ,
// s_col:
/*  7060 */	stmt    | 1760   << off_ ,	//	mov xr (xs)+  load argument
/*  7061 */	load    | xr     << dst_ | xs     << src_ ,
/*  7062 */	ica     | xs     << dst_ ,
/*  7063 */	stmt    | 1761   << off_ ,	//	jsr gtint   convert to integer
/*  7064 */	call    | gtint  << off_ ,
/*  7065 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7066 */	err     | 73     << off_ ,
/*  7067 */	stmt    | 1762   << off_ ,	//	ldi icval(xr)   load collect argument
/*  7068 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  7069 */	ldi     | r1     << dst_ ,
/*  7070 */	stmt    | 1763   << off_ ,	//	sti clsvi   save collect argument
/*  7071 */	store   | ia     << dst_ | clsvi  << off_ ,
/*  7072 */	stmt    | 1764   << off_ ,	//	zer wb   set no move up
/*  7073 */	move    | wb     << dst_ ,
/*  7074 */	stmt    | 1765   << off_ ,	//	zer r_ccb   forget interim code block
/*  7075 */	store   | r0     << dst_ | r_ccb  << off_ ,
/*  7076 */	stmt    | 1766   << off_ ,	//	zer dnams   collect sediment too
/*  7077 */	store   | r0     << dst_ | dnams  << off_ ,
/*  7078 */	stmt    | 1767   << off_ ,	//	jsr gbcol   perform garbage collection
/*  7079 */	call    | gbcol  << off_ ,
/*  7080 */	stmt    | 1768   << off_ ,	//	mov dnams xr  record new sediment size
/*  7081 */	store   | xr     << dst_ | dnams  << off_ ,
/*  7082 */	stmt    | 1769   << off_ ,	//	mov wa dname  point to end of memory
/*  7083 */	load    | wa     << dst_ | dname  << off_ ,
/*  7084 */	stmt    | 1770   << off_ ,	//	sub wa dnamp  subtract next location
/*  7085 */	load    | r2     << dst_ | dnamp  << off_ ,
/*  7086 */	sub     | wa     << dst_ | r2     << src_ ,
/*  7087 */	stmt    | 1771   << off_ ,	//	btw wa   convert bytes to words
/*  7088 */	stmt    | 1772   << off_ ,	//	mti wa   convert words available as integer
/*  7089 */	move    | ia     << dst_ | wa     << src_ ,
/*  7090 */	stmt    | 1773   << off_ ,	//	sbi clsvi   subtract argument
/*  7091 */	load    | r1     << dst_ | clsvi  << off_ ,
/*  7092 */	sbi     | r1     << dst_ ,
/*  7093 */	stmt    | 1774   << off_ ,	//	iov exfal   fail if overflow
/*  7094 */	iov     | exfal  << off_ ,
/*  7095 */	stmt    | 1775   << off_ ,	//	ilt exfal   fail if not enough
/*  7096 */	ilt     | exfal  << off_ ,
/*  7097 */	stmt    | 1776   << off_ ,	//	adi clsvi   else recompute available
/*  7098 */	load    | r1     << dst_ | clsvi  << off_ ,
/*  7099 */	adi     | r1     << dst_ ,
/*  7100 */	stmt    | 1777   << off_ ,	//	brn exint   and exit with integer result
/*  7101 */	brn     | exint  << off_ ,
/*  7102 */	0       ,
// s_cnv:
/*  7103 */	stmt    | 1778   << off_ ,	//	jsr gtstg   convert second argument to string
/*  7104 */	call    | gtstg  << off_ ,
/*  7105 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7106 */	ppm     | scv29  << off_ ,
/*  7107 */	stmt    | 1779   << off_ ,	//	bze wa scv29  or if null string
/*  7108 */	bze     | wa     << dst_ | scv29  << off_ ,
/*  7109 */	stmt    | 1780   << off_ ,	//	mov xl (xs)  load first argument
/*  7110 */	load    | xl     << dst_ | xs     << src_ ,
/*  7111 */	stmt    | 1781   << off_ ,	//	bne (xl) =b_pdt scv01 jump if not program defined
/*  7112 */	load    | r1     << dst_ | xl     << src_ ,
/*  7113 */	loadi   | r2     << dst_ | b_pdt  << off_ ,
/*  7114 */	bne     | r1     << dst_ | r2     << src_ | scv01  << off_ ,
/*  7115 */	stmt    | 1782   << off_ ,	//	mov xl pddfp(xl)  point to dfblk
/*  7116 */	load    | xl     << dst_ | xl     << src_ | pddfp  << off_ ,
/*  7117 */	stmt    | 1783   << off_ ,	//	mov xl dfnam(xl)  load datatype name
/*  7118 */	load    | xl     << dst_ | xl     << src_ | dfnam  << off_ ,
/*  7119 */	stmt    | 1784   << off_ ,	//	jsr ident   compare with second arg
/*  7120 */	call    | ident  << off_ ,
/*  7121 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7122 */	ppm     | exits  << off_ ,
/*  7123 */	stmt    | 1785   << off_ ,	//	brn exfal   else fail
/*  7124 */	brn     | exfal  << off_ ,
// scv01:
/*  7125 */	stmt    | 1786   << off_ ,	//scv01	mov -(xs) xr  save string argument
/*  7126 */	dca     | xs     << dst_ ,
/*  7127 */	store   | xr     << dst_ | xs     << src_ ,
/*  7128 */	stmt    | 1787   << off_ ,	//	mov xl =svctb  point to table of names to compare
/*  7129 */	loadi   | xl     << dst_ | svctb  << off_ ,
/*  7130 */	stmt    | 1788   << off_ ,	//	zer wb   initialize counter
/*  7131 */	move    | wb     << dst_ ,
/*  7132 */	stmt    | 1789   << off_ ,	//	mov wc wa  save length of argument string
/*  7133 */	move    | wc     << dst_ | wa     << src_ ,
// scv02:
/*  7134 */	stmt    | 1790   << off_ ,	//scv02	mov xr (xl)+  load next table entry, bump pointer
/*  7135 */	load    | xr     << dst_ | xl     << src_ ,
/*  7136 */	ica     | xl     << dst_ ,
/*  7137 */	stmt    | 1791   << off_ ,	//	bze xr exfal  fail if zero marking end of list
/*  7138 */	bze     | xr     << dst_ | exfal  << off_ ,
/*  7139 */	stmt    | 1792   << off_ ,	//	bne wc sclen(xr) scv05 jump if wrong length
/*  7140 */	load    | r2     << dst_ | xr     << src_ | sclen  << off_ ,
/*  7141 */	bne     | wc     << dst_ | r2     << src_ | scv05  << off_ ,
/*  7142 */	stmt    | 1793   << off_ ,	//	mov cnvtp xl  else store table pointer
/*  7143 */	store   | xl     << dst_ | cnvtp  << off_ ,
/*  7144 */	stmt    | 1794   << off_ ,	//	plc xr   point to chars of table entry
/*  7145 */	plc     | xr     << dst_ ,
/*  7146 */	stmt    | 1795   << off_ ,	//	mov xl (xs)  load pointer to string argument
/*  7147 */	load    | xl     << dst_ | xs     << src_ ,
/*  7148 */	stmt    | 1796   << off_ ,	//	plc xl   point to chars of string arg
/*  7149 */	plc     | xl     << dst_ ,
/*  7150 */	stmt    | 1797   << off_ ,	//	mov wa wc  set number of chars to compare
/*  7151 */	move    | wa     << dst_ | wc     << src_ ,
/*  7152 */	stmt    | 1798   << off_ ,	//	cmc scv04 scv04  compare, jump if no match
/*  7153 */	loadi   | r1     << dst_ | scv04  << src_ ,
/*  7154 */	loadi   | r2     << dst_ | scv04  << src_ ,
/*  7155 */	cmc     ,
// scv03:
/*  7156 */	stmt    | 1799   << off_ ,	//scv03	mov xl wb  copy entry number
/*  7157 */	move    | xl     << dst_ | wb     << src_ ,
/*  7158 */	stmt    | 1800   << off_ ,	//	ica xs   pop string arg off stack
/*  7159 */	ica     | xs     << dst_ ,
/*  7160 */	stmt    | 1801   << off_ ,	//	mov xr (xs)+  load first argument
/*  7161 */	load    | xr     << dst_ | xs     << src_ ,
/*  7162 */	ica     | xs     << dst_ ,
/*  7163 */	stmt    | 1802   << off_ ,	//	bsw xl cnvtt  jump to appropriate routine
/*  7164 */	loadi   | r1     << dst_ | cnvtt  << off_ ,
/*  7165 */	bsw     | xl     << dst_ | r1     << src_ ,
/*  7166 */	scv06   ,
/*  7167 */	scv07   ,
/*  7168 */	scv09   ,
/*  7169 */	scv10   ,
/*  7170 */	scv11   ,
/*  7171 */	scv19   ,
/*  7172 */	scv25   ,
/*  7173 */	scv26   ,
/*  7174 */	scv27   ,
/*  7175 */	scv08   ,
// scv04:
/*  7176 */	stmt    | 1803   << off_ ,	//scv04	mov xl cnvtp  restore table pointer, merge
/*  7177 */	load    | xl     << dst_ | cnvtp  << off_ ,
// scv05:
/*  7178 */	stmt    | 1804   << off_ ,	//scv05	icv wb   bump entry number
/*  7179 */	icv     | wb     << dst_ ,
/*  7180 */	stmt    | 1805   << off_ ,	//	brn scv02   loop back to check next entry
/*  7181 */	brn     | scv02  << off_ ,
// scv06:
/*  7182 */	stmt    | 1806   << off_ ,	//scv06	mov -(xs) xr  replace string argument on stack
/*  7183 */	dca     | xs     << dst_ ,
/*  7184 */	store   | xr     << dst_ | xs     << src_ ,
/*  7185 */	stmt    | 1807   << off_ ,	//	jsr gtstg   convert to string
/*  7186 */	call    | gtstg  << off_ ,
/*  7187 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7188 */	ppm     | exfal  << off_ ,
/*  7189 */	stmt    | 1808   << off_ ,	//	mov -(xs) xr  stack result
/*  7190 */	dca     | xs     << dst_ ,
/*  7191 */	store   | xr     << dst_ | xs     << src_ ,
/*  7192 */	stmt    | 1809   << off_ ,	//	lcw xr   get next code word
/*  7193 */	lcw     | xr     << dst_ ,
/*  7194 */	stmt    | 1810   << off_ ,	//	bri (xr)   execute it
/*  7195 */	load    | r1     << dst_ | xr     << src_ ,
/*  7196 */	bri     | r1     << dst_ ,
// scv07:
/*  7197 */	stmt    | 1811   << off_ ,	//scv07	jsr gtint   convert to integer
/*  7198 */	call    | gtint  << off_ ,
/*  7199 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7200 */	ppm     | exfal  << off_ ,
/*  7201 */	stmt    | 1812   << off_ ,	//	mov -(xs) xr  stack result
/*  7202 */	dca     | xs     << dst_ ,
/*  7203 */	store   | xr     << dst_ | xs     << src_ ,
/*  7204 */	stmt    | 1813   << off_ ,	//	lcw xr   get next code word
/*  7205 */	lcw     | xr     << dst_ ,
/*  7206 */	stmt    | 1814   << off_ ,	//	bri (xr)   execute it
/*  7207 */	load    | r1     << dst_ | xr     << src_ ,
/*  7208 */	bri     | r1     << dst_ ,
// scv08:
/*  7209 */	stmt    | 1815   << off_ ,	//scv08	jsr gtrea   convert to real
/*  7210 */	call    | gtrea  << off_ ,
/*  7211 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7212 */	ppm     | exfal  << off_ ,
/*  7213 */	stmt    | 1816   << off_ ,	//	mov -(xs) xr  stack result
/*  7214 */	dca     | xs     << dst_ ,
/*  7215 */	store   | xr     << dst_ | xs     << src_ ,
/*  7216 */	stmt    | 1817   << off_ ,	//	lcw xr   get next code word
/*  7217 */	lcw     | xr     << dst_ ,
/*  7218 */	stmt    | 1818   << off_ ,	//	bri (xr)   execute it
/*  7219 */	load    | r1     << dst_ | xr     << src_ ,
/*  7220 */	bri     | r1     << dst_ ,
// scv09:
/*  7221 */	stmt    | 1819   << off_ ,	//scv09	beq (xr) =b_nml exixr return if already a name
/*  7222 */	load    | r1     << dst_ | xr     << src_ ,
/*  7223 */	loadi   | r2     << dst_ | b_nml  << off_ ,
/*  7224 */	beq     | r1     << dst_ | r2     << src_ | exixr  << off_ ,
/*  7225 */	stmt    | 1820   << off_ ,	//	jsr gtnvr   else try string to name convert
/*  7226 */	call    | gtnvr  << off_ ,
/*  7227 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7228 */	ppm     | exfal  << off_ ,
/*  7229 */	stmt    | 1821   << off_ ,	//	brn exvnm   else exit building nmblk for vrblk
/*  7230 */	brn     | exvnm  << off_ ,
// scv10:
/*  7231 */	stmt    | 1822   << off_ ,	//scv10	jsr gtpat   convert to pattern
/*  7232 */	call    | gtpat  << off_ ,
/*  7233 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7234 */	ppm     | exfal  << off_ ,
/*  7235 */	stmt    | 1823   << off_ ,	//	mov -(xs) xr  stack result
/*  7236 */	dca     | xs     << dst_ ,
/*  7237 */	store   | xr     << dst_ | xs     << src_ ,
/*  7238 */	stmt    | 1824   << off_ ,	//	lcw xr   get next code word
/*  7239 */	lcw     | xr     << dst_ ,
/*  7240 */	stmt    | 1825   << off_ ,	//	bri (xr)   execute it
/*  7241 */	load    | r1     << dst_ | xr     << src_ ,
/*  7242 */	bri     | r1     << dst_ ,
// scv11:
/*  7243 */	stmt    | 1826   << off_ ,	//scv11	mov -(xs) xr  save argument on stack
/*  7244 */	dca     | xs     << dst_ ,
/*  7245 */	store   | xr     << dst_ | xs     << src_ ,
/*  7246 */	stmt    | 1827   << off_ ,	//	zer wa   use table chain block addresses
/*  7247 */	move    | wa     << dst_ ,
/*  7248 */	stmt    | 1828   << off_ ,	//	jsr gtarr   get an array
/*  7249 */	call    | gtarr  << off_ ,
/*  7250 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  7251 */	ppm     | exfal  << off_ ,
/*  7252 */	ppm     | exfal  << off_ ,
/*  7253 */	stmt    | 1829   << off_ ,	//	mov xl (xs)+  reload original arg
/*  7254 */	load    | xl     << dst_ | xs     << src_ ,
/*  7255 */	ica     | xs     << dst_ ,
/*  7256 */	stmt    | 1830   << off_ ,	//	bne (xl) =b_tbt exsid exit if original not a table
/*  7257 */	load    | r1     << dst_ | xl     << src_ ,
/*  7258 */	loadi   | r2     << dst_ | b_tbt  << off_ ,
/*  7259 */	bne     | r1     << dst_ | r2     << src_ | exsid  << off_ ,
/*  7260 */	stmt    | 1831   << off_ ,	//	mov -(xs) xr  sort the intermediate array
/*  7261 */	dca     | xs     << dst_ ,
/*  7262 */	store   | xr     << dst_ | xs     << src_ ,
/*  7263 */	stmt    | 1832   << off_ ,	//	mov -(xs) =nulls  on first column
/*  7264 */	loadi   | r1     << dst_ | nulls  << off_ ,
/*  7265 */	dca     | xs     << dst_ ,
/*  7266 */	store   | r1     << dst_ | xs     << src_ ,
/*  7267 */	stmt    | 1833   << off_ ,	//	zer wa   sort ascending
/*  7268 */	move    | wa     << dst_ ,
/*  7269 */	stmt    | 1834   << off_ ,	//	jsr sorta   do sort
/*  7270 */	call    | sorta  << off_ ,
/*  7271 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7272 */	ppm     | exfal  << off_ ,
/*  7273 */	stmt    | 1835   << off_ ,	//	mov wb xr  save array result
/*  7274 */	move    | wb     << dst_ | xr     << src_ ,
/*  7275 */	stmt    | 1836   << off_ ,	//	ldi ardim(xr)   load dim 1 (number of elements)
/*  7276 */	load    | r1     << dst_ | xr     << src_ | ardim  << off_ ,
/*  7277 */	ldi     | r1     << dst_ ,
/*  7278 */	stmt    | 1837   << off_ ,	//	mfi wa   get as one word integer
/*  7279 */	move    | wa     << dst_ | ia     << src_ ,
/*  7280 */	stmt    | 1838   << off_ ,	//	lct wa wa  copy to control loop
/*  7281 */	stmt    | 1839   << off_ ,	//	add xr *arvl2  point to first element in array
/*  7282 */	loadi   | r2     << dst_ | arvl2  << off_ ,
/*  7283 */	add     | xr     << dst_ | r2     << src_ ,
// scv12:
/*  7284 */	stmt    | 1840   << off_ ,	//scv12	mov xl (xr)  get teblk address
/*  7285 */	load    | xl     << dst_ | xr     << src_ ,
/*  7286 */	stmt    | 1841   << off_ ,	//	mov (xr)+ tesub(xl)  replace with subscript
/*  7287 */	load    | r1     << dst_ | xl     << src_ | tesub  << off_ ,
/*  7288 */	store   | r1     << dst_ | xr     << src_ ,
/*  7289 */	ica     | xr     << dst_ ,
/*  7290 */	stmt    | 1842   << off_ ,	//	mov (xr)+ teval(xl)  replace with value
/*  7291 */	load    | r1     << dst_ | xl     << src_ | teval  << off_ ,
/*  7292 */	store   | r1     << dst_ | xr     << src_ ,
/*  7293 */	ica     | xr     << dst_ ,
/*  7294 */	stmt    | 1843   << off_ ,	//	bct wa scv12  loop till all copied over
/*  7295 */	bct     | wa     << dst_ | scv12  << off_ ,
/*  7296 */	stmt    | 1844   << off_ ,	//	mov xr wb  retrieve array address
/*  7297 */	move    | xr     << dst_ | wb     << src_ ,
/*  7298 */	stmt    | 1845   << off_ ,	//	brn exsid   exit setting id field
/*  7299 */	brn     | exsid  << off_ ,
// scv19:
/*  7300 */	stmt    | 1846   << off_ ,	//scv19	mov wa (xr)  load first word of block
/*  7301 */	load    | wa     << dst_ | xr     << src_ ,
/*  7302 */	stmt    | 1847   << off_ ,	//	mov -(xs) xr  replace arblk pointer on stack
/*  7303 */	dca     | xs     << dst_ ,
/*  7304 */	store   | xr     << dst_ | xs     << src_ ,
/*  7305 */	stmt    | 1848   << off_ ,	//	beq wa =b_tbt exits return arg if already a table
/*  7306 */	loadi   | r2     << dst_ | b_tbt  << off_ ,
/*  7307 */	beq     | wa     << dst_ | r2     << src_ | exits  << off_ ,
/*  7308 */	stmt    | 1849   << off_ ,	//	bne wa =b_art exfal else fail if not an array
/*  7309 */	loadi   | r2     << dst_ | b_art  << off_ ,
/*  7310 */	bne     | wa     << dst_ | r2     << src_ | exfal  << off_ ,
/*  7311 */	stmt    | 1850   << off_ ,	//	bne arndm(xr) =num02 exfal fail if not 2-dim array
/*  7312 */	load    | r1     << dst_ | xr     << src_ | arndm  << off_ ,
/*  7313 */	loadi   | r2     << dst_ | num02  << off_ ,
/*  7314 */	bne     | r1     << dst_ | r2     << src_ | exfal  << off_ ,
/*  7315 */	stmt    | 1851   << off_ ,	//	ldi ardm2(xr)   load dim 2
/*  7316 */	load    | r1     << dst_ | xr     << src_ | ardm2  << off_ ,
/*  7317 */	ldi     | r1     << dst_ ,
/*  7318 */	stmt    | 1852   << off_ ,	//	sbi 4,intv2   subtract 2 to compare
/*  7319 */	load    | r1     << dst_ | intv2  << off_ ,
/*  7320 */	sbi     | r1     << dst_ ,
/*  7321 */	stmt    | 1853   << off_ ,	//	ine exfal   fail if dim2 not 2
/*  7322 */	ine     | exfal  << off_ ,
/*  7323 */	stmt    | 1854   << off_ ,	//	ldi ardim(xr)   load dim 1 (number of elements)
/*  7324 */	load    | r1     << dst_ | xr     << src_ | ardim  << off_ ,
/*  7325 */	ldi     | r1     << dst_ ,
/*  7326 */	stmt    | 1855   << off_ ,	//	mfi wa   get as one word integer
/*  7327 */	move    | wa     << dst_ | ia     << src_ ,
/*  7328 */	stmt    | 1856   << off_ ,	//	lct wb wa  copy to control loop
/*  7329 */	move    | wb     << dst_ | wa     << src_ ,
/*  7330 */	stmt    | 1857   << off_ ,	//	add wa =tbsi_  add space for standard fields
/*  7331 */	loadi   | r2     << dst_ | tbsi_  << off_ ,
/*  7332 */	add     | wa     << dst_ | r2     << src_ ,
/*  7333 */	stmt    | 1858   << off_ ,	//	wtb wa   convert length to bytes
/*  7334 */	stmt    | 1859   << off_ ,	//	jsr alloc   allocate space for tbblk
/*  7335 */	call    | alloc  << off_ ,
/*  7336 */	stmt    | 1860   << off_ ,	//	mov wc xr  copy tbblk pointer
/*  7337 */	move    | wc     << dst_ | xr     << src_ ,
/*  7338 */	stmt    | 1861   << off_ ,	//	mov -(xs) xr  save tbblk pointer
/*  7339 */	dca     | xs     << dst_ ,
/*  7340 */	store   | xr     << dst_ | xs     << src_ ,
/*  7341 */	stmt    | 1862   << off_ ,	//	mov (xr)+ =b_tbt  store type word
/*  7342 */	loadi   | r1     << dst_ | b_tbt  << off_ ,
/*  7343 */	store   | r1     << dst_ | xr     << src_ ,
/*  7344 */	ica     | xr     << dst_ ,
/*  7345 */	stmt    | 1863   << off_ ,	//	zer (xr)+   store zero for idval for now
/*  7346 */	store   | r0     << dst_ | xr     << src_ ,
/*  7347 */	ica     | xr     << dst_ ,
/*  7348 */	stmt    | 1864   << off_ ,	//	mov (xr)+ wa  store length
/*  7349 */	store   | wa     << dst_ | xr     << src_ ,
/*  7350 */	ica     | xr     << dst_ ,
/*  7351 */	stmt    | 1865   << off_ ,	//	mov (xr)+ =nulls  null initial lookup value
/*  7352 */	loadi   | r1     << dst_ | nulls  << off_ ,
/*  7353 */	store   | r1     << dst_ | xr     << src_ ,
/*  7354 */	ica     | xr     << dst_ ,
// scv20:
/*  7355 */	stmt    | 1866   << off_ ,	//scv20	mov (xr)+ wc  set bucket ptr to point to tbblk
/*  7356 */	store   | wc     << dst_ | xr     << src_ ,
/*  7357 */	ica     | xr     << dst_ ,
/*  7358 */	stmt    | 1867   << off_ ,	//	bct wb scv20  loop till all initialized
/*  7359 */	bct     | wb     << dst_ | scv20  << off_ ,
/*  7360 */	stmt    | 1868   << off_ ,	//	mov wb *arvl2  set offset to first arblk element
/*  7361 */	loadi   | wb     << dst_ | arvl2  << off_ ,
// scv21:
/*  7362 */	stmt    | 1869   << off_ ,	//scv21	mov xl num01(xs)  point to arblk
/*  7363 */	load    | xl     << dst_ | xs     << src_ | num01  << off_ ,
/*  7364 */	stmt    | 1870   << off_ ,	//	beq wb arlen(xl) scv24 jump if all moved
/*  7365 */	load    | r2     << dst_ | xl     << src_ | arlen  << off_ ,
/*  7366 */	beq     | wb     << dst_ | r2     << src_ | scv24  << off_ ,
/*  7367 */	stmt    | 1871   << off_ ,	//	add xl wb  else point to current location
/*  7368 */	add     | xl     << dst_ | wb     << src_ ,
/*  7369 */	stmt    | 1872   << off_ ,	//	add wb *num02  bump offset
/*  7370 */	loadi   | r2     << dst_ | num02  << off_ ,
/*  7371 */	add     | wb     << dst_ | r2     << src_ ,
/*  7372 */	stmt    | 1873   << off_ ,	//	mov xr (xl)  load subscript name
/*  7373 */	load    | xr     << dst_ | xl     << src_ ,
/*  7374 */	stmt    | 1874   << off_ ,	//	dca xl   adjust ptr to merge (trval=1+1)
/*  7375 */	dca     | xl     << dst_ ,
// scv22:
/*  7376 */	stmt    | 1875   << off_ ,	//scv22	mov xl trval(xl)  point to next value
/*  7377 */	load    | xl     << dst_ | xl     << src_ | trval  << off_ ,
/*  7378 */	stmt    | 1876   << off_ ,	//	beq (xl) =b_trt scv22 loop back if trapped
/*  7379 */	load    | r1     << dst_ | xl     << src_ ,
/*  7380 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/*  7381 */	beq     | r1     << dst_ | r2     << src_ | scv22  << off_ ,
// scv23:
/*  7382 */	stmt    | 1877   << off_ ,	//scv23	mov -(xs) xl  stack value
/*  7383 */	dca     | xs     << dst_ ,
/*  7384 */	store   | xl     << dst_ | xs     << src_ ,
/*  7385 */	stmt    | 1878   << off_ ,	//	mov xl num01(xs)  load tbblk pointer
/*  7386 */	load    | xl     << dst_ | xs     << src_ | num01  << off_ ,
/*  7387 */	stmt    | 1879   << off_ ,	//	jsr tfind   build teblk (note wb gt 0 by name)
/*  7388 */	call    | tfind  << off_ ,
/*  7389 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7390 */	ppm     | exfal  << off_ ,
/*  7391 */	stmt    | 1880   << off_ ,	//	mov teval(xl) (xs)+  store value in teblk
/*  7392 */	load    | r1     << dst_ | xs     << src_ ,
/*  7393 */	ica     | xs     << dst_ ,
/*  7394 */	store   | r1     << dst_ | xl     << src_ | teval  << off_ ,
/*  7395 */	stmt    | 1881   << off_ ,	//	brn scv21   loop back for next element
/*  7396 */	brn     | scv21  << off_ ,
// scv24:
/*  7397 */	stmt    | 1882   << off_ ,	//scv24	mov xr (xs)+  load tbblk pointer
/*  7398 */	load    | xr     << dst_ | xs     << src_ ,
/*  7399 */	ica     | xs     << dst_ ,
/*  7400 */	stmt    | 1883   << off_ ,	//	ica xs   pop arblk pointer
/*  7401 */	ica     | xs     << dst_ ,
/*  7402 */	stmt    | 1884   << off_ ,	//	brn exsid   exit setting idval
/*  7403 */	brn     | exsid  << off_ ,
// scv25:
/*  7404 */	stmt    | 1885   << off_ ,	//scv25	zer wb   by value
/*  7405 */	move    | wb     << dst_ ,
/*  7406 */	stmt    | 1886   << off_ ,	//	jsr gtexp   convert to expression
/*  7407 */	call    | gtexp  << off_ ,
/*  7408 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7409 */	ppm     | exfal  << off_ ,
/*  7410 */	stmt    | 1887   << off_ ,	//	zer r_ccb   forget interim code block
/*  7411 */	store   | r0     << dst_ | r_ccb  << off_ ,
/*  7412 */	stmt    | 1888   << off_ ,	//	mov -(xs) xr  stack result
/*  7413 */	dca     | xs     << dst_ ,
/*  7414 */	store   | xr     << dst_ | xs     << src_ ,
/*  7415 */	stmt    | 1889   << off_ ,	//	lcw xr   get next code word
/*  7416 */	lcw     | xr     << dst_ ,
/*  7417 */	stmt    | 1890   << off_ ,	//	bri (xr)   execute it
/*  7418 */	load    | r1     << dst_ | xr     << src_ ,
/*  7419 */	bri     | r1     << dst_ ,
// scv26:
/*  7420 */	stmt    | 1891   << off_ ,	//scv26	jsr gtcod   convert to code
/*  7421 */	call    | gtcod  << off_ ,
/*  7422 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7423 */	ppm     | exfal  << off_ ,
/*  7424 */	stmt    | 1892   << off_ ,	//	zer r_ccb   forget interim code block
/*  7425 */	store   | r0     << dst_ | r_ccb  << off_ ,
/*  7426 */	stmt    | 1893   << off_ ,	//	mov -(xs) xr  stack result
/*  7427 */	dca     | xs     << dst_ ,
/*  7428 */	store   | xr     << dst_ | xs     << src_ ,
/*  7429 */	stmt    | 1894   << off_ ,	//	lcw xr   get next code word
/*  7430 */	lcw     | xr     << dst_ ,
/*  7431 */	stmt    | 1895   << off_ ,	//	bri (xr)   execute it
/*  7432 */	load    | r1     << dst_ | xr     << src_ ,
/*  7433 */	bri     | r1     << dst_ ,
// scv27:
/*  7434 */	stmt    | 1896   << off_ ,	//scv27	jsr gtnum   convert to numeric
/*  7435 */	call    | gtnum  << off_ ,
/*  7436 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7437 */	ppm     | exfal  << off_ ,
// scv31:
/*  7438 */	stmt    | 1897   << off_ ,	//scv31	mov -(xs) xr  stack result
/*  7439 */	dca     | xs     << dst_ ,
/*  7440 */	store   | xr     << dst_ | xs     << src_ ,
/*  7441 */	stmt    | 1898   << off_ ,	//	lcw xr   get next code word
/*  7442 */	lcw     | xr     << dst_ ,
/*  7443 */	stmt    | 1899   << off_ ,	//	bri (xr)   execute it
/*  7444 */	load    | r1     << dst_ | xr     << src_ ,
/*  7445 */	bri     | r1     << dst_ ,
// scv29:
/*  7446 */	stmt    | 1900   << off_ ,	//scv29	erb 074 convert second argument is not a string
/*  7447 */	erb     | 74     << off_ ,
/*  7448 */	0       ,
// s_cop:
/*  7449 */	stmt    | 1901   << off_ ,	//	jsr copyb   copy the block
/*  7450 */	call    | copyb  << off_ ,
/*  7451 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7452 */	ppm     | exits  << off_ ,
/*  7453 */	stmt    | 1902   << off_ ,	//	brn exsid   exit setting id value
/*  7454 */	brn     | exsid  << off_ ,
/*  7455 */	0       ,
// s_cos:
/*  7456 */	stmt    | 1903   << off_ ,	//	mov xr (xs)+  get argument
/*  7457 */	load    | xr     << dst_ | xs     << src_ ,
/*  7458 */	ica     | xs     << dst_ ,
/*  7459 */	stmt    | 1904   << off_ ,	//	jsr gtrea   convert to real
/*  7460 */	call    | gtrea  << off_ ,
/*  7461 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7462 */	err     | 303    << off_ ,
/*  7463 */	stmt    | 1905   << off_ ,	//	ldr rcval(xr)   load accumulator with argument
/*  7464 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  7465 */	ldr     | r1     << dst_ ,
/*  7466 */	stmt    | 1906   << off_ ,	//	cos    take cosine
/*  7467 */	realop  | cos    << off_ ,
/*  7468 */	stmt    | 1907   << off_ ,	//	rno exrea   if no overflow, return result in ra
/*  7469 */	rno     | exrea  << off_ ,
/*  7470 */	stmt    | 1908   << off_ ,	//	erb 322 cos argument is out of range
/*  7471 */	erb     | 322    << off_ ,
/*  7472 */	0       ,
// s_dat:
/*  7473 */	stmt    | 1909   << off_ ,	//	jsr xscni   prepare to scan argument
/*  7474 */	call    | xscni  << off_ ,
/*  7475 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  7476 */	err     | 75     << off_ ,
/*  7477 */	err     | 76     << off_ ,
/*  7478 */	stmt    | 1910   << off_ ,	//	mov wc =ch_pp  delimiter one = left paren
/*  7479 */	loadi   | wc     << dst_ | ch_pp  << off_ ,
/*  7480 */	stmt    | 1911   << off_ ,	//	mov xl wc  delimiter two = left paren
/*  7481 */	move    | xl     << dst_ | wc     << src_ ,
/*  7482 */	stmt    | 1912   << off_ ,	//	mnz wa   skip/trim blanks in prototype
/*  7483 */	move    | wa     << dst_ | xs     << src_ ,
/*  7484 */	stmt    | 1913   << off_ ,	//	jsr xscan   scan datatype name
/*  7485 */	call    | xscan  << off_ ,
/*  7486 */	stmt    | 1914   << off_ ,	//	bnz wa sdat1  skip if left paren found
/*  7487 */	bnz     | wa     << dst_ | sdat1  << off_ ,
/*  7488 */	stmt    | 1915   << off_ ,	//	erb 077 data argument is missing a left paren
/*  7489 */	erb     | 77     << off_ ,
// sdat1:
/*  7490 */	stmt    | 1916   << off_ ,	//sdat1	mov xl xr  save name ptr
/*  7491 */	move    | xl     << dst_ | xr     << src_ ,
/*  7492 */	stmt    | 1917   << off_ ,	//	mov wa sclen(xr)  get length
/*  7493 */	load    | wa     << dst_ | xr     << src_ | sclen  << off_ ,
/*  7494 */	stmt    | 1918   << off_ ,	//	ctb wa scsi_  compute space needed
/*  7495 */	ctb     | wa     << dst_ | scsi_  << off_ ,
/*  7496 */	stmt    | 1919   << off_ ,	//	jsr alost   request static store for name
/*  7497 */	call    | alost  << off_ ,
/*  7498 */	stmt    | 1920   << off_ ,	//	mov -(xs) xr  save datatype name
/*  7499 */	dca     | xs     << dst_ ,
/*  7500 */	store   | xr     << dst_ | xs     << src_ ,
/*  7501 */	stmt    | 1921   << off_ ,	//	mvw    copy name to static
/*  7502 */	mvw     ,
/*  7503 */	stmt    | 1922   << off_ ,	//	mov xr (xs)  get name ptr
/*  7504 */	load    | xr     << dst_ | xs     << src_ ,
/*  7505 */	stmt    | 1923   << off_ ,	//	zer xl   scrub dud register
/*  7506 */	move    | xl     << dst_ ,
/*  7507 */	stmt    | 1924   << off_ ,	//	jsr gtnvr   locate vrblk for datatype name
/*  7508 */	call    | gtnvr  << off_ ,
/*  7509 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7510 */	err     | 78     << off_ ,
/*  7511 */	stmt    | 1925   << off_ ,	//	mov datdv xr  save vrblk pointer for datatype
/*  7512 */	store   | xr     << dst_ | datdv  << off_ ,
/*  7513 */	stmt    | 1926   << off_ ,	//	mov datxs xs  store starting stack value
/*  7514 */	store   | xs     << dst_ | datxs  << off_ ,
/*  7515 */	stmt    | 1927   << off_ ,	//	zer wb   zero count of field names
/*  7516 */	move    | wb     << dst_ ,
// sdat2:
/*  7517 */	stmt    | 1928   << off_ ,	//sdat2	mov wc =ch_rp  delimiter one = right paren
/*  7518 */	loadi   | wc     << dst_ | ch_rp  << off_ ,
/*  7519 */	stmt    | 1929   << off_ ,	//	mov xl =ch_cm  delimiter two = comma
/*  7520 */	loadi   | xl     << dst_ | ch_cm  << off_ ,
/*  7521 */	stmt    | 1930   << off_ ,	//	mnz wa   skip/trim blanks in prototype
/*  7522 */	move    | wa     << dst_ | xs     << src_ ,
/*  7523 */	stmt    | 1931   << off_ ,	//	jsr xscan   scan next field name
/*  7524 */	call    | xscan  << off_ ,
/*  7525 */	stmt    | 1932   << off_ ,	//	bnz wa sdat3  jump if delimiter found
/*  7526 */	bnz     | wa     << dst_ | sdat3  << off_ ,
/*  7527 */	stmt    | 1933   << off_ ,	//	erb 079 data argument is missing a right paren
/*  7528 */	erb     | 79     << off_ ,
// sdat3:
/*  7529 */	stmt    | 1934   << off_ ,	//sdat3	jsr gtnvr   locate vrblk for field name
/*  7530 */	call    | gtnvr  << off_ ,
/*  7531 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7532 */	err     | 80     << off_ ,
/*  7533 */	stmt    | 1935   << off_ ,	//	mov -(xs) xr  stack vrblk pointer
/*  7534 */	dca     | xs     << dst_ ,
/*  7535 */	store   | xr     << dst_ | xs     << src_ ,
/*  7536 */	stmt    | 1936   << off_ ,	//	icv wb   increment counter
/*  7537 */	icv     | wb     << dst_ ,
/*  7538 */	stmt    | 1937   << off_ ,	//	beq wa =num02 sdat2 loop back if stopped by comma
/*  7539 */	loadi   | r2     << dst_ | num02  << off_ ,
/*  7540 */	beq     | wa     << dst_ | r2     << src_ | sdat2  << off_ ,
/*  7541 */	stmt    | 1938   << off_ ,	//	mov wa =dfsi_  set size of dfblk standard fields
/*  7542 */	loadi   | wa     << dst_ | dfsi_  << off_ ,
/*  7543 */	stmt    | 1939   << off_ ,	//	add wa wb  add number of fields
/*  7544 */	add     | wa     << dst_ | wb     << src_ ,
/*  7545 */	stmt    | 1940   << off_ ,	//	wtb wa   convert length to bytes
/*  7546 */	stmt    | 1941   << off_ ,	//	mov wc wb  preserve no. of fields
/*  7547 */	move    | wc     << dst_ | wb     << src_ ,
/*  7548 */	stmt    | 1942   << off_ ,	//	jsr alost   allocate space for dfblk
/*  7549 */	call    | alost  << off_ ,
/*  7550 */	stmt    | 1943   << off_ ,	//	mov wb wc  get no of fields
/*  7551 */	move    | wb     << dst_ | wc     << src_ ,
/*  7552 */	stmt    | 1944   << off_ ,	//	mov xt datxs  point to start of stack
/*  7553 */	load    | xt     << dst_ | datxs  << off_ ,
/*  7554 */	stmt    | 1945   << off_ ,	//	mov wc (xt)  load datatype name
/*  7555 */	load    | wc     << dst_ | xt     << src_ ,
/*  7556 */	stmt    | 1946   << off_ ,	//	mov (xt) xr  save dfblk pointer on stack
/*  7557 */	store   | xr     << dst_ | xt     << src_ ,
/*  7558 */	stmt    | 1947   << off_ ,	//	mov (xr)+ =b_dfc  store type word
/*  7559 */	loadi   | r1     << dst_ | b_dfc  << off_ ,
/*  7560 */	store   | r1     << dst_ | xr     << src_ ,
/*  7561 */	ica     | xr     << dst_ ,
/*  7562 */	stmt    | 1948   << off_ ,	//	mov (xr)+ wb  store number of fields (fargs)
/*  7563 */	store   | wb     << dst_ | xr     << src_ ,
/*  7564 */	ica     | xr     << dst_ ,
/*  7565 */	stmt    | 1949   << off_ ,	//	mov (xr)+ wa  store length (dflen)
/*  7566 */	store   | wa     << dst_ | xr     << src_ ,
/*  7567 */	ica     | xr     << dst_ ,
/*  7568 */	stmt    | 1950   << off_ ,	//	sub wa *pddfs  compute pdblk length (for dfpdl)
/*  7569 */	loadi   | r2     << dst_ | pddfs  << off_ ,
/*  7570 */	sub     | wa     << dst_ | r2     << src_ ,
/*  7571 */	stmt    | 1951   << off_ ,	//	mov (xr)+ wa  store pdblk length (dfpdl)
/*  7572 */	store   | wa     << dst_ | xr     << src_ ,
/*  7573 */	ica     | xr     << dst_ ,
/*  7574 */	stmt    | 1952   << off_ ,	//	mov (xr)+ wc  store datatype name (dfnam)
/*  7575 */	store   | wc     << dst_ | xr     << src_ ,
/*  7576 */	ica     | xr     << dst_ ,
/*  7577 */	stmt    | 1953   << off_ ,	//	lct wc wb  copy number of fields
/*  7578 */	move    | wc     << dst_ | wb     << src_ ,
// sdat4:
/*  7579 */	stmt    | 1954   << off_ ,	//sdat4	mov (xr)+ -(xt)  move one field name vrblk pointer
/*  7580 */	dca     | xt     << dst_ ,
/*  7581 */	load    | r1     << dst_ | xt     << src_ ,
/*  7582 */	store   | r1     << dst_ | xr     << src_ ,
/*  7583 */	ica     | xr     << dst_ ,
/*  7584 */	stmt    | 1955   << off_ ,	//	bct wc sdat4  loop till all moved
/*  7585 */	bct     | wc     << dst_ | sdat4  << off_ ,
/*  7586 */	stmt    | 1956   << off_ ,	//	mov wc wa  copy length of pdblk for later loop
/*  7587 */	move    | wc     << dst_ | wa     << src_ ,
/*  7588 */	stmt    | 1957   << off_ ,	//	mov xr datdv  point to vrblk
/*  7589 */	load    | xr     << dst_ | datdv  << off_ ,
/*  7590 */	stmt    | 1958   << off_ ,	//	mov xt datxs  point back on stack
/*  7591 */	load    | xt     << dst_ | datxs  << off_ ,
/*  7592 */	stmt    | 1959   << off_ ,	//	mov xl (xt)  load dfblk pointer
/*  7593 */	load    | xl     << dst_ | xt     << src_ ,
/*  7594 */	stmt    | 1960   << off_ ,	//	jsr dffnc   define function
/*  7595 */	call    | dffnc  << off_ ,
// sdat5:
/*  7596 */	stmt    | 1961   << off_ ,	//sdat5	mov wa *ffsi_  set length of ffblk
/*  7597 */	loadi   | wa     << dst_ | ffsi_  << off_ ,
/*  7598 */	stmt    | 1962   << off_ ,	//	jsr alloc   allocate space for ffblk
/*  7599 */	call    | alloc  << off_ ,
/*  7600 */	stmt    | 1963   << off_ ,	//	mov (xr) =b_ffc  set type word
/*  7601 */	loadi   | r1     << dst_ | b_ffc  << off_ ,
/*  7602 */	store   | r1     << dst_ | xr     << src_ ,
/*  7603 */	stmt    | 1964   << off_ ,	//	mov fargs(xr) =num01  store fargs (always one)
/*  7604 */	loadi   | r1     << dst_ | num01  << off_ ,
/*  7605 */	store   | r1     << dst_ | xr     << src_ | fargs  << off_ ,
/*  7606 */	stmt    | 1965   << off_ ,	//	mov xt datxs  point back on stack
/*  7607 */	load    | xt     << dst_ | datxs  << off_ ,
/*  7608 */	stmt    | 1966   << off_ ,	//	mov ffdfp(xr) (xt)  copy dfblk ptr to ffblk
/*  7609 */	load    | r1     << dst_ | xt     << src_ ,
/*  7610 */	store   | r1     << dst_ | xr     << src_ | ffdfp  << off_ ,
/*  7611 */	stmt    | 1967   << off_ ,	//	dca wc   decrement old dfpdl to get next ofs
/*  7612 */	dca     | wc     << dst_ ,
/*  7613 */	stmt    | 1968   << off_ ,	//	mov ffofs(xr) wc  set offset to this field
/*  7614 */	store   | wc     << dst_ | xr     << src_ | ffofs  << off_ ,
/*  7615 */	stmt    | 1969   << off_ ,	//	zer ffnxt(xr)   tentatively set zero forward ptr
/*  7616 */	store   | r0     << dst_ | xr     << src_ | ffnxt  << off_ ,
/*  7617 */	stmt    | 1970   << off_ ,	//	mov xl xr  copy ffblk pointer for dffnc
/*  7618 */	move    | xl     << dst_ | xr     << src_ ,
/*  7619 */	stmt    | 1971   << off_ ,	//	mov xr (xs)  load vrblk pointer for field
/*  7620 */	load    | xr     << dst_ | xs     << src_ ,
/*  7621 */	stmt    | 1972   << off_ ,	//	mov xr vrfnc(xr)  load current function pointer
/*  7622 */	load    | xr     << dst_ | xr     << src_ | vrfnc  << off_ ,
/*  7623 */	stmt    | 1973   << off_ ,	//	bne (xr) =b_ffc sdat6 skip if not currently a field func
/*  7624 */	load    | r1     << dst_ | xr     << src_ ,
/*  7625 */	loadi   | r2     << dst_ | b_ffc  << off_ ,
/*  7626 */	bne     | r1     << dst_ | r2     << src_ | sdat6  << off_ ,
/*  7627 */	stmt    | 1974   << off_ ,	//	mov ffnxt(xl) xr  link new ffblk to previous chain
/*  7628 */	store   | xr     << dst_ | xl     << src_ | ffnxt  << off_ ,
// sdat6:
/*  7629 */	stmt    | 1975   << off_ ,	//sdat6	mov xr (xs)+  load vrblk pointer
/*  7630 */	load    | xr     << dst_ | xs     << src_ ,
/*  7631 */	ica     | xs     << dst_ ,
/*  7632 */	stmt    | 1976   << off_ ,	//	jsr dffnc   define field function
/*  7633 */	call    | dffnc  << off_ ,
/*  7634 */	stmt    | 1977   << off_ ,	//	bne xs datxs sdat5 loop back till all done
/*  7635 */	load    | r2     << dst_ | datxs  << off_ ,
/*  7636 */	bne     | xs     << dst_ | r2     << src_ | sdat5  << off_ ,
/*  7637 */	stmt    | 1978   << off_ ,	//	ica xs   pop dfblk pointer
/*  7638 */	ica     | xs     << dst_ ,
/*  7639 */	stmt    | 1979   << off_ ,	//	brn exnul   return with null result
/*  7640 */	brn     | exnul  << off_ ,
/*  7641 */	0       ,
// s_dtp:
/*  7642 */	stmt    | 1980   << off_ ,	//	mov xr (xs)+  load argument
/*  7643 */	load    | xr     << dst_ | xs     << src_ ,
/*  7644 */	ica     | xs     << dst_ ,
/*  7645 */	stmt    | 1981   << off_ ,	//	jsr dtype   get datatype
/*  7646 */	call    | dtype  << off_ ,
/*  7647 */	stmt    | 1982   << off_ ,	//	mov -(xs) xr  stack result
/*  7648 */	dca     | xs     << dst_ ,
/*  7649 */	store   | xr     << dst_ | xs     << src_ ,
/*  7650 */	stmt    | 1983   << off_ ,	//	lcw xr   get next code word
/*  7651 */	lcw     | xr     << dst_ ,
/*  7652 */	stmt    | 1984   << off_ ,	//	bri (xr)   execute it
/*  7653 */	load    | r1     << dst_ | xr     << src_ ,
/*  7654 */	bri     | r1     << dst_ ,
/*  7655 */	0       ,
// s_dte:
/*  7656 */	stmt    | 1985   << off_ ,	//	mov xr (xs)+  load argument
/*  7657 */	load    | xr     << dst_ | xs     << src_ ,
/*  7658 */	ica     | xs     << dst_ ,
/*  7659 */	stmt    | 1986   << off_ ,	//	jsr gtint   convert to an integer
/*  7660 */	call    | gtint  << off_ ,
/*  7661 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7662 */	err     | 330    << off_ ,
/*  7663 */	stmt    | 1987   << off_ ,	//	jsr sysdt   call system date routine
/*  7664 */	sys     | sysdt_ << off_ ,
/*  7665 */	stmt    | 1988   << off_ ,	//	mov wa num01(xl)  load length for sbstr
/*  7666 */	load    | wa     << dst_ | xl     << src_ | num01  << off_ ,
/*  7667 */	stmt    | 1989   << off_ ,	//	bze wa exnul  return null if length is zero
/*  7668 */	bze     | wa     << dst_ | exnul  << off_ ,
/*  7669 */	stmt    | 1990   << off_ ,	//	zer wb   set zero offset
/*  7670 */	move    | wb     << dst_ ,
/*  7671 */	stmt    | 1991   << off_ ,	//	jsr sbstr   use sbstr to build scblk
/*  7672 */	call    | sbstr  << off_ ,
/*  7673 */	stmt    | 1992   << off_ ,	//	mov -(xs) xr  stack result
/*  7674 */	dca     | xs     << dst_ ,
/*  7675 */	store   | xr     << dst_ | xs     << src_ ,
/*  7676 */	stmt    | 1993   << off_ ,	//	lcw xr   get next code word
/*  7677 */	lcw     | xr     << dst_ ,
/*  7678 */	stmt    | 1994   << off_ ,	//	bri (xr)   execute it
/*  7679 */	load    | r1     << dst_ | xr     << src_ ,
/*  7680 */	bri     | r1     << dst_ ,
/*  7681 */	0       ,
// s_def:
/*  7682 */	stmt    | 1995   << off_ ,	//	mov xr (xs)+  load second argument
/*  7683 */	load    | xr     << dst_ | xs     << src_ ,
/*  7684 */	ica     | xs     << dst_ ,
/*  7685 */	stmt    | 1996   << off_ ,	//	zer deflb   zero label pointer in case null
/*  7686 */	store   | r0     << dst_ | deflb  << off_ ,
/*  7687 */	stmt    | 1997   << off_ ,	//	beq xr =nulls sdf01 jump if null second argument
/*  7688 */	loadi   | r2     << dst_ | nulls  << off_ ,
/*  7689 */	beq     | xr     << dst_ | r2     << src_ | sdf01  << off_ ,
/*  7690 */	stmt    | 1998   << off_ ,	//	jsr gtnvr   else find vrblk for label
/*  7691 */	call    | gtnvr  << off_ ,
/*  7692 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7693 */	ppm     | sdf12  << off_ ,
/*  7694 */	stmt    | 1999   << off_ ,	//	mov deflb xr  else set specified entry
/*  7695 */	store   | xr     << dst_ | deflb  << off_ ,
// sdf01:
/*  7696 */	stmt    | 2000   << off_ ,	//sdf01	jsr xscni   prepare to scan first argument
/*  7697 */	call    | xscni  << off_ ,
/*  7698 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  7699 */	err     | 81     << off_ ,
/*  7700 */	err     | 82     << off_ ,
/*  7701 */	stmt    | 2001   << off_ ,	//	mov wc =ch_pp  delimiter one = left paren
/*  7702 */	loadi   | wc     << dst_ | ch_pp  << off_ ,
/*  7703 */	stmt    | 2002   << off_ ,	//	mov xl wc  delimiter two = left paren
/*  7704 */	move    | xl     << dst_ | wc     << src_ ,
/*  7705 */	stmt    | 2003   << off_ ,	//	mnz wa   skip/trim blanks in prototype
/*  7706 */	move    | wa     << dst_ | xs     << src_ ,
/*  7707 */	stmt    | 2004   << off_ ,	//	jsr xscan   scan out function name
/*  7708 */	call    | xscan  << off_ ,
/*  7709 */	stmt    | 2005   << off_ ,	//	bnz wa sdf02  jump if left paren found
/*  7710 */	bnz     | wa     << dst_ | sdf02  << off_ ,
/*  7711 */	stmt    | 2006   << off_ ,	//	erb 083 define first argument is missing a left paren
/*  7712 */	erb     | 83     << off_ ,
// sdf02:
/*  7713 */	stmt    | 2007   << off_ ,	//sdf02	jsr gtnvr   get variable name
/*  7714 */	call    | gtnvr  << off_ ,
/*  7715 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7716 */	err     | 84     << off_ ,
/*  7717 */	stmt    | 2008   << off_ ,	//	mov defvr xr  save vrblk pointer for function nam
/*  7718 */	store   | xr     << dst_ | defvr  << off_ ,
/*  7719 */	stmt    | 2009   << off_ ,	//	zer wb   zero count of arguments
/*  7720 */	move    | wb     << dst_ ,
/*  7721 */	stmt    | 2010   << off_ ,	//	mov defxs xs  save initial stack pointer
/*  7722 */	store   | xs     << dst_ | defxs  << off_ ,
/*  7723 */	stmt    | 2011   << off_ ,	//	bnz deflb sdf03  jump if second argument given
/*  7724 */	load    | r1     << dst_ | deflb  << off_ ,
/*  7725 */	bnz     | r1     << dst_ | sdf03  << off_ ,
/*  7726 */	stmt    | 2012   << off_ ,	//	mov deflb xr  else default is function name
/*  7727 */	store   | xr     << dst_ | deflb  << off_ ,
// sdf03:
/*  7728 */	stmt    | 2013   << off_ ,	//sdf03	mov wc =ch_rp  delimiter one = right paren
/*  7729 */	loadi   | wc     << dst_ | ch_rp  << off_ ,
/*  7730 */	stmt    | 2014   << off_ ,	//	mov xl =ch_cm  delimiter two = comma
/*  7731 */	loadi   | xl     << dst_ | ch_cm  << off_ ,
/*  7732 */	stmt    | 2015   << off_ ,	//	mnz wa   skip/trim blanks in prototype
/*  7733 */	move    | wa     << dst_ | xs     << src_ ,
/*  7734 */	stmt    | 2016   << off_ ,	//	jsr xscan   scan out next argument name
/*  7735 */	call    | xscan  << off_ ,
/*  7736 */	stmt    | 2017   << off_ ,	//	bnz wa sdf04  skip if delimiter found
/*  7737 */	bnz     | wa     << dst_ | sdf04  << off_ ,
/*  7738 */	stmt    | 2018   << off_ ,	//	erb 085 null arg name or missing ) in define first arg.
/*  7739 */	erb     | 85     << off_ ,
// sdf04:
/*  7740 */	stmt    | 2019   << off_ ,	//sdf04	bne xr =nulls sdf05 skip if non-null
/*  7741 */	loadi   | r2     << dst_ | nulls  << off_ ,
/*  7742 */	bne     | xr     << dst_ | r2     << src_ | sdf05  << off_ ,
/*  7743 */	stmt    | 2020   << off_ ,	//	bze wb sdf06  ignore null if case of no arguments
/*  7744 */	bze     | wb     << dst_ | sdf06  << off_ ,
// sdf05:
/*  7745 */	stmt    | 2021   << off_ ,	//sdf05	jsr gtnvr   get vrblk pointer
/*  7746 */	call    | gtnvr  << off_ ,
/*  7747 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7748 */	ppm     | sdf03  << off_ ,
/*  7749 */	stmt    | 2022   << off_ ,	//	mov -(xs) xr  stack argument vrblk pointer
/*  7750 */	dca     | xs     << dst_ ,
/*  7751 */	store   | xr     << dst_ | xs     << src_ ,
/*  7752 */	stmt    | 2023   << off_ ,	//	icv wb   increment counter
/*  7753 */	icv     | wb     << dst_ ,
/*  7754 */	stmt    | 2024   << off_ ,	//	beq wa =num02 sdf03 loop back if stopped by a comma
/*  7755 */	loadi   | r2     << dst_ | num02  << off_ ,
/*  7756 */	beq     | wa     << dst_ | r2     << src_ | sdf03  << off_ ,
// sdf06:
/*  7757 */	stmt    | 2025   << off_ ,	//sdf06	mov defna wb  save number of arguments
/*  7758 */	store   | wb     << dst_ | defna  << off_ ,
/*  7759 */	stmt    | 2026   << off_ ,	//	zer wb   zero count of locals
/*  7760 */	move    | wb     << dst_ ,
// sdf07:
/*  7761 */	stmt    | 2027   << off_ ,	//sdf07	mov wc =ch_cm  set delimiter one = comma
/*  7762 */	loadi   | wc     << dst_ | ch_cm  << off_ ,
/*  7763 */	stmt    | 2028   << off_ ,	//	mov xl wc  set delimiter two = comma
/*  7764 */	move    | xl     << dst_ | wc     << src_ ,
/*  7765 */	stmt    | 2029   << off_ ,	//	mnz wa   skip/trim blanks in prototype
/*  7766 */	move    | wa     << dst_ | xs     << src_ ,
/*  7767 */	stmt    | 2030   << off_ ,	//	jsr xscan   scan out next local name
/*  7768 */	call    | xscan  << off_ ,
/*  7769 */	stmt    | 2031   << off_ ,	//	bne xr =nulls sdf08 skip if non-null
/*  7770 */	loadi   | r2     << dst_ | nulls  << off_ ,
/*  7771 */	bne     | xr     << dst_ | r2     << src_ | sdf08  << off_ ,
/*  7772 */	stmt    | 2032   << off_ ,	//	bze wa sdf09  exit scan if end of string
/*  7773 */	bze     | wa     << dst_ | sdf09  << off_ ,
// sdf08:
/*  7774 */	stmt    | 2033   << off_ ,	//sdf08	jsr gtnvr   get vrblk pointer
/*  7775 */	call    | gtnvr  << off_ ,
/*  7776 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7777 */	ppm     | sdf07  << off_ ,
/*  7778 */	stmt    | 2034   << off_ ,	//	icv wb   if ok, increment count
/*  7779 */	icv     | wb     << dst_ ,
/*  7780 */	stmt    | 2035   << off_ ,	//	mov -(xs) xr  stack vrblk pointer
/*  7781 */	dca     | xs     << dst_ ,
/*  7782 */	store   | xr     << dst_ | xs     << src_ ,
/*  7783 */	stmt    | 2036   << off_ ,	//	bnz wa sdf07  loop back if stopped by a comma
/*  7784 */	bnz     | wa     << dst_ | sdf07  << off_ ,
// sdf09:
/*  7785 */	stmt    | 2037   << off_ ,	//sdf09	mov wa wb  copy count of locals
/*  7786 */	move    | wa     << dst_ | wb     << src_ ,
/*  7787 */	stmt    | 2038   << off_ ,	//	add wa defna  add number of arguments
/*  7788 */	load    | r2     << dst_ | defna  << off_ ,
/*  7789 */	add     | wa     << dst_ | r2     << src_ ,
/*  7790 */	stmt    | 2039   << off_ ,	//	mov wc wa  set sum args+locals as loop count
/*  7791 */	move    | wc     << dst_ | wa     << src_ ,
/*  7792 */	stmt    | 2040   << off_ ,	//	add wa =pfsi_  add space for standard fields
/*  7793 */	loadi   | r2     << dst_ | pfsi_  << off_ ,
/*  7794 */	add     | wa     << dst_ | r2     << src_ ,
/*  7795 */	stmt    | 2041   << off_ ,	//	wtb wa   convert length to bytes
/*  7796 */	stmt    | 2042   << off_ ,	//	jsr alloc   allocate space for pfblk
/*  7797 */	call    | alloc  << off_ ,
/*  7798 */	stmt    | 2043   << off_ ,	//	mov xl xr  save pointer to pfblk
/*  7799 */	move    | xl     << dst_ | xr     << src_ ,
/*  7800 */	stmt    | 2044   << off_ ,	//	mov (xr)+ =b_pfc  store first word
/*  7801 */	loadi   | r1     << dst_ | b_pfc  << off_ ,
/*  7802 */	store   | r1     << dst_ | xr     << src_ ,
/*  7803 */	ica     | xr     << dst_ ,
/*  7804 */	stmt    | 2045   << off_ ,	//	mov (xr)+ defna  store number of arguments
/*  7805 */	load    | r1     << dst_ | defna  << off_ ,
/*  7806 */	store   | r1     << dst_ | xr     << src_ ,
/*  7807 */	ica     | xr     << dst_ ,
/*  7808 */	stmt    | 2046   << off_ ,	//	mov (xr)+ wa  store length (pflen)
/*  7809 */	store   | wa     << dst_ | xr     << src_ ,
/*  7810 */	ica     | xr     << dst_ ,
/*  7811 */	stmt    | 2047   << off_ ,	//	mov (xr)+ defvr  store vrblk ptr for function name
/*  7812 */	load    | r1     << dst_ | defvr  << off_ ,
/*  7813 */	store   | r1     << dst_ | xr     << src_ ,
/*  7814 */	ica     | xr     << dst_ ,
/*  7815 */	stmt    | 2048   << off_ ,	//	mov (xr)+ wb  store number of locals
/*  7816 */	store   | wb     << dst_ | xr     << src_ ,
/*  7817 */	ica     | xr     << dst_ ,
/*  7818 */	stmt    | 2049   << off_ ,	//	zer (xr)+   deal with label later
/*  7819 */	store   | r0     << dst_ | xr     << src_ ,
/*  7820 */	ica     | xr     << dst_ ,
/*  7821 */	stmt    | 2050   << off_ ,	//	zer (xr)+   zero pfctr
/*  7822 */	store   | r0     << dst_ | xr     << src_ ,
/*  7823 */	ica     | xr     << dst_ ,
/*  7824 */	stmt    | 2051   << off_ ,	//	zer (xr)+   zero pfrtr
/*  7825 */	store   | r0     << dst_ | xr     << src_ ,
/*  7826 */	ica     | xr     << dst_ ,
/*  7827 */	stmt    | 2052   << off_ ,	//	bze wc sdf11  skip if no args or locals
/*  7828 */	bze     | wc     << dst_ | sdf11  << off_ ,
/*  7829 */	stmt    | 2053   << off_ ,	//	mov wa xl  keep pfblk pointer
/*  7830 */	move    | wa     << dst_ | xl     << src_ ,
/*  7831 */	stmt    | 2054   << off_ ,	//	mov xt defxs  point before arguments
/*  7832 */	load    | xt     << dst_ | defxs  << off_ ,
/*  7833 */	stmt    | 2055   << off_ ,	//	lct wc wc  get count of args+locals for loop
// sdf10:
/*  7834 */	stmt    | 2056   << off_ ,	//sdf10	mov (xr)+ -(xt)  store one entry and bump pointers
/*  7835 */	dca     | xt     << dst_ ,
/*  7836 */	load    | r1     << dst_ | xt     << src_ ,
/*  7837 */	store   | r1     << dst_ | xr     << src_ ,
/*  7838 */	ica     | xr     << dst_ ,
/*  7839 */	stmt    | 2057   << off_ ,	//	bct wc sdf10  loop till all stored
/*  7840 */	bct     | wc     << dst_ | sdf10  << off_ ,
/*  7841 */	stmt    | 2058   << off_ ,	//	mov xl wa  recover pfblk pointer
/*  7842 */	move    | xl     << dst_ | wa     << src_ ,
// sdf11:
/*  7843 */	stmt    | 2059   << off_ ,	//sdf11	mov xs defxs  pop stack
/*  7844 */	load    | xs     << dst_ | defxs  << off_ ,
/*  7845 */	stmt    | 2060   << off_ ,	//	mov pfcod(xl) deflb  store label vrblk in pfblk
/*  7846 */	load    | r1     << dst_ | deflb  << off_ ,
/*  7847 */	store   | r1     << dst_ | xl     << src_ | pfcod  << off_ ,
/*  7848 */	stmt    | 2061   << off_ ,	//	mov xr defvr  point back to vrblk for function
/*  7849 */	load    | xr     << dst_ | defvr  << off_ ,
/*  7850 */	stmt    | 2062   << off_ ,	//	jsr dffnc   define function
/*  7851 */	call    | dffnc  << off_ ,
/*  7852 */	stmt    | 2063   << off_ ,	//	brn exnul   and exit returning null
/*  7853 */	brn     | exnul  << off_ ,
// sdf12:
/*  7854 */	stmt    | 2064   << off_ ,	//sdf12	erb 086 define function entry point is not defined label
/*  7855 */	erb     | 86     << off_ ,
/*  7856 */	0       ,
// s_det:
/*  7857 */	stmt    | 2065   << off_ ,	//	mov xr (xs)+  load argument
/*  7858 */	load    | xr     << dst_ | xs     << src_ ,
/*  7859 */	ica     | xs     << dst_ ,
/*  7860 */	stmt    | 2066   << off_ ,	//	jsr gtvar   locate variable
/*  7861 */	call    | gtvar  << off_ ,
/*  7862 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7863 */	err     | 87     << off_ ,
/*  7864 */	stmt    | 2067   << off_ ,	//	jsr dtach   detach i/o association from name
/*  7865 */	call    | dtach  << off_ ,
/*  7866 */	stmt    | 2068   << off_ ,	//	brn exnul   return null result
/*  7867 */	brn     | exnul  << off_ ,
/*  7868 */	0       ,
// s_dif:
/*  7869 */	stmt    | 2069   << off_ ,	//	mov xr (xs)+  load second argument
/*  7870 */	load    | xr     << dst_ | xs     << src_ ,
/*  7871 */	ica     | xs     << dst_ ,
/*  7872 */	stmt    | 2070   << off_ ,	//	mov xl (xs)+  load first argument
/*  7873 */	load    | xl     << dst_ | xs     << src_ ,
/*  7874 */	ica     | xs     << dst_ ,
/*  7875 */	stmt    | 2071   << off_ ,	//	jsr ident   call ident comparison routine
/*  7876 */	call    | ident  << off_ ,
/*  7877 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7878 */	ppm     | exfal  << off_ ,
/*  7879 */	stmt    | 2072   << off_ ,	//	brn exnul   return null if differ
/*  7880 */	brn     | exnul  << off_ ,
/*  7881 */	0       ,
// s_dmp:
/*  7882 */	stmt    | 2073   << off_ ,	//	jsr gtsmi   load dump arg as small integer
/*  7883 */	call    | gtsmi  << off_ ,
/*  7884 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  7885 */	err     | 88     << off_ ,
/*  7886 */	err     | 89     << off_ ,
/*  7887 */	stmt    | 2074   << off_ ,	//	jsr dumpr   else call dump routine
/*  7888 */	call    | dumpr  << off_ ,
/*  7889 */	stmt    | 2075   << off_ ,	//	brn exnul   and return null as result
/*  7890 */	brn     | exnul  << off_ ,
/*  7891 */	0       ,
// s_dup:
/*  7892 */	stmt    | 2076   << off_ ,	//	jsr gtsmi   get second argument as small integr
/*  7893 */	call    | gtsmi  << off_ ,
/*  7894 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  7895 */	err     | 90     << off_ ,
/*  7896 */	ppm     | sdup7  << off_ ,
/*  7897 */	stmt    | 2077   << off_ ,	//	mov wb xr  save duplication factor
/*  7898 */	move    | wb     << dst_ | xr     << src_ ,
/*  7899 */	stmt    | 2078   << off_ ,	//	jsr gtstg   get first arg as string
/*  7900 */	call    | gtstg  << off_ ,
/*  7901 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7902 */	ppm     | sdup4  << off_ ,
/*  7903 */	stmt    | 2079   << off_ ,	//	mti wa   acquire length as integer
/*  7904 */	move    | ia     << dst_ | wa     << src_ ,
/*  7905 */	stmt    | 2080   << off_ ,	//	sti dupsi   save for the moment
/*  7906 */	store   | ia     << dst_ | dupsi  << off_ ,
/*  7907 */	stmt    | 2081   << off_ ,	//	mti wb   get duplication factor as integer
/*  7908 */	move    | ia     << dst_ | wb     << src_ ,
/*  7909 */	stmt    | 2082   << off_ ,	//	mli dupsi   form product
/*  7910 */	load    | r1     << dst_ | dupsi  << off_ ,
/*  7911 */	mli     | r1     << dst_ ,
/*  7912 */	stmt    | 2083   << off_ ,	//	iov sdup3   jump if overflow
/*  7913 */	iov     | sdup3  << off_ ,
/*  7914 */	stmt    | 2084   << off_ ,	//	ieq exnul   return null if result length = 0
/*  7915 */	ieq     | exnul  << off_ ,
/*  7916 */	stmt    | 2085   << off_ ,	//	mfi wa sdup3  get as addr integer, check ovflo
/*  7917 */	move    | wa     << dst_ | ia     << src_ ,
/*  7918 */	mfi     | sdup3  << off_ ,
// sdup1:
/*  7919 */	stmt    | 2086   << off_ ,	//sdup1	mov xl xr  save string pointer
/*  7920 */	move    | xl     << dst_ | xr     << src_ ,
/*  7921 */	stmt    | 2087   << off_ ,	//	jsr alocs   allocate space for string
/*  7922 */	call    | alocs  << off_ ,
/*  7923 */	stmt    | 2088   << off_ ,	//	mov -(xs) xr  save as result pointer
/*  7924 */	dca     | xs     << dst_ ,
/*  7925 */	store   | xr     << dst_ | xs     << src_ ,
/*  7926 */	stmt    | 2089   << off_ ,	//	mov wc xl  save pointer to argument string
/*  7927 */	move    | wc     << dst_ | xl     << src_ ,
/*  7928 */	stmt    | 2090   << off_ ,	//	psc xr   prepare to store chars of result
/*  7929 */	psc     | xr     << dst_ ,
/*  7930 */	stmt    | 2091   << off_ ,	//	lct wb wb  set counter to control loop
// sdup2:
/*  7931 */	stmt    | 2092   << off_ ,	//sdup2	mov xl wc  point back to argument string
/*  7932 */	move    | xl     << dst_ | wc     << src_ ,
/*  7933 */	stmt    | 2093   << off_ ,	//	mov wa sclen(xl)  get number of characters
/*  7934 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/*  7935 */	stmt    | 2094   << off_ ,	//	plc xl   point to chars in argument string
/*  7936 */	plc     | xl     << dst_ ,
/*  7937 */	stmt    | 2095   << off_ ,	//	mvc    move characters to result string
/*  7938 */	mvc     ,
/*  7939 */	stmt    | 2096   << off_ ,	//	bct wb sdup2  loop till all duplications done
/*  7940 */	bct     | wb     << dst_ | sdup2  << off_ ,
/*  7941 */	stmt    | 2097   << off_ ,	//	zer xl   clear garbage value
/*  7942 */	move    | xl     << dst_ ,
/*  7943 */	stmt    | 2098   << off_ ,	//	lcw xr   get next code word
/*  7944 */	lcw     | xr     << dst_ ,
/*  7945 */	stmt    | 2099   << off_ ,	//	bri (xr)   execute next code word
/*  7946 */	load    | r1     << dst_ | xr     << src_ ,
/*  7947 */	bri     | r1     << dst_ ,
// sdup3:
/*  7948 */	stmt    | 2100   << off_ ,	//sdup3	mov wa dname  set impossible length for alocs
/*  7949 */	load    | wa     << dst_ | dname  << off_ ,
/*  7950 */	stmt    | 2101   << off_ ,	//	brn sdup1   merge back
/*  7951 */	brn     | sdup1  << off_ ,
// sdup4:
/*  7952 */	stmt    | 2102   << off_ ,	//sdup4	jsr gtpat   convert argument to pattern
/*  7953 */	call    | gtpat  << off_ ,
/*  7954 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  7955 */	err     | 91     << off_ ,
/*  7956 */	stmt    | 2103   << off_ ,	//	mov -(xs) xr  store pattern on stack
/*  7957 */	dca     | xs     << dst_ ,
/*  7958 */	store   | xr     << dst_ | xs     << src_ ,
/*  7959 */	stmt    | 2104   << off_ ,	//	mov xr =ndnth  start off with null pattern
/*  7960 */	loadi   | xr     << dst_ | ndnth  << off_ ,
/*  7961 */	stmt    | 2105   << off_ ,	//	bze wb sdup6  null pattern is result if dupfac=0
/*  7962 */	bze     | wb     << dst_ | sdup6  << off_ ,
/*  7963 */	stmt    | 2106   << off_ ,	//	mov -(xs) wb  preserve loop count
/*  7964 */	dca     | xs     << dst_ ,
/*  7965 */	store   | wb     << dst_ | xs     << src_ ,
// sdup5:
/*  7966 */	stmt    | 2107   << off_ ,	//sdup5	mov xl xr  copy current value as right argumnt
/*  7967 */	move    | xl     << dst_ | xr     << src_ ,
/*  7968 */	stmt    | 2108   << off_ ,	//	mov xr num01(xs)  get a new copy of left
/*  7969 */	load    | xr     << dst_ | xs     << src_ | num01  << off_ ,
/*  7970 */	stmt    | 2109   << off_ ,	//	jsr pconc   concatenate
/*  7971 */	call    | pconc  << off_ ,
/*  7972 */	stmt    | 2110   << off_ ,	//	dcv (xs)   count down
/*  7973 */	load    | r1     << dst_ | xs     << src_ ,
/*  7974 */	dcv     | r1     << dst_ ,
/*  7975 */	store   | r1     << dst_ | xs     << src_ ,
/*  7976 */	stmt    | 2111   << off_ ,	//	bnz (xs) sdup5  loop
/*  7977 */	load    | r1     << dst_ | xs     << src_ ,
/*  7978 */	bnz     | r1     << dst_ | sdup5  << off_ ,
/*  7979 */	stmt    | 2112   << off_ ,	//	ica xs   pop loop count
/*  7980 */	ica     | xs     << dst_ ,
// sdup6:
/*  7981 */	stmt    | 2113   << off_ ,	//sdup6	mov (xs) xr  store result on stack
/*  7982 */	store   | xr     << dst_ | xs     << src_ ,
/*  7983 */	stmt    | 2114   << off_ ,	//	lcw xr   get next code word
/*  7984 */	lcw     | xr     << dst_ ,
/*  7985 */	stmt    | 2115   << off_ ,	//	bri (xr)   execute next code word
/*  7986 */	load    | r1     << dst_ | xr     << src_ ,
/*  7987 */	bri     | r1     << dst_ ,
// sdup7:
/*  7988 */	stmt    | 2116   << off_ ,	//sdup7	ica xs   pop first argument
/*  7989 */	ica     | xs     << dst_ ,
/*  7990 */	stmt    | 2117   << off_ ,	//	brn exfal   fail
/*  7991 */	brn     | exfal  << off_ ,
/*  7992 */	0       ,
// s_ejc:
/*  7993 */	stmt    | 2118   << off_ ,	//	jsr iofcb   call fcblk routine
/*  7994 */	call    | iofcb  << off_ ,
/*  7995 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  7996 */	err     | 92     << off_ ,
/*  7997 */	ppm     | sejc1  << off_ ,
/*  7998 */	err     | 93     << off_ ,
/*  7999 */	stmt    | 2119   << off_ ,	//	jsr sysef   call eject file function
/*  8000 */	sys     | sysef_ << off_ ,
/*  8001 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  8002 */	err     | 93     << off_ ,
/*  8003 */	err     | 94     << off_ ,
/*  8004 */	err     | 95     << off_ ,
/*  8005 */	stmt    | 2120   << off_ ,	//	brn exnul   return null as result
/*  8006 */	brn     | exnul  << off_ ,
// sejc1:
/*  8007 */	stmt    | 2121   << off_ ,	//sejc1	jsr sysep   call routine to eject printer
/*  8008 */	sys     | sysep_ << off_ ,
/*  8009 */	stmt    | 2122   << off_ ,	//	brn exnul   exit with null result
/*  8010 */	brn     | exnul  << off_ ,
/*  8011 */	0       ,
// s_enf:
/*  8012 */	stmt    | 2123   << off_ ,	//	jsr iofcb   call fcblk routine
/*  8013 */	call    | iofcb  << off_ ,
/*  8014 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  8015 */	err     | 96     << off_ ,
/*  8016 */	err     | 97     << off_ ,
/*  8017 */	err     | 98     << off_ ,
/*  8018 */	stmt    | 2124   << off_ ,	//	jsr sysen   call endfile routine
/*  8019 */	sys     | sysen_ << off_ ,
/*  8020 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  8021 */	err     | 98     << off_ ,
/*  8022 */	err     | 99     << off_ ,
/*  8023 */	err     | 100    << off_ ,
/*  8024 */	stmt    | 2125   << off_ ,	//	mov wb xl  remember vrblk ptr from iofcb call
/*  8025 */	move    | wb     << dst_ | xl     << src_ ,
/*  8026 */	stmt    | 2126   << off_ ,	//	mov xr xl  copy pointer
/*  8027 */	move    | xr     << dst_ | xl     << src_ ,
// senf1:
/*  8028 */	stmt    | 2127   << off_ ,	//senf1	mov xl xr  remember previous entry
/*  8029 */	move    | xl     << dst_ | xr     << src_ ,
/*  8030 */	stmt    | 2128   << off_ ,	//	mov xr trval(xr)  chain along
/*  8031 */	load    | xr     << dst_ | xr     << src_ | trval  << off_ ,
/*  8032 */	stmt    | 2129   << off_ ,	//	bne (xr) =b_trt exnul skip out if chain end
/*  8033 */	load    | r1     << dst_ | xr     << src_ ,
/*  8034 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/*  8035 */	bne     | r1     << dst_ | r2     << src_ | exnul  << off_ ,
/*  8036 */	stmt    | 2130   << off_ ,	//	bne trtyp(xr) =trtfc senf1 loop if not found
/*  8037 */	load    | r1     << dst_ | xr     << src_ | trtyp  << off_ ,
/*  8038 */	loadi   | r2     << dst_ | trtfc  << off_ ,
/*  8039 */	bne     | r1     << dst_ | r2     << src_ | senf1  << off_ ,
/*  8040 */	stmt    | 2131   << off_ ,	//	mov trval(xl) trval(xr)  remove trtrf
/*  8041 */	load    | r1     << dst_ | xr     << src_ | trval  << off_ ,
/*  8042 */	store   | r1     << dst_ | xl     << src_ | trval  << off_ ,
/*  8043 */	stmt    | 2132   << off_ ,	//	mov enfch trtrf(xr)  point to head of iochn
/*  8044 */	load    | r1     << dst_ | xr     << src_ | trtrf  << off_ ,
/*  8045 */	store   | r1     << dst_ | enfch  << off_ ,
/*  8046 */	stmt    | 2133   << off_ ,	//	mov wc trfpt(xr)  point to fcblk
/*  8047 */	load    | wc     << dst_ | xr     << src_ | trfpt  << off_ ,
/*  8048 */	stmt    | 2134   << off_ ,	//	mov xr wb  filearg1 vrblk from iofcb
/*  8049 */	move    | xr     << dst_ | wb     << src_ ,
/*  8050 */	stmt    | 2135   << off_ ,	//	jsr setvr   reset it
/*  8051 */	call    | setvr  << off_ ,
/*  8052 */	stmt    | 2136   << off_ ,	//	mov xl =r_fcb  ptr to head of fcblk chain
/*  8053 */	loadi   | xl     << dst_ | r_fcb  << off_ ,
/*  8054 */	stmt    | 2137   << off_ ,	//	sub xl *num02  adjust ready to enter loop
/*  8055 */	loadi   | r2     << dst_ | num02  << off_ ,
/*  8056 */	sub     | xl     << dst_ | r2     << src_ ,
// senf2:
/*  8057 */	stmt    | 2138   << off_ ,	//senf2	mov xr xl  copy ptr
/*  8058 */	move    | xr     << dst_ | xl     << src_ ,
/*  8059 */	stmt    | 2139   << off_ ,	//	mov xl num02(xl)  get next link
/*  8060 */	load    | xl     << dst_ | xl     << src_ | num02  << off_ ,
/*  8061 */	stmt    | 2140   << off_ ,	//	bze xl senf4  stop if chain end
/*  8062 */	bze     | xl     << dst_ | senf4  << off_ ,
/*  8063 */	stmt    | 2141   << off_ ,	//	beq num03(xl) wc senf3 jump if fcblk found
/*  8064 */	load    | r1     << dst_ | xl     << src_ | num03  << off_ ,
/*  8065 */	beq     | r1     << dst_ | wc     << src_ | senf3  << off_ ,
/*  8066 */	stmt    | 2142   << off_ ,	//	brn senf2   loop
/*  8067 */	brn     | senf2  << off_ ,
// senf3:
/*  8068 */	stmt    | 2143   << off_ ,	//senf3	mov num02(xr) num02(xl)  delete fcblk from chain
/*  8069 */	load    | r1     << dst_ | xl     << src_ | num02  << off_ ,
/*  8070 */	store   | r1     << dst_ | xr     << src_ | num02  << off_ ,
// senf4:
/*  8071 */	stmt    | 2144   << off_ ,	//senf4	mov xl enfch  get chain head
/*  8072 */	load    | xl     << dst_ | enfch  << off_ ,
/*  8073 */	stmt    | 2145   << off_ ,	//	bze xl exnul  finished if chain end
/*  8074 */	bze     | xl     << dst_ | exnul  << off_ ,
/*  8075 */	stmt    | 2146   << off_ ,	//	mov enfch trtrf(xl)  chain along
/*  8076 */	load    | r1     << dst_ | xl     << src_ | trtrf  << off_ ,
/*  8077 */	store   | r1     << dst_ | enfch  << off_ ,
/*  8078 */	stmt    | 2147   << off_ ,	//	mov wa ionmo(xl)  name offset
/*  8079 */	load    | wa     << dst_ | xl     << src_ | ionmo  << off_ ,
/*  8080 */	stmt    | 2148   << off_ ,	//	mov xl ionmb(xl)  name base
/*  8081 */	load    | xl     << dst_ | xl     << src_ | ionmb  << off_ ,
/*  8082 */	stmt    | 2149   << off_ ,	//	jsr dtach   detach name
/*  8083 */	call    | dtach  << off_ ,
/*  8084 */	stmt    | 2150   << off_ ,	//	brn senf4   loop till done
/*  8085 */	brn     | senf4  << off_ ,
/*  8086 */	0       ,
// s_eqf:
/*  8087 */	stmt    | 2151   << off_ ,	//	jsr acomp   call arithmetic comparison routine
/*  8088 */	call    | acomp  << off_ ,
/*  8089 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/*  8090 */	err     | 101    << off_ ,
/*  8091 */	err     | 102    << off_ ,
/*  8092 */	ppm     | exfal  << off_ ,
/*  8093 */	ppm     | exnul  << off_ ,
/*  8094 */	ppm     | exfal  << off_ ,
/*  8095 */	0       ,
// s_evl:
/*  8096 */	stmt    | 2152   << off_ ,	//	mov xr (xs)+  load argument
/*  8097 */	load    | xr     << dst_ | xs     << src_ ,
/*  8098 */	ica     | xs     << dst_ ,
/*  8099 */	stmt    | 2153   << off_ ,	//	lcw wc   load next code word
/*  8100 */	lcw     | wc     << dst_ ,
/*  8101 */	stmt    | 2154   << off_ ,	//	bne wc =ofne_ sevl1 jump if called by value
/*  8102 */	loadi   | r2     << dst_ | ofne_  << off_ ,
/*  8103 */	bne     | wc     << dst_ | r2     << src_ | sevl1  << off_ ,
/*  8104 */	stmt    | 2155   << off_ ,	//	scp xl   copy code pointer
/*  8105 */	scp     | xl     << dst_ ,
/*  8106 */	stmt    | 2156   << off_ ,	//	mov wa (xl)  get next code word
/*  8107 */	load    | wa     << dst_ | xl     << src_ ,
/*  8108 */	stmt    | 2157   << off_ ,	//	bne wa =ornm_ sevl2 by name unless expression
/*  8109 */	loadi   | r2     << dst_ | ornm_  << off_ ,
/*  8110 */	bne     | wa     << dst_ | r2     << src_ | sevl2  << off_ ,
/*  8111 */	stmt    | 2158   << off_ ,	//	bnz num01(xs) sevl2  jump if by name
/*  8112 */	load    | r1     << dst_ | xs     << src_ | num01  << off_ ,
/*  8113 */	bnz     | r1     << dst_ | sevl2  << off_ ,
// sevl1:
/*  8114 */	stmt    | 2159   << off_ ,	//sevl1	zer wb   set flag for by value
/*  8115 */	move    | wb     << dst_ ,
/*  8116 */	stmt    | 2160   << off_ ,	//	mov -(xs) wc  save code word
/*  8117 */	dca     | xs     << dst_ ,
/*  8118 */	store   | wc     << dst_ | xs     << src_ ,
/*  8119 */	stmt    | 2161   << off_ ,	//	jsr gtexp   convert to expression
/*  8120 */	call    | gtexp  << off_ ,
/*  8121 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8122 */	err     | 103    << off_ ,
/*  8123 */	stmt    | 2162   << off_ ,	//	zer r_ccb   forget interim code block
/*  8124 */	store   | r0     << dst_ | r_ccb  << off_ ,
/*  8125 */	stmt    | 2163   << off_ ,	//	zer wb   set flag for by value
/*  8126 */	move    | wb     << dst_ ,
/*  8127 */	stmt    | 2164   << off_ ,	//	jsr evalx   evaluate expression by value
/*  8128 */	call    | evalx  << off_ ,
/*  8129 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8130 */	ppm     | exfal  << off_ ,
/*  8131 */	stmt    | 2165   << off_ ,	//	mov xl xr  copy result
/*  8132 */	move    | xl     << dst_ | xr     << src_ ,
/*  8133 */	stmt    | 2166   << off_ ,	//	mov xr (xs)  reload next code word
/*  8134 */	load    | xr     << dst_ | xs     << src_ ,
/*  8135 */	stmt    | 2167   << off_ ,	//	mov (xs) xl  stack result
/*  8136 */	store   | xl     << dst_ | xs     << src_ ,
/*  8137 */	stmt    | 2168   << off_ ,	//	bri (xr)   jump to execute next code word
/*  8138 */	load    | r1     << dst_ | xr     << src_ ,
/*  8139 */	bri     | r1     << dst_ ,
// sevl2:
/*  8140 */	stmt    | 2169   << off_ ,	//sevl2	mov wb =num01  set flag for by name
/*  8141 */	loadi   | wb     << dst_ | num01  << off_ ,
/*  8142 */	stmt    | 2170   << off_ ,	//	jsr gtexp   convert to expression
/*  8143 */	call    | gtexp  << off_ ,
/*  8144 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8145 */	err     | 103    << off_ ,
/*  8146 */	stmt    | 2171   << off_ ,	//	zer r_ccb   forget interim code block
/*  8147 */	store   | r0     << dst_ | r_ccb  << off_ ,
/*  8148 */	stmt    | 2172   << off_ ,	//	mov wb =num01  set flag for by name
/*  8149 */	loadi   | wb     << dst_ | num01  << off_ ,
/*  8150 */	stmt    | 2173   << off_ ,	//	jsr evalx   evaluate expression by name
/*  8151 */	call    | evalx  << off_ ,
/*  8152 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8153 */	ppm     | exfal  << off_ ,
/*  8154 */	stmt    | 2174   << off_ ,	//	brn exnam   exit with name
/*  8155 */	brn     | exnam  << off_ ,
/*  8156 */	0       ,
// s_ext:
/*  8157 */	stmt    | 2175   << off_ ,	//	zer wb   clear amount of static shift
/*  8158 */	move    | wb     << dst_ ,
/*  8159 */	stmt    | 2176   << off_ ,	//	zer r_ccb   forget interim code block
/*  8160 */	store   | r0     << dst_ | r_ccb  << off_ ,
/*  8161 */	stmt    | 2177   << off_ ,	//	zer dnams   collect sediment too
/*  8162 */	store   | r0     << dst_ | dnams  << off_ ,
/*  8163 */	stmt    | 2178   << off_ ,	//	jsr gbcol   compact memory by collecting
/*  8164 */	call    | gbcol  << off_ ,
/*  8165 */	stmt    | 2179   << off_ ,	//	mov dnams xr  record new sediment size
/*  8166 */	store   | xr     << dst_ | dnams  << off_ ,
/*  8167 */	stmt    | 2180   << off_ ,	//	jsr gtstg
/*  8168 */	call    | gtstg  << off_ ,
/*  8169 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8170 */	err     | 288    << off_ ,
/*  8171 */	stmt    | 2181   << off_ ,	//	mov xl xr  copy second arg string pointer
/*  8172 */	move    | xl     << dst_ | xr     << src_ ,
/*  8173 */	stmt    | 2182   << off_ ,	//	jsr gtstg   convert arg to string
/*  8174 */	call    | gtstg  << off_ ,
/*  8175 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8176 */	err     | 104    << off_ ,
/*  8177 */	stmt    | 2183   << off_ ,	//	mov -(xs) xl  save second argument
/*  8178 */	dca     | xs     << dst_ ,
/*  8179 */	store   | xl     << dst_ | xs     << src_ ,
/*  8180 */	stmt    | 2184   << off_ ,	//	mov xl xr  copy first arg string ptr
/*  8181 */	move    | xl     << dst_ | xr     << src_ ,
/*  8182 */	stmt    | 2185   << off_ ,	//	jsr gtint   check it is integer
/*  8183 */	call    | gtint  << off_ ,
/*  8184 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8185 */	ppm     | sext1  << off_ ,
/*  8186 */	stmt    | 2186   << off_ ,	//	zer xl   note it is integer
/*  8187 */	move    | xl     << dst_ ,
/*  8188 */	stmt    | 2187   << off_ ,	//	ldi icval(xr)   get integer arg
/*  8189 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  8190 */	ldi     | r1     << dst_ ,
// sext1:
/*  8191 */	stmt    | 2188   << off_ ,	//sext1	mov wb r_fcb  get fcblk chain header
/*  8192 */	load    | wb     << dst_ | r_fcb  << off_ ,
/*  8193 */	stmt    | 2189   << off_ ,	//	mov xr =headv  point to v.v string
/*  8194 */	loadi   | xr     << dst_ | headv  << off_ ,
/*  8195 */	stmt    | 2190   << off_ ,	//	mov wa (xs)+  provide second argument scblk
/*  8196 */	load    | wa     << dst_ | xs     << src_ ,
/*  8197 */	ica     | xs     << dst_ ,
/*  8198 */	stmt    | 2191   << off_ ,	//	jsr sysxi   call external routine
/*  8199 */	sys     | sysxi_ << off_ ,
/*  8200 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  8201 */	err     | 105    << off_ ,
/*  8202 */	err     | 106    << off_ ,
/*  8203 */	stmt    | 2192   << off_ ,	//	ieq exnul   return if argument 0
/*  8204 */	ieq     | exnul  << off_ ,
/*  8205 */	stmt    | 2193   << off_ ,	//	igt sext2   skip if positive
/*  8206 */	igt     | sext2  << off_ ,
/*  8207 */	stmt    | 2194   << off_ ,	//	ngi    make positive
/*  8208 */	ngi     ,
// sext2:
/*  8209 */	stmt    | 2195   << off_ ,	//sext2	mfi wc   get value in work reg
/*  8210 */	move    | wc     << dst_ | ia     << src_ ,
/*  8211 */	stmt    | 2196   << off_ ,	//	add wa wc  prepare to test for continue
/*  8212 */	add     | wa     << dst_ | wc     << src_ ,
/*  8213 */	stmt    | 2197   << off_ ,	//	beq wa =num05 sext5 continued execution if 4 plus 1
/*  8214 */	loadi   | r2     << dst_ | num05  << off_ ,
/*  8215 */	beq     | wa     << dst_ | r2     << src_ | sext5  << off_ ,
/*  8216 */	stmt    | 2198   << off_ ,	//	zer gbcnt   resuming execution so reset
/*  8217 */	store   | r0     << dst_ | gbcnt  << off_ ,
/*  8218 */	stmt    | 2199   << off_ ,	//	bge wc =num03 sext3 skip if was 3 or 4
/*  8219 */	loadi   | r2     << dst_ | num03  << off_ ,
/*  8220 */	bge     | wc     << dst_ | r2     << src_ | sext3  << off_ ,
/*  8221 */	stmt    | 2200   << off_ ,	//	mov -(xs) wc  save value
/*  8222 */	dca     | xs     << dst_ ,
/*  8223 */	store   | wc     << dst_ | xs     << src_ ,
/*  8224 */	stmt    | 2201   << off_ ,	//	zer wc   set to read options
/*  8225 */	move    | wc     << dst_ ,
/*  8226 */	stmt    | 2202   << off_ ,	//	jsr prpar   read syspp options
/*  8227 */	call    | prpar  << off_ ,
/*  8228 */	stmt    | 2203   << off_ ,	//	mov wc (xs)+  restore value
/*  8229 */	load    | wc     << dst_ | xs     << src_ ,
/*  8230 */	ica     | xs     << dst_ ,
// sext3:
/*  8231 */	stmt    | 2204   << off_ ,	//sext3	mnz headp   assume no headers
/*  8232 */	store   | xs     << dst_ | headp  << off_ ,
/*  8233 */	stmt    | 2205   << off_ ,	//	bne wc =num01 sext4 skip if not 1
/*  8234 */	loadi   | r2     << dst_ | num01  << off_ ,
/*  8235 */	bne     | wc     << dst_ | r2     << src_ | sext4  << off_ ,
/*  8236 */	stmt    | 2206   << off_ ,	//	zer headp   request header printing
/*  8237 */	store   | r0     << dst_ | headp  << off_ ,
// sext4:
/*  8238 */	stmt    | 2207   << off_ ,	//sext4	jsr systm   get execution time start (sgd11)
/*  8239 */	sys     | systm_ << off_ ,
/*  8240 */	stmt    | 2208   << off_ ,	//	sti timsx   save as initial time
/*  8241 */	store   | ia     << dst_ | timsx  << off_ ,
/*  8242 */	stmt    | 2209   << off_ ,	//	ldi kvstc   reset to ensure ...
/*  8243 */	load    | r1     << dst_ | kvstc  << off_ ,
/*  8244 */	ldi     | r1     << dst_ ,
/*  8245 */	stmt    | 2210   << off_ ,	//	sti kvstl   ... correct execution stats
/*  8246 */	store   | ia     << dst_ | kvstl  << off_ ,
/*  8247 */	stmt    | 2211   << off_ ,	//	jsr stgcc   recompute countdown counters
/*  8248 */	call    | stgcc  << off_ ,
/*  8249 */	stmt    | 2212   << off_ ,	//	brn exnul   resume execution
/*  8250 */	brn     | exnul  << off_ ,
// sext5:
/*  8251 */	stmt    | 2213   << off_ ,	//sext5	mov xr =inton  integer one
/*  8252 */	loadi   | xr     << dst_ | inton  << off_ ,
/*  8253 */	stmt    | 2214   << off_ ,	//	brn exixr   return as result
/*  8254 */	brn     | exixr  << off_ ,
/*  8255 */	0       ,
// s_exp:
/*  8256 */	stmt    | 2215   << off_ ,	//	mov xr (xs)+  get argument
/*  8257 */	load    | xr     << dst_ | xs     << src_ ,
/*  8258 */	ica     | xs     << dst_ ,
/*  8259 */	stmt    | 2216   << off_ ,	//	jsr gtrea   convert to real
/*  8260 */	call    | gtrea  << off_ ,
/*  8261 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8262 */	err     | 304    << off_ ,
/*  8263 */	stmt    | 2217   << off_ ,	//	ldr rcval(xr)   load accumulator with argument
/*  8264 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  8265 */	ldr     | r1     << dst_ ,
/*  8266 */	stmt    | 2218   << off_ ,	//	etx    take exponential
/*  8267 */	realop  | etx    << off_ ,
/*  8268 */	stmt    | 2219   << off_ ,	//	rno exrea   if no overflow, return result in ra
/*  8269 */	rno     | exrea  << off_ ,
/*  8270 */	stmt    | 2220   << off_ ,	//	erb 305 exp produced real overflow
/*  8271 */	erb     | 305    << off_ ,
/*  8272 */	0       ,
// s_fld:
/*  8273 */	stmt    | 2221   << off_ ,	//	jsr gtsmi   get second argument (field number)
/*  8274 */	call    | gtsmi  << off_ ,
/*  8275 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  8276 */	err     | 107    << off_ ,
/*  8277 */	ppm     | exfal  << off_ ,
/*  8278 */	stmt    | 2222   << off_ ,	//	mov wb xr  else save integer value
/*  8279 */	move    | wb     << dst_ | xr     << src_ ,
/*  8280 */	stmt    | 2223   << off_ ,	//	mov xr (xs)+  load first argument
/*  8281 */	load    | xr     << dst_ | xs     << src_ ,
/*  8282 */	ica     | xs     << dst_ ,
/*  8283 */	stmt    | 2224   << off_ ,	//	jsr gtnvr   point to vrblk
/*  8284 */	call    | gtnvr  << off_ ,
/*  8285 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8286 */	ppm     | sfld1  << off_ ,
/*  8287 */	stmt    | 2225   << off_ ,	//	mov xr vrfnc(xr)  else point to function block
/*  8288 */	load    | xr     << dst_ | xr     << src_ | vrfnc  << off_ ,
/*  8289 */	stmt    | 2226   << off_ ,	//	bne (xr) =b_dfc sfld1 error if not datatype function
/*  8290 */	load    | r1     << dst_ | xr     << src_ ,
/*  8291 */	loadi   | r2     << dst_ | b_dfc  << off_ ,
/*  8292 */	bne     | r1     << dst_ | r2     << src_ | sfld1  << off_ ,
/*  8293 */	stmt    | 2227   << off_ ,	//	bze wb exfal  fail if argument number is zero
/*  8294 */	bze     | wb     << dst_ | exfal  << off_ ,
/*  8295 */	stmt    | 2228   << off_ ,	//	bgt wb fargs(xr) exfal fail if too large
/*  8296 */	load    | r2     << dst_ | xr     << src_ | fargs  << off_ ,
/*  8297 */	bgt     | wb     << dst_ | r2     << src_ | exfal  << off_ ,
/*  8298 */	stmt    | 2229   << off_ ,	//	wtb wb   else convert to byte offset
/*  8299 */	stmt    | 2230   << off_ ,	//	add xr wb  point to field name
/*  8300 */	add     | xr     << dst_ | wb     << src_ ,
/*  8301 */	stmt    | 2231   << off_ ,	//	mov xr dfflb(xr)  load vrblk pointer
/*  8302 */	load    | xr     << dst_ | xr     << src_ | dfflb  << off_ ,
/*  8303 */	stmt    | 2232   << off_ ,	//	brn exvnm   exit to build nmblk
/*  8304 */	brn     | exvnm  << off_ ,
// sfld1:
/*  8305 */	stmt    | 2233   << off_ ,	//sfld1	erb 108 field first argument is not datatype name
/*  8306 */	erb     | 108    << off_ ,
/*  8307 */	0       ,
// s_fnc:
/*  8308 */	stmt    | 2234   << off_ ,	//	mov wb =p_fnc  set pcode for p_fnc
/*  8309 */	loadi   | wb     << dst_ | p_fnc  << off_ ,
/*  8310 */	stmt    | 2235   << off_ ,	//	zer xr   p0blk
/*  8311 */	move    | xr     << dst_ ,
/*  8312 */	stmt    | 2236   << off_ ,	//	jsr pbild   build p_fnc node
/*  8313 */	call    | pbild  << off_ ,
/*  8314 */	stmt    | 2237   << off_ ,	//	mov xl xr  save pointer to it
/*  8315 */	move    | xl     << dst_ | xr     << src_ ,
/*  8316 */	stmt    | 2238   << off_ ,	//	mov xr (xs)+  get argument
/*  8317 */	load    | xr     << dst_ | xs     << src_ ,
/*  8318 */	ica     | xs     << dst_ ,
/*  8319 */	stmt    | 2239   << off_ ,	//	jsr gtpat   convert to pattern
/*  8320 */	call    | gtpat  << off_ ,
/*  8321 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8322 */	err     | 259    << off_ ,
/*  8323 */	stmt    | 2240   << off_ ,	//	jsr pconc   concatenate to p_fnc node
/*  8324 */	call    | pconc  << off_ ,
/*  8325 */	stmt    | 2241   << off_ ,	//	mov xl xr  save ptr to concatenated pattern
/*  8326 */	move    | xl     << dst_ | xr     << src_ ,
/*  8327 */	stmt    | 2242   << off_ ,	//	mov wb =p_fna  set for p_fna pcode
/*  8328 */	loadi   | wb     << dst_ | p_fna  << off_ ,
/*  8329 */	stmt    | 2243   << off_ ,	//	zer xr   p0blk
/*  8330 */	move    | xr     << dst_ ,
/*  8331 */	stmt    | 2244   << off_ ,	//	jsr pbild   construct p_fna node
/*  8332 */	call    | pbild  << off_ ,
/*  8333 */	stmt    | 2245   << off_ ,	//	mov pthen(xr) xl  set pattern as pthen
/*  8334 */	store   | xl     << dst_ | xr     << src_ | pthen  << off_ ,
/*  8335 */	stmt    | 2246   << off_ ,	//	mov -(xs) xr  set as result
/*  8336 */	dca     | xs     << dst_ ,
/*  8337 */	store   | xr     << dst_ | xs     << src_ ,
/*  8338 */	stmt    | 2247   << off_ ,	//	lcw xr   get next code word
/*  8339 */	lcw     | xr     << dst_ ,
/*  8340 */	stmt    | 2248   << off_ ,	//	bri (xr)   execute next code word
/*  8341 */	load    | r1     << dst_ | xr     << src_ ,
/*  8342 */	bri     | r1     << dst_ ,
/*  8343 */	0       ,
// s_gef:
/*  8344 */	stmt    | 2249   << off_ ,	//	jsr acomp   call arithmetic comparison routine
/*  8345 */	call    | acomp  << off_ ,
/*  8346 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/*  8347 */	err     | 109    << off_ ,
/*  8348 */	err     | 110    << off_ ,
/*  8349 */	ppm     | exfal  << off_ ,
/*  8350 */	ppm     | exnul  << off_ ,
/*  8351 */	ppm     | exnul  << off_ ,
/*  8352 */	0       ,
// s_gtf:
/*  8353 */	stmt    | 2250   << off_ ,	//	jsr acomp   call arithmetic comparison routine
/*  8354 */	call    | acomp  << off_ ,
/*  8355 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/*  8356 */	err     | 111    << off_ ,
/*  8357 */	err     | 112    << off_ ,
/*  8358 */	ppm     | exfal  << off_ ,
/*  8359 */	ppm     | exfal  << off_ ,
/*  8360 */	ppm     | exnul  << off_ ,
/*  8361 */	0       ,
// s_hst:
/*  8362 */	stmt    | 2251   << off_ ,	//	mov wc (xs)+  get fifth arg
/*  8363 */	load    | wc     << dst_ | xs     << src_ ,
/*  8364 */	ica     | xs     << dst_ ,
/*  8365 */	stmt    | 2252   << off_ ,	//	mov wb (xs)+  get fourth arg
/*  8366 */	load    | wb     << dst_ | xs     << src_ ,
/*  8367 */	ica     | xs     << dst_ ,
/*  8368 */	stmt    | 2253   << off_ ,	//	mov xr (xs)+  get third arg
/*  8369 */	load    | xr     << dst_ | xs     << src_ ,
/*  8370 */	ica     | xs     << dst_ ,
/*  8371 */	stmt    | 2254   << off_ ,	//	mov xl (xs)+  get second arg
/*  8372 */	load    | xl     << dst_ | xs     << src_ ,
/*  8373 */	ica     | xs     << dst_ ,
/*  8374 */	stmt    | 2255   << off_ ,	//	mov wa (xs)+  get first arg
/*  8375 */	load    | wa     << dst_ | xs     << src_ ,
/*  8376 */	ica     | xs     << dst_ ,
/*  8377 */	stmt    | 2256   << off_ ,	//	jsr syshs   enter syshs routine
/*  8378 */	sys     | syshs_ << off_ ,
/*  8379 */	jsrerr  | r1     << dst_ | 8      << off_ ,
/*  8380 */	err     | 254    << off_ ,
/*  8381 */	err     | 255    << off_ ,
/*  8382 */	ppm     | shst1  << off_ ,
/*  8383 */	ppm     | exnul  << off_ ,
/*  8384 */	ppm     | exixr  << off_ ,
/*  8385 */	ppm     | exfal  << off_ ,
/*  8386 */	ppm     | shst3  << off_ ,
/*  8387 */	ppm     | shst4  << off_ ,
// shst1:
/*  8388 */	stmt    | 2257   << off_ ,	//shst1	bze xl exnul  null string if syshs uncooperative
/*  8389 */	bze     | xl     << dst_ | exnul  << off_ ,
/*  8390 */	stmt    | 2258   << off_ ,	//	mov wa sclen(xl)  length
/*  8391 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/*  8392 */	stmt    | 2259   << off_ ,	//	zer wb   zero offset
/*  8393 */	move    | wb     << dst_ ,
// shst2:
/*  8394 */	stmt    | 2260   << off_ ,	//shst2	jsr sbstr   build copy of string
/*  8395 */	call    | sbstr  << off_ ,
/*  8396 */	stmt    | 2261   << off_ ,	//	mov -(xs) xr  stack the result
/*  8397 */	dca     | xs     << dst_ ,
/*  8398 */	store   | xr     << dst_ | xs     << src_ ,
/*  8399 */	stmt    | 2262   << off_ ,	//	lcw xr   load next code word
/*  8400 */	lcw     | xr     << dst_ ,
/*  8401 */	stmt    | 2263   << off_ ,	//	bri (xr)   execute it
/*  8402 */	load    | r1     << dst_ | xr     << src_ ,
/*  8403 */	bri     | r1     << dst_ ,
// shst3:
/*  8404 */	stmt    | 2264   << off_ ,	//shst3	zer wb   treat xl like an scblk ptr
/*  8405 */	move    | wb     << dst_ ,
/*  8406 */	stmt    | 2265   << off_ ,	//	sub wb =cfp_f  by creating a negative offset
/*  8407 */	loadi   | r2     << dst_ | cfp_f  << off_ ,
/*  8408 */	sub     | wb     << dst_ | r2     << src_ ,
/*  8409 */	stmt    | 2266   << off_ ,	//	brn shst2   join to copy string
/*  8410 */	brn     | shst2  << off_ ,
// shst4:
/*  8411 */	stmt    | 2267   << off_ ,	//shst4	mov -(xs) xr  stack results
/*  8412 */	dca     | xs     << dst_ ,
/*  8413 */	store   | xr     << dst_ | xs     << src_ ,
/*  8414 */	stmt    | 2268   << off_ ,	//	jsr copyb   make copy of block
/*  8415 */	call    | copyb  << off_ ,
/*  8416 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8417 */	ppm     | exits  << off_ ,
/*  8418 */	stmt    | 2269   << off_ ,	//	brn exsid   set current id value otherwise
/*  8419 */	brn     | exsid  << off_ ,
/*  8420 */	0       ,
// s_idn:
/*  8421 */	stmt    | 2270   << off_ ,	//	mov xr (xs)+  load second argument
/*  8422 */	load    | xr     << dst_ | xs     << src_ ,
/*  8423 */	ica     | xs     << dst_ ,
/*  8424 */	stmt    | 2271   << off_ ,	//	mov xl (xs)+  load first argument
/*  8425 */	load    | xl     << dst_ | xs     << src_ ,
/*  8426 */	ica     | xs     << dst_ ,
/*  8427 */	stmt    | 2272   << off_ ,	//	jsr ident   call ident comparison routine
/*  8428 */	call    | ident  << off_ ,
/*  8429 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8430 */	ppm     | exnul  << off_ ,
/*  8431 */	stmt    | 2273   << off_ ,	//	brn exfal   fail if differ
/*  8432 */	brn     | exfal  << off_ ,
/*  8433 */	0       ,
// s_inp:
/*  8434 */	stmt    | 2274   << off_ ,	//	zer wb   input flag
/*  8435 */	move    | wb     << dst_ ,
/*  8436 */	stmt    | 2275   << off_ ,	//	jsr ioput   call input/output assoc. routine
/*  8437 */	call    | ioput  << off_ ,
/*  8438 */	jsrerr  | r1     << dst_ | 7      << off_ ,
/*  8439 */	err     | 113    << off_ ,
/*  8440 */	err     | 114    << off_ ,
/*  8441 */	err     | 115    << off_ ,
/*  8442 */	err     | 116    << off_ ,
/*  8443 */	ppm     | exfal  << off_ ,
/*  8444 */	err     | 117    << off_ ,
/*  8445 */	err     | 289    << off_ ,
/*  8446 */	stmt    | 2276   << off_ ,	//	brn exnul   return null string
/*  8447 */	brn     | exnul  << off_ ,
/*  8448 */	0       ,
// s_int:
/*  8449 */	stmt    | 2277   << off_ ,	//	mov xr (xs)+  load argument
/*  8450 */	load    | xr     << dst_ | xs     << src_ ,
/*  8451 */	ica     | xs     << dst_ ,
/*  8452 */	stmt    | 2278   << off_ ,	//	jsr gtnum   convert to numeric
/*  8453 */	call    | gtnum  << off_ ,
/*  8454 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8455 */	ppm     | exfal  << off_ ,
/*  8456 */	stmt    | 2279   << off_ ,	//	beq wa =b_icl exnul return null if integer
/*  8457 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/*  8458 */	beq     | wa     << dst_ | r2     << src_ | exnul  << off_ ,
/*  8459 */	stmt    | 2280   << off_ ,	//	brn exfal   fail if real
/*  8460 */	brn     | exfal  << off_ ,
/*  8461 */	0       ,
// s_itm:
/*  8462 */	stmt    | 2281   << off_ ,	//	bnz wa sitm1  jump if at least one arg
/*  8463 */	bnz     | wa     << dst_ | sitm1  << off_ ,
/*  8464 */	stmt    | 2282   << off_ ,	//	mov -(xs) =nulls  else supply garbage null arg
/*  8465 */	loadi   | r1     << dst_ | nulls  << off_ ,
/*  8466 */	dca     | xs     << dst_ ,
/*  8467 */	store   | r1     << dst_ | xs     << src_ ,
/*  8468 */	stmt    | 2283   << off_ ,	//	mov wa =num01  and fix argument count
/*  8469 */	loadi   | wa     << dst_ | num01  << off_ ,
// sitm1:
/*  8470 */	stmt    | 2284   << off_ ,	//sitm1	scp xr   get current code pointer
/*  8471 */	scp     | xr     << dst_ ,
/*  8472 */	stmt    | 2285   << off_ ,	//	mov xl (xr)  load next code word
/*  8473 */	load    | xl     << dst_ | xr     << src_ ,
/*  8474 */	stmt    | 2286   << off_ ,	//	dcv wa   get number of subscripts
/*  8475 */	dcv     | wa     << dst_ ,
/*  8476 */	stmt    | 2287   << off_ ,	//	mov xr wa  copy for arref
/*  8477 */	move    | xr     << dst_ | wa     << src_ ,
/*  8478 */	stmt    | 2288   << off_ ,	//	beq xl =ofne_ sitm2 jump if called by name
/*  8479 */	loadi   | r2     << dst_ | ofne_  << off_ ,
/*  8480 */	beq     | xl     << dst_ | r2     << src_ | sitm2  << off_ ,
/*  8481 */	stmt    | 2289   << off_ ,	//	zer wb   set code for call by value
/*  8482 */	move    | wb     << dst_ ,
/*  8483 */	stmt    | 2290   << off_ ,	//	brn arref   off to array reference routine
/*  8484 */	brn     | arref  << off_ ,
// sitm2:
/*  8485 */	stmt    | 2291   << off_ ,	//sitm2	mnz wb   set code for call by name
/*  8486 */	move    | wb     << dst_ | xs     << src_ ,
/*  8487 */	stmt    | 2292   << off_ ,	//	lcw wa   load and ignore ofne_ call
/*  8488 */	lcw     | wa     << dst_ ,
/*  8489 */	stmt    | 2293   << off_ ,	//	brn arref   off to array reference routine
/*  8490 */	brn     | arref  << off_ ,
/*  8491 */	0       ,
// s_lef:
/*  8492 */	stmt    | 2294   << off_ ,	//	jsr acomp   call arithmetic comparison routine
/*  8493 */	call    | acomp  << off_ ,
/*  8494 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/*  8495 */	err     | 118    << off_ ,
/*  8496 */	err     | 119    << off_ ,
/*  8497 */	ppm     | exnul  << off_ ,
/*  8498 */	ppm     | exnul  << off_ ,
/*  8499 */	ppm     | exfal  << off_ ,
/*  8500 */	0       ,
// s_len:
/*  8501 */	stmt    | 2295   << off_ ,	//	mov wb =p_len  set pcode for integer arg case
/*  8502 */	loadi   | wb     << dst_ | p_len  << off_ ,
/*  8503 */	stmt    | 2296   << off_ ,	//	mov wa =p_lnd  set pcode for expr arg case
/*  8504 */	loadi   | wa     << dst_ | p_lnd  << off_ ,
/*  8505 */	stmt    | 2297   << off_ ,	//	jsr patin   call common routine to build node
/*  8506 */	call    | patin  << off_ ,
/*  8507 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  8508 */	err     | 120    << off_ ,
/*  8509 */	err     | 121    << off_ ,
/*  8510 */	stmt    | 2298   << off_ ,	//	mov -(xs) xr  stack result
/*  8511 */	dca     | xs     << dst_ ,
/*  8512 */	store   | xr     << dst_ | xs     << src_ ,
/*  8513 */	stmt    | 2299   << off_ ,	//	lcw xr   get next code word
/*  8514 */	lcw     | xr     << dst_ ,
/*  8515 */	stmt    | 2300   << off_ ,	//	bri (xr)   execute it
/*  8516 */	load    | r1     << dst_ | xr     << src_ ,
/*  8517 */	bri     | r1     << dst_ ,
/*  8518 */	0       ,
// s_leq:
/*  8519 */	stmt    | 2301   << off_ ,	//	jsr lcomp   call string comparison routine
/*  8520 */	call    | lcomp  << off_ ,
/*  8521 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/*  8522 */	err     | 122    << off_ ,
/*  8523 */	err     | 123    << off_ ,
/*  8524 */	ppm     | exfal  << off_ ,
/*  8525 */	ppm     | exnul  << off_ ,
/*  8526 */	ppm     | exfal  << off_ ,
/*  8527 */	0       ,
// s_lge:
/*  8528 */	stmt    | 2302   << off_ ,	//	jsr lcomp   call string comparison routine
/*  8529 */	call    | lcomp  << off_ ,
/*  8530 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/*  8531 */	err     | 124    << off_ ,
/*  8532 */	err     | 125    << off_ ,
/*  8533 */	ppm     | exfal  << off_ ,
/*  8534 */	ppm     | exnul  << off_ ,
/*  8535 */	ppm     | exnul  << off_ ,
/*  8536 */	0       ,
// s_lgt:
/*  8537 */	stmt    | 2303   << off_ ,	//	jsr lcomp   call string comparison routine
/*  8538 */	call    | lcomp  << off_ ,
/*  8539 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/*  8540 */	err     | 126    << off_ ,
/*  8541 */	err     | 127    << off_ ,
/*  8542 */	ppm     | exfal  << off_ ,
/*  8543 */	ppm     | exfal  << off_ ,
/*  8544 */	ppm     | exnul  << off_ ,
/*  8545 */	0       ,
// s_lle:
/*  8546 */	stmt    | 2304   << off_ ,	//	jsr lcomp   call string comparison routine
/*  8547 */	call    | lcomp  << off_ ,
/*  8548 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/*  8549 */	err     | 128    << off_ ,
/*  8550 */	err     | 129    << off_ ,
/*  8551 */	ppm     | exnul  << off_ ,
/*  8552 */	ppm     | exnul  << off_ ,
/*  8553 */	ppm     | exfal  << off_ ,
/*  8554 */	0       ,
// s_llt:
/*  8555 */	stmt    | 2305   << off_ ,	//	jsr lcomp   call string comparison routine
/*  8556 */	call    | lcomp  << off_ ,
/*  8557 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/*  8558 */	err     | 130    << off_ ,
/*  8559 */	err     | 131    << off_ ,
/*  8560 */	ppm     | exnul  << off_ ,
/*  8561 */	ppm     | exfal  << off_ ,
/*  8562 */	ppm     | exfal  << off_ ,
/*  8563 */	0       ,
// s_lne:
/*  8564 */	stmt    | 2306   << off_ ,	//	jsr lcomp   call string comparison routine
/*  8565 */	call    | lcomp  << off_ ,
/*  8566 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/*  8567 */	err     | 132    << off_ ,
/*  8568 */	err     | 133    << off_ ,
/*  8569 */	ppm     | exnul  << off_ ,
/*  8570 */	ppm     | exfal  << off_ ,
/*  8571 */	ppm     | exnul  << off_ ,
/*  8572 */	0       ,
// s_lnf:
/*  8573 */	stmt    | 2307   << off_ ,	//	mov xr (xs)+  get argument
/*  8574 */	load    | xr     << dst_ | xs     << src_ ,
/*  8575 */	ica     | xs     << dst_ ,
/*  8576 */	stmt    | 2308   << off_ ,	//	jsr gtrea   convert to real
/*  8577 */	call    | gtrea  << off_ ,
/*  8578 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8579 */	err     | 306    << off_ ,
/*  8580 */	stmt    | 2309   << off_ ,	//	ldr rcval(xr)   load accumulator with argument
/*  8581 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  8582 */	ldr     | r1     << dst_ ,
/*  8583 */	stmt    | 2310   << off_ ,	//	req slnf1   overflow if argument is 0
/*  8584 */	req     | slnf1  << off_ ,
/*  8585 */	stmt    | 2311   << off_ ,	//	rlt slnf2   error if argument less than 0
/*  8586 */	rlt     | slnf2  << off_ ,
/*  8587 */	stmt    | 2312   << off_ ,	//	lnf    take natural logarithm
/*  8588 */	realop  | lnf    << off_ ,
/*  8589 */	stmt    | 2313   << off_ ,	//	rno exrea   if no overflow, return result in ra
/*  8590 */	rno     | exrea  << off_ ,
// slnf1:
/*  8591 */	stmt    | 2314   << off_ ,	//slnf1	erb 307 ln produced real overflow
/*  8592 */	erb     | 307    << off_ ,
// slnf2:
/*  8593 */	stmt    | 2315   << off_ ,	//slnf2	erb 315 ln argument negative
/*  8594 */	erb     | 315    << off_ ,
/*  8595 */	0       ,
// s_loc:
/*  8596 */	stmt    | 2316   << off_ ,	//	jsr gtsmi   get second argument (local number)
/*  8597 */	call    | gtsmi  << off_ ,
/*  8598 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  8599 */	err     | 134    << off_ ,
/*  8600 */	ppm     | exfal  << off_ ,
/*  8601 */	stmt    | 2317   << off_ ,	//	mov wb xr  save local number
/*  8602 */	move    | wb     << dst_ | xr     << src_ ,
/*  8603 */	stmt    | 2318   << off_ ,	//	mov xr (xs)+  load first argument
/*  8604 */	load    | xr     << dst_ | xs     << src_ ,
/*  8605 */	ica     | xs     << dst_ ,
/*  8606 */	stmt    | 2319   << off_ ,	//	jsr gtnvr   point to vrblk
/*  8607 */	call    | gtnvr  << off_ ,
/*  8608 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8609 */	ppm     | sloc1  << off_ ,
/*  8610 */	stmt    | 2320   << off_ ,	//	mov xr vrfnc(xr)  else load function pointer
/*  8611 */	load    | xr     << dst_ | xr     << src_ | vrfnc  << off_ ,
/*  8612 */	stmt    | 2321   << off_ ,	//	bne (xr) =b_pfc sloc1 jump if not program defined
/*  8613 */	load    | r1     << dst_ | xr     << src_ ,
/*  8614 */	loadi   | r2     << dst_ | b_pfc  << off_ ,
/*  8615 */	bne     | r1     << dst_ | r2     << src_ | sloc1  << off_ ,
/*  8616 */	stmt    | 2322   << off_ ,	//	bze wb exfal  fail if second arg is zero
/*  8617 */	bze     | wb     << dst_ | exfal  << off_ ,
/*  8618 */	stmt    | 2323   << off_ ,	//	bgt wb pfnlo(xr) exfal or too large
/*  8619 */	load    | r2     << dst_ | xr     << src_ | pfnlo  << off_ ,
/*  8620 */	bgt     | wb     << dst_ | r2     << src_ | exfal  << off_ ,
/*  8621 */	stmt    | 2324   << off_ ,	//	add wb fargs(xr)  else adjust offset to include args
/*  8622 */	load    | r2     << dst_ | xr     << src_ | fargs  << off_ ,
/*  8623 */	add     | wb     << dst_ | r2     << src_ ,
/*  8624 */	stmt    | 2325   << off_ ,	//	wtb wb   convert to bytes
/*  8625 */	stmt    | 2326   << off_ ,	//	add xr wb  point to local pointer
/*  8626 */	add     | xr     << dst_ | wb     << src_ ,
/*  8627 */	stmt    | 2327   << off_ ,	//	mov xr pfagb(xr)  load vrblk pointer
/*  8628 */	load    | xr     << dst_ | xr     << src_ | pfagb  << off_ ,
/*  8629 */	stmt    | 2328   << off_ ,	//	brn exvnm   exit building nmblk
/*  8630 */	brn     | exvnm  << off_ ,
// sloc1:
/*  8631 */	stmt    | 2329   << off_ ,	//sloc1	erb 135 local first arg is not a program function name
/*  8632 */	erb     | 135    << off_ ,
/*  8633 */	0       ,
// s_lod:
/*  8634 */	stmt    | 2330   << off_ ,	//	jsr gtstg   load library name
/*  8635 */	call    | gtstg  << off_ ,
/*  8636 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8637 */	err     | 136    << off_ ,
/*  8638 */	stmt    | 2331   << off_ ,	//	mov xl xr  save library name
/*  8639 */	move    | xl     << dst_ | xr     << src_ ,
/*  8640 */	stmt    | 2332   << off_ ,	//	jsr xscni   prepare to scan first argument
/*  8641 */	call    | xscni  << off_ ,
/*  8642 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  8643 */	err     | 137    << off_ ,
/*  8644 */	err     | 138    << off_ ,
/*  8645 */	stmt    | 2333   << off_ ,	//	mov -(xs) xl  stack library name
/*  8646 */	dca     | xs     << dst_ ,
/*  8647 */	store   | xl     << dst_ | xs     << src_ ,
/*  8648 */	stmt    | 2334   << off_ ,	//	mov wc =ch_pp  set delimiter one = left paren
/*  8649 */	loadi   | wc     << dst_ | ch_pp  << off_ ,
/*  8650 */	stmt    | 2335   << off_ ,	//	mov xl wc  set delimiter two = left paren
/*  8651 */	move    | xl     << dst_ | wc     << src_ ,
/*  8652 */	stmt    | 2336   << off_ ,	//	mnz wa   skip/trim blanks in prototype
/*  8653 */	move    | wa     << dst_ | xs     << src_ ,
/*  8654 */	stmt    | 2337   << off_ ,	//	jsr xscan   scan function name
/*  8655 */	call    | xscan  << off_ ,
/*  8656 */	stmt    | 2338   << off_ ,	//	mov -(xs) xr  save ptr to function name
/*  8657 */	dca     | xs     << dst_ ,
/*  8658 */	store   | xr     << dst_ | xs     << src_ ,
/*  8659 */	stmt    | 2339   << off_ ,	//	bnz wa slod1  jump if left paren found
/*  8660 */	bnz     | wa     << dst_ | slod1  << off_ ,
/*  8661 */	stmt    | 2340   << off_ ,	//	erb 139 load first argument is missing a left paren
/*  8662 */	erb     | 139    << off_ ,
// slod1:
/*  8663 */	stmt    | 2341   << off_ ,	//slod1	jsr gtnvr   locate vrblk
/*  8664 */	call    | gtnvr  << off_ ,
/*  8665 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8666 */	err     | 140    << off_ ,
/*  8667 */	stmt    | 2342   << off_ ,	//	mov lodfn xr  save vrblk pointer
/*  8668 */	store   | xr     << dst_ | lodfn  << off_ ,
/*  8669 */	stmt    | 2343   << off_ ,	//	zer lodna   zero count of arguments
/*  8670 */	store   | r0     << dst_ | lodna  << off_ ,
// slod2:
/*  8671 */	stmt    | 2344   << off_ ,	//slod2	mov wc =ch_rp  delimiter one is right paren
/*  8672 */	loadi   | wc     << dst_ | ch_rp  << off_ ,
/*  8673 */	stmt    | 2345   << off_ ,	//	mov xl =ch_cm  delimiter two is comma
/*  8674 */	loadi   | xl     << dst_ | ch_cm  << off_ ,
/*  8675 */	stmt    | 2346   << off_ ,	//	mnz wa   skip/trim blanks in prototype
/*  8676 */	move    | wa     << dst_ | xs     << src_ ,
/*  8677 */	stmt    | 2347   << off_ ,	//	jsr xscan   scan next argument name
/*  8678 */	call    | xscan  << off_ ,
/*  8679 */	stmt    | 2348   << off_ ,	//	icv lodna   bump argument count
/*  8680 */	load    | r1     << dst_ | lodna  << off_ ,
/*  8681 */	icv     | r1     << dst_ ,
/*  8682 */	store   | r1     << dst_ | lodna  << off_ ,
/*  8683 */	stmt    | 2349   << off_ ,	//	bnz wa slod3  jump if ok delimiter was found
/*  8684 */	bnz     | wa     << dst_ | slod3  << off_ ,
/*  8685 */	stmt    | 2350   << off_ ,	//	erb 141 load first argument is missing a right paren
/*  8686 */	erb     | 141    << off_ ,
// slod3:
/*  8687 */	stmt    | 2351   << off_ ,	//slod3	mov -(xs) xr  stack datatype name pointer
/*  8688 */	dca     | xs     << dst_ ,
/*  8689 */	store   | xr     << dst_ | xs     << src_ ,
/*  8690 */	stmt    | 2352   << off_ ,	//	mov wb =num01  set string code in case
/*  8691 */	loadi   | wb     << dst_ | num01  << off_ ,
/*  8692 */	stmt    | 2353   << off_ ,	//	mov xl =scstr  point to /string/
/*  8693 */	loadi   | xl     << dst_ | scstr  << off_ ,
/*  8694 */	stmt    | 2354   << off_ ,	//	jsr ident   check for match
/*  8695 */	call    | ident  << off_ ,
/*  8696 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8697 */	ppm     | slod4  << off_ ,
/*  8698 */	stmt    | 2355   << off_ ,	//	mov xr (xs)  else reload name
/*  8699 */	load    | xr     << dst_ | xs     << src_ ,
/*  8700 */	stmt    | 2356   << off_ ,	//	add wb wb  set code for integer (2)
/*  8701 */	add     | wb     << dst_ | wb     << src_ ,
/*  8702 */	stmt    | 2357   << off_ ,	//	mov xl =scint  point to /integer/
/*  8703 */	loadi   | xl     << dst_ | scint  << off_ ,
/*  8704 */	stmt    | 2358   << off_ ,	//	jsr ident   check for match
/*  8705 */	call    | ident  << off_ ,
/*  8706 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8707 */	ppm     | slod4  << off_ ,
/*  8708 */	stmt    | 2359   << off_ ,	//	mov xr (xs)  else reload string pointer
/*  8709 */	load    | xr     << dst_ | xs     << src_ ,
/*  8710 */	stmt    | 2360   << off_ ,	//	icv wb   set code for real (3)
/*  8711 */	icv     | wb     << dst_ ,
/*  8712 */	stmt    | 2361   << off_ ,	//	mov xl =screa  point to /real/
/*  8713 */	loadi   | xl     << dst_ | screa  << off_ ,
/*  8714 */	stmt    | 2362   << off_ ,	//	jsr ident   check for match
/*  8715 */	call    | ident  << off_ ,
/*  8716 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8717 */	ppm     | slod4  << off_ ,
/*  8718 */	stmt    | 2363   << off_ ,	//	mov xr (xs)  reload string pointer
/*  8719 */	load    | xr     << dst_ | xs     << src_ ,
/*  8720 */	stmt    | 2364   << off_ ,	//	icv wb   code for file (4, or 3 if no reals)
/*  8721 */	icv     | wb     << dst_ ,
/*  8722 */	stmt    | 2365   << off_ ,	//	mov xl =scfil  point to /file/
/*  8723 */	loadi   | xl     << dst_ | scfil  << off_ ,
/*  8724 */	stmt    | 2366   << off_ ,	//	jsr ident   check for match
/*  8725 */	call    | ident  << off_ ,
/*  8726 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8727 */	ppm     | slod4  << off_ ,
/*  8728 */	stmt    | 2367   << off_ ,	//	zer wb   else get code for no convert
/*  8729 */	move    | wb     << dst_ ,
// slod4:
/*  8730 */	stmt    | 2368   << off_ ,	//slod4	mov (xs) wb  store code on stack
/*  8731 */	store   | wb     << dst_ | xs     << src_ ,
/*  8732 */	stmt    | 2369   << off_ ,	//	beq wa =num02 slod2 loop back if arg stopped by comma
/*  8733 */	loadi   | r2     << dst_ | num02  << off_ ,
/*  8734 */	beq     | wa     << dst_ | r2     << src_ | slod2  << off_ ,
/*  8735 */	stmt    | 2370   << off_ ,	//	bze wa slod5  jump if that was the result type
/*  8736 */	bze     | wa     << dst_ | slod5  << off_ ,
/*  8737 */	stmt    | 2371   << off_ ,	//	mov wc mxlen  set dummy (impossible) delimiter 1
/*  8738 */	load    | wc     << dst_ | mxlen  << off_ ,
/*  8739 */	stmt    | 2372   << off_ ,	//	mov xl wc  and delimiter two
/*  8740 */	move    | xl     << dst_ | wc     << src_ ,
/*  8741 */	stmt    | 2373   << off_ ,	//	mnz wa   skip/trim blanks in prototype
/*  8742 */	move    | wa     << dst_ | xs     << src_ ,
/*  8743 */	stmt    | 2374   << off_ ,	//	jsr xscan   scan result name
/*  8744 */	call    | xscan  << off_ ,
/*  8745 */	stmt    | 2375   << off_ ,	//	zer wa   set code for processing result
/*  8746 */	move    | wa     << dst_ ,
/*  8747 */	stmt    | 2376   << off_ ,	//	brn slod3   jump back to process result name
/*  8748 */	brn     | slod3  << off_ ,
// slod5:
/*  8749 */	stmt    | 2377   << off_ ,	//slod5	mov wa lodna  get number of arguments
/*  8750 */	load    | wa     << dst_ | lodna  << off_ ,
/*  8751 */	stmt    | 2378   << off_ ,	//	mov wc wa  copy for later
/*  8752 */	move    | wc     << dst_ | wa     << src_ ,
/*  8753 */	stmt    | 2379   << off_ ,	//	wtb wa   convert length to bytes
/*  8754 */	stmt    | 2380   << off_ ,	//	add wa *efsi_  add space for standard fields
/*  8755 */	loadi   | r2     << dst_ | efsi_  << off_ ,
/*  8756 */	add     | wa     << dst_ | r2     << src_ ,
/*  8757 */	stmt    | 2381   << off_ ,	//	jsr alloc   allocate efblk
/*  8758 */	call    | alloc  << off_ ,
/*  8759 */	stmt    | 2382   << off_ ,	//	mov (xr) =b_efc  set type word
/*  8760 */	loadi   | r1     << dst_ | b_efc  << off_ ,
/*  8761 */	store   | r1     << dst_ | xr     << src_ ,
/*  8762 */	stmt    | 2383   << off_ ,	//	mov fargs(xr) wc  set number of arguments
/*  8763 */	store   | wc     << dst_ | xr     << src_ | fargs  << off_ ,
/*  8764 */	stmt    | 2384   << off_ ,	//	zer efuse(xr)   set use count (dffnc will set to 1)
/*  8765 */	store   | r0     << dst_ | xr     << src_ | efuse  << off_ ,
/*  8766 */	stmt    | 2385   << off_ ,	//	zer efcod(xr)   zero code pointer for now
/*  8767 */	store   | r0     << dst_ | xr     << src_ | efcod  << off_ ,
/*  8768 */	stmt    | 2386   << off_ ,	//	mov efrsl(xr) (xs)+  store result type code
/*  8769 */	load    | r1     << dst_ | xs     << src_ ,
/*  8770 */	ica     | xs     << dst_ ,
/*  8771 */	store   | r1     << dst_ | xr     << src_ | efrsl  << off_ ,
/*  8772 */	stmt    | 2387   << off_ ,	//	mov efvar(xr) lodfn  store function vrblk pointer
/*  8773 */	load    | r1     << dst_ | lodfn  << off_ ,
/*  8774 */	store   | r1     << dst_ | xr     << src_ | efvar  << off_ ,
/*  8775 */	stmt    | 2388   << off_ ,	//	mov eflen(xr) wa  store efblk length
/*  8776 */	store   | wa     << dst_ | xr     << src_ | eflen  << off_ ,
/*  8777 */	stmt    | 2389   << off_ ,	//	mov wb xr  save efblk pointer
/*  8778 */	move    | wb     << dst_ | xr     << src_ ,
/*  8779 */	stmt    | 2390   << off_ ,	//	add xr wa  point past end of efblk
/*  8780 */	add     | xr     << dst_ | wa     << src_ ,
/*  8781 */	stmt    | 2391   << off_ ,	//	lct wc wc  set number of arguments for loop
// slod6:
/*  8782 */	stmt    | 2392   << off_ ,	//slod6	mov -(xr) (xs)+  store one type code from stack
/*  8783 */	load    | r1     << dst_ | xs     << src_ ,
/*  8784 */	ica     | xs     << dst_ ,
/*  8785 */	dca     | xr     << dst_ ,
/*  8786 */	store   | r1     << dst_ | xr     << src_ ,
/*  8787 */	stmt    | 2393   << off_ ,	//	bct wc slod6  loop till all stored
/*  8788 */	bct     | wc     << dst_ | slod6  << off_ ,
/*  8789 */	stmt    | 2394   << off_ ,	//	mov xr (xs)+  load function string name
/*  8790 */	load    | xr     << dst_ | xs     << src_ ,
/*  8791 */	ica     | xs     << dst_ ,
/*  8792 */	stmt    | 2395   << off_ ,	//	mov xl (xs)  load library name
/*  8793 */	load    | xl     << dst_ | xs     << src_ ,
/*  8794 */	stmt    | 2396   << off_ ,	//	mov (xs) wb  store efblk pointer
/*  8795 */	store   | wb     << dst_ | xs     << src_ ,
/*  8796 */	stmt    | 2397   << off_ ,	//	jsr sysld   call function to load external func
/*  8797 */	sys     | sysld_ << off_ ,
/*  8798 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  8799 */	err     | 142    << off_ ,
/*  8800 */	err     | 143    << off_ ,
/*  8801 */	err     | 328    << off_ ,
/*  8802 */	stmt    | 2398   << off_ ,	//	mov xl (xs)+  recall efblk pointer
/*  8803 */	load    | xl     << dst_ | xs     << src_ ,
/*  8804 */	ica     | xs     << dst_ ,
/*  8805 */	stmt    | 2399   << off_ ,	//	mov efcod(xl) xr  store code pointer
/*  8806 */	store   | xr     << dst_ | xl     << src_ | efcod  << off_ ,
/*  8807 */	stmt    | 2400   << off_ ,	//	mov xr lodfn  point to vrblk for function
/*  8808 */	load    | xr     << dst_ | lodfn  << off_ ,
/*  8809 */	stmt    | 2401   << off_ ,	//	jsr dffnc   perform function definition
/*  8810 */	call    | dffnc  << off_ ,
/*  8811 */	stmt    | 2402   << off_ ,	//	brn exnul   return null result
/*  8812 */	brn     | exnul  << off_ ,
/*  8813 */	0       ,
// s_lpd:
/*  8814 */	stmt    | 2403   << off_ ,	//	jsr gtstg   get pad character
/*  8815 */	call    | gtstg  << off_ ,
/*  8816 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8817 */	err     | 144    << off_ ,
/*  8818 */	stmt    | 2404   << off_ ,	//	plc xr   point to character (null is blank)
/*  8819 */	plc     | xr     << dst_ ,
/*  8820 */	stmt    | 2405   << off_ ,	//	lch wb (xr)  load pad character
/*  8821 */	load    | wb     << dst_ | xr     << src_ ,
/*  8822 */	stmt    | 2406   << off_ ,	//	jsr gtsmi   get pad length
/*  8823 */	call    | gtsmi  << off_ ,
/*  8824 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  8825 */	err     | 145    << off_ ,
/*  8826 */	ppm     | slpd4  << off_ ,
// slpd1:
/*  8827 */	stmt    | 2407   << off_ ,	//slpd1	jsr gtstg   get first argument (string to pad)
/*  8828 */	call    | gtstg  << off_ ,
/*  8829 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8830 */	err     | 146    << off_ ,
/*  8831 */	stmt    | 2408   << off_ ,	//	bge wa wc exixr return 1st arg if too long to pad
/*  8832 */	bge     | wa     << dst_ | wc     << src_ | exixr  << off_ ,
/*  8833 */	stmt    | 2409   << off_ ,	//	mov xl xr  else move ptr to string to pad
/*  8834 */	move    | xl     << dst_ | xr     << src_ ,
/*  8835 */	stmt    | 2410   << off_ ,	//	mov wa wc  copy length
/*  8836 */	move    | wa     << dst_ | wc     << src_ ,
/*  8837 */	stmt    | 2411   << off_ ,	//	jsr alocs   allocate scblk for new string
/*  8838 */	call    | alocs  << off_ ,
/*  8839 */	stmt    | 2412   << off_ ,	//	mov -(xs) xr  save as result
/*  8840 */	dca     | xs     << dst_ ,
/*  8841 */	store   | xr     << dst_ | xs     << src_ ,
/*  8842 */	stmt    | 2413   << off_ ,	//	mov wa sclen(xl)  load length of argument
/*  8843 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/*  8844 */	stmt    | 2414   << off_ ,	//	sub wc wa  calculate number of pad characters
/*  8845 */	sub     | wc     << dst_ | wa     << src_ ,
/*  8846 */	stmt    | 2415   << off_ ,	//	psc xr   point to chars in result string
/*  8847 */	psc     | xr     << dst_ ,
/*  8848 */	stmt    | 2416   << off_ ,	//	lct wc wc  set counter for pad loop
// slpd2:
/*  8849 */	stmt    | 2417   << off_ ,	//slpd2	sch wb (xr)+  store pad character, bump ptr
/*  8850 */	store   | wb     << dst_ | xr     << src_ ,
/*  8851 */	ica     | xr     << dst_ ,
/*  8852 */	stmt    | 2418   << off_ ,	//	bct wc slpd2  loop till all pad chars stored
/*  8853 */	bct     | wc     << dst_ | slpd2  << off_ ,
/*  8854 */	stmt    | 2419   << off_ ,	//	csc xr   complete store characters
/*  8855 */	stmt    | 2420   << off_ ,	//	bze wa slpd3  exit if null string
/*  8856 */	bze     | wa     << dst_ | slpd3  << off_ ,
/*  8857 */	stmt    | 2421   << off_ ,	//	plc xl   else point to chars in argument
/*  8858 */	plc     | xl     << dst_ ,
/*  8859 */	stmt    | 2422   << off_ ,	//	mvc    move characters to result string
/*  8860 */	mvc     ,
/*  8861 */	stmt    | 2423   << off_ ,	//	zer xl   clear garbage xl
/*  8862 */	move    | xl     << dst_ ,
// slpd3:
/*  8863 */	stmt    | 2424   << off_ ,	//slpd3	lcw xr   load next code word
/*  8864 */	lcw     | xr     << dst_ ,
/*  8865 */	stmt    | 2425   << off_ ,	//	bri (xr)   execute it
/*  8866 */	load    | r1     << dst_ | xr     << src_ ,
/*  8867 */	bri     | r1     << dst_ ,
// slpd4:
/*  8868 */	stmt    | 2426   << off_ ,	//slpd4	zer wc   zero pad count
/*  8869 */	move    | wc     << dst_ ,
/*  8870 */	stmt    | 2427   << off_ ,	//	brn slpd1   merge
/*  8871 */	brn     | slpd1  << off_ ,
/*  8872 */	0       ,
// s_ltf:
/*  8873 */	stmt    | 2428   << off_ ,	//	jsr acomp   call arithmetic comparison routine
/*  8874 */	call    | acomp  << off_ ,
/*  8875 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/*  8876 */	err     | 147    << off_ ,
/*  8877 */	err     | 148    << off_ ,
/*  8878 */	ppm     | exnul  << off_ ,
/*  8879 */	ppm     | exfal  << off_ ,
/*  8880 */	ppm     | exfal  << off_ ,
/*  8881 */	0       ,
// s_nef:
/*  8882 */	stmt    | 2429   << off_ ,	//	jsr acomp   call arithmetic comparison routine
/*  8883 */	call    | acomp  << off_ ,
/*  8884 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/*  8885 */	err     | 149    << off_ ,
/*  8886 */	err     | 150    << off_ ,
/*  8887 */	ppm     | exnul  << off_ ,
/*  8888 */	ppm     | exfal  << off_ ,
/*  8889 */	ppm     | exnul  << off_ ,
/*  8890 */	0       ,
// s_nay:
/*  8891 */	stmt    | 2430   << off_ ,	//	mov wb =p_nas  set pcode for single char arg
/*  8892 */	loadi   | wb     << dst_ | p_nas  << off_ ,
/*  8893 */	stmt    | 2431   << off_ ,	//	mov xl =p_nay  pcode for multi-char arg
/*  8894 */	loadi   | xl     << dst_ | p_nay  << off_ ,
/*  8895 */	stmt    | 2432   << off_ ,	//	mov wc =p_nad  set pcode for expr arg
/*  8896 */	loadi   | wc     << dst_ | p_nad  << off_ ,
/*  8897 */	stmt    | 2433   << off_ ,	//	jsr patst   call common routine to build node
/*  8898 */	call    | patst  << off_ ,
/*  8899 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8900 */	err     | 151    << off_ ,
/*  8901 */	stmt    | 2434   << off_ ,	//	mov -(xs) xr  stack result
/*  8902 */	dca     | xs     << dst_ ,
/*  8903 */	store   | xr     << dst_ | xs     << src_ ,
/*  8904 */	stmt    | 2435   << off_ ,	//	lcw xr   get next code word
/*  8905 */	lcw     | xr     << dst_ ,
/*  8906 */	stmt    | 2436   << off_ ,	//	bri (xr)   execute it
/*  8907 */	load    | r1     << dst_ | xr     << src_ ,
/*  8908 */	bri     | r1     << dst_ ,
/*  8909 */	0       ,
// s_ops:
/*  8910 */	stmt    | 2437   << off_ ,	//	jsr gtsmi   load third argument
/*  8911 */	call    | gtsmi  << off_ ,
/*  8912 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  8913 */	err     | 152    << off_ ,
/*  8914 */	err     | 153    << off_ ,
/*  8915 */	stmt    | 2438   << off_ ,	//	mov wb wc  if ok, save third argumnet
/*  8916 */	move    | wb     << dst_ | wc     << src_ ,
/*  8917 */	stmt    | 2439   << off_ ,	//	mov xr (xs)+  load second argument
/*  8918 */	load    | xr     << dst_ | xs     << src_ ,
/*  8919 */	ica     | xs     << dst_ ,
/*  8920 */	stmt    | 2440   << off_ ,	//	jsr gtnvr   locate variable block
/*  8921 */	call    | gtnvr  << off_ ,
/*  8922 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8923 */	err     | 154    << off_ ,
/*  8924 */	stmt    | 2441   << off_ ,	//	mov xl vrfnc(xr)  if ok, load function block pointer
/*  8925 */	load    | xl     << dst_ | xr     << src_ | vrfnc  << off_ ,
/*  8926 */	stmt    | 2442   << off_ ,	//	bnz wb sops2  jump if operator opsyn case
/*  8927 */	bnz     | wb     << dst_ | sops2  << off_ ,
/*  8928 */	stmt    | 2443   << off_ ,	//	mov xr (xs)+  load first argument
/*  8929 */	load    | xr     << dst_ | xs     << src_ ,
/*  8930 */	ica     | xs     << dst_ ,
/*  8931 */	stmt    | 2444   << off_ ,	//	jsr gtnvr   get vrblk pointer
/*  8932 */	call    | gtnvr  << off_ ,
/*  8933 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8934 */	err     | 155    << off_ ,
// sops1:
/*  8935 */	stmt    | 2445   << off_ ,	//sops1	jsr dffnc   call function definer
/*  8936 */	call    | dffnc  << off_ ,
/*  8937 */	stmt    | 2446   << off_ ,	//	brn exnul   exit with null result
/*  8938 */	brn     | exnul  << off_ ,
// sops2:
/*  8939 */	stmt    | 2447   << off_ ,	//sops2	jsr gtstg   get operator name
/*  8940 */	call    | gtstg  << off_ ,
/*  8941 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  8942 */	ppm     | sops5  << off_ ,
/*  8943 */	stmt    | 2448   << off_ ,	//	bne wa =num01 sops5 error if not one char long
/*  8944 */	loadi   | r2     << dst_ | num01  << off_ ,
/*  8945 */	bne     | wa     << dst_ | r2     << src_ | sops5  << off_ ,
/*  8946 */	stmt    | 2449   << off_ ,	//	plc xr   else point to character
/*  8947 */	plc     | xr     << dst_ ,
/*  8948 */	stmt    | 2450   << off_ ,	//	lch wc (xr)  load character name
/*  8949 */	load    | wc     << dst_ | xr     << src_ ,
/*  8950 */	stmt    | 2451   << off_ ,	//	mov wa =r_uub  point to unop pointers in case
/*  8951 */	loadi   | wa     << dst_ | r_uub  << off_ ,
/*  8952 */	stmt    | 2452   << off_ ,	//	mov xr =opnsu  point to names of unary operators
/*  8953 */	loadi   | xr     << dst_ | opnsu  << off_ ,
/*  8954 */	stmt    | 2453   << off_ ,	//	add wb =opbun  add no. of undefined binary ops
/*  8955 */	loadi   | r2     << dst_ | opbun  << off_ ,
/*  8956 */	add     | wb     << dst_ | r2     << src_ ,
/*  8957 */	stmt    | 2454   << off_ ,	//	beq wb =opuun sops3 jump if unop (third arg was 1)
/*  8958 */	loadi   | r2     << dst_ | opuun  << off_ ,
/*  8959 */	beq     | wb     << dst_ | r2     << src_ | sops3  << off_ ,
/*  8960 */	stmt    | 2455   << off_ ,	//	mov wa =r_uba  else point to binary operator ptrs
/*  8961 */	loadi   | wa     << dst_ | r_uba  << off_ ,
/*  8962 */	stmt    | 2456   << off_ ,	//	mov xr =opsnb  point to names of binary operators
/*  8963 */	loadi   | xr     << dst_ | opsnb  << off_ ,
/*  8964 */	stmt    | 2457   << off_ ,	//	mov wb =opbun  set number of undefined binops
/*  8965 */	loadi   | wb     << dst_ | opbun  << off_ ,
// sops3:
/*  8966 */	stmt    | 2458   << off_ ,	//sops3	lct wb wb  set counter to control loop
// sops4:
/*  8967 */	stmt    | 2459   << off_ ,	//sops4	beq wc (xr) sops6 jump if names match
/*  8968 */	load    | r2     << dst_ | xr     << src_ ,
/*  8969 */	beq     | wc     << dst_ | r2     << src_ | sops6  << off_ ,
/*  8970 */	stmt    | 2460   << off_ ,	//	ica wa   else push pointer to function ptr
/*  8971 */	ica     | wa     << dst_ ,
/*  8972 */	stmt    | 2461   << off_ ,	//	ica xr   bump pointer
/*  8973 */	ica     | xr     << dst_ ,
/*  8974 */	stmt    | 2462   << off_ ,	//	bct wb sops4  loop back till all checked
/*  8975 */	bct     | wb     << dst_ | sops4  << off_ ,
// sops5:
/*  8976 */	stmt    | 2463   << off_ ,	//sops5	erb 156 opsyn first arg is not correct operator name
/*  8977 */	erb     | 156    << off_ ,
// sops6:
/*  8978 */	stmt    | 2464   << off_ ,	//sops6	mov xr wa  copy pointer to function block ptr
/*  8979 */	move    | xr     << dst_ | wa     << src_ ,
/*  8980 */	stmt    | 2465   << off_ ,	//	sub xr *vrfnc  make it look like dummy vrblk
/*  8981 */	loadi   | r2     << dst_ | vrfnc  << off_ ,
/*  8982 */	sub     | xr     << dst_ | r2     << src_ ,
/*  8983 */	stmt    | 2466   << off_ ,	//	brn sops1   merge back to define operator
/*  8984 */	brn     | sops1  << off_ ,
/*  8985 */	0       ,
// s_oup:
/*  8986 */	stmt    | 2467   << off_ ,	//	mov wb =num03  output flag
/*  8987 */	loadi   | wb     << dst_ | num03  << off_ ,
/*  8988 */	stmt    | 2468   << off_ ,	//	jsr ioput   call input/output assoc. routine
/*  8989 */	call    | ioput  << off_ ,
/*  8990 */	jsrerr  | r1     << dst_ | 7      << off_ ,
/*  8991 */	err     | 157    << off_ ,
/*  8992 */	err     | 158    << off_ ,
/*  8993 */	err     | 159    << off_ ,
/*  8994 */	err     | 160    << off_ ,
/*  8995 */	ppm     | exfal  << off_ ,
/*  8996 */	err     | 161    << off_ ,
/*  8997 */	err     | 290    << off_ ,
/*  8998 */	stmt    | 2469   << off_ ,	//	brn exnul   return null string
/*  8999 */	brn     | exnul  << off_ ,
/*  9000 */	0       ,
// s_pos:
/*  9001 */	stmt    | 2470   << off_ ,	//	mov wb =p_pos  set pcode for integer arg case
/*  9002 */	loadi   | wb     << dst_ | p_pos  << off_ ,
/*  9003 */	stmt    | 2471   << off_ ,	//	mov wa =p_psd  set pcode for expression arg case
/*  9004 */	loadi   | wa     << dst_ | p_psd  << off_ ,
/*  9005 */	stmt    | 2472   << off_ ,	//	jsr patin   call common routine to build node
/*  9006 */	call    | patin  << off_ ,
/*  9007 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  9008 */	err     | 162    << off_ ,
/*  9009 */	err     | 163    << off_ ,
/*  9010 */	stmt    | 2473   << off_ ,	//	mov -(xs) xr  stack result
/*  9011 */	dca     | xs     << dst_ ,
/*  9012 */	store   | xr     << dst_ | xs     << src_ ,
/*  9013 */	stmt    | 2474   << off_ ,	//	lcw xr   get next code word
/*  9014 */	lcw     | xr     << dst_ ,
/*  9015 */	stmt    | 2475   << off_ ,	//	bri (xr)   execute it
/*  9016 */	load    | r1     << dst_ | xr     << src_ ,
/*  9017 */	bri     | r1     << dst_ ,
/*  9018 */	0       ,
// s_pro:
/*  9019 */	stmt    | 2476   << off_ ,	//	mov xr (xs)+  load argument
/*  9020 */	load    | xr     << dst_ | xs     << src_ ,
/*  9021 */	ica     | xs     << dst_ ,
/*  9022 */	stmt    | 2477   << off_ ,	//	mov wb tblen(xr)  length if table, vector (=vclen)
/*  9023 */	load    | wb     << dst_ | xr     << src_ | tblen  << off_ ,
/*  9024 */	stmt    | 2478   << off_ ,	//	btw wb   convert to words
/*  9025 */	stmt    | 2479   << off_ ,	//	mov wa (xr)  load type word of argument block
/*  9026 */	load    | wa     << dst_ | xr     << src_ ,
/*  9027 */	stmt    | 2480   << off_ ,	//	beq wa =b_art spro4 jump if array
/*  9028 */	loadi   | r2     << dst_ | b_art  << off_ ,
/*  9029 */	beq     | wa     << dst_ | r2     << src_ | spro4  << off_ ,
/*  9030 */	stmt    | 2481   << off_ ,	//	beq wa =b_tbt spro1 jump if table
/*  9031 */	loadi   | r2     << dst_ | b_tbt  << off_ ,
/*  9032 */	beq     | wa     << dst_ | r2     << src_ | spro1  << off_ ,
/*  9033 */	stmt    | 2482   << off_ ,	//	beq wa =b_vct spro3 jump if vector
/*  9034 */	loadi   | r2     << dst_ | b_vct  << off_ ,
/*  9035 */	beq     | wa     << dst_ | r2     << src_ | spro3  << off_ ,
/*  9036 */	stmt    | 2483   << off_ ,	//	erb 164 prototype argument is not valid object
/*  9037 */	erb     | 164    << off_ ,
// spro1:
/*  9038 */	stmt    | 2484   << off_ ,	//spro1	sub wb =tbsi_  subtract standard fields
/*  9039 */	loadi   | r2     << dst_ | tbsi_  << off_ ,
/*  9040 */	sub     | wb     << dst_ | r2     << src_ ,
// spro2:
/*  9041 */	stmt    | 2485   << off_ ,	//spro2	mti wb   convert to integer
/*  9042 */	move    | ia     << dst_ | wb     << src_ ,
/*  9043 */	stmt    | 2486   << off_ ,	//	brn exint   exit with integer result
/*  9044 */	brn     | exint  << off_ ,
// spro3:
/*  9045 */	stmt    | 2487   << off_ ,	//spro3	sub wb =vcsi_  subtract standard fields
/*  9046 */	loadi   | r2     << dst_ | vcsi_  << off_ ,
/*  9047 */	sub     | wb     << dst_ | r2     << src_ ,
/*  9048 */	stmt    | 2488   << off_ ,	//	brn spro2   merge
/*  9049 */	brn     | spro2  << off_ ,
// spro4:
/*  9050 */	stmt    | 2489   << off_ ,	//spro4	add xr arofs(xr)  point to prototype field
/*  9051 */	load    | r2     << dst_ | xr     << src_ | arofs  << off_ ,
/*  9052 */	add     | xr     << dst_ | r2     << src_ ,
/*  9053 */	stmt    | 2490   << off_ ,	//	mov xr (xr)  load prototype
/*  9054 */	load    | xr     << dst_ | xr     << src_ ,
/*  9055 */	stmt    | 2491   << off_ ,	//	mov -(xs) xr  stack result
/*  9056 */	dca     | xs     << dst_ ,
/*  9057 */	store   | xr     << dst_ | xs     << src_ ,
/*  9058 */	stmt    | 2492   << off_ ,	//	lcw xr   get next code word
/*  9059 */	lcw     | xr     << dst_ ,
/*  9060 */	stmt    | 2493   << off_ ,	//	bri (xr)   execute it
/*  9061 */	load    | r1     << dst_ | xr     << src_ ,
/*  9062 */	bri     | r1     << dst_ ,
/*  9063 */	0       ,
// s_rmd:
/*  9064 */	stmt    | 2494   << off_ ,	//	jsr arith   get two integers or two reals
/*  9065 */	call    | arith  << off_ ,
/*  9066 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  9067 */	err     | 166    << off_ ,
/*  9068 */	err     | 165    << off_ ,
/*  9069 */	ppm     | srm06  << off_ ,
/*  9070 */	stmt    | 2495   << off_ ,	//	zer wb   set positive flag
/*  9071 */	move    | wb     << dst_ ,
/*  9072 */	stmt    | 2496   << off_ ,	//	ldi icval(xr)   load left argument value
/*  9073 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  9074 */	ldi     | r1     << dst_ ,
/*  9075 */	stmt    | 2497   << off_ ,	//	ige srm01   jump if positive
/*  9076 */	ige     | srm01  << off_ ,
/*  9077 */	stmt    | 2498   << off_ ,	//	mnz wb   set negative flag
/*  9078 */	move    | wb     << dst_ | xs     << src_ ,
// srm01:
/*  9079 */	stmt    | 2499   << off_ ,	//srm01	rmi icval(xl)   get remainder
/*  9080 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/*  9081 */	rmi     | r1     << dst_ ,
/*  9082 */	stmt    | 2500   << off_ ,	//	iov srm05   error if overflow
/*  9083 */	iov     | srm05  << off_ ,
/*  9084 */	stmt    | 2501   << off_ ,	//	bze wb srm03  if result should be positive
/*  9085 */	bze     | wb     << dst_ | srm03  << off_ ,
/*  9086 */	stmt    | 2502   << off_ ,	//	ile exint   if should be negative, and is
/*  9087 */	ile     | exint  << off_ ,
// srm02:
/*  9088 */	stmt    | 2503   << off_ ,	//srm02	ngi    adjust sign of result
/*  9089 */	ngi     ,
/*  9090 */	stmt    | 2504   << off_ ,	//	brn exint   return result
/*  9091 */	brn     | exint  << off_ ,
// srm03:
/*  9092 */	stmt    | 2505   << off_ ,	//srm03	ilt srm02   should be pos, and result negative
/*  9093 */	ilt     | srm02  << off_ ,
/*  9094 */	stmt    | 2506   << off_ ,	//	brn exint   should be positive, and is
/*  9095 */	brn     | exint  << off_ ,
// srm04:
/*  9096 */	stmt    | 2507   << off_ ,	//srm04	erb 166 remdr first argument is not numeric
/*  9097 */	erb     | 166    << off_ ,
// srm05:
/*  9098 */	stmt    | 2508   << off_ ,	//srm05	erb 167 remdr caused integer overflow
/*  9099 */	erb     | 167    << off_ ,
// srm06:
/*  9100 */	stmt    | 2509   << off_ ,	//srm06	zer wb   set positive flag
/*  9101 */	move    | wb     << dst_ ,
/*  9102 */	stmt    | 2510   << off_ ,	//	ldr rcval(xr)   load left argument value
/*  9103 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  9104 */	ldr     | r1     << dst_ ,
/*  9105 */	stmt    | 2511   << off_ ,	//	rge srm07   jump if positive
/*  9106 */	rge     | srm07  << off_ ,
/*  9107 */	stmt    | 2512   << off_ ,	//	mnz wb   set negative flag
/*  9108 */	move    | wb     << dst_ | xs     << src_ ,
// srm07:
/*  9109 */	stmt    | 2513   << off_ ,	//srm07	dvr rcval(xl)   compute n1/n2
/*  9110 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/*  9111 */	dvr     | r1     << dst_ ,
/*  9112 */	stmt    | 2514   << off_ ,	//	rov srm10   jump if overflow
/*  9113 */	rov     | srm10  << off_ ,
/*  9114 */	stmt    | 2515   << off_ ,	//	chp    chop result
/*  9115 */	realop  | chp    << off_ ,
/*  9116 */	stmt    | 2516   << off_ ,	//	mlr rcval(xl)   times n2
/*  9117 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/*  9118 */	mlr     | r1     << dst_ ,
/*  9119 */	stmt    | 2517   << off_ ,	//	sbr rcval(xr)   compute difference
/*  9120 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  9121 */	sbr     | r1     << dst_ ,
/*  9122 */	stmt    | 2518   << off_ ,	//	bze wb srm09  if result should be positive
/*  9123 */	bze     | wb     << dst_ | srm09  << off_ ,
/*  9124 */	stmt    | 2519   << off_ ,	//	rle exrea   if should be negative, and is
/*  9125 */	rle     | exrea  << off_ ,
// srm08:
/*  9126 */	stmt    | 2520   << off_ ,	//srm08	ngr    adjust sign of result
/*  9127 */	ngr     ,
/*  9128 */	stmt    | 2521   << off_ ,	//	brn exrea   return result
/*  9129 */	brn     | exrea  << off_ ,
// srm09:
/*  9130 */	stmt    | 2522   << off_ ,	//srm09	rlt srm08   should be pos, and result negative
/*  9131 */	rlt     | srm08  << off_ ,
/*  9132 */	stmt    | 2523   << off_ ,	//	brn exrea   should be positive, and is
/*  9133 */	brn     | exrea  << off_ ,
// srm10:
/*  9134 */	stmt    | 2524   << off_ ,	//srm10	erb 312 remdr caused real overflow
/*  9135 */	erb     | 312    << off_ ,
/*  9136 */	0       ,
// s_rpl:
/*  9137 */	stmt    | 2525   << off_ ,	//	jsr gtstg   load third argument as string
/*  9138 */	call    | gtstg  << off_ ,
/*  9139 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9140 */	err     | 168    << off_ ,
/*  9141 */	stmt    | 2526   << off_ ,	//	mov xl xr  save third arg ptr
/*  9142 */	move    | xl     << dst_ | xr     << src_ ,
/*  9143 */	stmt    | 2527   << off_ ,	//	jsr gtstg   get second argument
/*  9144 */	call    | gtstg  << off_ ,
/*  9145 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9146 */	err     | 169    << off_ ,
/*  9147 */	stmt    | 2528   << off_ ,	//	bne xr r_ra2 srpl1 jump if 2nd argument different
/*  9148 */	load    | r2     << dst_ | r_ra2  << off_ ,
/*  9149 */	bne     | xr     << dst_ | r2     << src_ | srpl1  << off_ ,
/*  9150 */	stmt    | 2529   << off_ ,	//	beq xl r_ra3 srpl4 jump if args same as last time
/*  9151 */	load    | r2     << dst_ | r_ra3  << off_ ,
/*  9152 */	beq     | xl     << dst_ | r2     << src_ | srpl4  << off_ ,
// srpl1:
/*  9153 */	stmt    | 2530   << off_ ,	//srpl1	mov wb sclen(xl)  load 3rd argument length
/*  9154 */	load    | wb     << dst_ | xl     << src_ | sclen  << off_ ,
/*  9155 */	stmt    | 2531   << off_ ,	//	bne wa wb srpl6 jump if arguments not same length
/*  9156 */	bne     | wa     << dst_ | wb     << src_ | srpl6  << off_ ,
/*  9157 */	stmt    | 2532   << off_ ,	//	beq xr kvalp srpl5 jump if 2nd arg is alphabet string
/*  9158 */	load    | r2     << dst_ | kvalp  << off_ ,
/*  9159 */	beq     | xr     << dst_ | r2     << src_ | srpl5  << off_ ,
/*  9160 */	stmt    | 2533   << off_ ,	//	bze wb srpl6  jump if null 2nd argument
/*  9161 */	bze     | wb     << dst_ | srpl6  << off_ ,
/*  9162 */	stmt    | 2534   << off_ ,	//	mov r_ra3 xl  save third arg for next time in
/*  9163 */	store   | xl     << dst_ | r_ra3  << off_ ,
/*  9164 */	stmt    | 2535   << off_ ,	//	mov r_ra2 xr  save second arg for next time in
/*  9165 */	store   | xr     << dst_ | r_ra2  << off_ ,
/*  9166 */	stmt    | 2536   << off_ ,	//	mov xl kvalp  point to alphabet string
/*  9167 */	load    | xl     << dst_ | kvalp  << off_ ,
/*  9168 */	stmt    | 2537   << off_ ,	//	mov wa sclen(xl)  load alphabet scblk length
/*  9169 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/*  9170 */	stmt    | 2538   << off_ ,	//	mov xr r_rpt  point to current table (if any)
/*  9171 */	load    | xr     << dst_ | r_rpt  << off_ ,
/*  9172 */	stmt    | 2539   << off_ ,	//	bnz xr srpl2  jump if we already have a table
/*  9173 */	bnz     | xr     << dst_ | srpl2  << off_ ,
/*  9174 */	stmt    | 2540   << off_ ,	//	jsr alocs   allocate new table
/*  9175 */	call    | alocs  << off_ ,
/*  9176 */	stmt    | 2541   << off_ ,	//	mov wa wc  keep scblk length
/*  9177 */	move    | wa     << dst_ | wc     << src_ ,
/*  9178 */	stmt    | 2542   << off_ ,	//	mov r_rpt xr  save table pointer for next time
/*  9179 */	store   | xr     << dst_ | r_rpt  << off_ ,
// srpl2:
/*  9180 */	stmt    | 2543   << off_ ,	//srpl2	ctb wa scsi_  compute length of scblk
/*  9181 */	ctb     | wa     << dst_ | scsi_  << off_ ,
/*  9182 */	stmt    | 2544   << off_ ,	//	mvw    copy to get initial table values
/*  9183 */	mvw     ,
/*  9184 */	stmt    | 2545   << off_ ,	//	mov xl r_ra2  point to second argument
/*  9185 */	load    | xl     << dst_ | r_ra2  << off_ ,
/*  9186 */	stmt    | 2546   << off_ ,	//	lct wb wb  number of chars to plug
/*  9187 */	stmt    | 2547   << off_ ,	//	zer wc   zero char offset
/*  9188 */	move    | wc     << dst_ ,
/*  9189 */	stmt    | 2548   << off_ ,	//	mov xr r_ra3  point to 3rd arg
/*  9190 */	load    | xr     << dst_ | r_ra3  << off_ ,
/*  9191 */	stmt    | 2549   << off_ ,	//	plc xr   get char ptr for 3rd arg
/*  9192 */	plc     | xr     << dst_ ,
// srpl3:
/*  9193 */	stmt    | 2550   << off_ ,	//srpl3	mov xl r_ra2  point to 2nd arg
/*  9194 */	load    | xl     << dst_ | r_ra2  << off_ ,
/*  9195 */	stmt    | 2551   << off_ ,	//	plc xl wc  point to next char
/*  9196 */	plc     | xl     << dst_ | wc     << src_ ,
/*  9197 */	stmt    | 2552   << off_ ,	//	icv wc   increment offset
/*  9198 */	icv     | wc     << dst_ ,
/*  9199 */	stmt    | 2553   << off_ ,	//	lch wa (xl)  get next char
/*  9200 */	load    | wa     << dst_ | xl     << src_ ,
/*  9201 */	stmt    | 2554   << off_ ,	//	mov xl r_rpt  point to translate table
/*  9202 */	load    | xl     << dst_ | r_rpt  << off_ ,
/*  9203 */	stmt    | 2555   << off_ ,	//	psc xl wa  convert char to offset into table
/*  9204 */	psc     | xl     << dst_ | wa     << src_ ,
/*  9205 */	stmt    | 2556   << off_ ,	//	lch wa (xr)+  get translated char
/*  9206 */	load    | wa     << dst_ | xr     << src_ ,
/*  9207 */	ica     | xr     << dst_ ,
/*  9208 */	stmt    | 2557   << off_ ,	//	sch wa (xl)  store in table
/*  9209 */	store   | wa     << dst_ | xl     << src_ ,
/*  9210 */	stmt    | 2558   << off_ ,	//	csc xl   complete store characters
/*  9211 */	stmt    | 2559   << off_ ,	//	bct wb srpl3  loop till done
/*  9212 */	bct     | wb     << dst_ | srpl3  << off_ ,
// srpl4:
/*  9213 */	stmt    | 2560   << off_ ,	//srpl4	mov xl r_rpt  replace table to use
/*  9214 */	load    | xl     << dst_ | r_rpt  << off_ ,
// srpl5:
/*  9215 */	stmt    | 2561   << off_ ,	//srpl5	jsr gtstg   get first argument
/*  9216 */	call    | gtstg  << off_ ,
/*  9217 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9218 */	err     | 170    << off_ ,
/*  9219 */	stmt    | 2562   << off_ ,	//	bze wa exnul  return null if null argument
/*  9220 */	bze     | wa     << dst_ | exnul  << off_ ,
/*  9221 */	stmt    | 2563   << off_ ,	//	mov -(xs) xl  stack replace table to use
/*  9222 */	dca     | xs     << dst_ ,
/*  9223 */	store   | xl     << dst_ | xs     << src_ ,
/*  9224 */	stmt    | 2564   << off_ ,	//	mov xl xr  copy pointer
/*  9225 */	move    | xl     << dst_ | xr     << src_ ,
/*  9226 */	stmt    | 2565   << off_ ,	//	mov wc wa  save length
/*  9227 */	move    | wc     << dst_ | wa     << src_ ,
/*  9228 */	stmt    | 2566   << off_ ,	//	ctb wa schar  get scblk length
/*  9229 */	ctb     | wa     << dst_ | schar  << off_ ,
/*  9230 */	stmt    | 2567   << off_ ,	//	jsr alloc   allocate space for copy
/*  9231 */	call    | alloc  << off_ ,
/*  9232 */	stmt    | 2568   << off_ ,	//	mov wb xr  save address of copy
/*  9233 */	move    | wb     << dst_ | xr     << src_ ,
/*  9234 */	stmt    | 2569   << off_ ,	//	mvw    move scblk contents to copy
/*  9235 */	mvw     ,
/*  9236 */	stmt    | 2570   << off_ ,	//	mov xr (xs)+  unstack replace table
/*  9237 */	load    | xr     << dst_ | xs     << src_ ,
/*  9238 */	ica     | xs     << dst_ ,
/*  9239 */	stmt    | 2571   << off_ ,	//	plc xr   point to chars of table
/*  9240 */	plc     | xr     << dst_ ,
/*  9241 */	stmt    | 2572   << off_ ,	//	mov xl wb  point to string to translate
/*  9242 */	move    | xl     << dst_ | wb     << src_ ,
/*  9243 */	stmt    | 2573   << off_ ,	//	plc xl   point to chars of string
/*  9244 */	plc     | xl     << dst_ ,
/*  9245 */	stmt    | 2574   << off_ ,	//	mov wa wc  set number of chars to translate
/*  9246 */	move    | wa     << dst_ | wc     << src_ ,
/*  9247 */	stmt    | 2575   << off_ ,	//	trc    perform translation
/*  9248 */	trc     ,
// srpl8:
/*  9249 */	stmt    | 2576   << off_ ,	//srpl8	mov -(xs) wb  stack result
/*  9250 */	dca     | xs     << dst_ ,
/*  9251 */	store   | wb     << dst_ | xs     << src_ ,
/*  9252 */	stmt    | 2577   << off_ ,	//	lcw xr   load next code word
/*  9253 */	lcw     | xr     << dst_ ,
/*  9254 */	stmt    | 2578   << off_ ,	//	bri (xr)   execute it
/*  9255 */	load    | r1     << dst_ | xr     << src_ ,
/*  9256 */	bri     | r1     << dst_ ,
// srpl6:
/*  9257 */	stmt    | 2579   << off_ ,	//srpl6	erb 171 null or unequally long 2nd, 3rd args to replace
/*  9258 */	erb     | 171    << off_ ,
/*  9259 */	0       ,
// s_rew:
/*  9260 */	stmt    | 2580   << off_ ,	//	jsr iofcb   call fcblk routine
/*  9261 */	call    | iofcb  << off_ ,
/*  9262 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  9263 */	err     | 172    << off_ ,
/*  9264 */	err     | 173    << off_ ,
/*  9265 */	err     | 174    << off_ ,
/*  9266 */	stmt    | 2581   << off_ ,	//	jsr sysrw   call system rewind function
/*  9267 */	sys     | sysrw_ << off_ ,
/*  9268 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  9269 */	err     | 174    << off_ ,
/*  9270 */	err     | 175    << off_ ,
/*  9271 */	err     | 176    << off_ ,
/*  9272 */	stmt    | 2582   << off_ ,	//	brn exnul   exit with null result if no error
/*  9273 */	brn     | exnul  << off_ ,
/*  9274 */	0       ,
// s_rvs:
/*  9275 */	stmt    | 2583   << off_ ,	//	jsr gtstg   load string argument
/*  9276 */	call    | gtstg  << off_ ,
/*  9277 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9278 */	err     | 177    << off_ ,
/*  9279 */	stmt    | 2584   << off_ ,	//	bze wa exixr  return argument if null
/*  9280 */	bze     | wa     << dst_ | exixr  << off_ ,
/*  9281 */	stmt    | 2585   << off_ ,	//	mov xl xr  else save pointer to string arg
/*  9282 */	move    | xl     << dst_ | xr     << src_ ,
/*  9283 */	stmt    | 2586   << off_ ,	//	jsr alocs   allocate space for new scblk
/*  9284 */	call    | alocs  << off_ ,
/*  9285 */	stmt    | 2587   << off_ ,	//	mov -(xs) xr  store scblk ptr on stack as result
/*  9286 */	dca     | xs     << dst_ ,
/*  9287 */	store   | xr     << dst_ | xs     << src_ ,
/*  9288 */	stmt    | 2588   << off_ ,	//	psc xr   prepare to store in new scblk
/*  9289 */	psc     | xr     << dst_ ,
/*  9290 */	stmt    | 2589   << off_ ,	//	plc xl wc  point past last char in argument
/*  9291 */	plc     | xl     << dst_ | wc     << src_ ,
/*  9292 */	stmt    | 2590   << off_ ,	//	lct wc wc  set loop counter
// srvs1:
/*  9293 */	stmt    | 2591   << off_ ,	//srvs1	lch wb -(xl)  load next char from argument
/*  9294 */	dca     | xl     << dst_ ,
/*  9295 */	load    | wb     << dst_ | xl     << src_ ,
/*  9296 */	stmt    | 2592   << off_ ,	//	sch wb (xr)+  store in result
/*  9297 */	store   | wb     << dst_ | xr     << src_ ,
/*  9298 */	ica     | xr     << dst_ ,
/*  9299 */	stmt    | 2593   << off_ ,	//	bct wc srvs1  loop till all moved
/*  9300 */	bct     | wc     << dst_ | srvs1  << off_ ,
// srvs4:
/*  9301 */	stmt    | 2594   << off_ ,	//srvs4	csc xr   complete store characters
/*  9302 */	stmt    | 2595   << off_ ,	//	zer xl   clear garbage xl
/*  9303 */	move    | xl     << dst_ ,
// srvs2:
/*  9304 */	stmt    | 2596   << off_ ,	//srvs2	lcw xr   load next code word
/*  9305 */	lcw     | xr     << dst_ ,
/*  9306 */	stmt    | 2597   << off_ ,	//	bri (xr)   execute it
/*  9307 */	load    | r1     << dst_ | xr     << src_ ,
/*  9308 */	bri     | r1     << dst_ ,
/*  9309 */	0       ,
// s_rpd:
/*  9310 */	stmt    | 2598   << off_ ,	//	jsr gtstg   get pad character
/*  9311 */	call    | gtstg  << off_ ,
/*  9312 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9313 */	err     | 178    << off_ ,
/*  9314 */	stmt    | 2599   << off_ ,	//	plc xr   point to character (null is blank)
/*  9315 */	plc     | xr     << dst_ ,
/*  9316 */	stmt    | 2600   << off_ ,	//	lch wb (xr)  load pad character
/*  9317 */	load    | wb     << dst_ | xr     << src_ ,
/*  9318 */	stmt    | 2601   << off_ ,	//	jsr gtsmi   get pad length
/*  9319 */	call    | gtsmi  << off_ ,
/*  9320 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  9321 */	err     | 179    << off_ ,
/*  9322 */	ppm     | srpd3  << off_ ,
// srpd1:
/*  9323 */	stmt    | 2602   << off_ ,	//srpd1	jsr gtstg   get first argument (string to pad)
/*  9324 */	call    | gtstg  << off_ ,
/*  9325 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9326 */	err     | 180    << off_ ,
/*  9327 */	stmt    | 2603   << off_ ,	//	bge wa wc exixr return 1st arg if too long to pad
/*  9328 */	bge     | wa     << dst_ | wc     << src_ | exixr  << off_ ,
/*  9329 */	stmt    | 2604   << off_ ,	//	mov xl xr  else move ptr to string to pad
/*  9330 */	move    | xl     << dst_ | xr     << src_ ,
/*  9331 */	stmt    | 2605   << off_ ,	//	mov wa wc  copy length
/*  9332 */	move    | wa     << dst_ | wc     << src_ ,
/*  9333 */	stmt    | 2606   << off_ ,	//	jsr alocs   allocate scblk for new string
/*  9334 */	call    | alocs  << off_ ,
/*  9335 */	stmt    | 2607   << off_ ,	//	mov -(xs) xr  save as result
/*  9336 */	dca     | xs     << dst_ ,
/*  9337 */	store   | xr     << dst_ | xs     << src_ ,
/*  9338 */	stmt    | 2608   << off_ ,	//	mov wa sclen(xl)  load length of argument
/*  9339 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/*  9340 */	stmt    | 2609   << off_ ,	//	sub wc wa  calculate number of pad characters
/*  9341 */	sub     | wc     << dst_ | wa     << src_ ,
/*  9342 */	stmt    | 2610   << off_ ,	//	psc xr   point to chars in result string
/*  9343 */	psc     | xr     << dst_ ,
/*  9344 */	stmt    | 2611   << off_ ,	//	lct wc wc  set counter for pad loop
/*  9345 */	stmt    | 2612   << off_ ,	//	bze wa srpd2  jump if argument is null
/*  9346 */	bze     | wa     << dst_ | srpd2  << off_ ,
/*  9347 */	stmt    | 2613   << off_ ,	//	plc xl   else point to argument chars
/*  9348 */	plc     | xl     << dst_ ,
/*  9349 */	stmt    | 2614   << off_ ,	//	mvc    move characters to result string
/*  9350 */	mvc     ,
/*  9351 */	stmt    | 2615   << off_ ,	//	zer xl   clear garbage xl
/*  9352 */	move    | xl     << dst_ ,
// srpd2:
/*  9353 */	stmt    | 2616   << off_ ,	//srpd2	sch wb (xr)+  store pad character, bump ptr
/*  9354 */	store   | wb     << dst_ | xr     << src_ ,
/*  9355 */	ica     | xr     << dst_ ,
/*  9356 */	stmt    | 2617   << off_ ,	//	bct wc srpd2  loop till all pad chars stored
/*  9357 */	bct     | wc     << dst_ | srpd2  << off_ ,
/*  9358 */	stmt    | 2618   << off_ ,	//	csc xr   complete character storing
/*  9359 */	stmt    | 2619   << off_ ,	//	lcw xr   load next code word
/*  9360 */	lcw     | xr     << dst_ ,
/*  9361 */	stmt    | 2620   << off_ ,	//	bri (xr)   execute it
/*  9362 */	load    | r1     << dst_ | xr     << src_ ,
/*  9363 */	bri     | r1     << dst_ ,
// srpd3:
/*  9364 */	stmt    | 2621   << off_ ,	//srpd3	zer wc   zero pad count
/*  9365 */	move    | wc     << dst_ ,
/*  9366 */	stmt    | 2622   << off_ ,	//	brn srpd1   merge
/*  9367 */	brn     | srpd1  << off_ ,
/*  9368 */	0       ,
// s_rtb:
/*  9369 */	stmt    | 2623   << off_ ,	//	mov wb =p_rtb  set pcode for integer arg case
/*  9370 */	loadi   | wb     << dst_ | p_rtb  << off_ ,
/*  9371 */	stmt    | 2624   << off_ ,	//	mov wa =p_rtd  set pcode for expression arg case
/*  9372 */	loadi   | wa     << dst_ | p_rtd  << off_ ,
/*  9373 */	stmt    | 2625   << off_ ,	//	jsr patin   call common routine to build node
/*  9374 */	call    | patin  << off_ ,
/*  9375 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  9376 */	err     | 181    << off_ ,
/*  9377 */	err     | 182    << off_ ,
/*  9378 */	stmt    | 2626   << off_ ,	//	mov -(xs) xr  stack result
/*  9379 */	dca     | xs     << dst_ ,
/*  9380 */	store   | xr     << dst_ | xs     << src_ ,
/*  9381 */	stmt    | 2627   << off_ ,	//	lcw xr   get next code word
/*  9382 */	lcw     | xr     << dst_ ,
/*  9383 */	stmt    | 2628   << off_ ,	//	bri (xr)   execute it
/*  9384 */	load    | r1     << dst_ | xr     << src_ ,
/*  9385 */	bri     | r1     << dst_ ,
/*  9386 */	0       ,
// s_set:
/*  9387 */	stmt    | 2629   << off_ ,	//	mov r_io2 (xs)+  save third arg (whence)
/*  9388 */	load    | r1     << dst_ | xs     << src_ ,
/*  9389 */	ica     | xs     << dst_ ,
/*  9390 */	store   | r1     << dst_ | r_io2  << off_ ,
/*  9391 */	stmt    | 2630   << off_ ,	//	mov r_io1 (xs)+  save second arg (offset)
/*  9392 */	load    | r1     << dst_ | xs     << src_ ,
/*  9393 */	ica     | xs     << dst_ ,
/*  9394 */	store   | r1     << dst_ | r_io1  << off_ ,
/*  9395 */	stmt    | 2631   << off_ ,	//	jsr iofcb   call fcblk routine
/*  9396 */	call    | iofcb  << off_ ,
/*  9397 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/*  9398 */	err     | 291    << off_ ,
/*  9399 */	err     | 292    << off_ ,
/*  9400 */	err     | 295    << off_ ,
/*  9401 */	stmt    | 2632   << off_ ,	//	mov wb r_io1  load second arg
/*  9402 */	load    | wb     << dst_ | r_io1  << off_ ,
/*  9403 */	stmt    | 2633   << off_ ,	//	mov wc r_io2  load third arg
/*  9404 */	load    | wc     << dst_ | r_io2  << off_ ,
/*  9405 */	stmt    | 2634   << off_ ,	//	jsr sysst   call system set routine
/*  9406 */	sys     | sysst_ << off_ ,
/*  9407 */	err     | 293    << off_ ,
/*  9408 */	err     | 294    << off_ ,
/*  9409 */	err     | 295    << off_ ,
/*  9410 */	err     | 296    << off_ ,
/*  9411 */	err     | 297    << off_ ,
/*  9412 */	stmt    | 2635   << off_ ,	//	brn exint   otherwise return position
/*  9413 */	brn     | exint  << off_ ,
/*  9414 */	0       ,
// s_tab:
/*  9415 */	stmt    | 2636   << off_ ,	//	mov wb =p_tab  set pcode for integer arg case
/*  9416 */	loadi   | wb     << dst_ | p_tab  << off_ ,
/*  9417 */	stmt    | 2637   << off_ ,	//	mov wa =p_tbd  set pcode for expression arg case
/*  9418 */	loadi   | wa     << dst_ | p_tbd  << off_ ,
/*  9419 */	stmt    | 2638   << off_ ,	//	jsr patin   call common routine to build node
/*  9420 */	call    | patin  << off_ ,
/*  9421 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  9422 */	err     | 183    << off_ ,
/*  9423 */	err     | 184    << off_ ,
/*  9424 */	stmt    | 2639   << off_ ,	//	mov -(xs) xr  stack result
/*  9425 */	dca     | xs     << dst_ ,
/*  9426 */	store   | xr     << dst_ | xs     << src_ ,
/*  9427 */	stmt    | 2640   << off_ ,	//	lcw xr   get next code word
/*  9428 */	lcw     | xr     << dst_ ,
/*  9429 */	stmt    | 2641   << off_ ,	//	bri (xr)   execute it
/*  9430 */	load    | r1     << dst_ | xr     << src_ ,
/*  9431 */	bri     | r1     << dst_ ,
/*  9432 */	0       ,
// s_rps:
/*  9433 */	stmt    | 2642   << off_ ,	//	mov wb =p_rps  set pcode for integer arg case
/*  9434 */	loadi   | wb     << dst_ | p_rps  << off_ ,
/*  9435 */	stmt    | 2643   << off_ ,	//	mov wa =p_rpd  set pcode for expression arg case
/*  9436 */	loadi   | wa     << dst_ | p_rpd  << off_ ,
/*  9437 */	stmt    | 2644   << off_ ,	//	jsr patin   call common routine to build node
/*  9438 */	call    | patin  << off_ ,
/*  9439 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  9440 */	err     | 185    << off_ ,
/*  9441 */	err     | 186    << off_ ,
/*  9442 */	stmt    | 2645   << off_ ,	//	mov -(xs) xr  stack result
/*  9443 */	dca     | xs     << dst_ ,
/*  9444 */	store   | xr     << dst_ | xs     << src_ ,
/*  9445 */	stmt    | 2646   << off_ ,	//	lcw xr   get next code word
/*  9446 */	lcw     | xr     << dst_ ,
/*  9447 */	stmt    | 2647   << off_ ,	//	bri (xr)   execute it
/*  9448 */	load    | r1     << dst_ | xr     << src_ ,
/*  9449 */	bri     | r1     << dst_ ,
/*  9450 */	0       ,
// s_rsr:
/*  9451 */	stmt    | 2648   << off_ ,	//	mnz wa   mark as rsort
/*  9452 */	move    | wa     << dst_ | xs     << src_ ,
/*  9453 */	stmt    | 2649   << off_ ,	//	jsr sorta   call sort routine
/*  9454 */	call    | sorta  << off_ ,
/*  9455 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9456 */	ppm     | exfal  << off_ ,
/*  9457 */	stmt    | 2650   << off_ ,	//	brn exsid   return, setting idval
/*  9458 */	brn     | exsid  << off_ ,
/*  9459 */	0       ,
// s_stx:
/*  9460 */	stmt    | 2651   << off_ ,	//	mov xr (xs)+  load argument
/*  9461 */	load    | xr     << dst_ | xs     << src_ ,
/*  9462 */	ica     | xs     << dst_ ,
/*  9463 */	stmt    | 2652   << off_ ,	//	mov wa stxvr  load old vrblk pointer
/*  9464 */	load    | wa     << dst_ | stxvr  << off_ ,
/*  9465 */	stmt    | 2653   << off_ ,	//	zer xl   load zero in case null arg
/*  9466 */	move    | xl     << dst_ ,
/*  9467 */	stmt    | 2654   << off_ ,	//	beq xr =nulls sstx1 jump if null argument (reset call)
/*  9468 */	loadi   | r2     << dst_ | nulls  << off_ ,
/*  9469 */	beq     | xr     << dst_ | r2     << src_ | sstx1  << off_ ,
/*  9470 */	stmt    | 2655   << off_ ,	//	jsr gtnvr   else get specified vrblk
/*  9471 */	call    | gtnvr  << off_ ,
/*  9472 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9473 */	ppm     | sstx2  << off_ ,
/*  9474 */	stmt    | 2656   << off_ ,	//	mov xl vrlbl(xr)  else load label
/*  9475 */	load    | xl     << dst_ | xr     << src_ | vrlbl  << off_ ,
/*  9476 */	stmt    | 2657   << off_ ,	//	beq xl =stndl sstx2 jump if label is not defined
/*  9477 */	loadi   | r2     << dst_ | stndl  << off_ ,
/*  9478 */	beq     | xl     << dst_ | r2     << src_ | sstx2  << off_ ,
/*  9479 */	stmt    | 2658   << off_ ,	//	bne (xl) =b_trt sstx1 jump if not trapped
/*  9480 */	load    | r1     << dst_ | xl     << src_ ,
/*  9481 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/*  9482 */	bne     | r1     << dst_ | r2     << src_ | sstx1  << off_ ,
/*  9483 */	stmt    | 2659   << off_ ,	//	mov xl trlbl(xl)  else load ptr to real label code
/*  9484 */	load    | xl     << dst_ | xl     << src_ | trlbl  << off_ ,
// sstx1:
/*  9485 */	stmt    | 2660   << off_ ,	//sstx1	mov stxvr xr  store new vrblk pointer (or null)
/*  9486 */	store   | xr     << dst_ | stxvr  << off_ ,
/*  9487 */	stmt    | 2661   << off_ ,	//	mov r_sxc xl  store new code ptr (or zero)
/*  9488 */	store   | xl     << dst_ | r_sxc  << off_ ,
/*  9489 */	stmt    | 2662   << off_ ,	//	beq wa =nulls exnul return null if null result
/*  9490 */	loadi   | r2     << dst_ | nulls  << off_ ,
/*  9491 */	beq     | wa     << dst_ | r2     << src_ | exnul  << off_ ,
/*  9492 */	stmt    | 2663   << off_ ,	//	mov xr wa  else copy vrblk pointer
/*  9493 */	move    | xr     << dst_ | wa     << src_ ,
/*  9494 */	stmt    | 2664   << off_ ,	//	brn exvnm   and return building nmblk
/*  9495 */	brn     | exvnm  << off_ ,
// sstx2:
/*  9496 */	stmt    | 2665   << off_ ,	//sstx2	erb 187 setexit argument is not label name or null
/*  9497 */	erb     | 187    << off_ ,
/*  9498 */	0       ,
// s_sin:
/*  9499 */	stmt    | 2666   << off_ ,	//	mov xr (xs)+  get argument
/*  9500 */	load    | xr     << dst_ | xs     << src_ ,
/*  9501 */	ica     | xs     << dst_ ,
/*  9502 */	stmt    | 2667   << off_ ,	//	jsr gtrea   convert to real
/*  9503 */	call    | gtrea  << off_ ,
/*  9504 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9505 */	err     | 308    << off_ ,
/*  9506 */	stmt    | 2668   << off_ ,	//	ldr rcval(xr)   load accumulator with argument
/*  9507 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  9508 */	ldr     | r1     << dst_ ,
/*  9509 */	stmt    | 2669   << off_ ,	//	sin    take sine
/*  9510 */	realop  | sin    << off_ ,
/*  9511 */	stmt    | 2670   << off_ ,	//	rno exrea   if no overflow, return result in ra
/*  9512 */	rno     | exrea  << off_ ,
/*  9513 */	stmt    | 2671   << off_ ,	//	erb 323 sin argument is out of range
/*  9514 */	erb     | 323    << off_ ,
/*  9515 */	0       ,
// s_sqr:
/*  9516 */	stmt    | 2672   << off_ ,	//	mov xr (xs)+  get argument
/*  9517 */	load    | xr     << dst_ | xs     << src_ ,
/*  9518 */	ica     | xs     << dst_ ,
/*  9519 */	stmt    | 2673   << off_ ,	//	jsr gtrea   convert to real
/*  9520 */	call    | gtrea  << off_ ,
/*  9521 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9522 */	err     | 313    << off_ ,
/*  9523 */	stmt    | 2674   << off_ ,	//	ldr rcval(xr)   load accumulator with argument
/*  9524 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  9525 */	ldr     | r1     << dst_ ,
/*  9526 */	stmt    | 2675   << off_ ,	//	rlt ssqr1   negative number
/*  9527 */	rlt     | ssqr1  << off_ ,
/*  9528 */	stmt    | 2676   << off_ ,	//	sqr    take square root
/*  9529 */	realop  | sqr    << off_ ,
/*  9530 */	stmt    | 2677   << off_ ,	//	brn exrea   no overflow possible, result in ra
/*  9531 */	brn     | exrea  << off_ ,
// ssqr1:
/*  9532 */	stmt    | 2678   << off_ ,	//ssqr1	erb 314 sqrt argument negative
/*  9533 */	erb     | 314    << off_ ,
/*  9534 */	0       ,
// s_srt:
/*  9535 */	stmt    | 2679   << off_ ,	//	zer wa   mark as sort
/*  9536 */	move    | wa     << dst_ ,
/*  9537 */	stmt    | 2680   << off_ ,	//	jsr sorta   call sort routine
/*  9538 */	call    | sorta  << off_ ,
/*  9539 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9540 */	ppm     | exfal  << off_ ,
/*  9541 */	stmt    | 2681   << off_ ,	//	brn exsid   return, setting idval
/*  9542 */	brn     | exsid  << off_ ,
/*  9543 */	0       ,
// s_spn:
/*  9544 */	stmt    | 2682   << off_ ,	//	mov wb =p_sps  set pcode for single char arg
/*  9545 */	loadi   | wb     << dst_ | p_sps  << off_ ,
/*  9546 */	stmt    | 2683   << off_ ,	//	mov xl =p_spn  set pcode for multi-char arg
/*  9547 */	loadi   | xl     << dst_ | p_spn  << off_ ,
/*  9548 */	stmt    | 2684   << off_ ,	//	mov wc =p_spd  set pcode for expression arg
/*  9549 */	loadi   | wc     << dst_ | p_spd  << off_ ,
/*  9550 */	stmt    | 2685   << off_ ,	//	jsr patst   call common routine to build node
/*  9551 */	call    | patst  << off_ ,
/*  9552 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9553 */	err     | 188    << off_ ,
/*  9554 */	stmt    | 2686   << off_ ,	//	mov -(xs) xr  stack result
/*  9555 */	dca     | xs     << dst_ ,
/*  9556 */	store   | xr     << dst_ | xs     << src_ ,
/*  9557 */	stmt    | 2687   << off_ ,	//	lcw xr   get next code word
/*  9558 */	lcw     | xr     << dst_ ,
/*  9559 */	stmt    | 2688   << off_ ,	//	bri (xr)   execute it
/*  9560 */	load    | r1     << dst_ | xr     << src_ ,
/*  9561 */	bri     | r1     << dst_ ,
/*  9562 */	0       ,
// s_si_:
/*  9563 */	stmt    | 2689   << off_ ,	//	jsr gtstg   load string argument
/*  9564 */	call    | gtstg  << off_ ,
/*  9565 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9566 */	err     | 189    << off_ ,
/*  9567 */	stmt    | 2690   << off_ ,	//	mti wa   load length as integer
/*  9568 */	move    | ia     << dst_ | wa     << src_ ,
/*  9569 */	stmt    | 2691   << off_ ,	//	brn exint   exit with integer result
/*  9570 */	brn     | exint  << off_ ,
/*  9571 */	0       ,
// s_stt:
/*  9572 */	stmt    | 2692   << off_ ,	//	zer xl   indicate stoptr case
/*  9573 */	move    | xl     << dst_ ,
/*  9574 */	stmt    | 2693   << off_ ,	//	jsr trace   call trace procedure
/*  9575 */	call    | trace  << off_ ,
/*  9576 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  9577 */	err     | 190    << off_ ,
/*  9578 */	err     | 191    << off_ ,
/*  9579 */	stmt    | 2694   << off_ ,	//	brn exnul   return null
/*  9580 */	brn     | exnul  << off_ ,
/*  9581 */	0       ,
// s_sub:
/*  9582 */	stmt    | 2695   << off_ ,	//	jsr gtsmi   load third argument
/*  9583 */	call    | gtsmi  << off_ ,
/*  9584 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  9585 */	err     | 192    << off_ ,
/*  9586 */	ppm     | exfal  << off_ ,
/*  9587 */	stmt    | 2696   << off_ ,	//	mov sbssv xr  save third argument
/*  9588 */	store   | xr     << dst_ | sbssv  << off_ ,
/*  9589 */	stmt    | 2697   << off_ ,	//	jsr gtsmi   load second argument
/*  9590 */	call    | gtsmi  << off_ ,
/*  9591 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  9592 */	err     | 193    << off_ ,
/*  9593 */	ppm     | exfal  << off_ ,
/*  9594 */	stmt    | 2698   << off_ ,	//	mov wc xr  save second argument
/*  9595 */	move    | wc     << dst_ | xr     << src_ ,
/*  9596 */	stmt    | 2699   << off_ ,	//	bze wc exfal  jump if second argument zero
/*  9597 */	bze     | wc     << dst_ | exfal  << off_ ,
/*  9598 */	stmt    | 2700   << off_ ,	//	dcv wc   else decrement for ones origin
/*  9599 */	dcv     | wc     << dst_ ,
/*  9600 */	stmt    | 2701   << off_ ,	//	jsr gtstg   load first argument
/*  9601 */	call    | gtstg  << off_ ,
/*  9602 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9603 */	err     | 194    << off_ ,
/*  9604 */	stmt    | 2702   << off_ ,	//	mov wb wc  copy second arg to wb
/*  9605 */	move    | wb     << dst_ | wc     << src_ ,
/*  9606 */	stmt    | 2703   << off_ ,	//	mov wc sbssv  reload third argument
/*  9607 */	load    | wc     << dst_ | sbssv  << off_ ,
/*  9608 */	stmt    | 2704   << off_ ,	//	bnz wc ssub2  skip if third arg given
/*  9609 */	bnz     | wc     << dst_ | ssub2  << off_ ,
/*  9610 */	stmt    | 2705   << off_ ,	//	mov wc wa  else get string length
/*  9611 */	move    | wc     << dst_ | wa     << src_ ,
/*  9612 */	stmt    | 2706   << off_ ,	//	bgt wb wc exfal fail if improper
/*  9613 */	bgt     | wb     << dst_ | wc     << src_ | exfal  << off_ ,
/*  9614 */	stmt    | 2707   << off_ ,	//	sub wc wb  reduce by offset to start
/*  9615 */	sub     | wc     << dst_ | wb     << src_ ,
// ssub2:
/*  9616 */	stmt    | 2708   << off_ ,	//ssub2	mov xl wa  save string length
/*  9617 */	move    | xl     << dst_ | wa     << src_ ,
/*  9618 */	stmt    | 2709   << off_ ,	//	mov wa wc  set length of substring
/*  9619 */	move    | wa     << dst_ | wc     << src_ ,
/*  9620 */	stmt    | 2710   << off_ ,	//	add wc wb  add 2nd arg to 3rd arg
/*  9621 */	add     | wc     << dst_ | wb     << src_ ,
/*  9622 */	stmt    | 2711   << off_ ,	//	bgt wc xl exfal jump if improper substring
/*  9623 */	bgt     | wc     << dst_ | xl     << src_ | exfal  << off_ ,
/*  9624 */	stmt    | 2712   << off_ ,	//	mov xl xr  copy pointer to first arg
/*  9625 */	move    | xl     << dst_ | xr     << src_ ,
/*  9626 */	stmt    | 2713   << off_ ,	//	jsr sbstr   build substring
/*  9627 */	call    | sbstr  << off_ ,
/*  9628 */	stmt    | 2714   << off_ ,	//	mov -(xs) xr  stack result
/*  9629 */	dca     | xs     << dst_ ,
/*  9630 */	store   | xr     << dst_ | xs     << src_ ,
/*  9631 */	stmt    | 2715   << off_ ,	//	lcw xr   get next code word
/*  9632 */	lcw     | xr     << dst_ ,
/*  9633 */	stmt    | 2716   << off_ ,	//	bri (xr)   execute it
/*  9634 */	load    | r1     << dst_ | xr     << src_ ,
/*  9635 */	bri     | r1     << dst_ ,
/*  9636 */	0       ,
// s_tbl:
/*  9637 */	stmt    | 2717   << off_ ,	//	mov xl (xs)+  get initial lookup value
/*  9638 */	load    | xl     << dst_ | xs     << src_ ,
/*  9639 */	ica     | xs     << dst_ ,
/*  9640 */	stmt    | 2718   << off_ ,	//	ica xs   pop second argument
/*  9641 */	ica     | xs     << dst_ ,
/*  9642 */	stmt    | 2719   << off_ ,	//	jsr gtsmi   load argument
/*  9643 */	call    | gtsmi  << off_ ,
/*  9644 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  9645 */	err     | 195    << off_ ,
/*  9646 */	err     | 196    << off_ ,
/*  9647 */	stmt    | 2720   << off_ ,	//	bnz wc stbl1  jump if non-zero
/*  9648 */	bnz     | wc     << dst_ | stbl1  << off_ ,
/*  9649 */	stmt    | 2721   << off_ ,	//	mov wc =tbnbk  else supply default value
/*  9650 */	loadi   | wc     << dst_ | tbnbk  << off_ ,
// stbl1:
/*  9651 */	stmt    | 2722   << off_ ,	//stbl1	jsr tmake   make table
/*  9652 */	call    | tmake  << off_ ,
/*  9653 */	stmt    | 2723   << off_ ,	//	brn exsid   exit setting idval
/*  9654 */	brn     | exsid  << off_ ,
/*  9655 */	0       ,
// s_tan:
/*  9656 */	stmt    | 2724   << off_ ,	//	mov xr (xs)+  get argument
/*  9657 */	load    | xr     << dst_ | xs     << src_ ,
/*  9658 */	ica     | xs     << dst_ ,
/*  9659 */	stmt    | 2725   << off_ ,	//	jsr gtrea   convert to real
/*  9660 */	call    | gtrea  << off_ ,
/*  9661 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9662 */	err     | 309    << off_ ,
/*  9663 */	stmt    | 2726   << off_ ,	//	ldr rcval(xr)   load accumulator with argument
/*  9664 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/*  9665 */	ldr     | r1     << dst_ ,
/*  9666 */	realop  | tan    << off_ ,
/*  9667 */	stmt    | 2727   << off_ ,	//	rno exrea   if no overflow, return result in ra
/*  9668 */	rno     | exrea  << off_ ,
/*  9669 */	stmt    | 2728   << off_ ,	//	erb 310 tan produced real overflow or argument is out of range
/*  9670 */	erb     | 310    << off_ ,
/*  9671 */	0       ,
// s_tim:
/*  9672 */	stmt    | 2729   << off_ ,	//	jsr systm   get timer value
/*  9673 */	sys     | systm_ << off_ ,
/*  9674 */	stmt    | 2730   << off_ ,	//	sbi timsx   subtract starting time
/*  9675 */	load    | r1     << dst_ | timsx  << off_ ,
/*  9676 */	sbi     | r1     << dst_ ,
/*  9677 */	stmt    | 2731   << off_ ,	//	brn exint   exit with integer value
/*  9678 */	brn     | exint  << off_ ,
/*  9679 */	0       ,
// s_tra:
/*  9680 */	stmt    | 2732   << off_ ,	//	beq num03(xs) =nulls str02 jump if first argument is null
/*  9681 */	load    | r1     << dst_ | xs     << src_ | num03  << off_ ,
/*  9682 */	loadi   | r2     << dst_ | nulls  << off_ ,
/*  9683 */	beq     | r1     << dst_ | r2     << src_ | str02  << off_ ,
/*  9684 */	stmt    | 2733   << off_ ,	//	mov xr (xs)+  load fourth argument
/*  9685 */	load    | xr     << dst_ | xs     << src_ ,
/*  9686 */	ica     | xs     << dst_ ,
/*  9687 */	stmt    | 2734   << off_ ,	//	zer xl   tentatively set zero pointer
/*  9688 */	move    | xl     << dst_ ,
/*  9689 */	stmt    | 2735   << off_ ,	//	beq xr =nulls str01 jump if 4th argument is null
/*  9690 */	loadi   | r2     << dst_ | nulls  << off_ ,
/*  9691 */	beq     | xr     << dst_ | r2     << src_ | str01  << off_ ,
/*  9692 */	stmt    | 2736   << off_ ,	//	jsr gtnvr   else point to vrblk
/*  9693 */	call    | gtnvr  << off_ ,
/*  9694 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9695 */	ppm     | str03  << off_ ,
/*  9696 */	stmt    | 2737   << off_ ,	//	mov xl xr  else save vrblk in trfnc
/*  9697 */	move    | xl     << dst_ | xr     << src_ ,
// str01:
/*  9698 */	stmt    | 2738   << off_ ,	//str01	mov xr (xs)+  load third argument (tag)
/*  9699 */	load    | xr     << dst_ | xs     << src_ ,
/*  9700 */	ica     | xs     << dst_ ,
/*  9701 */	stmt    | 2739   << off_ ,	//	zer wb   set zero as trtyp value for now
/*  9702 */	move    | wb     << dst_ ,
/*  9703 */	stmt    | 2740   << off_ ,	//	jsr trbld   build trblk for trace call
/*  9704 */	call    | trbld  << off_ ,
/*  9705 */	stmt    | 2741   << off_ ,	//	mov xl xr  move trblk pointer for trace
/*  9706 */	move    | xl     << dst_ | xr     << src_ ,
/*  9707 */	stmt    | 2742   << off_ ,	//	jsr trace   call trace procedure
/*  9708 */	call    | trace  << off_ ,
/*  9709 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/*  9710 */	err     | 198    << off_ ,
/*  9711 */	err     | 199    << off_ ,
/*  9712 */	stmt    | 2743   << off_ ,	//	brn exnul   return null
/*  9713 */	brn     | exnul  << off_ ,
// str02:
/*  9714 */	stmt    | 2744   << off_ ,	//str02	jsr systt   call it
/*  9715 */	sys     | systt_ << off_ ,
/*  9716 */	stmt    | 2745   << off_ ,	//	add xs *num04  pop trace arguments
/*  9717 */	loadi   | r2     << dst_ | num04  << off_ ,
/*  9718 */	add     | xs     << dst_ | r2     << src_ ,
/*  9719 */	stmt    | 2746   << off_ ,	//	brn exnul   return
/*  9720 */	brn     | exnul  << off_ ,
// str03:
/*  9721 */	stmt    | 2747   << off_ ,	//str03	erb 197 trace fourth arg is not function name or null
/*  9722 */	erb     | 197    << off_ ,
/*  9723 */	0       ,
// s_trm:
/*  9724 */	stmt    | 2748   << off_ ,	//	jsr gtstg   load argument as string
/*  9725 */	call    | gtstg  << off_ ,
/*  9726 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9727 */	err     | 200    << off_ ,
/*  9728 */	stmt    | 2749   << off_ ,	//	bze wa exnul  return null if argument is null
/*  9729 */	bze     | wa     << dst_ | exnul  << off_ ,
/*  9730 */	stmt    | 2750   << off_ ,	//	mov xl xr  copy string pointer
/*  9731 */	move    | xl     << dst_ | xr     << src_ ,
/*  9732 */	stmt    | 2751   << off_ ,	//	ctb wa schar  get block length
/*  9733 */	ctb     | wa     << dst_ | schar  << off_ ,
/*  9734 */	stmt    | 2752   << off_ ,	//	jsr alloc   allocate copy same size
/*  9735 */	call    | alloc  << off_ ,
/*  9736 */	stmt    | 2753   << off_ ,	//	mov wb xr  save pointer to copy
/*  9737 */	move    | wb     << dst_ | xr     << src_ ,
/*  9738 */	stmt    | 2754   << off_ ,	//	mvw    copy old string block to new
/*  9739 */	mvw     ,
/*  9740 */	stmt    | 2755   << off_ ,	//	mov xr wb  restore ptr to new block
/*  9741 */	move    | xr     << dst_ | wb     << src_ ,
/*  9742 */	stmt    | 2756   << off_ ,	//	jsr trimr   trim blanks (wb is non-zero)
/*  9743 */	call    | trimr  << off_ ,
/*  9744 */	stmt    | 2757   << off_ ,	//	mov -(xs) xr  stack result
/*  9745 */	dca     | xs     << dst_ ,
/*  9746 */	store   | xr     << dst_ | xs     << src_ ,
/*  9747 */	stmt    | 2758   << off_ ,	//	lcw xr   get next code word
/*  9748 */	lcw     | xr     << dst_ ,
/*  9749 */	stmt    | 2759   << off_ ,	//	bri (xr)   execute it
/*  9750 */	load    | r1     << dst_ | xr     << src_ ,
/*  9751 */	bri     | r1     << dst_ ,
/*  9752 */	0       ,
// s_unl:
/*  9753 */	stmt    | 2760   << off_ ,	//	mov xr (xs)+  load argument
/*  9754 */	load    | xr     << dst_ | xs     << src_ ,
/*  9755 */	ica     | xs     << dst_ ,
/*  9756 */	stmt    | 2761   << off_ ,	//	jsr gtnvr   point to vrblk
/*  9757 */	call    | gtnvr  << off_ ,
/*  9758 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9759 */	err     | 201    << off_ ,
/*  9760 */	stmt    | 2762   << off_ ,	//	mov xl =stndf  get ptr to undefined function
/*  9761 */	loadi   | xl     << dst_ | stndf  << off_ ,
/*  9762 */	stmt    | 2763   << off_ ,	//	jsr dffnc   undefine named function
/*  9763 */	call    | dffnc  << off_ ,
/*  9764 */	stmt    | 2764   << off_ ,	//	brn exnul   return null as result
/*  9765 */	brn     | exnul  << off_ ,
// arref:
/*  9766 */	stmt    | 2765   << off_ ,	//arref	rtn
/*  9767 */	stmt    | 2766   << off_ ,	//	mov wa xr  copy number of subscripts
/*  9768 */	move    | wa     << dst_ | xr     << src_ ,
/*  9769 */	stmt    | 2767   << off_ ,	//	mov xt xs  point to stack front
/*  9770 */	move    | xt     << dst_ | xs     << src_ ,
/*  9771 */	stmt    | 2768   << off_ ,	//	wtb xr   convert to byte offset
/*  9772 */	stmt    | 2769   << off_ ,	//	add xt xr  point to array operand on stack
/*  9773 */	add     | xt     << dst_ | xr     << src_ ,
/*  9774 */	stmt    | 2770   << off_ ,	//	ica xt   final value for stack popping
/*  9775 */	ica     | xt     << dst_ ,
/*  9776 */	stmt    | 2771   << off_ ,	//	mov arfxs xt  keep for later
/*  9777 */	store   | xt     << dst_ | arfxs  << off_ ,
/*  9778 */	stmt    | 2772   << off_ ,	//	mov xr -(xt)  load array operand pointer
/*  9779 */	dca     | xt     << dst_ ,
/*  9780 */	load    | xr     << dst_ | xt     << src_ ,
/*  9781 */	stmt    | 2773   << off_ ,	//	mov r_arf xr  keep array pointer
/*  9782 */	store   | xr     << dst_ | r_arf  << off_ ,
/*  9783 */	stmt    | 2774   << off_ ,	//	mov xr xt  save pointer to subscripts
/*  9784 */	move    | xr     << dst_ | xt     << src_ ,
/*  9785 */	stmt    | 2775   << off_ ,	//	mov xl r_arf  point xl to possible vcblk or tbblk
/*  9786 */	load    | xl     << dst_ | r_arf  << off_ ,
/*  9787 */	stmt    | 2776   << off_ ,	//	mov wc (xl)  load first word
/*  9788 */	load    | wc     << dst_ | xl     << src_ ,
/*  9789 */	stmt    | 2777   << off_ ,	//	beq wc =b_art arf01 jump if arblk
/*  9790 */	loadi   | r2     << dst_ | b_art  << off_ ,
/*  9791 */	beq     | wc     << dst_ | r2     << src_ | arf01  << off_ ,
/*  9792 */	stmt    | 2778   << off_ ,	//	beq wc =b_vct arf07 jump if vcblk
/*  9793 */	loadi   | r2     << dst_ | b_vct  << off_ ,
/*  9794 */	beq     | wc     << dst_ | r2     << src_ | arf07  << off_ ,
/*  9795 */	stmt    | 2779   << off_ ,	//	beq wc =b_tbt arf10 jump if tbblk
/*  9796 */	loadi   | r2     << dst_ | b_tbt  << off_ ,
/*  9797 */	beq     | wc     << dst_ | r2     << src_ | arf10  << off_ ,
/*  9798 */	stmt    | 2780   << off_ ,	//	erb 235 subscripted operand is not table or array
/*  9799 */	erb     | 235    << off_ ,
// arf01:
/*  9800 */	stmt    | 2781   << off_ ,	//arf01	bne wa arndm(xl) arf09 jump if wrong number of dims
/*  9801 */	load    | r2     << dst_ | xl     << src_ | arndm  << off_ ,
/*  9802 */	bne     | wa     << dst_ | r2     << src_ | arf09  << off_ ,
/*  9803 */	stmt    | 2782   << off_ ,	//	ldi 4,intv0   get initial subscript of zero
/*  9804 */	load    | r1     << dst_ | intv0  << off_ ,
/*  9805 */	ldi     | r1     << dst_ ,
/*  9806 */	stmt    | 2783   << off_ ,	//	mov xt xr  point before subscripts
/*  9807 */	move    | xt     << dst_ | xr     << src_ ,
/*  9808 */	stmt    | 2784   << off_ ,	//	zer wa   initial offset to bounds
/*  9809 */	move    | wa     << dst_ ,
/*  9810 */	stmt    | 2785   << off_ ,	//	brn arf03   jump into loop
/*  9811 */	brn     | arf03  << off_ ,
// arf02:
/*  9812 */	stmt    | 2786   << off_ ,	//arf02	mli ardm2(xr)   multiply total by next dimension
/*  9813 */	load    | r1     << dst_ | xr     << src_ | ardm2  << off_ ,
/*  9814 */	mli     | r1     << dst_ ,
// arf03:
/*  9815 */	stmt    | 2787   << off_ ,	//arf03	mov xr -(xt)  load next subscript
/*  9816 */	dca     | xt     << dst_ ,
/*  9817 */	load    | xr     << dst_ | xt     << src_ ,
/*  9818 */	stmt    | 2788   << off_ ,	//	sti arfsi   save current subscript
/*  9819 */	store   | ia     << dst_ | arfsi  << off_ ,
/*  9820 */	stmt    | 2789   << off_ ,	//	ldi icval(xr)   load integer value in case
/*  9821 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  9822 */	ldi     | r1     << dst_ ,
/*  9823 */	stmt    | 2790   << off_ ,	//	beq (xr) =b_icl arf04 jump if it was an integer
/*  9824 */	load    | r1     << dst_ | xr     << src_ ,
/*  9825 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/*  9826 */	beq     | r1     << dst_ | r2     << src_ | arf04  << off_ ,
/*  9827 */	stmt    | 2791   << off_ ,	//	jsr gtint   convert to integer
/*  9828 */	call    | gtint  << off_ ,
/*  9829 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9830 */	ppm     | arf12  << off_ ,
/*  9831 */	stmt    | 2792   << off_ ,	//	ldi icval(xr)   if ok, load integer value
/*  9832 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  9833 */	ldi     | r1     << dst_ ,
// arf04:
/*  9834 */	stmt    | 2793   << off_ ,	//arf04	mov xr r_arf  point to array
/*  9835 */	load    | xr     << dst_ | r_arf  << off_ ,
/*  9836 */	stmt    | 2794   << off_ ,	//	add xr wa  offset to next bounds
/*  9837 */	add     | xr     << dst_ | wa     << src_ ,
/*  9838 */	stmt    | 2795   << off_ ,	//	sbi arlbd(xr)   subtract low bound to compare
/*  9839 */	load    | r1     << dst_ | xr     << src_ | arlbd  << off_ ,
/*  9840 */	sbi     | r1     << dst_ ,
/*  9841 */	stmt    | 2796   << off_ ,	//	iov arf13   out of range fail if overflow
/*  9842 */	iov     | arf13  << off_ ,
/*  9843 */	stmt    | 2797   << off_ ,	//	ilt arf13   out of range fail if too small
/*  9844 */	ilt     | arf13  << off_ ,
/*  9845 */	stmt    | 2798   << off_ ,	//	sbi ardim(xr)   subtract dimension
/*  9846 */	load    | r1     << dst_ | xr     << src_ | ardim  << off_ ,
/*  9847 */	sbi     | r1     << dst_ ,
/*  9848 */	stmt    | 2799   << off_ ,	//	ige arf13   out of range fail if too large
/*  9849 */	ige     | arf13  << off_ ,
/*  9850 */	stmt    | 2800   << off_ ,	//	adi ardim(xr)   else restore subscript offset
/*  9851 */	load    | r1     << dst_ | xr     << src_ | ardim  << off_ ,
/*  9852 */	adi     | r1     << dst_ ,
/*  9853 */	stmt    | 2801   << off_ ,	//	adi arfsi   add to current total
/*  9854 */	load    | r1     << dst_ | arfsi  << off_ ,
/*  9855 */	adi     | r1     << dst_ ,
/*  9856 */	stmt    | 2802   << off_ ,	//	add wa *ardms  point to next bounds
/*  9857 */	loadi   | r2     << dst_ | ardms  << off_ ,
/*  9858 */	add     | wa     << dst_ | r2     << src_ ,
/*  9859 */	stmt    | 2803   << off_ ,	//	bne xt xs arf02 loop back if more to go
/*  9860 */	bne     | xt     << dst_ | xs     << src_ | arf02  << off_ ,
/*  9861 */	stmt    | 2804   << off_ ,	//	mfi wa   get as one word integer
/*  9862 */	move    | wa     << dst_ | ia     << src_ ,
/*  9863 */	stmt    | 2805   << off_ ,	//	wtb wa   convert to offset
/*  9864 */	stmt    | 2806   << off_ ,	//	mov xl r_arf  point to arblk
/*  9865 */	load    | xl     << dst_ | r_arf  << off_ ,
/*  9866 */	stmt    | 2807   << off_ ,	//	add wa arofs(xl)  add offset past bounds
/*  9867 */	load    | r2     << dst_ | xl     << src_ | arofs  << off_ ,
/*  9868 */	add     | wa     << dst_ | r2     << src_ ,
/*  9869 */	stmt    | 2808   << off_ ,	//	ica wa   adjust for arpro field
/*  9870 */	ica     | wa     << dst_ ,
/*  9871 */	stmt    | 2809   << off_ ,	//	bnz wb arf08  exit with name if name call
/*  9872 */	bnz     | wb     << dst_ | arf08  << off_ ,
// arf05:
/*  9873 */	stmt    | 2810   << off_ ,	//arf05	jsr acess   get value
/*  9874 */	call    | acess  << off_ ,
/*  9875 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9876 */	ppm     | arf13  << off_ ,
// arf06:
/*  9877 */	stmt    | 2811   << off_ ,	//arf06	mov xs arfxs  pop stack entries
/*  9878 */	load    | xs     << dst_ | arfxs  << off_ ,
/*  9879 */	stmt    | 2812   << off_ ,	//	zer r_arf   finished with array pointer
/*  9880 */	store   | r0     << dst_ | r_arf  << off_ ,
/*  9881 */	stmt    | 2813   << off_ ,	//	mov -(xs) xr  stack result
/*  9882 */	dca     | xs     << dst_ ,
/*  9883 */	store   | xr     << dst_ | xs     << src_ ,
/*  9884 */	stmt    | 2814   << off_ ,	//	lcw xr   get next code word
/*  9885 */	lcw     | xr     << dst_ ,
/*  9886 */	stmt    | 2815   << off_ ,	//	bri (xr)   execute it
/*  9887 */	load    | r1     << dst_ | xr     << src_ ,
/*  9888 */	bri     | r1     << dst_ ,
// arf07:
/*  9889 */	stmt    | 2816   << off_ ,	//arf07	bne wa =num01 arf09 error if more than 1 subscript
/*  9890 */	loadi   | r2     << dst_ | num01  << off_ ,
/*  9891 */	bne     | wa     << dst_ | r2     << src_ | arf09  << off_ ,
/*  9892 */	stmt    | 2817   << off_ ,	//	mov xr (xs)  else load subscript
/*  9893 */	load    | xr     << dst_ | xs     << src_ ,
/*  9894 */	stmt    | 2818   << off_ ,	//	jsr gtint   convert to integer
/*  9895 */	call    | gtint  << off_ ,
/*  9896 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9897 */	ppm     | arf12  << off_ ,
/*  9898 */	stmt    | 2819   << off_ ,	//	ldi icval(xr)   else load integer value
/*  9899 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/*  9900 */	ldi     | r1     << dst_ ,
/*  9901 */	stmt    | 2820   << off_ ,	//	sbi 4,intv1   subtract for ones offset
/*  9902 */	load    | r1     << dst_ | intv1  << off_ ,
/*  9903 */	sbi     | r1     << dst_ ,
/*  9904 */	stmt    | 2821   << off_ ,	//	mfi wa arf13  get subscript as one word
/*  9905 */	move    | wa     << dst_ | ia     << src_ ,
/*  9906 */	mfi     | arf13  << off_ ,
/*  9907 */	stmt    | 2822   << off_ ,	//	add wa =vcvls  add offset for standard fields
/*  9908 */	loadi   | r2     << dst_ | vcvls  << off_ ,
/*  9909 */	add     | wa     << dst_ | r2     << src_ ,
/*  9910 */	stmt    | 2823   << off_ ,	//	wtb wa   convert offset to bytes
/*  9911 */	stmt    | 2824   << off_ ,	//	bge wa vclen(xl) arf13 fail if out of range subscript
/*  9912 */	load    | r2     << dst_ | xl     << src_ | vclen  << off_ ,
/*  9913 */	bge     | wa     << dst_ | r2     << src_ | arf13  << off_ ,
/*  9914 */	stmt    | 2825   << off_ ,	//	bze wb arf05  back to get value if value call
/*  9915 */	bze     | wb     << dst_ | arf05  << off_ ,
// arf08:
/*  9916 */	stmt    | 2826   << off_ ,	//arf08	mov xs arfxs  pop stack entries
/*  9917 */	load    | xs     << dst_ | arfxs  << off_ ,
/*  9918 */	stmt    | 2827   << off_ ,	//	zer r_arf   finished with array pointer
/*  9919 */	store   | r0     << dst_ | r_arf  << off_ ,
/*  9920 */	stmt    | 2828   << off_ ,	//	brn exnam   else exit with name
/*  9921 */	brn     | exnam  << off_ ,
// arf09:
/*  9922 */	stmt    | 2829   << off_ ,	//arf09	erb 236 array referenced with wrong number of subscripts
/*  9923 */	erb     | 236    << off_ ,
// arf10:
/*  9924 */	stmt    | 2830   << off_ ,	//arf10	bne wa =num01 arf11 error if more than 1 subscript
/*  9925 */	loadi   | r2     << dst_ | num01  << off_ ,
/*  9926 */	bne     | wa     << dst_ | r2     << src_ | arf11  << off_ ,
/*  9927 */	stmt    | 2831   << off_ ,	//	mov xr (xs)  else load subscript
/*  9928 */	load    | xr     << dst_ | xs     << src_ ,
/*  9929 */	stmt    | 2832   << off_ ,	//	jsr tfind   call table search routine
/*  9930 */	call    | tfind  << off_ ,
/*  9931 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/*  9932 */	ppm     | arf13  << off_ ,
/*  9933 */	stmt    | 2833   << off_ ,	//	bnz wb arf08  exit with name if name call
/*  9934 */	bnz     | wb     << dst_ | arf08  << off_ ,
/*  9935 */	stmt    | 2834   << off_ ,	//	brn arf06   else exit with value
/*  9936 */	brn     | arf06  << off_ ,
// arf11:
/*  9937 */	stmt    | 2835   << off_ ,	//arf11	erb 237 table referenced with more than one subscript
/*  9938 */	erb     | 237    << off_ ,
// arf12:
/*  9939 */	stmt    | 2836   << off_ ,	//arf12	erb 238 array subscript is not integer
/*  9940 */	erb     | 238    << off_ ,
// arf13:
/*  9941 */	stmt    | 2837   << off_ ,	//arf13	zer r_arf   finished with array pointer
/*  9942 */	store   | r0     << dst_ | r_arf  << off_ ,
/*  9943 */	stmt    | 2838   << off_ ,	//	brn exfal   fail
/*  9944 */	brn     | exfal  << off_ ,
// cfunc:
/*  9945 */	stmt    | 2839   << off_ ,	//cfunc	rtn
/*  9946 */	stmt    | 2840   << off_ ,	//	blt wa fargs(xl) cfnc1 jump if too few arguments
/*  9947 */	load    | r2     << dst_ | xl     << src_ | fargs  << off_ ,
/*  9948 */	blt     | wa     << dst_ | r2     << src_ | cfnc1  << off_ ,
/*  9949 */	stmt    | 2841   << off_ ,	//	beq wa fargs(xl) cfnc3 jump if correct number of args
/*  9950 */	load    | r2     << dst_ | xl     << src_ | fargs  << off_ ,
/*  9951 */	beq     | wa     << dst_ | r2     << src_ | cfnc3  << off_ ,
/*  9952 */	stmt    | 2842   << off_ ,	//	mov wb wa  copy actual number
/*  9953 */	move    | wb     << dst_ | wa     << src_ ,
/*  9954 */	stmt    | 2843   << off_ ,	//	sub wb fargs(xl)  get number of extra args
/*  9955 */	load    | r2     << dst_ | xl     << src_ | fargs  << off_ ,
/*  9956 */	sub     | wb     << dst_ | r2     << src_ ,
/*  9957 */	stmt    | 2844   << off_ ,	//	wtb wb   convert to bytes
/*  9958 */	stmt    | 2845   << off_ ,	//	add xs wb  pop off unwanted arguments
/*  9959 */	add     | xs     << dst_ | wb     << src_ ,
/*  9960 */	stmt    | 2846   << off_ ,	//	brn cfnc3   jump to go off to function
/*  9961 */	brn     | cfnc3  << off_ ,
// cfnc1:
/*  9962 */	stmt    | 2847   << off_ ,	//cfnc1	mov wb fargs(xl)  load required number of arguments
/*  9963 */	load    | wb     << dst_ | xl     << src_ | fargs  << off_ ,
/*  9964 */	stmt    | 2848   << off_ ,	//	beq wb =nini9 cfnc3 jump if case of var num of args
/*  9965 */	loadi   | r2     << dst_ | nini9  << off_ ,
/*  9966 */	beq     | wb     << dst_ | r2     << src_ | cfnc3  << off_ ,
/*  9967 */	stmt    | 2849   << off_ ,	//	sub wb wa  calculate number missing
/*  9968 */	sub     | wb     << dst_ | wa     << src_ ,
/*  9969 */	stmt    | 2850   << off_ ,	//	lct wb wb  set counter to control loop
// cfnc2:
/*  9970 */	stmt    | 2851   << off_ ,	//cfnc2	mov -(xs) =nulls  stack a null argument
/*  9971 */	loadi   | r1     << dst_ | nulls  << off_ ,
/*  9972 */	dca     | xs     << dst_ ,
/*  9973 */	store   | r1     << dst_ | xs     << src_ ,
/*  9974 */	stmt    | 2852   << off_ ,	//	bct wb cfnc2  loop till proper number stacked
/*  9975 */	bct     | wb     << dst_ | cfnc2  << off_ ,
// cfnc3:
/*  9976 */	stmt    | 2853   << off_ ,	//cfnc3	bri (xl)   jump through fcode field
/*  9977 */	load    | r1     << dst_ | xl     << src_ ,
/*  9978 */	bri     | r1     << dst_ ,
// exfal:
/*  9979 */	stmt    | 2854   << off_ ,	//exfal	rtn
/*  9980 */	stmt    | 2855   << off_ ,	//	mov xs flptr  pop stack
/*  9981 */	load    | xs     << dst_ | flptr  << off_ ,
/*  9982 */	stmt    | 2856   << off_ ,	//	mov xr (xs)  load failure offset
/*  9983 */	load    | xr     << dst_ | xs     << src_ ,
/*  9984 */	stmt    | 2857   << off_ ,	//	add xr r_cod  point to failure code location
/*  9985 */	load    | r2     << dst_ | r_cod  << off_ ,
/*  9986 */	add     | xr     << dst_ | r2     << src_ ,
/*  9987 */	stmt    | 2858   << off_ ,	//	lcp xr   set code pointer
/*  9988 */	lcp     | xr     << dst_ ,
/*  9989 */	stmt    | 2859   << off_ ,	//	lcw xr   load next code word
/*  9990 */	lcw     | xr     << dst_ ,
/*  9991 */	stmt    | 2860   << off_ ,	//	mov xl (xr)  load entry address
/*  9992 */	load    | xl     << dst_ | xr     << src_ ,
/*  9993 */	stmt    | 2861   << off_ ,	//	bri xl   jump to execute next code word
/*  9994 */	bri     | xl     << dst_ ,
// exint:
/*  9995 */	stmt    | 2862   << off_ ,	//exint	rtn
/*  9996 */	stmt    | 2863   << off_ ,	//	zer xl   clear dud value
/*  9997 */	move    | xl     << dst_ ,
/*  9998 */	stmt    | 2864   << off_ ,	//	jsr icbld   build icblk
/*  9999 */	call    | icbld  << off_ ,
// exixr:
/* 10000 */	stmt    | 2865   << off_ ,	//exixr	rtn
/* 10001 */	stmt    | 2866   << off_ ,	//	mov -(xs) xr  stack result
/* 10002 */	dca     | xs     << dst_ ,
/* 10003 */	store   | xr     << dst_ | xs     << src_ ,
// exits:
/* 10004 */	stmt    | 2867   << off_ ,	//exits	rtn
/* 10005 */	stmt    | 2868   << off_ ,	//	lcw xr   load next code word
/* 10006 */	lcw     | xr     << dst_ ,
/* 10007 */	stmt    | 2869   << off_ ,	//	mov xl (xr)  load entry address
/* 10008 */	load    | xl     << dst_ | xr     << src_ ,
/* 10009 */	stmt    | 2870   << off_ ,	//	bri xl   jump to execute next code word
/* 10010 */	bri     | xl     << dst_ ,
// exnam:
/* 10011 */	stmt    | 2871   << off_ ,	//exnam	rtn
/* 10012 */	stmt    | 2872   << off_ ,	//	mov -(xs) xl  stack name base
/* 10013 */	dca     | xs     << dst_ ,
/* 10014 */	store   | xl     << dst_ | xs     << src_ ,
/* 10015 */	stmt    | 2873   << off_ ,	//	mov -(xs) wa  stack name offset
/* 10016 */	dca     | xs     << dst_ ,
/* 10017 */	store   | wa     << dst_ | xs     << src_ ,
/* 10018 */	stmt    | 2874   << off_ ,	//	lcw xr   load next code word
/* 10019 */	lcw     | xr     << dst_ ,
/* 10020 */	stmt    | 2875   << off_ ,	//	bri (xr)   execute it
/* 10021 */	load    | r1     << dst_ | xr     << src_ ,
/* 10022 */	bri     | r1     << dst_ ,
// exnul:
/* 10023 */	stmt    | 2876   << off_ ,	//exnul	rtn
/* 10024 */	stmt    | 2877   << off_ ,	//	mov -(xs) =nulls  stack null value
/* 10025 */	loadi   | r1     << dst_ | nulls  << off_ ,
/* 10026 */	dca     | xs     << dst_ ,
/* 10027 */	store   | r1     << dst_ | xs     << src_ ,
/* 10028 */	stmt    | 2878   << off_ ,	//	lcw xr   load next code word
/* 10029 */	lcw     | xr     << dst_ ,
/* 10030 */	stmt    | 2879   << off_ ,	//	mov xl (xr)  load entry address
/* 10031 */	load    | xl     << dst_ | xr     << src_ ,
/* 10032 */	stmt    | 2880   << off_ ,	//	bri xl   jump to execute next code word
/* 10033 */	bri     | xl     << dst_ ,
// exrea:
/* 10034 */	stmt    | 2881   << off_ ,	//exrea	rtn
/* 10035 */	stmt    | 2882   << off_ ,	//	zer xl   clear dud value
/* 10036 */	move    | xl     << dst_ ,
/* 10037 */	stmt    | 2883   << off_ ,	//	jsr rcbld   build rcblk
/* 10038 */	call    | rcbld  << off_ ,
/* 10039 */	stmt    | 2884   << off_ ,	//	brn exixr   jump to exit with result in xr
/* 10040 */	brn     | exixr  << off_ ,
// exsid:
/* 10041 */	stmt    | 2885   << off_ ,	//exsid	rtn
/* 10042 */	stmt    | 2886   << off_ ,	//	mov wa curid  load current id value
/* 10043 */	load    | wa     << dst_ | curid  << off_ ,
/* 10044 */	stmt    | 2887   << off_ ,	//	bne wa mxint exsi1 jump if no overflow
/* 10045 */	load    | r2     << dst_ | mxint  << off_ ,
/* 10046 */	bne     | wa     << dst_ | r2     << src_ | exsi1  << off_ ,
/* 10047 */	stmt    | 2888   << off_ ,	//	zer wa   else reset for wraparound
/* 10048 */	move    | wa     << dst_ ,
// exsi1:
/* 10049 */	stmt    | 2889   << off_ ,	//exsi1	icv wa   bump id value
/* 10050 */	icv     | wa     << dst_ ,
/* 10051 */	stmt    | 2890   << off_ ,	//	mov curid wa  store for next time
/* 10052 */	store   | wa     << dst_ | curid  << off_ ,
/* 10053 */	stmt    | 2891   << off_ ,	//	mov idval(xr) wa  store id value
/* 10054 */	store   | wa     << dst_ | xr     << src_ | idval  << off_ ,
/* 10055 */	stmt    | 2892   << off_ ,	//	brn exixr   exit with result in (xr)
/* 10056 */	brn     | exixr  << off_ ,
// exvnm:
/* 10057 */	stmt    | 2893   << off_ ,	//exvnm	rtn
/* 10058 */	stmt    | 2894   << off_ ,	//	mov xl xr  copy name base pointer
/* 10059 */	move    | xl     << dst_ | xr     << src_ ,
/* 10060 */	stmt    | 2895   << off_ ,	//	mov wa *nmsi_  set size of nmblk
/* 10061 */	loadi   | wa     << dst_ | nmsi_  << off_ ,
/* 10062 */	stmt    | 2896   << off_ ,	//	jsr alloc   allocate nmblk
/* 10063 */	call    | alloc  << off_ ,
/* 10064 */	stmt    | 2897   << off_ ,	//	mov (xr) =b_nml  store type word
/* 10065 */	loadi   | r1     << dst_ | b_nml  << off_ ,
/* 10066 */	store   | r1     << dst_ | xr     << src_ ,
/* 10067 */	stmt    | 2898   << off_ ,	//	mov nmbas(xr) xl  store name base
/* 10068 */	store   | xl     << dst_ | xr     << src_ | nmbas  << off_ ,
/* 10069 */	stmt    | 2899   << off_ ,	//	mov nmofs(xr) *vrval  store name offset
/* 10070 */	loadi   | r1     << dst_ | vrval  << off_ ,
/* 10071 */	store   | r1     << dst_ | xr     << src_ | nmofs  << off_ ,
/* 10072 */	stmt    | 2900   << off_ ,	//	brn exixr   exit with result in xr
/* 10073 */	brn     | exixr  << off_ ,
// flpop:
/* 10074 */	stmt    | 2901   << off_ ,	//flpop	rtn
/* 10075 */	stmt    | 2902   << off_ ,	//	add xs *num02  pop two entries off stack
/* 10076 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 10077 */	add     | xs     << dst_ | r2     << src_ ,
// failp:
/* 10078 */	stmt    | 2903   << off_ ,	//failp	rtn
/* 10079 */	stmt    | 2904   << off_ ,	//	mov xr (xs)+  load alternative node pointer
/* 10080 */	load    | xr     << dst_ | xs     << src_ ,
/* 10081 */	ica     | xs     << dst_ ,
/* 10082 */	stmt    | 2905   << off_ ,	//	mov wb (xs)+  restore old cursor
/* 10083 */	load    | wb     << dst_ | xs     << src_ ,
/* 10084 */	ica     | xs     << dst_ ,
/* 10085 */	stmt    | 2906   << off_ ,	//	mov xl (xr)  load pcode entry pointer
/* 10086 */	load    | xl     << dst_ | xr     << src_ ,
/* 10087 */	stmt    | 2907   << off_ ,	//	bri xl   jump to execute code for node
/* 10088 */	bri     | xl     << dst_ ,
// indir:
/* 10089 */	stmt    | 2908   << off_ ,	//indir	rtn
/* 10090 */	stmt    | 2909   << off_ ,	//	mov xr (xs)+  load argument
/* 10091 */	load    | xr     << dst_ | xs     << src_ ,
/* 10092 */	ica     | xs     << dst_ ,
/* 10093 */	stmt    | 2910   << off_ ,	//	beq (xr) =b_nml indr2 jump if a name
/* 10094 */	load    | r1     << dst_ | xr     << src_ ,
/* 10095 */	loadi   | r2     << dst_ | b_nml  << off_ ,
/* 10096 */	beq     | r1     << dst_ | r2     << src_ | indr2  << off_ ,
/* 10097 */	stmt    | 2911   << off_ ,	//	jsr gtnvr   else convert to variable
/* 10098 */	call    | gtnvr  << off_ ,
/* 10099 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 10100 */	err     | 239    << off_ ,
/* 10101 */	stmt    | 2912   << off_ ,	//	bze wb indr1  skip if by value
/* 10102 */	bze     | wb     << dst_ | indr1  << off_ ,
/* 10103 */	stmt    | 2913   << off_ ,	//	mov -(xs) xr  else stack vrblk ptr
/* 10104 */	dca     | xs     << dst_ ,
/* 10105 */	store   | xr     << dst_ | xs     << src_ ,
/* 10106 */	stmt    | 2914   << off_ ,	//	mov -(xs) *vrval  stack name offset
/* 10107 */	loadi   | r1     << dst_ | vrval  << off_ ,
/* 10108 */	dca     | xs     << dst_ ,
/* 10109 */	store   | r1     << dst_ | xs     << src_ ,
/* 10110 */	stmt    | 2915   << off_ ,	//	lcw xr   load next code word
/* 10111 */	lcw     | xr     << dst_ ,
/* 10112 */	stmt    | 2916   << off_ ,	//	mov xl (xr)  load entry address
/* 10113 */	load    | xl     << dst_ | xr     << src_ ,
/* 10114 */	stmt    | 2917   << off_ ,	//	bri xl   jump to execute next code word
/* 10115 */	bri     | xl     << dst_ ,
// indr1:
/* 10116 */	stmt    | 2918   << off_ ,	//indr1	bri (xr)   jump through vrget field of vrblk
/* 10117 */	load    | r1     << dst_ | xr     << src_ ,
/* 10118 */	bri     | r1     << dst_ ,
// indr2:
/* 10119 */	stmt    | 2919   << off_ ,	//indr2	mov xl nmbas(xr)  load name base
/* 10120 */	load    | xl     << dst_ | xr     << src_ | nmbas  << off_ ,
/* 10121 */	stmt    | 2920   << off_ ,	//	mov wa nmofs(xr)  load name offset
/* 10122 */	load    | wa     << dst_ | xr     << src_ | nmofs  << off_ ,
/* 10123 */	stmt    | 2921   << off_ ,	//	bnz wb exnam  exit if called by name
/* 10124 */	bnz     | wb     << dst_ | exnam  << off_ ,
/* 10125 */	stmt    | 2922   << off_ ,	//	jsr acess   else get value first
/* 10126 */	call    | acess  << off_ ,
/* 10127 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 10128 */	ppm     | exfal  << off_ ,
/* 10129 */	stmt    | 2923   << off_ ,	//	brn exixr   else return with value in xr
/* 10130 */	brn     | exixr  << off_ ,
// match:
/* 10131 */	stmt    | 2924   << off_ ,	//match	rtn
/* 10132 */	stmt    | 2925   << off_ ,	//	mov xr (xs)+  load pattern operand
/* 10133 */	load    | xr     << dst_ | xs     << src_ ,
/* 10134 */	ica     | xs     << dst_ ,
/* 10135 */	stmt    | 2926   << off_ ,	//	jsr gtpat   convert to pattern
/* 10136 */	call    | gtpat  << off_ ,
/* 10137 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 10138 */	err     | 240    << off_ ,
/* 10139 */	stmt    | 2927   << off_ ,	//	mov xl xr  if ok, save pattern pointer
/* 10140 */	move    | xl     << dst_ | xr     << src_ ,
/* 10141 */	stmt    | 2928   << off_ ,	//	bnz wb mtch1  jump if not match by name
/* 10142 */	bnz     | wb     << dst_ | mtch1  << off_ ,
/* 10143 */	stmt    | 2929   << off_ ,	//	mov wa (xs)  else load name offset
/* 10144 */	load    | wa     << dst_ | xs     << src_ ,
/* 10145 */	stmt    | 2930   << off_ ,	//	mov -(xs) xl  save pattern pointer
/* 10146 */	dca     | xs     << dst_ ,
/* 10147 */	store   | xl     << dst_ | xs     << src_ ,
/* 10148 */	stmt    | 2931   << off_ ,	//	mov xl num02(xs)  load name base
/* 10149 */	load    | xl     << dst_ | xs     << src_ | num02  << off_ ,
/* 10150 */	stmt    | 2932   << off_ ,	//	jsr acess   access subject value
/* 10151 */	call    | acess  << off_ ,
/* 10152 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 10153 */	ppm     | exfal  << off_ ,
/* 10154 */	stmt    | 2933   << off_ ,	//	mov xl (xs)  restore pattern pointer
/* 10155 */	load    | xl     << dst_ | xs     << src_ ,
/* 10156 */	stmt    | 2934   << off_ ,	//	mov (xs) xr  stack subject string val for merge
/* 10157 */	store   | xr     << dst_ | xs     << src_ ,
/* 10158 */	stmt    | 2935   << off_ ,	//	zer wb   restore type code
/* 10159 */	move    | wb     << dst_ ,
// mtch1:
/* 10160 */	stmt    | 2936   << off_ ,	//mtch1	jsr gtstg   convert subject to string
/* 10161 */	call    | gtstg  << off_ ,
/* 10162 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 10163 */	err     | 241    << off_ ,
/* 10164 */	stmt    | 2937   << off_ ,	//	mov -(xs) wb  stack match type code
/* 10165 */	dca     | xs     << dst_ ,
/* 10166 */	store   | wb     << dst_ | xs     << src_ ,
/* 10167 */	stmt    | 2938   << off_ ,	//	mov r_pms xr  if ok, store subject string pointer
/* 10168 */	store   | xr     << dst_ | r_pms  << off_ ,
/* 10169 */	stmt    | 2939   << off_ ,	//	mov pmssl wa  and length
/* 10170 */	store   | wa     << dst_ | pmssl  << off_ ,
/* 10171 */	stmt    | 2940   << off_ ,	//	zer -(xs)   stack initial cursor (zero)
/* 10172 */	dca     | xs     << dst_ ,
/* 10173 */	store   | r0     << dst_ | xs     << src_ ,
/* 10174 */	stmt    | 2941   << off_ ,	//	zer wb   set initial cursor
/* 10175 */	move    | wb     << dst_ ,
/* 10176 */	stmt    | 2942   << off_ ,	//	mov pmhbs xs  set history stack base ptr
/* 10177 */	store   | xs     << dst_ | pmhbs  << off_ ,
/* 10178 */	stmt    | 2943   << off_ ,	//	zer pmdfl   reset pattern assignment flag
/* 10179 */	store   | r0     << dst_ | pmdfl  << off_ ,
/* 10180 */	stmt    | 2944   << off_ ,	//	mov xr xl  set initial node pointer
/* 10181 */	move    | xr     << dst_ | xl     << src_ ,
/* 10182 */	stmt    | 2945   << off_ ,	//	bnz kvanc mtch2  jump if anchored
/* 10183 */	load    | r1     << dst_ | kvanc  << off_ ,
/* 10184 */	bnz     | r1     << dst_ | mtch2  << off_ ,
/* 10185 */	stmt    | 2946   << off_ ,	//	mov -(xs) xr  stack initial node pointer
/* 10186 */	dca     | xs     << dst_ ,
/* 10187 */	store   | xr     << dst_ | xs     << src_ ,
/* 10188 */	stmt    | 2947   << off_ ,	//	mov -(xs) =nduna  stack pointer to anchor move node
/* 10189 */	loadi   | r1     << dst_ | nduna  << off_ ,
/* 10190 */	dca     | xs     << dst_ ,
/* 10191 */	store   | r1     << dst_ | xs     << src_ ,
/* 10192 */	stmt    | 2948   << off_ ,	//	bri (xr)   start match of first node
/* 10193 */	load    | r1     << dst_ | xr     << src_ ,
/* 10194 */	bri     | r1     << dst_ ,
// mtch2:
/* 10195 */	stmt    | 2949   << off_ ,	//mtch2	zer -(xs)   dummy cursor value
/* 10196 */	dca     | xs     << dst_ ,
/* 10197 */	store   | r0     << dst_ | xs     << src_ ,
/* 10198 */	stmt    | 2950   << off_ ,	//	mov -(xs) =ndabo  stack pointer to abort node
/* 10199 */	loadi   | r1     << dst_ | ndabo  << off_ ,
/* 10200 */	dca     | xs     << dst_ ,
/* 10201 */	store   | r1     << dst_ | xs     << src_ ,
/* 10202 */	stmt    | 2951   << off_ ,	//	bri (xr)   start match of first node
/* 10203 */	load    | r1     << dst_ | xr     << src_ ,
/* 10204 */	bri     | r1     << dst_ ,
// retrn:
/* 10205 */	stmt    | 2952   << off_ ,	//retrn	rtn
/* 10206 */	stmt    | 2953   << off_ ,	//	bnz kvfnc rtn01  jump if not level zero
/* 10207 */	load    | r1     << dst_ | kvfnc  << off_ ,
/* 10208 */	bnz     | r1     << dst_ | rtn01  << off_ ,
/* 10209 */	stmt    | 2954   << off_ ,	//	erb 242 function return from level zero
/* 10210 */	erb     | 242    << off_ ,
// rtn01:
/* 10211 */	stmt    | 2955   << off_ ,	//rtn01	mov xs flprt  pop stack
/* 10212 */	load    | xs     << dst_ | flprt  << off_ ,
/* 10213 */	stmt    | 2956   << off_ ,	//	ica xs   remove failure offset
/* 10214 */	ica     | xs     << dst_ ,
/* 10215 */	stmt    | 2957   << off_ ,	//	mov xr (xs)+  pop pfblk pointer
/* 10216 */	load    | xr     << dst_ | xs     << src_ ,
/* 10217 */	ica     | xs     << dst_ ,
/* 10218 */	stmt    | 2958   << off_ ,	//	mov flptr (xs)+  pop failure pointer
/* 10219 */	load    | r1     << dst_ | xs     << src_ ,
/* 10220 */	ica     | xs     << dst_ ,
/* 10221 */	store   | r1     << dst_ | flptr  << off_ ,
/* 10222 */	stmt    | 2959   << off_ ,	//	mov flprt (xs)+  pop old flprt
/* 10223 */	load    | r1     << dst_ | xs     << src_ ,
/* 10224 */	ica     | xs     << dst_ ,
/* 10225 */	store   | r1     << dst_ | flprt  << off_ ,
/* 10226 */	stmt    | 2960   << off_ ,	//	mov wb (xs)+  pop code pointer offset
/* 10227 */	load    | wb     << dst_ | xs     << src_ ,
/* 10228 */	ica     | xs     << dst_ ,
/* 10229 */	stmt    | 2961   << off_ ,	//	mov wc (xs)+  pop old code block pointer
/* 10230 */	load    | wc     << dst_ | xs     << src_ ,
/* 10231 */	ica     | xs     << dst_ ,
/* 10232 */	stmt    | 2962   << off_ ,	//	add wb wc  make old code pointer absolute
/* 10233 */	add     | wb     << dst_ | wc     << src_ ,
/* 10234 */	stmt    | 2963   << off_ ,	//	lcp wb   restore old code pointer
/* 10235 */	lcp     | wb     << dst_ ,
/* 10236 */	stmt    | 2964   << off_ ,	//	mov r_cod wc  restore old code block pointer
/* 10237 */	store   | wc     << dst_ | r_cod  << off_ ,
/* 10238 */	stmt    | 2965   << off_ ,	//	dcv kvfnc   decrement function level
/* 10239 */	load    | r1     << dst_ | kvfnc  << off_ ,
/* 10240 */	dcv     | r1     << dst_ ,
/* 10241 */	store   | r1     << dst_ | kvfnc  << off_ ,
/* 10242 */	stmt    | 2966   << off_ ,	//	mov wb kvtra  load trace
/* 10243 */	load    | wb     << dst_ | kvtra  << off_ ,
/* 10244 */	stmt    | 2967   << off_ ,	//	add wb kvftr  add ftrace
/* 10245 */	load    | r2     << dst_ | kvftr  << off_ ,
/* 10246 */	add     | wb     << dst_ | r2     << src_ ,
/* 10247 */	stmt    | 2968   << off_ ,	//	bze wb rtn06  jump if no tracing possible
/* 10248 */	bze     | wb     << dst_ | rtn06  << off_ ,
/* 10249 */	stmt    | 2969   << off_ ,	//	mov -(xs) wa  save function return type
/* 10250 */	dca     | xs     << dst_ ,
/* 10251 */	store   | wa     << dst_ | xs     << src_ ,
/* 10252 */	stmt    | 2970   << off_ ,	//	mov -(xs) xr  save pfblk pointer
/* 10253 */	dca     | xs     << dst_ ,
/* 10254 */	store   | xr     << dst_ | xs     << src_ ,
/* 10255 */	stmt    | 2971   << off_ ,	//	mov kvrtn wa  set rtntype for trace function
/* 10256 */	store   | wa     << dst_ | kvrtn  << off_ ,
/* 10257 */	stmt    | 2972   << off_ ,	//	mov xl r_fnc  load fnclevel trblk ptr (if any)
/* 10258 */	load    | xl     << dst_ | r_fnc  << off_ ,
/* 10259 */	stmt    | 2973   << off_ ,	//	jsr ktrex   execute possible fnclevel trace
/* 10260 */	call    | ktrex  << off_ ,
/* 10261 */	stmt    | 2974   << off_ ,	//	mov xl pfvbl(xr)  load vrblk ptr (sgd13)
/* 10262 */	load    | xl     << dst_ | xr     << src_ | pfvbl  << off_ ,
/* 10263 */	stmt    | 2975   << off_ ,	//	bze kvtra rtn02  jump if trace is off
/* 10264 */	load    | r1     << dst_ | kvtra  << off_ ,
/* 10265 */	bze     | r1     << dst_ | rtn02  << off_ ,
/* 10266 */	stmt    | 2976   << off_ ,	//	mov xr pfrtr(xr)  else load return trace trblk ptr
/* 10267 */	load    | xr     << dst_ | xr     << src_ | pfrtr  << off_ ,
/* 10268 */	stmt    | 2977   << off_ ,	//	bze xr rtn02  jump if not return traced
/* 10269 */	bze     | xr     << dst_ | rtn02  << off_ ,
/* 10270 */	stmt    | 2978   << off_ ,	//	dcv kvtra   else decrement trace count
/* 10271 */	load    | r1     << dst_ | kvtra  << off_ ,
/* 10272 */	dcv     | r1     << dst_ ,
/* 10273 */	store   | r1     << dst_ | kvtra  << off_ ,
/* 10274 */	stmt    | 2979   << off_ ,	//	bze trfnc(xr) rtn03  jump if print trace
/* 10275 */	load    | r1     << dst_ | xr     << src_ | trfnc  << off_ ,
/* 10276 */	bze     | r1     << dst_ | rtn03  << off_ ,
/* 10277 */	stmt    | 2980   << off_ ,	//	mov wa *vrval  else set name offset
/* 10278 */	loadi   | wa     << dst_ | vrval  << off_ ,
/* 10279 */	stmt    | 2981   << off_ ,	//	mov kvrtn num01(xs)  make sure rtntype is set right
/* 10280 */	load    | r1     << dst_ | xs     << src_ | num01  << off_ ,
/* 10281 */	store   | r1     << dst_ | kvrtn  << off_ ,
/* 10282 */	stmt    | 2982   << off_ ,	//	jsr trxeq   execute full trace
/* 10283 */	call    | trxeq  << off_ ,
// rtn02:
/* 10284 */	stmt    | 2983   << off_ ,	//rtn02	bze kvftr rtn05  jump if ftrace is off
/* 10285 */	load    | r1     << dst_ | kvftr  << off_ ,
/* 10286 */	bze     | r1     << dst_ | rtn05  << off_ ,
/* 10287 */	stmt    | 2984   << off_ ,	//	dcv kvftr   else decrement ftrace
/* 10288 */	load    | r1     << dst_ | kvftr  << off_ ,
/* 10289 */	dcv     | r1     << dst_ ,
/* 10290 */	store   | r1     << dst_ | kvftr  << off_ ,
// rtn03:
/* 10291 */	stmt    | 2985   << off_ ,	//rtn03	jsr prtsn   print statement number
/* 10292 */	call    | prtsn  << off_ ,
/* 10293 */	stmt    | 2986   << off_ ,	//	mov xr num01(xs)  load return type
/* 10294 */	load    | xr     << dst_ | xs     << src_ | num01  << off_ ,
/* 10295 */	stmt    | 2987   << off_ ,	//	jsr prtst   print it
/* 10296 */	call    | prtst  << off_ ,
/* 10297 */	stmt    | 2988   << off_ ,	//	mov wa =ch_bl  load blank
/* 10298 */	loadi   | wa     << dst_ | ch_bl  << off_ ,
/* 10299 */	stmt    | 2989   << off_ ,	//	jsr prtch   print it
/* 10300 */	call    | prtch  << off_ ,
/* 10301 */	stmt    | 2990   << off_ ,	//	mov xl 0(xs)  load pfblk ptr
/* 10302 */	load    | xl     << dst_ | xs     << src_ | 0      << off_ ,
/* 10303 */	stmt    | 2991   << off_ ,	//	mov xl pfvbl(xl)  load function vrblk ptr
/* 10304 */	load    | xl     << dst_ | xl     << src_ | pfvbl  << off_ ,
/* 10305 */	stmt    | 2992   << off_ ,	//	mov wa *vrval  set vrblk name offset
/* 10306 */	loadi   | wa     << dst_ | vrval  << off_ ,
/* 10307 */	stmt    | 2993   << off_ ,	//	bne xr =scfrt rtn04 jump if not freturn case
/* 10308 */	loadi   | r2     << dst_ | scfrt  << off_ ,
/* 10309 */	bne     | xr     << dst_ | r2     << src_ | rtn04  << off_ ,
/* 10310 */	stmt    | 2994   << off_ ,	//	jsr prtnm   print name
/* 10311 */	call    | prtnm  << off_ ,
/* 10312 */	stmt    | 2995   << off_ ,	//	jsr prtnl   terminate print line
/* 10313 */	call    | prtnl  << off_ ,
/* 10314 */	stmt    | 2996   << off_ ,	//	brn rtn05   merge
/* 10315 */	brn     | rtn05  << off_ ,
// rtn04:
/* 10316 */	stmt    | 2997   << off_ ,	//rtn04	jsr prtnv   print name = value
/* 10317 */	call    | prtnv  << off_ ,
// rtn05:
/* 10318 */	stmt    | 2998   << off_ ,	//rtn05	mov xr (xs)+  pop pfblk pointer
/* 10319 */	load    | xr     << dst_ | xs     << src_ ,
/* 10320 */	ica     | xs     << dst_ ,
/* 10321 */	stmt    | 2999   << off_ ,	//	mov wa (xs)+  pop return type string
/* 10322 */	load    | wa     << dst_ | xs     << src_ ,
/* 10323 */	ica     | xs     << dst_ ,
// rtn06:
/* 10324 */	stmt    | 3000   << off_ ,	//rtn06	mov kvrtn wa  set rtntype keyword
/* 10325 */	store   | wa     << dst_ | kvrtn  << off_ ,
/* 10326 */	stmt    | 3001   << off_ ,	//	mov xl pfvbl(xr)  load pointer to fn vrblk
/* 10327 */	load    | xl     << dst_ | xr     << src_ | pfvbl  << off_ ,
// rtn07:
/* 10328 */	stmt    | 3002   << off_ ,	//rtn07	mov rtnbp xl  save block pointer
/* 10329 */	store   | xl     << dst_ | rtnbp  << off_ ,
/* 10330 */	stmt    | 3003   << off_ ,	//	mov xl vrval(xl)  load value
/* 10331 */	load    | xl     << dst_ | xl     << src_ | vrval  << off_ ,
/* 10332 */	stmt    | 3004   << off_ ,	//	beq (xl) =b_trt rtn07 loop back if trapped
/* 10333 */	load    | r1     << dst_ | xl     << src_ ,
/* 10334 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 10335 */	beq     | r1     << dst_ | r2     << src_ | rtn07  << off_ ,
/* 10336 */	stmt    | 3005   << off_ ,	//	mov rtnfv xl  else save function result value
/* 10337 */	store   | xl     << dst_ | rtnfv  << off_ ,
/* 10338 */	stmt    | 3006   << off_ ,	//	mov rtnsv (xs)+  save original function value
/* 10339 */	load    | r1     << dst_ | xs     << src_ ,
/* 10340 */	ica     | xs     << dst_ ,
/* 10341 */	store   | r1     << dst_ | rtnsv  << off_ ,
/* 10342 */	stmt    | 3007   << off_ ,	//	mov xl (xs)+  pop saved pointer
/* 10343 */	load    | xl     << dst_ | xs     << src_ ,
/* 10344 */	ica     | xs     << dst_ ,
/* 10345 */	stmt    | 3008   << off_ ,	//	bze xl rtn7c  no action if none
/* 10346 */	bze     | xl     << dst_ | rtn7c  << off_ ,
/* 10347 */	stmt    | 3009   << off_ ,	//	bze kvpfl rtn7c  jump if no profiling
/* 10348 */	load    | r1     << dst_ | kvpfl  << off_ ,
/* 10349 */	bze     | r1     << dst_ | rtn7c  << off_ ,
/* 10350 */	stmt    | 3010   << off_ ,	//	jsr prflu   else profile last func stmt
/* 10351 */	call    | prflu  << off_ ,
/* 10352 */	stmt    | 3011   << off_ ,	//	beq kvpfl =num02 rtn7a branch on value of profile keywd
/* 10353 */	load    | r1     << dst_ | kvpfl  << off_ ,
/* 10354 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 10355 */	beq     | r1     << dst_ | r2     << src_ | rtn7a  << off_ ,
/* 10356 */	stmt    | 3012   << off_ ,	//	ldi pfstm   load current time
/* 10357 */	load    | r1     << dst_ | pfstm  << off_ ,
/* 10358 */	ldi     | r1     << dst_ ,
/* 10359 */	stmt    | 3013   << off_ ,	//	sbi icval(xl)   frig by subtracting saved amount
/* 10360 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/* 10361 */	sbi     | r1     << dst_ ,
/* 10362 */	stmt    | 3014   << off_ ,	//	brn rtn7b   and merge
/* 10363 */	brn     | rtn7b  << off_ ,
// rtn7a:
/* 10364 */	stmt    | 3015   << off_ ,	//rtn7a	ldi icval(xl)   load saved time
/* 10365 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/* 10366 */	ldi     | r1     << dst_ ,
// rtn7b:
/* 10367 */	stmt    | 3016   << off_ ,	//rtn7b	sti pfstm   store back correct start time
/* 10368 */	store   | ia     << dst_ | pfstm  << off_ ,
// rtn7c:
/* 10369 */	stmt    | 3017   << off_ ,	//rtn7c	mov wb fargs(xr)  get number of args
/* 10370 */	load    | wb     << dst_ | xr     << src_ | fargs  << off_ ,
/* 10371 */	stmt    | 3018   << off_ ,	//	add wb pfnlo(xr)  add number of locals
/* 10372 */	load    | r2     << dst_ | xr     << src_ | pfnlo  << off_ ,
/* 10373 */	add     | wb     << dst_ | r2     << src_ ,
/* 10374 */	stmt    | 3019   << off_ ,	//	bze wb rtn10  jump if no args/locals
/* 10375 */	bze     | wb     << dst_ | rtn10  << off_ ,
/* 10376 */	stmt    | 3020   << off_ ,	//	lct wb wb  else set loop counter
/* 10377 */	stmt    | 3021   << off_ ,	//	add xr pflen(xr)  and point to end of pfblk
/* 10378 */	load    | r2     << dst_ | xr     << src_ | pflen  << off_ ,
/* 10379 */	add     | xr     << dst_ | r2     << src_ ,
// rtn08:
/* 10380 */	stmt    | 3022   << off_ ,	//rtn08	mov xl -(xr)  load next vrblk pointer
/* 10381 */	dca     | xr     << dst_ ,
/* 10382 */	load    | xl     << dst_ | xr     << src_ ,
// rtn09:
/* 10383 */	stmt    | 3023   << off_ ,	//rtn09	mov wa xl  save block pointer
/* 10384 */	move    | wa     << dst_ | xl     << src_ ,
/* 10385 */	stmt    | 3024   << off_ ,	//	mov xl vrval(xl)  load pointer to next value
/* 10386 */	load    | xl     << dst_ | xl     << src_ | vrval  << off_ ,
/* 10387 */	stmt    | 3025   << off_ ,	//	beq (xl) =b_trt rtn09 loop back if trapped
/* 10388 */	load    | r1     << dst_ | xl     << src_ ,
/* 10389 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 10390 */	beq     | r1     << dst_ | r2     << src_ | rtn09  << off_ ,
/* 10391 */	stmt    | 3026   << off_ ,	//	mov xl wa  else restore last block pointer
/* 10392 */	move    | xl     << dst_ | wa     << src_ ,
/* 10393 */	stmt    | 3027   << off_ ,	//	mov vrval(xl) (xs)+  restore old variable value
/* 10394 */	load    | r1     << dst_ | xs     << src_ ,
/* 10395 */	ica     | xs     << dst_ ,
/* 10396 */	store   | r1     << dst_ | xl     << src_ | vrval  << off_ ,
/* 10397 */	stmt    | 3028   << off_ ,	//	bct wb rtn08  loop till all processed
/* 10398 */	bct     | wb     << dst_ | rtn08  << off_ ,
// rtn10:
/* 10399 */	stmt    | 3029   << off_ ,	//rtn10	mov xl rtnbp  restore ptr to last function block
/* 10400 */	load    | xl     << dst_ | rtnbp  << off_ ,
/* 10401 */	stmt    | 3030   << off_ ,	//	mov vrval(xl) rtnsv  restore old function value
/* 10402 */	load    | r1     << dst_ | rtnsv  << off_ ,
/* 10403 */	store   | r1     << dst_ | xl     << src_ | vrval  << off_ ,
/* 10404 */	stmt    | 3031   << off_ ,	//	mov xr rtnfv  reload function result
/* 10405 */	load    | xr     << dst_ | rtnfv  << off_ ,
/* 10406 */	stmt    | 3032   << off_ ,	//	mov xl r_cod  point to new code block
/* 10407 */	load    | xl     << dst_ | r_cod  << off_ ,
/* 10408 */	stmt    | 3033   << off_ ,	//	mov kvlst kvstn  set lastno from stno
/* 10409 */	load    | r1     << dst_ | kvstn  << off_ ,
/* 10410 */	store   | r1     << dst_ | kvlst  << off_ ,
/* 10411 */	stmt    | 3034   << off_ ,	//	mov kvstn cdstm(xl)  reset proper stno value
/* 10412 */	load    | r1     << dst_ | xl     << src_ | cdstm  << off_ ,
/* 10413 */	store   | r1     << dst_ | kvstn  << off_ ,
/* 10414 */	stmt    | 3035   << off_ ,	//	mov kvlln kvlin  set lastline from line
/* 10415 */	load    | r1     << dst_ | kvlin  << off_ ,
/* 10416 */	store   | r1     << dst_ | kvlln  << off_ ,
/* 10417 */	stmt    | 3036   << off_ ,	//	mov kvlin cdsln(xl)  reset proper line value
/* 10418 */	load    | r1     << dst_ | xl     << src_ | cdsln  << off_ ,
/* 10419 */	store   | r1     << dst_ | kvlin  << off_ ,
/* 10420 */	stmt    | 3037   << off_ ,	//	mov wa kvrtn  load return type
/* 10421 */	load    | wa     << dst_ | kvrtn  << off_ ,
/* 10422 */	stmt    | 3038   << off_ ,	//	beq wa =scrtn exixr exit with result in xr if return
/* 10423 */	loadi   | r2     << dst_ | scrtn  << off_ ,
/* 10424 */	beq     | wa     << dst_ | r2     << src_ | exixr  << off_ ,
/* 10425 */	stmt    | 3039   << off_ ,	//	beq wa =scfrt exfal fail if freturn
/* 10426 */	loadi   | r2     << dst_ | scfrt  << off_ ,
/* 10427 */	beq     | wa     << dst_ | r2     << src_ | exfal  << off_ ,
/* 10428 */	stmt    | 3040   << off_ ,	//	beq (xr) =b_nml rtn11 jump if is a name
/* 10429 */	load    | r1     << dst_ | xr     << src_ ,
/* 10430 */	loadi   | r2     << dst_ | b_nml  << off_ ,
/* 10431 */	beq     | r1     << dst_ | r2     << src_ | rtn11  << off_ ,
/* 10432 */	stmt    | 3041   << off_ ,	//	jsr gtnvr   else try convert to variable name
/* 10433 */	call    | gtnvr  << off_ ,
/* 10434 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 10435 */	err     | 243    << off_ ,
/* 10436 */	stmt    | 3042   << off_ ,	//	mov xl xr  if ok, copy vrblk (name base) ptr
/* 10437 */	move    | xl     << dst_ | xr     << src_ ,
/* 10438 */	stmt    | 3043   << off_ ,	//	mov wa *vrval  set name offset
/* 10439 */	loadi   | wa     << dst_ | vrval  << off_ ,
/* 10440 */	stmt    | 3044   << off_ ,	//	brn rtn12   and merge
/* 10441 */	brn     | rtn12  << off_ ,
// rtn11:
/* 10442 */	stmt    | 3045   << off_ ,	//rtn11	mov xl nmbas(xr)  load name base
/* 10443 */	load    | xl     << dst_ | xr     << src_ | nmbas  << off_ ,
/* 10444 */	stmt    | 3046   << off_ ,	//	mov wa nmofs(xr)  load name offset
/* 10445 */	load    | wa     << dst_ | xr     << src_ | nmofs  << off_ ,
// rtn12:
/* 10446 */	stmt    | 3047   << off_ ,	//rtn12	mov xr xl  preserve xl
/* 10447 */	move    | xr     << dst_ | xl     << src_ ,
/* 10448 */	stmt    | 3048   << off_ ,	//	lcw wb   load next word
/* 10449 */	lcw     | wb     << dst_ ,
/* 10450 */	stmt    | 3049   << off_ ,	//	mov xl xr  restore xl
/* 10451 */	move    | xl     << dst_ | xr     << src_ ,
/* 10452 */	stmt    | 3050   << off_ ,	//	beq wb =ofne_ exnam exit if called by name
/* 10453 */	loadi   | r2     << dst_ | ofne_  << off_ ,
/* 10454 */	beq     | wb     << dst_ | r2     << src_ | exnam  << off_ ,
/* 10455 */	stmt    | 3051   << off_ ,	//	mov -(xs) wb  else save code word
/* 10456 */	dca     | xs     << dst_ ,
/* 10457 */	store   | wb     << dst_ | xs     << src_ ,
/* 10458 */	stmt    | 3052   << off_ ,	//	jsr acess   get value
/* 10459 */	call    | acess  << off_ ,
/* 10460 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 10461 */	ppm     | exfal  << off_ ,
/* 10462 */	stmt    | 3053   << off_ ,	//	mov xl xr  if ok, copy result
/* 10463 */	move    | xl     << dst_ | xr     << src_ ,
/* 10464 */	stmt    | 3054   << off_ ,	//	mov xr (xs)  reload next code word
/* 10465 */	load    | xr     << dst_ | xs     << src_ ,
/* 10466 */	stmt    | 3055   << off_ ,	//	mov (xs) xl  store result on stack
/* 10467 */	store   | xl     << dst_ | xs     << src_ ,
/* 10468 */	stmt    | 3056   << off_ ,	//	mov xl (xr)  load routine address
/* 10469 */	load    | xl     << dst_ | xr     << src_ ,
/* 10470 */	stmt    | 3057   << off_ ,	//	bri xl   jump to execute next code word
/* 10471 */	bri     | xl     << dst_ ,
// stcov:
/* 10472 */	stmt    | 3058   << off_ ,	//stcov	rtn
/* 10473 */	stmt    | 3059   << off_ ,	//	icv errft   fatal error
/* 10474 */	load    | r1     << dst_ | errft  << off_ ,
/* 10475 */	icv     | r1     << dst_ ,
/* 10476 */	store   | r1     << dst_ | errft  << off_ ,
/* 10477 */	stmt    | 3060   << off_ ,	//	ldi 4,intvt   get 10
/* 10478 */	load    | r1     << dst_ | intvt  << off_ ,
/* 10479 */	ldi     | r1     << dst_ ,
/* 10480 */	stmt    | 3061   << off_ ,	//	adi kvstl   add to former limit
/* 10481 */	load    | r1     << dst_ | kvstl  << off_ ,
/* 10482 */	adi     | r1     << dst_ ,
/* 10483 */	stmt    | 3062   << off_ ,	//	sti kvstl   store as new stlimit
/* 10484 */	store   | ia     << dst_ | kvstl  << off_ ,
/* 10485 */	stmt    | 3063   << off_ ,	//	ldi 4,intvt   get 10
/* 10486 */	load    | r1     << dst_ | intvt  << off_ ,
/* 10487 */	ldi     | r1     << dst_ ,
/* 10488 */	stmt    | 3064   << off_ ,	//	sti kvstc   set as new count
/* 10489 */	store   | ia     << dst_ | kvstc  << off_ ,
/* 10490 */	stmt    | 3065   << off_ ,	//	jsr stgcc   recompute countdown counters
/* 10491 */	call    | stgcc  << off_ ,
/* 10492 */	stmt    | 3066   << off_ ,	//	erb 244 statement count exceeds value of stlimit keyword
/* 10493 */	erb     | 244    << off_ ,
// stmgo:
/* 10494 */	stmt    | 3067   << off_ ,	//stmgo	rtn
/* 10495 */	stmt    | 3068   << off_ ,	//	mov r_cod xr  set new code block pointer
/* 10496 */	store   | xr     << dst_ | r_cod  << off_ ,
/* 10497 */	stmt    | 3069   << off_ ,	//	dcv stmct   see if time to check something
/* 10498 */	load    | r1     << dst_ | stmct  << off_ ,
/* 10499 */	dcv     | r1     << dst_ ,
/* 10500 */	store   | r1     << dst_ | stmct  << off_ ,
/* 10501 */	stmt    | 3070   << off_ ,	//	bze stmct stgo2  jump if so
/* 10502 */	load    | r1     << dst_ | stmct  << off_ ,
/* 10503 */	bze     | r1     << dst_ | stgo2  << off_ ,
/* 10504 */	stmt    | 3071   << off_ ,	//	mov kvlst kvstn  set lastno
/* 10505 */	load    | r1     << dst_ | kvstn  << off_ ,
/* 10506 */	store   | r1     << dst_ | kvlst  << off_ ,
/* 10507 */	stmt    | 3072   << off_ ,	//	mov kvstn cdstm(xr)  set stno
/* 10508 */	load    | r1     << dst_ | xr     << src_ | cdstm  << off_ ,
/* 10509 */	store   | r1     << dst_ | kvstn  << off_ ,
/* 10510 */	stmt    | 3073   << off_ ,	//	mov kvlln kvlin  set lastline
/* 10511 */	load    | r1     << dst_ | kvlin  << off_ ,
/* 10512 */	store   | r1     << dst_ | kvlln  << off_ ,
/* 10513 */	stmt    | 3074   << off_ ,	//	mov kvlin cdsln(xr)  set line
/* 10514 */	load    | r1     << dst_ | xr     << src_ | cdsln  << off_ ,
/* 10515 */	store   | r1     << dst_ | kvlin  << off_ ,
/* 10516 */	stmt    | 3075   << off_ ,	//	add xr *cdcod  point to first code word
/* 10517 */	loadi   | r2     << dst_ | cdcod  << off_ ,
/* 10518 */	add     | xr     << dst_ | r2     << src_ ,
/* 10519 */	stmt    | 3076   << off_ ,	//	lcp xr   set code pointer
/* 10520 */	lcp     | xr     << dst_ ,
// stgo1:
/* 10521 */	stmt    | 3077   << off_ ,	//stgo1	lcw xr   load next code word
/* 10522 */	lcw     | xr     << dst_ ,
/* 10523 */	stmt    | 3078   << off_ ,	//	zer xl   clear garbage xl
/* 10524 */	move    | xl     << dst_ ,
/* 10525 */	stmt    | 3079   << off_ ,	//	bri (xr)   execute it
/* 10526 */	load    | r1     << dst_ | xr     << src_ ,
/* 10527 */	bri     | r1     << dst_ ,
// stgo2:
/* 10528 */	stmt    | 3080   << off_ ,	//stgo2	bze kvpfl stgo3  skip if no profiling
/* 10529 */	load    | r1     << dst_ | kvpfl  << off_ ,
/* 10530 */	bze     | r1     << dst_ | stgo3  << off_ ,
/* 10531 */	stmt    | 3081   << off_ ,	//	jsr prflu   else profile the statement in kvstn
/* 10532 */	call    | prflu  << off_ ,
// stgo3:
/* 10533 */	stmt    | 3082   << off_ ,	//stgo3	mov kvlst kvstn  set lastno
/* 10534 */	load    | r1     << dst_ | kvstn  << off_ ,
/* 10535 */	store   | r1     << dst_ | kvlst  << off_ ,
/* 10536 */	stmt    | 3083   << off_ ,	//	mov kvstn cdstm(xr)  set stno
/* 10537 */	load    | r1     << dst_ | xr     << src_ | cdstm  << off_ ,
/* 10538 */	store   | r1     << dst_ | kvstn  << off_ ,
/* 10539 */	stmt    | 3084   << off_ ,	//	mov kvlln kvlin  set lastline
/* 10540 */	load    | r1     << dst_ | kvlin  << off_ ,
/* 10541 */	store   | r1     << dst_ | kvlln  << off_ ,
/* 10542 */	stmt    | 3085   << off_ ,	//	mov kvlin cdsln(xr)  set line
/* 10543 */	load    | r1     << dst_ | xr     << src_ | cdsln  << off_ ,
/* 10544 */	store   | r1     << dst_ | kvlin  << off_ ,
/* 10545 */	stmt    | 3086   << off_ ,	//	add xr *cdcod  point to first code word
/* 10546 */	loadi   | r2     << dst_ | cdcod  << off_ ,
/* 10547 */	add     | xr     << dst_ | r2     << src_ ,
/* 10548 */	stmt    | 3087   << off_ ,	//	lcp xr   set code pointer
/* 10549 */	lcp     | xr     << dst_ ,
/* 10550 */	stmt    | 3088   << off_ ,	//	mov -(xs) stmcs  save present count start on stack
/* 10551 */	load    | r1     << dst_ | stmcs  << off_ ,
/* 10552 */	dca     | xs     << dst_ ,
/* 10553 */	store   | r1     << dst_ | xs     << src_ ,
/* 10554 */	stmt    | 3089   << off_ ,	//	dcv polct   poll interval within stmct
/* 10555 */	load    | r1     << dst_ | polct  << off_ ,
/* 10556 */	dcv     | r1     << dst_ ,
/* 10557 */	store   | r1     << dst_ | polct  << off_ ,
/* 10558 */	stmt    | 3090   << off_ ,	//	bnz polct stgo4  jump if not poll time yet
/* 10559 */	load    | r1     << dst_ | polct  << off_ ,
/* 10560 */	bnz     | r1     << dst_ | stgo4  << off_ ,
/* 10561 */	stmt    | 3091   << off_ ,	//	zer wa   =0 for poll
/* 10562 */	move    | wa     << dst_ ,
/* 10563 */	stmt    | 3092   << off_ ,	//	mov wb kvstn  statement number
/* 10564 */	load    | wb     << dst_ | kvstn  << off_ ,
/* 10565 */	stmt    | 3093   << off_ ,	//	mov xl xr  make collectable
/* 10566 */	move    | xl     << dst_ | xr     << src_ ,
/* 10567 */	stmt    | 3094   << off_ ,	//	jsr syspl   allow interactive access
/* 10568 */	sys     | syspl_ << off_ ,
/* 10569 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/* 10570 */	err     | 320    << off_ ,
/* 10571 */	ppm     ,
/* 10572 */	ppm     ,
/* 10573 */	stmt    | 3095   << off_ ,	//	mov xr xl  restore code block pointer
/* 10574 */	move    | xr     << dst_ | xl     << src_ ,
/* 10575 */	stmt    | 3096   << off_ ,	//	mov polcs wa  poll interval start value
/* 10576 */	store   | wa     << dst_ | polcs  << off_ ,
/* 10577 */	stmt    | 3097   << off_ ,	//	jsr stgcc   recompute counter values
/* 10578 */	call    | stgcc  << off_ ,
// stgo4:
/* 10579 */	stmt    | 3098   << off_ ,	//stgo4	ldi kvstc   get stmt count
/* 10580 */	load    | r1     << dst_ | kvstc  << off_ ,
/* 10581 */	ldi     | r1     << dst_ ,
/* 10582 */	stmt    | 3099   << off_ ,	//	ilt stgo5   omit counting if negative
/* 10583 */	ilt     | stgo5  << off_ ,
/* 10584 */	stmt    | 3100   << off_ ,	//	mti (xs)+   reload start value of counter
/* 10585 */	load    | ia     << dst_ | xs     << src_ ,
/* 10586 */	ica     | xs     << dst_ ,
/* 10587 */	stmt    | 3101   << off_ ,	//	ngi    negate
/* 10588 */	ngi     ,
/* 10589 */	stmt    | 3102   << off_ ,	//	adi kvstc   stmt count minus counter
/* 10590 */	load    | r1     << dst_ | kvstc  << off_ ,
/* 10591 */	adi     | r1     << dst_ ,
/* 10592 */	stmt    | 3103   << off_ ,	//	sti kvstc   replace it
/* 10593 */	store   | ia     << dst_ | kvstc  << off_ ,
/* 10594 */	stmt    | 3104   << off_ ,	//	ile stcov   fail if stlimit reached
/* 10595 */	ile     | stcov  << off_ ,
/* 10596 */	stmt    | 3105   << off_ ,	//	bze r_stc stgo5  jump if no statement trace
/* 10597 */	load    | r1     << dst_ | r_stc  << off_ ,
/* 10598 */	bze     | r1     << dst_ | stgo5  << off_ ,
/* 10599 */	stmt    | 3106   << off_ ,	//	zer xr   clear garbage value in xr
/* 10600 */	move    | xr     << dst_ ,
/* 10601 */	stmt    | 3107   << off_ ,	//	mov xl r_stc  load pointer to stcount trblk
/* 10602 */	load    | xl     << dst_ | r_stc  << off_ ,
/* 10603 */	stmt    | 3108   << off_ ,	//	jsr ktrex   execute keyword trace
/* 10604 */	call    | ktrex  << off_ ,
// stgo5:
/* 10605 */	stmt    | 3109   << off_ ,	//stgo5	mov stmct stmcs  reset counter
/* 10606 */	load    | r1     << dst_ | stmcs  << off_ ,
/* 10607 */	store   | r1     << dst_ | stmct  << off_ ,
/* 10608 */	stmt    | 3110   << off_ ,	//	brn stgo1   fetch next code word
/* 10609 */	brn     | stgo1  << off_ ,
// stopr:
/* 10610 */	stmt    | 3111   << off_ ,	//stopr	rtn
/* 10611 */	stmt    | 3112   << off_ ,	//	bze xr stpra  skip if sysax already called
/* 10612 */	bze     | xr     << dst_ | stpra  << off_ ,
/* 10613 */	stmt    | 3113   << off_ ,	//	jsr sysax   call after execution proc
/* 10614 */	sys     | sysax_ << off_ ,
// stpra:
/* 10615 */	stmt    | 3114   << off_ ,	//stpra	add dname rsmem  use the reserve memory
/* 10616 */	load    | r1     << dst_ | dname  << off_ ,
/* 10617 */	load    | r2     << dst_ | rsmem  << off_ ,
/* 10618 */	add     | r1     << dst_ | r2     << src_ ,
/* 10619 */	store   | r1     << dst_ | dname  << off_ ,
/* 10620 */	stmt    | 3115   << off_ ,	//	bne xr =endms stpr0 skip if not normal end message
/* 10621 */	loadi   | r2     << dst_ | endms  << off_ ,
/* 10622 */	bne     | xr     << dst_ | r2     << src_ | stpr0  << off_ ,
/* 10623 */	stmt    | 3116   << off_ ,	//	bnz exsts stpr3  skip if exec stats suppressed
/* 10624 */	load    | r1     << dst_ | exsts  << off_ ,
/* 10625 */	bnz     | r1     << dst_ | stpr3  << off_ ,
/* 10626 */	stmt    | 3117   << off_ ,	//	zer erich   clear errors to int.ch. flag
/* 10627 */	store   | r0     << dst_ | erich  << off_ ,
// stpr0:
/* 10628 */	stmt    | 3118   << off_ ,	//stpr0	jsr prtpg   eject printer
/* 10629 */	call    | prtpg  << off_ ,
/* 10630 */	stmt    | 3119   << off_ ,	//	bze xr stpr1  skip if no message
/* 10631 */	bze     | xr     << dst_ | stpr1  << off_ ,
/* 10632 */	stmt    | 3120   << off_ ,	//	jsr prtst   print message
/* 10633 */	call    | prtst  << off_ ,
// stpr1:
/* 10634 */	stmt    | 3121   << off_ ,	//stpr1	jsr prtis   print blank line
/* 10635 */	call    | prtis  << off_ ,
/* 10636 */	stmt    | 3122   << off_ ,	//	bnz gbcfl stpr5  if in garbage collection, skip
/* 10637 */	load    | r1     << dst_ | gbcfl  << off_ ,
/* 10638 */	bnz     | r1     << dst_ | stpr5  << off_ ,
/* 10639 */	stmt    | 3123   << off_ ,	//	mov xr =stpm6  point to message /in file xxx/
/* 10640 */	loadi   | xr     << dst_ | stpm6  << off_ ,
/* 10641 */	stmt    | 3124   << off_ ,	//	jsr prtst   print it
/* 10642 */	call    | prtst  << off_ ,
/* 10643 */	stmt    | 3125   << off_ ,	//	mov profs =prtmf  set column offset
/* 10644 */	loadi   | r1     << dst_ | prtmf  << off_ ,
/* 10645 */	store   | r1     << dst_ | profs  << off_ ,
/* 10646 */	stmt    | 3126   << off_ ,	//	mov wc kvstn  get statement number
/* 10647 */	load    | wc     << dst_ | kvstn  << off_ ,
/* 10648 */	stmt    | 3127   << off_ ,	//	jsr filnm   get file name
/* 10649 */	call    | filnm  << off_ ,
/* 10650 */	stmt    | 3128   << off_ ,	//	mov xr xl  prepare to print
/* 10651 */	move    | xr     << dst_ | xl     << src_ ,
/* 10652 */	stmt    | 3129   << off_ ,	//	jsr prtst   print file name
/* 10653 */	call    | prtst  << off_ ,
/* 10654 */	stmt    | 3130   << off_ ,	//	jsr prtis   print to interactive channel
/* 10655 */	call    | prtis  << off_ ,
/* 10656 */	stmt    | 3131   << off_ ,	//	mov xr r_cod  get code pointer
/* 10657 */	load    | xr     << dst_ | r_cod  << off_ ,
/* 10658 */	stmt    | 3132   << off_ ,	//	mti cdsln(xr)   get source line number
/* 10659 */	load    | ia     << dst_ | xr     << src_ | cdsln  << off_ ,
/* 10660 */	stmt    | 3133   << off_ ,	//	mov xr =stpm4  point to message /in line xxx/
/* 10661 */	loadi   | xr     << dst_ | stpm4  << off_ ,
/* 10662 */	stmt    | 3134   << off_ ,	//	jsr prtmx   print it
/* 10663 */	call    | prtmx  << off_ ,
// stpr5:
/* 10664 */	stmt    | 3135   << off_ ,	//stpr5	mti kvstn   get statement number
/* 10665 */	load    | ia     << dst_ | kvstn  << off_ ,
/* 10666 */	stmt    | 3136   << off_ ,	//	mov xr =stpm1  point to message /in statement xxx/
/* 10667 */	loadi   | xr     << dst_ | stpm1  << off_ ,
/* 10668 */	stmt    | 3137   << off_ ,	//	jsr prtmx   print it
/* 10669 */	call    | prtmx  << off_ ,
/* 10670 */	stmt    | 3138   << off_ ,	//	ldi kvstl   get statement limit
/* 10671 */	load    | r1     << dst_ | kvstl  << off_ ,
/* 10672 */	ldi     | r1     << dst_ ,
/* 10673 */	stmt    | 3139   << off_ ,	//	ilt stpr2   skip if negative
/* 10674 */	ilt     | stpr2  << off_ ,
/* 10675 */	stmt    | 3140   << off_ ,	//	sbi kvstc   minus counter = course count
/* 10676 */	load    | r1     << dst_ | kvstc  << off_ ,
/* 10677 */	sbi     | r1     << dst_ ,
/* 10678 */	stmt    | 3141   << off_ ,	//	sti stpsi   save
/* 10679 */	store   | ia     << dst_ | stpsi  << off_ ,
/* 10680 */	stmt    | 3142   << off_ ,	//	mov wa stmcs  refine with counter start value
/* 10681 */	load    | wa     << dst_ | stmcs  << off_ ,
/* 10682 */	stmt    | 3143   << off_ ,	//	sub wa stmct  minus current counter
/* 10683 */	load    | r2     << dst_ | stmct  << off_ ,
/* 10684 */	sub     | wa     << dst_ | r2     << src_ ,
/* 10685 */	stmt    | 3144   << off_ ,	//	mti wa   convert to integer
/* 10686 */	move    | ia     << dst_ | wa     << src_ ,
/* 10687 */	stmt    | 3145   << off_ ,	//	adi stpsi   add in course count
/* 10688 */	load    | r1     << dst_ | stpsi  << off_ ,
/* 10689 */	adi     | r1     << dst_ ,
/* 10690 */	stmt    | 3146   << off_ ,	//	sti stpsi   save
/* 10691 */	store   | ia     << dst_ | stpsi  << off_ ,
/* 10692 */	stmt    | 3147   << off_ ,	//	mov xr =stpm2  point to message /stmts executed/
/* 10693 */	loadi   | xr     << dst_ | stpm2  << off_ ,
/* 10694 */	stmt    | 3148   << off_ ,	//	jsr prtmx   print it
/* 10695 */	call    | prtmx  << off_ ,
/* 10696 */	stmt    | 3149   << off_ ,	//	jsr systm   get current time
/* 10697 */	sys     | systm_ << off_ ,
/* 10698 */	stmt    | 3150   << off_ ,	//	sbi timsx   minus start time = elapsed exec tim in nanosec
/* 10699 */	load    | r1     << dst_ | timsx  << off_ ,
/* 10700 */	sbi     | r1     << dst_ ,
/* 10701 */	stmt    | 3151   << off_ ,	//	sti stpti   save for later
/* 10702 */	store   | ia     << dst_ | stpti  << off_ ,
/* 10703 */	stmt    | 3152   << off_ ,	//	dvi 4,intth   divide by 1000 to convert to microseconds
/* 10704 */	load    | r1     << dst_ | intth  << off_ ,
/* 10705 */	dvi     | r1     << dst_ ,
/* 10706 */	stmt    | 3153   << off_ ,	//	iov stpr2   jump if we cannot compute
/* 10707 */	iov     | stpr2  << off_ ,
/* 10708 */	stmt    | 3154   << off_ ,	//	dvi 4,intth   divide by 1000 to convert to milliseconds
/* 10709 */	load    | r1     << dst_ | intth  << off_ ,
/* 10710 */	dvi     | r1     << dst_ ,
/* 10711 */	stmt    | 3155   << off_ ,	//	iov stpr2   jump if we cannot compute
/* 10712 */	iov     | stpr2  << off_ ,
/* 10713 */	stmt    | 3156   << off_ ,	//	sti stpti   save elapsed time in milliseconds
/* 10714 */	store   | ia     << dst_ | stpti  << off_ ,
/* 10715 */	stmt    | 3157   << off_ ,	//	mov xr =stpm3  point to msg /execution time msec /
/* 10716 */	loadi   | xr     << dst_ | stpm3  << off_ ,
/* 10717 */	stmt    | 3158   << off_ ,	//	jsr prtmx   print it
/* 10718 */	call    | prtmx  << off_ ,
/* 10719 */	stmt    | 3159   << off_ ,	//	ldi stpti   reload execution time in milliseconds
/* 10720 */	load    | r1     << dst_ | stpti  << off_ ,
/* 10721 */	ldi     | r1     << dst_ ,
/* 10722 */	stmt    | 3160   << off_ ,	//	ile stpr2   jump if exection time less than a millisecond
/* 10723 */	ile     | stpr2  << off_ ,
/* 10724 */	stmt    | 3161   << off_ ,	//	ldi stpsi   load statement count
/* 10725 */	load    | r1     << dst_ | stpsi  << off_ ,
/* 10726 */	ldi     | r1     << dst_ ,
/* 10727 */	stmt    | 3162   << off_ ,	//	dvi stpti   divide to get stmts per millisecond
/* 10728 */	load    | r1     << dst_ | stpti  << off_ ,
/* 10729 */	dvi     | r1     << dst_ ,
/* 10730 */	stmt    | 3163   << off_ ,	//	iov stpr2   jump if we cannot compute
/* 10731 */	iov     | stpr2  << off_ ,
/* 10732 */	stmt    | 3164   << off_ ,	//	dvi 4,intth   divide to get stmts per microsecond
/* 10733 */	load    | r1     << dst_ | intth  << off_ ,
/* 10734 */	dvi     | r1     << dst_ ,
/* 10735 */	stmt    | 3165   << off_ ,	//	iov stpr2   jump if we cannot compute
/* 10736 */	iov     | stpr2  << off_ ,
/* 10737 */	stmt    | 3166   << off_ ,	//	mov xr =stpm7  point to msg (stmt / microsec)
/* 10738 */	loadi   | xr     << dst_ | stpm7  << off_ ,
/* 10739 */	stmt    | 3167   << off_ ,	//	jsr prtmx   print it
/* 10740 */	call    | prtmx  << off_ ,
/* 10741 */	stmt    | 3168   << off_ ,	//	ldi stpsi   reload statement count
/* 10742 */	load    | r1     << dst_ | stpsi  << off_ ,
/* 10743 */	ldi     | r1     << dst_ ,
/* 10744 */	stmt    | 3169   << off_ ,	//	dvi stpti   divide to get stmts per millisecond
/* 10745 */	load    | r1     << dst_ | stpti  << off_ ,
/* 10746 */	dvi     | r1     << dst_ ,
/* 10747 */	stmt    | 3170   << off_ ,	//	iov stpr2   jump if we cannot compute
/* 10748 */	iov     | stpr2  << off_ ,
/* 10749 */	stmt    | 3171   << off_ ,	//	mov xr =stpm8  point to msg (stmt / millisec )
/* 10750 */	loadi   | xr     << dst_ | stpm8  << off_ ,
/* 10751 */	stmt    | 3172   << off_ ,	//	jsr prtmx   print it
/* 10752 */	call    | prtmx  << off_ ,
/* 10753 */	stmt    | 3173   << off_ ,	//	ldi stpsi   reload statement count
/* 10754 */	load    | r1     << dst_ | stpsi  << off_ ,
/* 10755 */	ldi     | r1     << dst_ ,
/* 10756 */	stmt    | 3174   << off_ ,	//	dvi stpti   divide to get stmts per millisecond
/* 10757 */	load    | r1     << dst_ | stpti  << off_ ,
/* 10758 */	dvi     | r1     << dst_ ,
/* 10759 */	stmt    | 3175   << off_ ,	//	iov stpr2   jump if we cannot compute
/* 10760 */	iov     | stpr2  << off_ ,
/* 10761 */	stmt    | 3176   << off_ ,	//	mli 4,intth   multiply by 1000 to get stmts per microsecond
/* 10762 */	load    | r1     << dst_ | intth  << off_ ,
/* 10763 */	mli     | r1     << dst_ ,
/* 10764 */	stmt    | 3177   << off_ ,	//	iov stpr2   jump if overflow
/* 10765 */	iov     | stpr2  << off_ ,
/* 10766 */	stmt    | 3178   << off_ ,	//	mov xr =stpm9  point to msg ( stmt / second )
/* 10767 */	loadi   | xr     << dst_ | stpm9  << off_ ,
/* 10768 */	stmt    | 3179   << off_ ,	//	jsr prtmx   print it
/* 10769 */	call    | prtmx  << off_ ,
// stpr2:
/* 10770 */	stmt    | 3180   << off_ ,	//stpr2	mti gbcnt   load count of collections
/* 10771 */	load    | ia     << dst_ | gbcnt  << off_ ,
/* 10772 */	stmt    | 3181   << off_ ,	//	mov xr =stpm4  point to message /regenerations /
/* 10773 */	loadi   | xr     << dst_ | stpm4  << off_ ,
/* 10774 */	stmt    | 3182   << off_ ,	//	jsr prtmx   print it
/* 10775 */	call    | prtmx  << off_ ,
/* 10776 */	stmt    | 3183   << off_ ,	//	jsr prtmm   print memory usage
/* 10777 */	call    | prtmm  << off_ ,
/* 10778 */	stmt    | 3184   << off_ ,	//	jsr prtis   one more blank for luck
/* 10779 */	call    | prtis  << off_ ,
// stpr3:
/* 10780 */	stmt    | 3185   << off_ ,	//stpr3	jsr prflr   print profile if wanted
/* 10781 */	call    | prflr  << off_ ,
/* 10782 */	stmt    | 3186   << off_ ,	//	mov xr kvdmp  load dump keyword
/* 10783 */	load    | xr     << dst_ | kvdmp  << off_ ,
/* 10784 */	stmt    | 3187   << off_ ,	//	jsr dumpr   execute dump if requested
/* 10785 */	call    | dumpr  << off_ ,
/* 10786 */	stmt    | 3188   << off_ ,	//	mov xl r_fcb  get fcblk chain head
/* 10787 */	load    | xl     << dst_ | r_fcb  << off_ ,
/* 10788 */	stmt    | 3189   << off_ ,	//	mov wa kvabe  load abend value
/* 10789 */	load    | wa     << dst_ | kvabe  << off_ ,
/* 10790 */	stmt    | 3190   << off_ ,	//	mov wb kvcod  load code value
/* 10791 */	load    | wb     << dst_ | kvcod  << off_ ,
/* 10792 */	stmt    | 3191   << off_ ,	//	jsr sysej   exit to system
/* 10793 */	sys     | sysej_ << off_ ,
// stpr4:
/* 10794 */	stmt    | 3192   << off_ ,	//stpr4	rtn
/* 10795 */	stmt    | 3193   << off_ ,	//	add dname rsmem  use the reserve memory
/* 10796 */	load    | r1     << dst_ | dname  << off_ ,
/* 10797 */	load    | r2     << dst_ | rsmem  << off_ ,
/* 10798 */	add     | r1     << dst_ | r2     << src_ ,
/* 10799 */	store   | r1     << dst_ | dname  << off_ ,
/* 10800 */	stmt    | 3194   << off_ ,	//	bze exsts stpr1  if execution stats requested
/* 10801 */	load    | r1     << dst_ | exsts  << off_ ,
/* 10802 */	bze     | r1     << dst_ | stpr1  << off_ ,
/* 10803 */	stmt    | 3195   << off_ ,	//	brn stpr3   check if dump or profile needed
/* 10804 */	brn     | stpr3  << off_ ,
// succp:
/* 10805 */	stmt    | 3196   << off_ ,	//succp	rtn
/* 10806 */	stmt    | 3197   << off_ ,	//	mov xr pthen(xr)  load successor node
/* 10807 */	load    | xr     << dst_ | xr     << src_ | pthen  << off_ ,
/* 10808 */	stmt    | 3198   << off_ ,	//	mov xl (xr)  load node code entry address
/* 10809 */	load    | xl     << dst_ | xr     << src_ ,
/* 10810 */	stmt    | 3199   << off_ ,	//	bri xl   jump to match successor node
/* 10811 */	bri     | xl     << dst_ ,
// sysab:
/* 10812 */	stmt    | 3200   << off_ ,	//sysab	rtn
/* 10813 */	stmt    | 3201   << off_ ,	//	mov xr =endab  point to message
/* 10814 */	loadi   | xr     << dst_ | endab  << off_ ,
/* 10815 */	stmt    | 3202   << off_ ,	//	mov kvabe =num01  set abend flag
/* 10816 */	loadi   | r1     << dst_ | num01  << off_ ,
/* 10817 */	store   | r1     << dst_ | kvabe  << off_ ,
/* 10818 */	stmt    | 3203   << off_ ,	//	jsr prtnl   skip to new line
/* 10819 */	call    | prtnl  << off_ ,
/* 10820 */	stmt    | 3204   << off_ ,	//	brn stopr   jump to pack up
/* 10821 */	brn     | stopr  << off_ ,
// systu:
/* 10822 */	stmt    | 3205   << off_ ,	//systu	rtn
/* 10823 */	stmt    | 3206   << off_ ,	//	mov xr =endtu  point to message
/* 10824 */	loadi   | xr     << dst_ | endtu  << off_ ,
/* 10825 */	stmt    | 3207   << off_ ,	//	mov wa 4,strtu  get chars /tu/
/* 10826 */	load    | wa     << dst_ | strtu  << off_ ,
/* 10827 */	stmt    | 3208   << off_ ,	//	mov kvcod wa  put in kvcod
/* 10828 */	store   | wa     << dst_ | kvcod  << off_ ,
/* 10829 */	stmt    | 3209   << off_ ,	//	mov wa timup  check state of timeup switch
/* 10830 */	load    | wa     << dst_ | timup  << off_ ,
/* 10831 */	stmt    | 3210   << off_ ,	//	mnz timup   set switch
/* 10832 */	store   | xs     << dst_ | timup  << off_ ,
/* 10833 */	stmt    | 3211   << off_ ,	//	bnz wa stopr  stop run if already set
/* 10834 */	bnz     | wa     << dst_ | stopr  << off_ ,
/* 10835 */	stmt    | 3212   << off_ ,	//	erb 245 translation/execution time expired
/* 10836 */	erb     | 245    << off_ ,
// acess:
/* 10837 */	stmt    | 3213   << off_ ,	//acess	prc r 1  entry point (recursive)
/* 10838 */	stmt    | 3214   << off_ ,	//	mov xr xl  copy name base
/* 10839 */	move    | xr     << dst_ | xl     << src_ ,
/* 10840 */	stmt    | 3215   << off_ ,	//	add xr wa  point to variable location
/* 10841 */	add     | xr     << dst_ | wa     << src_ ,
/* 10842 */	stmt    | 3216   << off_ ,	//	mov xr (xr)  load variable value
/* 10843 */	load    | xr     << dst_ | xr     << src_ ,
// acs02:
/* 10844 */	stmt    | 3217   << off_ ,	//acs02	bne (xr) =b_trt acs18 jump if not trapped
/* 10845 */	load    | r1     << dst_ | xr     << src_ ,
/* 10846 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 10847 */	bne     | r1     << dst_ | r2     << src_ | acs18  << off_ ,
/* 10848 */	stmt    | 3218   << off_ ,	//	beq xr =trbkv acs12 jump if keyword variable
/* 10849 */	loadi   | r2     << dst_ | trbkv  << off_ ,
/* 10850 */	beq     | xr     << dst_ | r2     << src_ | acs12  << off_ ,
/* 10851 */	stmt    | 3219   << off_ ,	//	bne xr =trbev acs05 jump if not expression variable
/* 10852 */	loadi   | r2     << dst_ | trbev  << off_ ,
/* 10853 */	bne     | xr     << dst_ | r2     << src_ | acs05  << off_ ,
/* 10854 */	stmt    | 3220   << off_ ,	//	mov xr evexp(xl)  load expression pointer
/* 10855 */	load    | xr     << dst_ | xl     << src_ | evexp  << off_ ,
/* 10856 */	stmt    | 3221   << off_ ,	//	zer wb   evaluate by value
/* 10857 */	move    | wb     << dst_ ,
/* 10858 */	stmt    | 3222   << off_ ,	//	jsr evalx   evaluate expression
/* 10859 */	call    | evalx  << off_ ,
/* 10860 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 10861 */	ppm     | acs04  << off_ ,
/* 10862 */	stmt    | 3223   << off_ ,	//	brn acs02   check value for more trblks
/* 10863 */	brn     | acs02  << off_ ,
// acs03:
/* 10864 */	stmt    | 3224   << off_ ,	//acs03	add xs *num03  pop trblk ptr, name base and offset
/* 10865 */	loadi   | r2     << dst_ | num03  << off_ ,
/* 10866 */	add     | xs     << dst_ | r2     << src_ ,
/* 10867 */	stmt    | 3225   << off_ ,	//	mov dnamp xr  pop unused scblk
/* 10868 */	store   | xr     << dst_ | dnamp  << off_ ,
// acs04:
/* 10869 */	stmt    | 3226   << off_ ,	//acs04	exi 1   take alternate (failure) return
/* 10870 */	exi     | 1      << off_ ,
// acs05:
/* 10871 */	stmt    | 3227   << off_ ,	//acs05	mov wb trtyp(xr)  load trap type code
/* 10872 */	load    | wb     << dst_ | xr     << src_ | trtyp  << off_ ,
/* 10873 */	stmt    | 3228   << off_ ,	//	bnz wb acs10  jump if not input association
/* 10874 */	bnz     | wb     << dst_ | acs10  << off_ ,
/* 10875 */	stmt    | 3229   << off_ ,	//	bze kvinp acs09  ignore input assoc if input is off
/* 10876 */	load    | r1     << dst_ | kvinp  << off_ ,
/* 10877 */	bze     | r1     << dst_ | acs09  << off_ ,
/* 10878 */	stmt    | 3230   << off_ ,	//	mov -(xs) xl  stack name base
/* 10879 */	dca     | xs     << dst_ ,
/* 10880 */	store   | xl     << dst_ | xs     << src_ ,
/* 10881 */	stmt    | 3231   << off_ ,	//	mov -(xs) wa  stack name offset
/* 10882 */	dca     | xs     << dst_ ,
/* 10883 */	store   | wa     << dst_ | xs     << src_ ,
/* 10884 */	stmt    | 3232   << off_ ,	//	mov -(xs) xr  stack trblk pointer
/* 10885 */	dca     | xs     << dst_ ,
/* 10886 */	store   | xr     << dst_ | xs     << src_ ,
/* 10887 */	stmt    | 3233   << off_ ,	//	mov actrm kvtrm  temp to hold trim keyword
/* 10888 */	load    | r1     << dst_ | kvtrm  << off_ ,
/* 10889 */	store   | r1     << dst_ | actrm  << off_ ,
/* 10890 */	stmt    | 3234   << off_ ,	//	mov xl trfpt(xr)  get file ctrl blk ptr or zero
/* 10891 */	load    | xl     << dst_ | xr     << src_ | trfpt  << off_ ,
/* 10892 */	stmt    | 3235   << off_ ,	//	bnz xl acs06  jump if not standard input file
/* 10893 */	bnz     | xl     << dst_ | acs06  << off_ ,
/* 10894 */	stmt    | 3236   << off_ ,	//	beq trter(xr) =v_ter acs21 jump if terminal
/* 10895 */	load    | r1     << dst_ | xr     << src_ | trter  << off_ ,
/* 10896 */	loadi   | r2     << dst_ | v_ter  << off_ ,
/* 10897 */	beq     | r1     << dst_ | r2     << src_ | acs21  << off_ ,
/* 10898 */	stmt    | 3237   << off_ ,	//	mov wa cswin  length for read buffer
/* 10899 */	load    | wa     << dst_ | cswin  << off_ ,
/* 10900 */	stmt    | 3238   << off_ ,	//	jsr alocs   build string of appropriate length
/* 10901 */	call    | alocs  << off_ ,
/* 10902 */	stmt    | 3239   << off_ ,	//	jsr sysrd   read next standard input image
/* 10903 */	sys     | sysrd_ << off_ ,
/* 10904 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 10905 */	ppm     | acs03  << off_ ,
/* 10906 */	stmt    | 3240   << off_ ,	//	brn acs07   else merge with other file case
/* 10907 */	brn     | acs07  << off_ ,
// acs06:
/* 10908 */	stmt    | 3241   << off_ ,	//acs06	mov wa xl  fcblk ptr
/* 10909 */	move    | wa     << dst_ | xl     << src_ ,
/* 10910 */	stmt    | 3242   << off_ ,	//	jsr sysil   get input record max length (to wa)
/* 10911 */	sys     | sysil_ << off_ ,
/* 10912 */	stmt    | 3243   << off_ ,	//	bnz wc acs6a  jump if not binary file
/* 10913 */	bnz     | wc     << dst_ | acs6a  << off_ ,
/* 10914 */	stmt    | 3244   << off_ ,	//	mov actrm wc  disable trim for binary file
/* 10915 */	store   | wc     << dst_ | actrm  << off_ ,
// acs6a:
/* 10916 */	stmt    | 3245   << off_ ,	//acs6a	jsr alocs   allocate string of correct size
/* 10917 */	call    | alocs  << off_ ,
/* 10918 */	stmt    | 3246   << off_ ,	//	mov wa xl  fcblk ptr
/* 10919 */	move    | wa     << dst_ | xl     << src_ ,
/* 10920 */	stmt    | 3247   << off_ ,	//	jsr sysin   call system input routine
/* 10921 */	sys     | sysin_ << off_ ,
/* 10922 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/* 10923 */	ppm     | acs03  << off_ ,
/* 10924 */	ppm     | acs22  << off_ ,
/* 10925 */	ppm     | acs23  << off_ ,
// acs07:
/* 10926 */	stmt    | 3248   << off_ ,	//acs07	mov wb actrm  load trim indicator
/* 10927 */	load    | wb     << dst_ | actrm  << off_ ,
/* 10928 */	stmt    | 3249   << off_ ,	//	jsr trimr   trim record as required
/* 10929 */	call    | trimr  << off_ ,
/* 10930 */	stmt    | 3250   << off_ ,	//	mov wb xr  copy result pointer
/* 10931 */	move    | wb     << dst_ | xr     << src_ ,
/* 10932 */	stmt    | 3251   << off_ ,	//	mov xr (xs)  reload pointer to trblk
/* 10933 */	load    | xr     << dst_ | xs     << src_ ,
// acs08:
/* 10934 */	stmt    | 3252   << off_ ,	//acs08	mov xl xr  save pointer to this trblk
/* 10935 */	move    | xl     << dst_ | xr     << src_ ,
/* 10936 */	stmt    | 3253   << off_ ,	//	mov xr trnxt(xr)  load forward pointer
/* 10937 */	load    | xr     << dst_ | xr     << src_ | trnxt  << off_ ,
/* 10938 */	stmt    | 3254   << off_ ,	//	beq (xr) =b_trt acs08 loop if this is another trblk
/* 10939 */	load    | r1     << dst_ | xr     << src_ ,
/* 10940 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 10941 */	beq     | r1     << dst_ | r2     << src_ | acs08  << off_ ,
/* 10942 */	stmt    | 3255   << off_ ,	//	mov trnxt(xl) wb  else store result at end of chain
/* 10943 */	store   | wb     << dst_ | xl     << src_ | trnxt  << off_ ,
/* 10944 */	stmt    | 3256   << off_ ,	//	mov xr (xs)+  restore initial trblk pointer
/* 10945 */	load    | xr     << dst_ | xs     << src_ ,
/* 10946 */	ica     | xs     << dst_ ,
/* 10947 */	stmt    | 3257   << off_ ,	//	mov wa (xs)+  restore name offset
/* 10948 */	load    | wa     << dst_ | xs     << src_ ,
/* 10949 */	ica     | xs     << dst_ ,
/* 10950 */	stmt    | 3258   << off_ ,	//	mov xl (xs)+  restore name base pointer
/* 10951 */	load    | xl     << dst_ | xs     << src_ ,
/* 10952 */	ica     | xs     << dst_ ,
// acs09:
/* 10953 */	stmt    | 3259   << off_ ,	//acs09	mov xr trnxt(xr)  load forward ptr to next value
/* 10954 */	load    | xr     << dst_ | xr     << src_ | trnxt  << off_ ,
/* 10955 */	stmt    | 3260   << off_ ,	//	brn acs02   back to check if trapped
/* 10956 */	brn     | acs02  << off_ ,
// acs10:
/* 10957 */	stmt    | 3261   << off_ ,	//acs10	bne wb =trtac acs09 loop back if not access trace
/* 10958 */	loadi   | r2     << dst_ | trtac  << off_ ,
/* 10959 */	bne     | wb     << dst_ | r2     << src_ | acs09  << off_ ,
/* 10960 */	stmt    | 3262   << off_ ,	//	bze kvtra acs09  ignore access trace if trace off
/* 10961 */	load    | r1     << dst_ | kvtra  << off_ ,
/* 10962 */	bze     | r1     << dst_ | acs09  << off_ ,
/* 10963 */	stmt    | 3263   << off_ ,	//	dcv kvtra   else decrement trace count
/* 10964 */	load    | r1     << dst_ | kvtra  << off_ ,
/* 10965 */	dcv     | r1     << dst_ ,
/* 10966 */	store   | r1     << dst_ | kvtra  << off_ ,
/* 10967 */	stmt    | 3264   << off_ ,	//	bze trfnc(xr) acs11  jump if print trace
/* 10968 */	load    | r1     << dst_ | xr     << src_ | trfnc  << off_ ,
/* 10969 */	bze     | r1     << dst_ | acs11  << off_ ,
/* 10970 */	stmt    | 3265   << off_ ,	//	jsr trxeq   call routine to execute trace
/* 10971 */	call    | trxeq  << off_ ,
/* 10972 */	stmt    | 3266   << off_ ,	//	brn acs09   jump for next trblk
/* 10973 */	brn     | acs09  << off_ ,
// acs11:
/* 10974 */	stmt    | 3267   << off_ ,	//acs11	jsr prtsn   print statement number
/* 10975 */	call    | prtsn  << off_ ,
/* 10976 */	stmt    | 3268   << off_ ,	//	jsr prtnv   print name = value
/* 10977 */	call    | prtnv  << off_ ,
/* 10978 */	stmt    | 3269   << off_ ,	//	brn acs09   jump back for next trblk
/* 10979 */	brn     | acs09  << off_ ,
// acs12:
/* 10980 */	stmt    | 3270   << off_ ,	//acs12	mov xr kvnum(xl)  load keyword number
/* 10981 */	load    | xr     << dst_ | xl     << src_ | kvnum  << off_ ,
/* 10982 */	stmt    | 3271   << off_ ,	//	bge xr =k_v__ acs14 jump if not one word value
/* 10983 */	loadi   | r2     << dst_ | k_v__  << off_ ,
/* 10984 */	bge     | xr     << dst_ | r2     << src_ | acs14  << off_ ,
/* 10985 */	stmt    | 3272   << off_ ,	//	mti kvabe(xr)   else load value as integer
/* 10986 */	load    | ia     << dst_ | xr     << src_ | kvabe  << off_ ,
// acs13:
/* 10987 */	stmt    | 3273   << off_ ,	//acs13	jsr icbld   build icblk
/* 10988 */	call    | icbld  << off_ ,
/* 10989 */	stmt    | 3274   << off_ ,	//	brn acs18   jump to exit
/* 10990 */	brn     | acs18  << off_ ,
// acs14:
/* 10991 */	stmt    | 3275   << off_ ,	//acs14	bge xr =k_s__ acs15 jump if special case
/* 10992 */	loadi   | r2     << dst_ | k_s__  << off_ ,
/* 10993 */	bge     | xr     << dst_ | r2     << src_ | acs15  << off_ ,
/* 10994 */	stmt    | 3276   << off_ ,	//	sub xr =k_v__  else get offset
/* 10995 */	loadi   | r2     << dst_ | k_v__  << off_ ,
/* 10996 */	sub     | xr     << dst_ | r2     << src_ ,
/* 10997 */	stmt    | 3277   << off_ ,	//	wtb xr   convert to byte offset
/* 10998 */	stmt    | 3278   << off_ ,	//	add xr =ndabo  point to pattern value
/* 10999 */	loadi   | r2     << dst_ | ndabo  << off_ ,
/* 11000 */	add     | xr     << dst_ | r2     << src_ ,
/* 11001 */	stmt    | 3279   << off_ ,	//	brn acs18   jump to exit
/* 11002 */	brn     | acs18  << off_ ,
// acs15:
/* 11003 */	stmt    | 3280   << off_ ,	//acs15	mov xl kvrtn  load rtntype in case
/* 11004 */	load    | xl     << dst_ | kvrtn  << off_ ,
/* 11005 */	stmt    | 3281   << off_ ,	//	ldi kvstl   load stlimit in case
/* 11006 */	load    | r1     << dst_ | kvstl  << off_ ,
/* 11007 */	ldi     | r1     << dst_ ,
/* 11008 */	stmt    | 3282   << off_ ,	//	sub xr =k_s__  get case number
/* 11009 */	loadi   | r2     << dst_ | k_s__  << off_ ,
/* 11010 */	sub     | xr     << dst_ | r2     << src_ ,
/* 11011 */	stmt    | 3283   << off_ ,	//	bsw xr k__n_  switch on keyword number
/* 11012 */	loadi   | r1     << dst_ | k__n_  << off_ ,
/* 11013 */	bsw     | xr     << dst_ | r1     << src_ ,
/* 11014 */	acs16   ,
/* 11015 */	acs17   ,
/* 11016 */	acs19   ,
/* 11017 */	acs20   ,
/* 11018 */	acs26   ,
/* 11019 */	acs27   ,
/* 11020 */	acs13   ,
/* 11021 */	acs24   ,
/* 11022 */	acs25   ,
// acs24:
/* 11023 */	stmt    | 3284   << off_ ,	//acs24	mov xr =lcase  load pointer to lcase string
/* 11024 */	loadi   | xr     << dst_ | lcase  << off_ ,
/* 11025 */	stmt    | 3285   << off_ ,	//	brn acs18   common return
/* 11026 */	brn     | acs18  << off_ ,
// acs25:
/* 11027 */	stmt    | 3286   << off_ ,	//acs25	mov xr =ucase  load pointer to ucase string
/* 11028 */	loadi   | xr     << dst_ | ucase  << off_ ,
/* 11029 */	stmt    | 3287   << off_ ,	//	brn acs18   common return
/* 11030 */	brn     | acs18  << off_ ,
// acs26:
/* 11031 */	stmt    | 3288   << off_ ,	//acs26	mov wc kvstn  load current stmt number
/* 11032 */	load    | wc     << dst_ | kvstn  << off_ ,
/* 11033 */	stmt    | 3289   << off_ ,	//	brn acs28   merge to obtain file name
/* 11034 */	brn     | acs28  << off_ ,
// acs27:
/* 11035 */	stmt    | 3290   << off_ ,	//acs27	mov wc kvlst  load last stmt number
/* 11036 */	load    | wc     << dst_ | kvlst  << off_ ,
// acs28:
/* 11037 */	stmt    | 3291   << off_ ,	//acs28	jsr filnm   obtain file name for this stmt
/* 11038 */	call    | filnm  << off_ ,
/* 11039 */	stmt    | 3292   << off_ ,	//	brn acs17   merge to return string in xl
/* 11040 */	brn     | acs17  << off_ ,
// acs16:
/* 11041 */	stmt    | 3293   << off_ ,	//acs16	mov xl kvalp  load pointer to alphabet string
/* 11042 */	load    | xl     << dst_ | kvalp  << off_ ,
// acs17:
/* 11043 */	stmt    | 3294   << off_ ,	//acs17	mov xr xl  copy string ptr to proper reg
/* 11044 */	move    | xr     << dst_ | xl     << src_ ,
// acs18:
/* 11045 */	stmt    | 3295   << off_ ,	//acs18	exi    return to acess caller
/* 11046 */	exi     | 0      << off_ ,
// acs19:
/* 11047 */	stmt    | 3296   << off_ ,	//acs19	ilt acs29   if counting suppressed
/* 11048 */	ilt     | acs29  << off_ ,
/* 11049 */	stmt    | 3297   << off_ ,	//	mov wa stmcs  refine with counter start value
/* 11050 */	load    | wa     << dst_ | stmcs  << off_ ,
/* 11051 */	stmt    | 3298   << off_ ,	//	sub wa stmct  minus current counter
/* 11052 */	load    | r2     << dst_ | stmct  << off_ ,
/* 11053 */	sub     | wa     << dst_ | r2     << src_ ,
/* 11054 */	stmt    | 3299   << off_ ,	//	mti wa   convert to integer
/* 11055 */	move    | ia     << dst_ | wa     << src_ ,
/* 11056 */	stmt    | 3300   << off_ ,	//	adi kvstl   add stlimit
/* 11057 */	load    | r1     << dst_ | kvstl  << off_ ,
/* 11058 */	adi     | r1     << dst_ ,
// acs29:
/* 11059 */	stmt    | 3301   << off_ ,	//acs29	sbi kvstc   stcount = limit - left
/* 11060 */	load    | r1     << dst_ | kvstc  << off_ ,
/* 11061 */	sbi     | r1     << dst_ ,
/* 11062 */	stmt    | 3302   << off_ ,	//	brn acs13   merge back with integer result
/* 11063 */	brn     | acs13  << off_ ,
// acs20:
/* 11064 */	stmt    | 3303   << off_ ,	//acs20	mov xr r_etx  get errtext string
/* 11065 */	load    | xr     << dst_ | r_etx  << off_ ,
/* 11066 */	stmt    | 3304   << off_ ,	//	brn acs18   merge with result
/* 11067 */	brn     | acs18  << off_ ,
// acs21:
/* 11068 */	stmt    | 3305   << off_ ,	//acs21	mov wa =rilen  buffer length
/* 11069 */	loadi   | wa     << dst_ | rilen  << off_ ,
/* 11070 */	stmt    | 3306   << off_ ,	//	jsr alocs   allocate buffer
/* 11071 */	call    | alocs  << off_ ,
/* 11072 */	stmt    | 3307   << off_ ,	//	jsr sysri   read record
/* 11073 */	sys     | sysri_ << off_ ,
/* 11074 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 11075 */	ppm     | acs03  << off_ ,
/* 11076 */	stmt    | 3308   << off_ ,	//	brn acs07   merge with record read
/* 11077 */	brn     | acs07  << off_ ,
// acs22:
/* 11078 */	stmt    | 3309   << off_ ,	//acs22	mov dnamp xr  pop unused scblk
/* 11079 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 11080 */	stmt    | 3310   << off_ ,	//	erb 202 input from file caused non-recoverable error
/* 11081 */	erb     | 202    << off_ ,
// acs23:
/* 11082 */	stmt    | 3311   << off_ ,	//acs23	mov dnamp xr  pop unused scblk
/* 11083 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 11084 */	stmt    | 3312   << off_ ,	//	erb 203 input file record has incorrect format
/* 11085 */	erb     | 203    << off_ ,
// acomp:
/* 11086 */	stmt    | 3313   << off_ ,	//acomp	prc n 5  entry point
/* 11087 */	prc     | 1      << off_ ,
/* 11088 */	stmt    | 3314   << off_ ,	//	jsr arith   load arithmetic operands
/* 11089 */	call    | arith  << off_ ,
/* 11090 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/* 11091 */	ppm     | acmp7  << off_ ,
/* 11092 */	ppm     | acmp8  << off_ ,
/* 11093 */	ppm     | acmp4  << off_ ,
/* 11094 */	stmt    | 3315   << off_ ,	//	sbi icval(xl)   subtract to compare
/* 11095 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/* 11096 */	sbi     | r1     << dst_ ,
/* 11097 */	stmt    | 3316   << off_ ,	//	iov acmp3   jump if overflow
/* 11098 */	iov     | acmp3  << off_ ,
/* 11099 */	stmt    | 3317   << off_ ,	//	ilt acmp5   else jump if arg1 lt arg2
/* 11100 */	ilt     | acmp5  << off_ ,
/* 11101 */	stmt    | 3318   << off_ ,	//	ieq acmp2   jump if arg1 eq arg2
/* 11102 */	ieq     | acmp2  << off_ ,
// acmp1:
/* 11103 */	stmt    | 3319   << off_ ,	//acmp1	exi 5   take gt exit
/* 11104 */	exi     | 105    << off_ ,
// acmp2:
/* 11105 */	stmt    | 3320   << off_ ,	//acmp2	exi 4   take eq exit
/* 11106 */	exi     | 104    << off_ ,
// acmp3:
/* 11107 */	stmt    | 3321   << off_ ,	//acmp3	ldi icval(xl)   load second argument
/* 11108 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/* 11109 */	ldi     | r1     << dst_ ,
/* 11110 */	stmt    | 3322   << off_ ,	//	ilt acmp1   gt if negative
/* 11111 */	ilt     | acmp1  << off_ ,
/* 11112 */	stmt    | 3323   << off_ ,	//	brn acmp5   else lt
/* 11113 */	brn     | acmp5  << off_ ,
// acmp4:
/* 11114 */	stmt    | 3324   << off_ ,	//acmp4	sbr rcval(xl)   subtract to compare
/* 11115 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/* 11116 */	sbr     | r1     << dst_ ,
/* 11117 */	stmt    | 3325   << off_ ,	//	rov acmp6   jump if overflow
/* 11118 */	rov     | acmp6  << off_ ,
/* 11119 */	stmt    | 3326   << off_ ,	//	rgt acmp1   else jump if arg1 gt
/* 11120 */	rgt     | acmp1  << off_ ,
/* 11121 */	stmt    | 3327   << off_ ,	//	req acmp2   jump if arg1 eq arg2
/* 11122 */	req     | acmp2  << off_ ,
// acmp5:
/* 11123 */	stmt    | 3328   << off_ ,	//acmp5	exi 3   take lt exit
/* 11124 */	exi     | 103    << off_ ,
// acmp6:
/* 11125 */	stmt    | 3329   << off_ ,	//acmp6	ldr rcval(xl)   reload arg2
/* 11126 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/* 11127 */	ldr     | r1     << dst_ ,
/* 11128 */	stmt    | 3330   << off_ ,	//	rlt acmp1   gt if negative
/* 11129 */	rlt     | acmp1  << off_ ,
/* 11130 */	stmt    | 3331   << off_ ,	//	brn acmp5   else lt
/* 11131 */	brn     | acmp5  << off_ ,
// acmp7:
/* 11132 */	stmt    | 3332   << off_ ,	//acmp7	exi 1   take error exit
/* 11133 */	exi     | 101    << off_ ,
// acmp8:
/* 11134 */	stmt    | 3333   << off_ ,	//acmp8	exi 2   take error exit
/* 11135 */	exi     | 102    << off_ ,
// alloc:
/* 11136 */	stmt    | 3334   << off_ ,	//alloc	prc e 0  entry point
// aloc1:
/* 11137 */	stmt    | 3335   << off_ ,	//aloc1	mov xr dnamp  point to next available loc
/* 11138 */	load    | xr     << dst_ | dnamp  << off_ ,
/* 11139 */	stmt    | 3336   << off_ ,	//	aov wa xr aloc2 point past allocated block
/* 11140 */	aov     | xr     << dst_ | wa     << src_ | aloc2  << off_ ,
/* 11141 */	stmt    | 3337   << off_ ,	//	bgt xr dname aloc2 jump if not enough room
/* 11142 */	load    | r2     << dst_ | dname  << off_ ,
/* 11143 */	bgt     | xr     << dst_ | r2     << src_ | aloc2  << off_ ,
/* 11144 */	stmt    | 3338   << off_ ,	//	mov dnamp xr  store new pointer
/* 11145 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 11146 */	stmt    | 3339   << off_ ,	//	sub xr wa  point back to start of allocated bk
/* 11147 */	sub     | xr     << dst_ | wa     << src_ ,
/* 11148 */	stmt    | 3340   << off_ ,	//	exi    return to caller
/* 11149 */	exi     | 0      << off_ ,
// aloc2:
/* 11150 */	stmt    | 3341   << off_ ,	//aloc2	mov allsv wb  save wb
/* 11151 */	store   | wb     << dst_ | allsv  << off_ ,
// alc2a:
/* 11152 */	stmt    | 3342   << off_ ,	//alc2a	zer wb   set no upward move for gbcol
/* 11153 */	move    | wb     << dst_ ,
/* 11154 */	stmt    | 3343   << off_ ,	//	jsr gbcol   garbage collect
/* 11155 */	call    | gbcol  << off_ ,
/* 11156 */	stmt    | 3344   << off_ ,	//	mov wb xr  remember new sediment size
/* 11157 */	move    | wb     << dst_ | xr     << src_ ,
// aloc3:
/* 11158 */	stmt    | 3345   << off_ ,	//aloc3	mov xr dnamp  point to first available loc
/* 11159 */	load    | xr     << dst_ | dnamp  << off_ ,
/* 11160 */	stmt    | 3346   << off_ ,	//	aov wa xr alc3a point past new block
/* 11161 */	aov     | xr     << dst_ | wa     << src_ | alc3a  << off_ ,
/* 11162 */	stmt    | 3347   << off_ ,	//	blo xr dname aloc4 jump if there is room now
/* 11163 */	load    | r2     << dst_ | dname  << off_ ,
/* 11164 */	blo     | xr     << dst_ | r2     << src_ | aloc4  << off_ ,
// alc3a:
/* 11165 */	stmt    | 3348   << off_ ,	//alc3a	jsr sysmm   try to get more memory
/* 11166 */	sys     | sysmm_ << off_ ,
/* 11167 */	stmt    | 3349   << off_ ,	//	wtb xr   convert to baus (sgd05)
/* 11168 */	stmt    | 3350   << off_ ,	//	add dname xr  bump ptr by amount obtained
/* 11169 */	load    | r1     << dst_ | dname  << off_ ,
/* 11170 */	add     | r1     << dst_ | xr     << src_ ,
/* 11171 */	store   | r1     << dst_ | dname  << off_ ,
/* 11172 */	stmt    | 3351   << off_ ,	//	bnz xr aloc3  jump if got more core
/* 11173 */	bnz     | xr     << dst_ | aloc3  << off_ ,
/* 11174 */	stmt    | 3352   << off_ ,	//	bze dnams alc3b  jump if there was no sediment
/* 11175 */	load    | r1     << dst_ | dnams  << off_ ,
/* 11176 */	bze     | r1     << dst_ | alc3b  << off_ ,
/* 11177 */	stmt    | 3353   << off_ ,	//	zer dnams   try collecting the sediment
/* 11178 */	store   | r0     << dst_ | dnams  << off_ ,
/* 11179 */	stmt    | 3354   << off_ ,	//	brn alc2a
/* 11180 */	brn     | alc2a  << off_ ,
// alc3b:
/* 11181 */	stmt    | 3355   << off_ ,	//alc3b	add dname rsmem  get the reserve memory
/* 11182 */	load    | r1     << dst_ | dname  << off_ ,
/* 11183 */	load    | r2     << dst_ | rsmem  << off_ ,
/* 11184 */	add     | r1     << dst_ | r2     << src_ ,
/* 11185 */	store   | r1     << dst_ | dname  << off_ ,
/* 11186 */	stmt    | 3356   << off_ ,	//	zer rsmem   only permissible once
/* 11187 */	store   | r0     << dst_ | rsmem  << off_ ,
/* 11188 */	stmt    | 3357   << off_ ,	//	icv errft   fatal error
/* 11189 */	load    | r1     << dst_ | errft  << off_ ,
/* 11190 */	icv     | r1     << dst_ ,
/* 11191 */	store   | r1     << dst_ | errft  << off_ ,
/* 11192 */	stmt    | 3358   << off_ ,	//	erb 204 memory overflow
/* 11193 */	erb     | 204    << off_ ,
// aloc4:
/* 11194 */	stmt    | 3359   << off_ ,	//aloc4	sti allia   save ia
/* 11195 */	store   | ia     << dst_ | allia  << off_ ,
/* 11196 */	stmt    | 3360   << off_ ,	//	mov dnams wb  record new sediment size
/* 11197 */	store   | wb     << dst_ | dnams  << off_ ,
/* 11198 */	stmt    | 3361   << off_ ,	//	mov wb dname  get dynamic end adrs
/* 11199 */	load    | wb     << dst_ | dname  << off_ ,
/* 11200 */	stmt    | 3362   << off_ ,	//	sub wb dnamp  compute free store
/* 11201 */	load    | r2     << dst_ | dnamp  << off_ ,
/* 11202 */	sub     | wb     << dst_ | r2     << src_ ,
/* 11203 */	stmt    | 3363   << off_ ,	//	btw wb   convert bytes to words
/* 11204 */	stmt    | 3364   << off_ ,	//	mti wb   put free store in ia
/* 11205 */	move    | ia     << dst_ | wb     << src_ ,
/* 11206 */	stmt    | 3365   << off_ ,	//	mli alfsf   multiply by free store factor
/* 11207 */	load    | r1     << dst_ | alfsf  << off_ ,
/* 11208 */	mli     | r1     << dst_ ,
/* 11209 */	stmt    | 3366   << off_ ,	//	iov aloc5   jump if overflowed
/* 11210 */	iov     | aloc5  << off_ ,
/* 11211 */	stmt    | 3367   << off_ ,	//	mov wb dname  dynamic end adrs
/* 11212 */	load    | wb     << dst_ | dname  << off_ ,
/* 11213 */	stmt    | 3368   << off_ ,	//	sub wb dnamb  compute total amount of dynamic
/* 11214 */	load    | r2     << dst_ | dnamb  << off_ ,
/* 11215 */	sub     | wb     << dst_ | r2     << src_ ,
/* 11216 */	stmt    | 3369   << off_ ,	//	btw wb   convert to words
/* 11217 */	stmt    | 3370   << off_ ,	//	mov aldyn wb  store it
/* 11218 */	store   | wb     << dst_ | aldyn  << off_ ,
/* 11219 */	stmt    | 3371   << off_ ,	//	sbi aldyn   subtract from scaled up free store
/* 11220 */	load    | r1     << dst_ | aldyn  << off_ ,
/* 11221 */	sbi     | r1     << dst_ ,
/* 11222 */	stmt    | 3372   << off_ ,	//	igt aloc5   jump if sufficient free store
/* 11223 */	igt     | aloc5  << off_ ,
/* 11224 */	stmt    | 3373   << off_ ,	//	jsr sysmm   try to get more store
/* 11225 */	sys     | sysmm_ << off_ ,
/* 11226 */	stmt    | 3374   << off_ ,	//	wtb xr   convert to baus (sgd05)
/* 11227 */	stmt    | 3375   << off_ ,	//	add dname xr  adjust dynamic end adrs
/* 11228 */	load    | r1     << dst_ | dname  << off_ ,
/* 11229 */	add     | r1     << dst_ | xr     << src_ ,
/* 11230 */	store   | r1     << dst_ | dname  << off_ ,
// aloc5:
/* 11231 */	stmt    | 3376   << off_ ,	//aloc5	ldi allia   recover ia
/* 11232 */	load    | r1     << dst_ | allia  << off_ ,
/* 11233 */	ldi     | r1     << dst_ ,
/* 11234 */	stmt    | 3377   << off_ ,	//	mov wb allsv  restore wb
/* 11235 */	load    | wb     << dst_ | allsv  << off_ ,
/* 11236 */	stmt    | 3378   << off_ ,	//	brn aloc1   jump back to exit
/* 11237 */	brn     | aloc1  << off_ ,
// alocs:
/* 11238 */	stmt    | 3379   << off_ ,	//alocs	prc e 0  entry point
/* 11239 */	stmt    | 3380   << off_ ,	//	bgt wa kvmxl alcs2 jump if length exceeds maxlength
/* 11240 */	load    | r2     << dst_ | kvmxl  << off_ ,
/* 11241 */	bgt     | wa     << dst_ | r2     << src_ | alcs2  << off_ ,
/* 11242 */	stmt    | 3381   << off_ ,	//	mov wc wa  else copy length
/* 11243 */	move    | wc     << dst_ | wa     << src_ ,
/* 11244 */	stmt    | 3382   << off_ ,	//	ctb wa scsi_  compute length of scblk in bytes
/* 11245 */	ctb     | wa     << dst_ | scsi_  << off_ ,
/* 11246 */	stmt    | 3383   << off_ ,	//	mov xr dnamp  point to next available location
/* 11247 */	load    | xr     << dst_ | dnamp  << off_ ,
/* 11248 */	stmt    | 3384   << off_ ,	//	aov wa xr alcs0 point past block
/* 11249 */	aov     | xr     << dst_ | wa     << src_ | alcs0  << off_ ,
/* 11250 */	stmt    | 3385   << off_ ,	//	blo xr dname alcs1 jump if there is room
/* 11251 */	load    | r2     << dst_ | dname  << off_ ,
/* 11252 */	blo     | xr     << dst_ | r2     << src_ | alcs1  << off_ ,
// alcs0:
/* 11253 */	stmt    | 3386   << off_ ,	//alcs0	zer xr   else clear garbage xr value
/* 11254 */	move    | xr     << dst_ ,
/* 11255 */	stmt    | 3387   << off_ ,	//	jsr alloc   and use standard allocator
/* 11256 */	call    | alloc  << off_ ,
/* 11257 */	stmt    | 3388   << off_ ,	//	add xr wa  point past end of block to merge
/* 11258 */	add     | xr     << dst_ | wa     << src_ ,
// alcs1:
/* 11259 */	stmt    | 3389   << off_ ,	//alcs1	mov dnamp xr  set updated storage pointer
/* 11260 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 11261 */	stmt    | 3390   << off_ ,	//	zer -(xr)   store zero chars in last word
/* 11262 */	dca     | xr     << dst_ ,
/* 11263 */	store   | r0     << dst_ | xr     << src_ ,
/* 11264 */	stmt    | 3391   << off_ ,	//	dca wa   decrement length
/* 11265 */	dca     | wa     << dst_ ,
/* 11266 */	stmt    | 3392   << off_ ,	//	sub xr wa  point back to start of block
/* 11267 */	sub     | xr     << dst_ | wa     << src_ ,
/* 11268 */	stmt    | 3393   << off_ ,	//	mov (xr) =b_scl  set type word
/* 11269 */	loadi   | r1     << dst_ | b_scl  << off_ ,
/* 11270 */	store   | r1     << dst_ | xr     << src_ ,
/* 11271 */	stmt    | 3394   << off_ ,	//	mov sclen(xr) wc  store length in chars
/* 11272 */	store   | wc     << dst_ | xr     << src_ | sclen  << off_ ,
/* 11273 */	stmt    | 3395   << off_ ,	//	exi    return to alocs caller
/* 11274 */	exi     | 0      << off_ ,
// alcs2:
/* 11275 */	stmt    | 3396   << off_ ,	//alcs2	erb 205 string length exceeds value of maxlngth keyword
/* 11276 */	erb     | 205    << off_ ,
// alost:
/* 11277 */	stmt    | 3397   << off_ ,	//alost	prc e 0  entry point
// alst1:
/* 11278 */	stmt    | 3398   << off_ ,	//alst1	mov xr state  point to current end of area
/* 11279 */	load    | xr     << dst_ | state  << off_ ,
/* 11280 */	stmt    | 3399   << off_ ,	//	aov wa xr alst2 point beyond proposed block
/* 11281 */	aov     | xr     << dst_ | wa     << src_ | alst2  << off_ ,
/* 11282 */	stmt    | 3400   << off_ ,	//	bge xr dnamb alst2 jump if overlap with dynamic area
/* 11283 */	load    | r2     << dst_ | dnamb  << off_ ,
/* 11284 */	bge     | xr     << dst_ | r2     << src_ | alst2  << off_ ,
/* 11285 */	stmt    | 3401   << off_ ,	//	mov state xr  else store new pointer
/* 11286 */	store   | xr     << dst_ | state  << off_ ,
/* 11287 */	stmt    | 3402   << off_ ,	//	sub xr wa  point back to start of block
/* 11288 */	sub     | xr     << dst_ | wa     << src_ ,
/* 11289 */	stmt    | 3403   << off_ ,	//	exi    return to alost caller
/* 11290 */	exi     | 0      << off_ ,
// alst2:
/* 11291 */	stmt    | 3404   << off_ ,	//alst2	mov alsta wa  save wa
/* 11292 */	store   | wa     << dst_ | alsta  << off_ ,
/* 11293 */	stmt    | 3405   << off_ ,	//	bge wa *e_sts alst3 skip if requested chunk is large
/* 11294 */	loadi   | r2     << dst_ | e_sts  << off_ ,
/* 11295 */	bge     | wa     << dst_ | r2     << src_ | alst3  << off_ ,
/* 11296 */	stmt    | 3406   << off_ ,	//	mov wa *e_sts  else set to get large enough chunk
/* 11297 */	loadi   | wa     << dst_ | e_sts  << off_ ,
// alst3:
/* 11298 */	stmt    | 3407   << off_ ,	//alst3	jsr alloc   allocate block to ensure room
/* 11299 */	call    | alloc  << off_ ,
/* 11300 */	stmt    | 3408   << off_ ,	//	mov dnamp xr  and delete it
/* 11301 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 11302 */	stmt    | 3409   << off_ ,	//	mov wb wa  copy move up amount
/* 11303 */	move    | wb     << dst_ | wa     << src_ ,
/* 11304 */	stmt    | 3410   << off_ ,	//	jsr gbcol   call gbcol to move dynamic area up
/* 11305 */	call    | gbcol  << off_ ,
/* 11306 */	stmt    | 3411   << off_ ,	//	mov dnams xr  remember new sediment size
/* 11307 */	store   | xr     << dst_ | dnams  << off_ ,
/* 11308 */	stmt    | 3412   << off_ ,	//	mov wa alsta  restore wa
/* 11309 */	load    | wa     << dst_ | alsta  << off_ ,
/* 11310 */	stmt    | 3413   << off_ ,	//	brn alst1   loop back to try again
/* 11311 */	brn     | alst1  << off_ ,
// arith:
/* 11312 */	stmt    | 3414   << off_ ,	//arith	prc n 3  entry point
/* 11313 */	prc     | 2      << off_ ,
/* 11314 */	stmt    | 3415   << off_ ,	//	mov xl (xs)+  load right operand
/* 11315 */	load    | xl     << dst_ | xs     << src_ ,
/* 11316 */	ica     | xs     << dst_ ,
/* 11317 */	stmt    | 3416   << off_ ,	//	mov xr (xs)+  load left operand
/* 11318 */	load    | xr     << dst_ | xs     << src_ ,
/* 11319 */	ica     | xs     << dst_ ,
/* 11320 */	stmt    | 3417   << off_ ,	//	mov wa (xl)  get right operand type word
/* 11321 */	load    | wa     << dst_ | xl     << src_ ,
/* 11322 */	stmt    | 3418   << off_ ,	//	beq wa =b_icl arth1 jump if integer
/* 11323 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/* 11324 */	beq     | wa     << dst_ | r2     << src_ | arth1  << off_ ,
/* 11325 */	stmt    | 3419   << off_ ,	//	beq wa =b_rcl arth4 jump if real
/* 11326 */	loadi   | r2     << dst_ | b_rcl  << off_ ,
/* 11327 */	beq     | wa     << dst_ | r2     << src_ | arth4  << off_ ,
/* 11328 */	stmt    | 3420   << off_ ,	//	mov -(xs) xr  else replace left arg on stack
/* 11329 */	dca     | xs     << dst_ ,
/* 11330 */	store   | xr     << dst_ | xs     << src_ ,
/* 11331 */	stmt    | 3421   << off_ ,	//	mov xr xl  copy left arg pointer
/* 11332 */	move    | xr     << dst_ | xl     << src_ ,
/* 11333 */	stmt    | 3422   << off_ ,	//	jsr gtnum   convert to numeric
/* 11334 */	call    | gtnum  << off_ ,
/* 11335 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 11336 */	ppm     | arth6  << off_ ,
/* 11337 */	stmt    | 3423   << off_ ,	//	mov xl xr  else copy converted result
/* 11338 */	move    | xl     << dst_ | xr     << src_ ,
/* 11339 */	stmt    | 3424   << off_ ,	//	mov wa (xl)  get right operand type word
/* 11340 */	load    | wa     << dst_ | xl     << src_ ,
/* 11341 */	stmt    | 3425   << off_ ,	//	mov xr (xs)+  reload left argument
/* 11342 */	load    | xr     << dst_ | xs     << src_ ,
/* 11343 */	ica     | xs     << dst_ ,
/* 11344 */	stmt    | 3426   << off_ ,	//	beq wa =b_rcl arth4 jump if right arg is real
/* 11345 */	loadi   | r2     << dst_ | b_rcl  << off_ ,
/* 11346 */	beq     | wa     << dst_ | r2     << src_ | arth4  << off_ ,
// arth1:
/* 11347 */	stmt    | 3427   << off_ ,	//arth1	bne (xr) =b_icl arth3 jump if left arg not integer
/* 11348 */	load    | r1     << dst_ | xr     << src_ ,
/* 11349 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/* 11350 */	bne     | r1     << dst_ | r2     << src_ | arth3  << off_ ,
// arth2:
/* 11351 */	stmt    | 3428   << off_ ,	//arth2	ldi icval(xr)   load left operand value
/* 11352 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/* 11353 */	ldi     | r1     << dst_ ,
/* 11354 */	stmt    | 3429   << off_ ,	//	exi    return to arith caller
/* 11355 */	exi     | 200    << off_ ,
// arth3:
/* 11356 */	stmt    | 3430   << off_ ,	//arth3	jsr gtnum   convert left arg to numeric
/* 11357 */	call    | gtnum  << off_ ,
/* 11358 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 11359 */	ppm     | arth7  << off_ ,
/* 11360 */	stmt    | 3431   << off_ ,	//	beq wa =b_icl arth2 jump back if integer-integer
/* 11361 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/* 11362 */	beq     | wa     << dst_ | r2     << src_ | arth2  << off_ ,
/* 11363 */	stmt    | 3432   << off_ ,	//	mov -(xs) xr  put left arg back on stack
/* 11364 */	dca     | xs     << dst_ ,
/* 11365 */	store   | xr     << dst_ | xs     << src_ ,
/* 11366 */	stmt    | 3433   << off_ ,	//	ldi icval(xl)   load right argument value
/* 11367 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/* 11368 */	ldi     | r1     << dst_ ,
/* 11369 */	stmt    | 3434   << off_ ,	//	itr    convert to real
/* 11370 */	itr     ,
/* 11371 */	stmt    | 3435   << off_ ,	//	jsr rcbld   get real block for right arg, merge
/* 11372 */	call    | rcbld  << off_ ,
/* 11373 */	stmt    | 3436   << off_ ,	//	mov xl xr  copy right arg ptr
/* 11374 */	move    | xl     << dst_ | xr     << src_ ,
/* 11375 */	stmt    | 3437   << off_ ,	//	mov xr (xs)+  load left argument
/* 11376 */	load    | xr     << dst_ | xs     << src_ ,
/* 11377 */	ica     | xs     << dst_ ,
/* 11378 */	stmt    | 3438   << off_ ,	//	brn arth5   merge for real-real case
/* 11379 */	brn     | arth5  << off_ ,
// arth4:
/* 11380 */	stmt    | 3439   << off_ ,	//arth4	beq (xr) =b_rcl arth5 jump if left arg real
/* 11381 */	load    | r1     << dst_ | xr     << src_ ,
/* 11382 */	loadi   | r2     << dst_ | b_rcl  << off_ ,
/* 11383 */	beq     | r1     << dst_ | r2     << src_ | arth5  << off_ ,
/* 11384 */	stmt    | 3440   << off_ ,	//	jsr gtrea   else convert to real
/* 11385 */	call    | gtrea  << off_ ,
/* 11386 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 11387 */	ppm     | arth7  << off_ ,
// arth5:
/* 11388 */	stmt    | 3441   << off_ ,	//arth5	ldr rcval(xr)   load left operand value
/* 11389 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/* 11390 */	ldr     | r1     << dst_ ,
/* 11391 */	stmt    | 3442   << off_ ,	//	exi 3   take real-real exit
/* 11392 */	exi     | 203    << off_ ,
// arth6:
/* 11393 */	stmt    | 3443   << off_ ,	//arth6	ica xs   pop unwanted left arg
/* 11394 */	ica     | xs     << dst_ ,
/* 11395 */	stmt    | 3444   << off_ ,	//	exi 2   take appropriate error exit
/* 11396 */	exi     | 202    << off_ ,
// arth7:
/* 11397 */	stmt    | 3445   << off_ ,	//arth7	exi 1   take appropriate error return
/* 11398 */	exi     | 201    << off_ ,
// asign:
/* 11399 */	stmt    | 3446   << off_ ,	//asign	prc r 1  entry point (recursive)
// asg01:
/* 11400 */	stmt    | 3447   << off_ ,	//asg01	add xl wa  point to variable value
/* 11401 */	add     | xl     << dst_ | wa     << src_ ,
/* 11402 */	stmt    | 3448   << off_ ,	//	mov xr (xl)  load variable value
/* 11403 */	load    | xr     << dst_ | xl     << src_ ,
/* 11404 */	stmt    | 3449   << off_ ,	//	beq (xr) =b_trt asg02 jump if trapped
/* 11405 */	load    | r1     << dst_ | xr     << src_ ,
/* 11406 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 11407 */	beq     | r1     << dst_ | r2     << src_ | asg02  << off_ ,
/* 11408 */	stmt    | 3450   << off_ ,	//	mov (xl) wb  else perform assignment
/* 11409 */	store   | wb     << dst_ | xl     << src_ ,
/* 11410 */	stmt    | 3451   << off_ ,	//	zer xl   clear garbage value in xl
/* 11411 */	move    | xl     << dst_ ,
/* 11412 */	stmt    | 3452   << off_ ,	//	exi    and return to asign caller
/* 11413 */	exi     | 0      << off_ ,
// asg02:
/* 11414 */	stmt    | 3453   << off_ ,	//asg02	sub xl wa  restore name base
/* 11415 */	sub     | xl     << dst_ | wa     << src_ ,
/* 11416 */	stmt    | 3454   << off_ ,	//	beq xr =trbkv asg14 jump if keyword variable
/* 11417 */	loadi   | r2     << dst_ | trbkv  << off_ ,
/* 11418 */	beq     | xr     << dst_ | r2     << src_ | asg14  << off_ ,
/* 11419 */	stmt    | 3455   << off_ ,	//	bne xr =trbev asg04 jump if not expression variable
/* 11420 */	loadi   | r2     << dst_ | trbev  << off_ ,
/* 11421 */	bne     | xr     << dst_ | r2     << src_ | asg04  << off_ ,
/* 11422 */	stmt    | 3456   << off_ ,	//	mov xr evexp(xl)  point to expression
/* 11423 */	load    | xr     << dst_ | xl     << src_ | evexp  << off_ ,
/* 11424 */	stmt    | 3457   << off_ ,	//	mov -(xs) wb  store value to assign on stack
/* 11425 */	dca     | xs     << dst_ ,
/* 11426 */	store   | wb     << dst_ | xs     << src_ ,
/* 11427 */	stmt    | 3458   << off_ ,	//	mov wb =num01  set for evaluation by name
/* 11428 */	loadi   | wb     << dst_ | num01  << off_ ,
/* 11429 */	stmt    | 3459   << off_ ,	//	jsr evalx   evaluate expression by name
/* 11430 */	call    | evalx  << off_ ,
/* 11431 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 11432 */	ppm     | asg03  << off_ ,
/* 11433 */	stmt    | 3460   << off_ ,	//	mov wb (xs)+  else reload value to assign
/* 11434 */	load    | wb     << dst_ | xs     << src_ ,
/* 11435 */	ica     | xs     << dst_ ,
/* 11436 */	stmt    | 3461   << off_ ,	//	brn asg01   loop back to perform assignment
/* 11437 */	brn     | asg01  << off_ ,
// asg03:
/* 11438 */	stmt    | 3462   << off_ ,	//asg03	ica xs   remove stacked value entry
/* 11439 */	ica     | xs     << dst_ ,
/* 11440 */	stmt    | 3463   << off_ ,	//	exi 1   take failure exit
/* 11441 */	exi     | 1      << off_ ,
// asg04:
/* 11442 */	stmt    | 3464   << off_ ,	//asg04	mov -(xs) xr  save ptr to first trblk
/* 11443 */	dca     | xs     << dst_ ,
/* 11444 */	store   | xr     << dst_ | xs     << src_ ,
// asg05:
/* 11445 */	stmt    | 3465   << off_ ,	//asg05	mov wc xr  save ptr to this trblk
/* 11446 */	move    | wc     << dst_ | xr     << src_ ,
/* 11447 */	stmt    | 3466   << off_ ,	//	mov xr trnxt(xr)  point to next trblk
/* 11448 */	load    | xr     << dst_ | xr     << src_ | trnxt  << off_ ,
/* 11449 */	stmt    | 3467   << off_ ,	//	beq (xr) =b_trt asg05 loop back if another trblk
/* 11450 */	load    | r1     << dst_ | xr     << src_ ,
/* 11451 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 11452 */	beq     | r1     << dst_ | r2     << src_ | asg05  << off_ ,
/* 11453 */	stmt    | 3468   << off_ ,	//	mov xr wc  else point back to last trblk
/* 11454 */	move    | xr     << dst_ | wc     << src_ ,
/* 11455 */	stmt    | 3469   << off_ ,	//	mov trval(xr) wb  store value at end of chain
/* 11456 */	store   | wb     << dst_ | xr     << src_ | trval  << off_ ,
/* 11457 */	stmt    | 3470   << off_ ,	//	mov xr (xs)+  restore ptr to first trblk
/* 11458 */	load    | xr     << dst_ | xs     << src_ ,
/* 11459 */	ica     | xs     << dst_ ,
// asg06:
/* 11460 */	stmt    | 3471   << off_ ,	//asg06	mov wb trtyp(xr)  load type code of trblk
/* 11461 */	load    | wb     << dst_ | xr     << src_ | trtyp  << off_ ,
/* 11462 */	stmt    | 3472   << off_ ,	//	beq wb =trtvl asg08 jump if value trace
/* 11463 */	loadi   | r2     << dst_ | trtvl  << off_ ,
/* 11464 */	beq     | wb     << dst_ | r2     << src_ | asg08  << off_ ,
/* 11465 */	stmt    | 3473   << off_ ,	//	beq wb =trtou asg10 jump if output association
/* 11466 */	loadi   | r2     << dst_ | trtou  << off_ ,
/* 11467 */	beq     | wb     << dst_ | r2     << src_ | asg10  << off_ ,
// asg07:
/* 11468 */	stmt    | 3474   << off_ ,	//asg07	mov xr trnxt(xr)  point to next trblk on chain
/* 11469 */	load    | xr     << dst_ | xr     << src_ | trnxt  << off_ ,
/* 11470 */	stmt    | 3475   << off_ ,	//	beq (xr) =b_trt asg06 loop back if another trblk
/* 11471 */	load    | r1     << dst_ | xr     << src_ ,
/* 11472 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 11473 */	beq     | r1     << dst_ | r2     << src_ | asg06  << off_ ,
/* 11474 */	stmt    | 3476   << off_ ,	//	exi    else end of chain, return to caller
/* 11475 */	exi     | 0      << off_ ,
// asg08:
/* 11476 */	stmt    | 3477   << off_ ,	//asg08	bze kvtra asg07  ignore value trace if trace off
/* 11477 */	load    | r1     << dst_ | kvtra  << off_ ,
/* 11478 */	bze     | r1     << dst_ | asg07  << off_ ,
/* 11479 */	stmt    | 3478   << off_ ,	//	dcv kvtra   else decrement trace count
/* 11480 */	load    | r1     << dst_ | kvtra  << off_ ,
/* 11481 */	dcv     | r1     << dst_ ,
/* 11482 */	store   | r1     << dst_ | kvtra  << off_ ,
/* 11483 */	stmt    | 3479   << off_ ,	//	bze trfnc(xr) asg09  jump if print trace
/* 11484 */	load    | r1     << dst_ | xr     << src_ | trfnc  << off_ ,
/* 11485 */	bze     | r1     << dst_ | asg09  << off_ ,
/* 11486 */	stmt    | 3480   << off_ ,	//	jsr trxeq   else execute function trace
/* 11487 */	call    | trxeq  << off_ ,
/* 11488 */	stmt    | 3481   << off_ ,	//	brn asg07   and loop back
/* 11489 */	brn     | asg07  << off_ ,
// asg09:
/* 11490 */	stmt    | 3482   << off_ ,	//asg09	jsr prtsn   print statement number
/* 11491 */	call    | prtsn  << off_ ,
/* 11492 */	stmt    | 3483   << off_ ,	//	jsr prtnv   print name = value
/* 11493 */	call    | prtnv  << off_ ,
/* 11494 */	stmt    | 3484   << off_ ,	//	brn asg07   loop back for next trblk
/* 11495 */	brn     | asg07  << off_ ,
// asg10:
/* 11496 */	stmt    | 3485   << off_ ,	//asg10	bze kvoup asg07  ignore output assoc if output off
/* 11497 */	load    | r1     << dst_ | kvoup  << off_ ,
/* 11498 */	bze     | r1     << dst_ | asg07  << off_ ,
// asg1b:
/* 11499 */	stmt    | 3486   << off_ ,	//asg1b	mov xl xr  copy trblk pointer
/* 11500 */	move    | xl     << dst_ | xr     << src_ ,
/* 11501 */	stmt    | 3487   << off_ ,	//	mov xr trnxt(xr)  point to next trblk
/* 11502 */	load    | xr     << dst_ | xr     << src_ | trnxt  << off_ ,
/* 11503 */	stmt    | 3488   << off_ ,	//	beq (xr) =b_trt asg1b loop back if another trblk
/* 11504 */	load    | r1     << dst_ | xr     << src_ ,
/* 11505 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 11506 */	beq     | r1     << dst_ | r2     << src_ | asg1b  << off_ ,
/* 11507 */	stmt    | 3489   << off_ ,	//	mov xr xl  else point back to last trblk
/* 11508 */	move    | xr     << dst_ | xl     << src_ ,
/* 11509 */	stmt    | 3490   << off_ ,	//	mov -(xs) trval(xr)  stack value to output
/* 11510 */	load    | r1     << dst_ | xr     << src_ | trval  << off_ ,
/* 11511 */	dca     | xs     << dst_ ,
/* 11512 */	store   | r1     << dst_ | xs     << src_ ,
/* 11513 */	stmt    | 3491   << off_ ,	//	jsr gtstg   convert to string
/* 11514 */	call    | gtstg  << off_ ,
/* 11515 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 11516 */	ppm     | asg12  << off_ ,
// asg11:
/* 11517 */	stmt    | 3492   << off_ ,	//asg11	mov wa trfpt(xl)  fcblk ptr
/* 11518 */	load    | wa     << dst_ | xl     << src_ | trfpt  << off_ ,
/* 11519 */	stmt    | 3493   << off_ ,	//	bze wa asg13  jump if standard output file
/* 11520 */	bze     | wa     << dst_ | asg13  << off_ ,
// asg1a:
/* 11521 */	stmt    | 3494   << off_ ,	//asg1a	jsr sysou   call system output routine
/* 11522 */	sys     | sysou_ << off_ ,
/* 11523 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/* 11524 */	err     | 206    << off_ ,
/* 11525 */	err     | 207    << off_ ,
/* 11526 */	stmt    | 3495   << off_ ,	//	exi    else all done, return to caller
/* 11527 */	exi     | 0      << off_ ,
// asg12:
/* 11528 */	stmt    | 3496   << off_ ,	//asg12	jsr dtype   call datatype routine
/* 11529 */	call    | dtype  << off_ ,
/* 11530 */	stmt    | 3497   << off_ ,	//	brn asg11   merge
/* 11531 */	brn     | asg11  << off_ ,
// asg13:
/* 11532 */	stmt    | 3498   << off_ ,	//asg13	beq trter(xl) =v_ter asg1a jump if terminal output
/* 11533 */	load    | r1     << dst_ | xl     << src_ | trter  << off_ ,
/* 11534 */	loadi   | r2     << dst_ | v_ter  << off_ ,
/* 11535 */	beq     | r1     << dst_ | r2     << src_ | asg1a  << off_ ,
/* 11536 */	stmt    | 3499   << off_ ,	//	icv wa   signal standard output
/* 11537 */	icv     | wa     << dst_ ,
/* 11538 */	stmt    | 3500   << off_ ,	//	brn asg1a   use sysou to perform output
/* 11539 */	brn     | asg1a  << off_ ,
// asg14:
/* 11540 */	stmt    | 3501   << off_ ,	//asg14	mov xl kvnum(xl)  load keyword number
/* 11541 */	load    | xl     << dst_ | xl     << src_ | kvnum  << off_ ,
/* 11542 */	stmt    | 3502   << off_ ,	//	beq xl =k_etx asg19 jump if errtext
/* 11543 */	loadi   | r2     << dst_ | k_etx  << off_ ,
/* 11544 */	beq     | xl     << dst_ | r2     << src_ | asg19  << off_ ,
/* 11545 */	stmt    | 3503   << off_ ,	//	mov xr wb  copy value to be assigned
/* 11546 */	move    | xr     << dst_ | wb     << src_ ,
/* 11547 */	stmt    | 3504   << off_ ,	//	jsr gtint   convert to integer
/* 11548 */	call    | gtint  << off_ ,
/* 11549 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 11550 */	err     | 208    << off_ ,
/* 11551 */	stmt    | 3505   << off_ ,	//	ldi icval(xr)   else load value
/* 11552 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/* 11553 */	ldi     | r1     << dst_ ,
/* 11554 */	stmt    | 3506   << off_ ,	//	beq xl =k_stl asg16 jump if special case of stlimit
/* 11555 */	loadi   | r2     << dst_ | k_stl  << off_ ,
/* 11556 */	beq     | xl     << dst_ | r2     << src_ | asg16  << off_ ,
/* 11557 */	stmt    | 3507   << off_ ,	//	mfi wa asg18  else get addr integer, test ovflow
/* 11558 */	move    | wa     << dst_ | ia     << src_ ,
/* 11559 */	mfi     | asg18  << off_ ,
/* 11560 */	stmt    | 3508   << off_ ,	//	bgt wa mxlen asg18 fail if too large
/* 11561 */	load    | r2     << dst_ | mxlen  << off_ ,
/* 11562 */	bgt     | wa     << dst_ | r2     << src_ | asg18  << off_ ,
/* 11563 */	stmt    | 3509   << off_ ,	//	beq xl =k_ert asg17 jump if special case of errtype
/* 11564 */	loadi   | r2     << dst_ | k_ert  << off_ ,
/* 11565 */	beq     | xl     << dst_ | r2     << src_ | asg17  << off_ ,
/* 11566 */	stmt    | 3510   << off_ ,	//	beq xl =k_pfl asg21 jump if special case of profile
/* 11567 */	loadi   | r2     << dst_ | k_pfl  << off_ ,
/* 11568 */	beq     | xl     << dst_ | r2     << src_ | asg21  << off_ ,
/* 11569 */	stmt    | 3511   << off_ ,	//	beq xl =k_mxl asg24 jump if special case of maxlngth
/* 11570 */	loadi   | r2     << dst_ | k_mxl  << off_ ,
/* 11571 */	beq     | xl     << dst_ | r2     << src_ | asg24  << off_ ,
/* 11572 */	stmt    | 3512   << off_ ,	//	beq xl =k_fls asg26 jump if special case of fullscan
/* 11573 */	loadi   | r2     << dst_ | k_fls  << off_ ,
/* 11574 */	beq     | xl     << dst_ | r2     << src_ | asg26  << off_ ,
/* 11575 */	stmt    | 3513   << off_ ,	//	blt xl =k_p__ asg15 jump unless protected
/* 11576 */	loadi   | r2     << dst_ | k_p__  << off_ ,
/* 11577 */	blt     | xl     << dst_ | r2     << src_ | asg15  << off_ ,
/* 11578 */	stmt    | 3514   << off_ ,	//	erb 209 keyword in assignment is protected
/* 11579 */	erb     | 209    << off_ ,
// asg15:
/* 11580 */	stmt    | 3515   << off_ ,	//asg15	mov kvabe(xl) wa  store new value
/* 11581 */	store   | wa     << dst_ | xl     << src_ | kvabe  << off_ ,
/* 11582 */	stmt    | 3516   << off_ ,	//	exi    return to asign caller
/* 11583 */	exi     | 0      << off_ ,
// asg16:
/* 11584 */	stmt    | 3517   << off_ ,	//asg16	sbi kvstl   subtract old limit
/* 11585 */	load    | r1     << dst_ | kvstl  << off_ ,
/* 11586 */	sbi     | r1     << dst_ ,
/* 11587 */	stmt    | 3518   << off_ ,	//	adi kvstc   add old counter
/* 11588 */	load    | r1     << dst_ | kvstc  << off_ ,
/* 11589 */	adi     | r1     << dst_ ,
/* 11590 */	stmt    | 3519   << off_ ,	//	sti kvstc   store course counter value
/* 11591 */	store   | ia     << dst_ | kvstc  << off_ ,
/* 11592 */	stmt    | 3520   << off_ ,	//	ldi kvstl   check if counting suppressed
/* 11593 */	load    | r1     << dst_ | kvstl  << off_ ,
/* 11594 */	ldi     | r1     << dst_ ,
/* 11595 */	stmt    | 3521   << off_ ,	//	ilt asg25   do not refine if so
/* 11596 */	ilt     | asg25  << off_ ,
/* 11597 */	stmt    | 3522   << off_ ,	//	mov wa stmcs  refine with counter breakout
/* 11598 */	load    | wa     << dst_ | stmcs  << off_ ,
/* 11599 */	stmt    | 3523   << off_ ,	//	sub wa stmct  values
/* 11600 */	load    | r2     << dst_ | stmct  << off_ ,
/* 11601 */	sub     | wa     << dst_ | r2     << src_ ,
/* 11602 */	stmt    | 3524   << off_ ,	//	mti wa   convert to integer
/* 11603 */	move    | ia     << dst_ | wa     << src_ ,
/* 11604 */	stmt    | 3525   << off_ ,	//	ngi    current-start value
/* 11605 */	ngi     ,
/* 11606 */	stmt    | 3526   << off_ ,	//	adi kvstc   add in course counter value
/* 11607 */	load    | r1     << dst_ | kvstc  << off_ ,
/* 11608 */	adi     | r1     << dst_ ,
/* 11609 */	stmt    | 3527   << off_ ,	//	sti kvstc   save refined value
/* 11610 */	store   | ia     << dst_ | kvstc  << off_ ,
// asg25:
/* 11611 */	stmt    | 3528   << off_ ,	//asg25	ldi icval(xr)   reload new limit value
/* 11612 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/* 11613 */	ldi     | r1     << dst_ ,
/* 11614 */	stmt    | 3529   << off_ ,	//	sti kvstl   store new limit value
/* 11615 */	store   | ia     << dst_ | kvstl  << off_ ,
/* 11616 */	stmt    | 3530   << off_ ,	//	jsr stgcc   recompute countdown counters
/* 11617 */	call    | stgcc  << off_ ,
/* 11618 */	stmt    | 3531   << off_ ,	//	exi    return to asign caller
/* 11619 */	exi     | 0      << off_ ,
// asg17:
/* 11620 */	stmt    | 3532   << off_ ,	//asg17	ble wa =nini9 error ok to signal if in range
/* 11621 */	loadi   | r2     << dst_ | nini9  << off_ ,
/* 11622 */	ble     | wa     << dst_ | r2     << src_ | error_ << off_ ,
// asg18:
/* 11623 */	stmt    | 3533   << off_ ,	//asg18	erb 210 keyword value assigned is negative or too large
/* 11624 */	erb     | 210    << off_ ,
// asg19:
/* 11625 */	stmt    | 3534   << off_ ,	//asg19	mov -(xs) wb  stack value
/* 11626 */	dca     | xs     << dst_ ,
/* 11627 */	store   | wb     << dst_ | xs     << src_ ,
/* 11628 */	stmt    | 3535   << off_ ,	//	jsr gtstg   convert to string
/* 11629 */	call    | gtstg  << off_ ,
/* 11630 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 11631 */	err     | 211    << off_ ,
/* 11632 */	stmt    | 3536   << off_ ,	//	mov r_etx xr  make assignment
/* 11633 */	store   | xr     << dst_ | r_etx  << off_ ,
/* 11634 */	stmt    | 3537   << off_ ,	//	exi    return to caller
/* 11635 */	exi     | 0      << off_ ,
// asg21:
/* 11636 */	stmt    | 3538   << off_ ,	//asg21	bgt wa =num02 asg18 moan if not 0,1, or 2
/* 11637 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 11638 */	bgt     | wa     << dst_ | r2     << src_ | asg18  << off_ ,
/* 11639 */	stmt    | 3539   << off_ ,	//	bze wa asg15  just assign if zero
/* 11640 */	bze     | wa     << dst_ | asg15  << off_ ,
/* 11641 */	stmt    | 3540   << off_ ,	//	bze pfdmp asg22  branch if first assignment
/* 11642 */	load    | r1     << dst_ | pfdmp  << off_ ,
/* 11643 */	bze     | r1     << dst_ | asg22  << off_ ,
/* 11644 */	stmt    | 3541   << off_ ,	//	beq wa pfdmp asg23 also if same value as before
/* 11645 */	load    | r2     << dst_ | pfdmp  << off_ ,
/* 11646 */	beq     | wa     << dst_ | r2     << src_ | asg23  << off_ ,
/* 11647 */	stmt    | 3542   << off_ ,	//	erb 268 inconsistent value assigned to keyword profile
/* 11648 */	erb     | 268    << off_ ,
// asg22:
/* 11649 */	stmt    | 3543   << off_ ,	//asg22	mov pfdmp wa  note value on first assignment
/* 11650 */	store   | wa     << dst_ | pfdmp  << off_ ,
// asg23:
/* 11651 */	stmt    | 3544   << off_ ,	//asg23	mov kvpfl wa  store new value
/* 11652 */	store   | wa     << dst_ | kvpfl  << off_ ,
/* 11653 */	stmt    | 3545   << off_ ,	//	jsr stgcc   recompute countdown counts
/* 11654 */	call    | stgcc  << off_ ,
/* 11655 */	stmt    | 3546   << off_ ,	//	jsr systm   get the time
/* 11656 */	sys     | systm_ << off_ ,
/* 11657 */	stmt    | 3547   << off_ ,	//	sti pfstm   fudge some kind of start time
/* 11658 */	store   | ia     << dst_ | pfstm  << off_ ,
/* 11659 */	stmt    | 3548   << off_ ,	//	exi    return to asign caller
/* 11660 */	exi     | 0      << off_ ,
// asg24:
/* 11661 */	stmt    | 3549   << off_ ,	//asg24	bge wa =mnlen asg15 if acceptable value
/* 11662 */	loadi   | r2     << dst_ | mnlen  << off_ ,
/* 11663 */	bge     | wa     << dst_ | r2     << src_ | asg15  << off_ ,
/* 11664 */	stmt    | 3550   << off_ ,	//	erb 287 value assigned to keyword maxlngth is too small
/* 11665 */	erb     | 287    << off_ ,
// asg26:
/* 11666 */	stmt    | 3551   << off_ ,	//asg26	bnz wa asg15  if acceptable value
/* 11667 */	bnz     | wa     << dst_ | asg15  << off_ ,
/* 11668 */	stmt    | 3552   << off_ ,	//	erb 274 value assigned to keyword fullscan is zero
/* 11669 */	erb     | 274    << off_ ,
// asinp:
/* 11670 */	stmt    | 3553   << off_ ,	//asinp	prc r 1  entry point, recursive
/* 11671 */	stmt    | 3554   << off_ ,	//	add xl wa  point to variable
/* 11672 */	add     | xl     << dst_ | wa     << src_ ,
/* 11673 */	stmt    | 3555   << off_ ,	//	mov xr (xl)  load current contents
/* 11674 */	load    | xr     << dst_ | xl     << src_ ,
/* 11675 */	stmt    | 3556   << off_ ,	//	beq (xr) =b_trt asnp1 jump if trapped
/* 11676 */	load    | r1     << dst_ | xr     << src_ ,
/* 11677 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 11678 */	beq     | r1     << dst_ | r2     << src_ | asnp1  << off_ ,
/* 11679 */	stmt    | 3557   << off_ ,	//	mov (xl) wb  else perform assignment
/* 11680 */	store   | wb     << dst_ | xl     << src_ ,
/* 11681 */	stmt    | 3558   << off_ ,	//	zer xl   clear garbage value in xl
/* 11682 */	move    | xl     << dst_ ,
/* 11683 */	stmt    | 3559   << off_ ,	//	exi    return to asinp caller
/* 11684 */	exi     | 0      << off_ ,
// asnp1:
/* 11685 */	stmt    | 3560   << off_ ,	//asnp1	sub xl wa  restore base pointer
/* 11686 */	sub     | xl     << dst_ | wa     << src_ ,
/* 11687 */	stmt    | 3561   << off_ ,	//	mov -(xs) pmssl  stack subject string length
/* 11688 */	load    | r1     << dst_ | pmssl  << off_ ,
/* 11689 */	dca     | xs     << dst_ ,
/* 11690 */	store   | r1     << dst_ | xs     << src_ ,
/* 11691 */	stmt    | 3562   << off_ ,	//	mov -(xs) pmhbs  stack history stack base ptr
/* 11692 */	load    | r1     << dst_ | pmhbs  << off_ ,
/* 11693 */	dca     | xs     << dst_ ,
/* 11694 */	store   | r1     << dst_ | xs     << src_ ,
/* 11695 */	stmt    | 3563   << off_ ,	//	mov -(xs) r_pms  stack subject string pointer
/* 11696 */	load    | r1     << dst_ | r_pms  << off_ ,
/* 11697 */	dca     | xs     << dst_ ,
/* 11698 */	store   | r1     << dst_ | xs     << src_ ,
/* 11699 */	stmt    | 3564   << off_ ,	//	mov -(xs) pmdfl  stack dot flag
/* 11700 */	load    | r1     << dst_ | pmdfl  << off_ ,
/* 11701 */	dca     | xs     << dst_ ,
/* 11702 */	store   | r1     << dst_ | xs     << src_ ,
/* 11703 */	stmt    | 3565   << off_ ,	//	jsr asign   call full-blown assignment routine
/* 11704 */	call    | asign  << off_ ,
/* 11705 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 11706 */	ppm     | asnp2  << off_ ,
/* 11707 */	stmt    | 3566   << off_ ,	//	mov pmdfl (xs)+  restore dot flag
/* 11708 */	load    | r1     << dst_ | xs     << src_ ,
/* 11709 */	ica     | xs     << dst_ ,
/* 11710 */	store   | r1     << dst_ | pmdfl  << off_ ,
/* 11711 */	stmt    | 3567   << off_ ,	//	mov r_pms (xs)+  restore subject string pointer
/* 11712 */	load    | r1     << dst_ | xs     << src_ ,
/* 11713 */	ica     | xs     << dst_ ,
/* 11714 */	store   | r1     << dst_ | r_pms  << off_ ,
/* 11715 */	stmt    | 3568   << off_ ,	//	mov pmhbs (xs)+  restore history stack base pointer
/* 11716 */	load    | r1     << dst_ | xs     << src_ ,
/* 11717 */	ica     | xs     << dst_ ,
/* 11718 */	store   | r1     << dst_ | pmhbs  << off_ ,
/* 11719 */	stmt    | 3569   << off_ ,	//	mov pmssl (xs)+  restore subject string length
/* 11720 */	load    | r1     << dst_ | xs     << src_ ,
/* 11721 */	ica     | xs     << dst_ ,
/* 11722 */	store   | r1     << dst_ | pmssl  << off_ ,
/* 11723 */	stmt    | 3570   << off_ ,	//	exi    return to asinp caller
/* 11724 */	exi     | 0      << off_ ,
// asnp2:
/* 11725 */	stmt    | 3571   << off_ ,	//asnp2	mov pmdfl (xs)+  restore dot flag
/* 11726 */	load    | r1     << dst_ | xs     << src_ ,
/* 11727 */	ica     | xs     << dst_ ,
/* 11728 */	store   | r1     << dst_ | pmdfl  << off_ ,
/* 11729 */	stmt    | 3572   << off_ ,	//	mov r_pms (xs)+  restore subject string pointer
/* 11730 */	load    | r1     << dst_ | xs     << src_ ,
/* 11731 */	ica     | xs     << dst_ ,
/* 11732 */	store   | r1     << dst_ | r_pms  << off_ ,
/* 11733 */	stmt    | 3573   << off_ ,	//	mov pmhbs (xs)+  restore history stack base pointer
/* 11734 */	load    | r1     << dst_ | xs     << src_ ,
/* 11735 */	ica     | xs     << dst_ ,
/* 11736 */	store   | r1     << dst_ | pmhbs  << off_ ,
/* 11737 */	stmt    | 3574   << off_ ,	//	mov pmssl (xs)+  restore subject string length
/* 11738 */	load    | r1     << dst_ | xs     << src_ ,
/* 11739 */	ica     | xs     << dst_ ,
/* 11740 */	store   | r1     << dst_ | pmssl  << off_ ,
/* 11741 */	stmt    | 3575   << off_ ,	//	exi 1   take failure exit
/* 11742 */	exi     | 1      << off_ ,
// blkln:
/* 11743 */	stmt    | 3576   << off_ ,	//blkln	prc e 0  entry point
/* 11744 */	stmt    | 3577   << off_ ,	//	mov xl wa  copy first word
/* 11745 */	move    | xl     << dst_ | wa     << src_ ,
/* 11746 */	stmt    | 3578   << off_ ,	//	lei xl   get entry id (bl_xx)
/* 11747 */	lei     | xl     << dst_ ,
/* 11748 */	stmt    | 3579   << off_ ,	//	bsw xl bl___ bln00 switch on block type
/* 11749 */	loadi   | r1     << dst_ | bl___  << off_ ,
/* 11750 */	bsw     | xl     << dst_ | r1     << src_ | bln00  << off_ ,
/* 11751 */	bln01   ,
/* 11752 */	bln12   ,
/* 11753 */	bln12   ,
/* 11754 */	bln07   ,
/* 11755 */	bln03   ,
/* 11756 */	bln02   ,
/* 11757 */	bln03   ,
/* 11758 */	bln04   ,
/* 11759 */	bln09   ,
/* 11760 */	bln10   ,
/* 11761 */	bln02   ,
/* 11762 */	bln01   ,
/* 11763 */	bln01   ,
/* 11764 */	bln00   ,
/* 11765 */	bln00   ,
/* 11766 */	bln00   ,
/* 11767 */	bln08   ,
/* 11768 */	bln05   ,
/* 11769 */	bln00   ,
/* 11770 */	bln00   ,
/* 11771 */	bln00   ,
/* 11772 */	bln06   ,
/* 11773 */	bln01   ,
/* 11774 */	bln01   ,
/* 11775 */	bln03   ,
/* 11776 */	bln05   ,
/* 11777 */	bln03   ,
/* 11778 */	bln01   ,
/* 11779 */	bln04   ,
// bln00:
/* 11780 */	stmt    | 3580   << off_ ,	//bln00	mov wa num01(xr)  load length
/* 11781 */	load    | wa     << dst_ | xr     << src_ | num01  << off_ ,
/* 11782 */	stmt    | 3581   << off_ ,	//	exi    return to blkln caller
/* 11783 */	exi     | 0      << off_ ,
// bln01:
/* 11784 */	stmt    | 3582   << off_ ,	//bln01	mov wa num02(xr)  load length from third word
/* 11785 */	load    | wa     << dst_ | xr     << src_ | num02  << off_ ,
/* 11786 */	stmt    | 3583   << off_ ,	//	exi    return to blkln caller
/* 11787 */	exi     | 0      << off_ ,
// bln02:
/* 11788 */	stmt    | 3584   << off_ ,	//bln02	mov wa *num02  load length (two words)
/* 11789 */	loadi   | wa     << dst_ | num02  << off_ ,
/* 11790 */	stmt    | 3585   << off_ ,	//	exi    return to blkln caller
/* 11791 */	exi     | 0      << off_ ,
// bln03:
/* 11792 */	stmt    | 3586   << off_ ,	//bln03	mov wa *num03  load length (three words)
/* 11793 */	loadi   | wa     << dst_ | num03  << off_ ,
/* 11794 */	stmt    | 3587   << off_ ,	//	exi    return to blkln caller
/* 11795 */	exi     | 0      << off_ ,
// bln04:
/* 11796 */	stmt    | 3588   << off_ ,	//bln04	mov wa *num04  load length (four words)
/* 11797 */	loadi   | wa     << dst_ | num04  << off_ ,
/* 11798 */	stmt    | 3589   << off_ ,	//	exi    return to blkln caller
/* 11799 */	exi     | 0      << off_ ,
// bln05:
/* 11800 */	stmt    | 3590   << off_ ,	//bln05	mov wa *num05  load length
/* 11801 */	loadi   | wa     << dst_ | num05  << off_ ,
/* 11802 */	stmt    | 3591   << off_ ,	//	exi    return to blkln caller
/* 11803 */	exi     | 0      << off_ ,
// bln06:
/* 11804 */	stmt    | 3592   << off_ ,	//bln06	mov wa *ctsi_  set size of ctblk
/* 11805 */	loadi   | wa     << dst_ | ctsi_  << off_ ,
/* 11806 */	stmt    | 3593   << off_ ,	//	exi    return to blkln caller
/* 11807 */	exi     | 0      << off_ ,
// bln07:
/* 11808 */	stmt    | 3594   << off_ ,	//bln07	mov wa *icsi_  set size of icblk
/* 11809 */	loadi   | wa     << dst_ | icsi_  << off_ ,
/* 11810 */	stmt    | 3595   << off_ ,	//	exi    return to blkln caller
/* 11811 */	exi     | 0      << off_ ,
// bln08:
/* 11812 */	stmt    | 3596   << off_ ,	//bln08	mov xl pddfp(xr)  point to dfblk
/* 11813 */	load    | xl     << dst_ | xr     << src_ | pddfp  << off_ ,
/* 11814 */	stmt    | 3597   << off_ ,	//	mov wa dfpdl(xl)  load pdblk length from dfblk
/* 11815 */	load    | wa     << dst_ | xl     << src_ | dfpdl  << off_ ,
/* 11816 */	stmt    | 3598   << off_ ,	//	exi    return to blkln caller
/* 11817 */	exi     | 0      << off_ ,
// bln09:
/* 11818 */	stmt    | 3599   << off_ ,	//bln09	mov wa *rcsi_  set size of rcblk
/* 11819 */	loadi   | wa     << dst_ | rcsi_  << off_ ,
/* 11820 */	stmt    | 3600   << off_ ,	//	exi    return to blkln caller
/* 11821 */	exi     | 0      << off_ ,
// bln10:
/* 11822 */	stmt    | 3601   << off_ ,	//bln10	mov wa sclen(xr)  load length in characters
/* 11823 */	load    | wa     << dst_ | xr     << src_ | sclen  << off_ ,
/* 11824 */	stmt    | 3602   << off_ ,	//	ctb wa scsi_  calculate length in bytes
/* 11825 */	ctb     | wa     << dst_ | scsi_  << off_ ,
/* 11826 */	stmt    | 3603   << off_ ,	//	exi    return to blkln caller
/* 11827 */	exi     | 0      << off_ ,
// bln12:
/* 11828 */	stmt    | 3604   << off_ ,	//bln12	mov wa num03(xr)  load length from cdlen/exlen
/* 11829 */	load    | wa     << dst_ | xr     << src_ | num03  << off_ ,
/* 11830 */	stmt    | 3605   << off_ ,	//	exi    return to blkln caller
/* 11831 */	exi     | 0      << off_ ,
// copyb:
/* 11832 */	stmt    | 3606   << off_ ,	//copyb	prc n 1  entry point
/* 11833 */	prc     | 3      << off_ ,
/* 11834 */	stmt    | 3607   << off_ ,	//	mov xr (xs)  load argument
/* 11835 */	load    | xr     << dst_ | xs     << src_ ,
/* 11836 */	stmt    | 3608   << off_ ,	//	beq xr =nulls cop10 return argument if it is null
/* 11837 */	loadi   | r2     << dst_ | nulls  << off_ ,
/* 11838 */	beq     | xr     << dst_ | r2     << src_ | cop10  << off_ ,
/* 11839 */	stmt    | 3609   << off_ ,	//	mov wa (xr)  else load type word
/* 11840 */	load    | wa     << dst_ | xr     << src_ ,
/* 11841 */	stmt    | 3610   << off_ ,	//	mov wb wa  copy type word
/* 11842 */	move    | wb     << dst_ | wa     << src_ ,
/* 11843 */	stmt    | 3611   << off_ ,	//	jsr blkln   get length of argument block
/* 11844 */	call    | blkln  << off_ ,
/* 11845 */	stmt    | 3612   << off_ ,	//	mov xl xr  copy pointer
/* 11846 */	move    | xl     << dst_ | xr     << src_ ,
/* 11847 */	stmt    | 3613   << off_ ,	//	jsr alloc   allocate block of same size
/* 11848 */	call    | alloc  << off_ ,
/* 11849 */	stmt    | 3614   << off_ ,	//	mov (xs) xr  store pointer to copy
/* 11850 */	store   | xr     << dst_ | xs     << src_ ,
/* 11851 */	stmt    | 3615   << off_ ,	//	mvw    copy contents of old block to new
/* 11852 */	mvw     ,
/* 11853 */	stmt    | 3616   << off_ ,	//	zer xl   clear garbage xl
/* 11854 */	move    | xl     << dst_ ,
/* 11855 */	stmt    | 3617   << off_ ,	//	mov xr (xs)  reload pointer to start of copy
/* 11856 */	load    | xr     << dst_ | xs     << src_ ,
/* 11857 */	stmt    | 3618   << off_ ,	//	beq wb =b_tbt cop05 jump if table
/* 11858 */	loadi   | r2     << dst_ | b_tbt  << off_ ,
/* 11859 */	beq     | wb     << dst_ | r2     << src_ | cop05  << off_ ,
/* 11860 */	stmt    | 3619   << off_ ,	//	beq wb =b_vct cop01 jump if vector
/* 11861 */	loadi   | r2     << dst_ | b_vct  << off_ ,
/* 11862 */	beq     | wb     << dst_ | r2     << src_ | cop01  << off_ ,
/* 11863 */	stmt    | 3620   << off_ ,	//	beq wb =b_pdt cop01 jump if program defined
/* 11864 */	loadi   | r2     << dst_ | b_pdt  << off_ ,
/* 11865 */	beq     | wb     << dst_ | r2     << src_ | cop01  << off_ ,
/* 11866 */	stmt    | 3621   << off_ ,	//	bne wb =b_art cop10 return copy if not array
/* 11867 */	loadi   | r2     << dst_ | b_art  << off_ ,
/* 11868 */	bne     | wb     << dst_ | r2     << src_ | cop10  << off_ ,
/* 11869 */	stmt    | 3622   << off_ ,	//	add xr arofs(xr)  point to prototype field
/* 11870 */	load    | r2     << dst_ | xr     << src_ | arofs  << off_ ,
/* 11871 */	add     | xr     << dst_ | r2     << src_ ,
/* 11872 */	stmt    | 3623   << off_ ,	//	brn cop02   jump to merge
/* 11873 */	brn     | cop02  << off_ ,
// cop01:
/* 11874 */	stmt    | 3624   << off_ ,	//cop01	add xr *pdfld  point to pdfld = vcvls
/* 11875 */	loadi   | r2     << dst_ | pdfld  << off_ ,
/* 11876 */	add     | xr     << dst_ | r2     << src_ ,
// cop02:
/* 11877 */	stmt    | 3625   << off_ ,	//cop02	mov xl (xr)  load next pointer
/* 11878 */	load    | xl     << dst_ | xr     << src_ ,
// cop03:
/* 11879 */	stmt    | 3626   << off_ ,	//cop03	bne (xl) =b_trt cop04 jump if not trapped
/* 11880 */	load    | r1     << dst_ | xl     << src_ ,
/* 11881 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 11882 */	bne     | r1     << dst_ | r2     << src_ | cop04  << off_ ,
/* 11883 */	stmt    | 3627   << off_ ,	//	mov xl trval(xl)  else point to next value
/* 11884 */	load    | xl     << dst_ | xl     << src_ | trval  << off_ ,
/* 11885 */	stmt    | 3628   << off_ ,	//	brn cop03   and loop back
/* 11886 */	brn     | cop03  << off_ ,
// cop04:
/* 11887 */	stmt    | 3629   << off_ ,	//cop04	mov (xr)+ xl  store real value, bump pointer
/* 11888 */	store   | xl     << dst_ | xr     << src_ ,
/* 11889 */	ica     | xr     << dst_ ,
/* 11890 */	stmt    | 3630   << off_ ,	//	bne xr dnamp cop02 loop back if more to go
/* 11891 */	load    | r2     << dst_ | dnamp  << off_ ,
/* 11892 */	bne     | xr     << dst_ | r2     << src_ | cop02  << off_ ,
/* 11893 */	stmt    | 3631   << off_ ,	//	brn cop09   else jump to exit
/* 11894 */	brn     | cop09  << off_ ,
// cop05:
/* 11895 */	stmt    | 3632   << off_ ,	//cop05	zer idval(xr)   zero id to stop dump blowing up
/* 11896 */	store   | r0     << dst_ | xr     << src_ | idval  << off_ ,
/* 11897 */	stmt    | 3633   << off_ ,	//	mov wa *tesi_  set size of teblk
/* 11898 */	loadi   | wa     << dst_ | tesi_  << off_ ,
/* 11899 */	stmt    | 3634   << off_ ,	//	mov wc *tbbuk  set initial offset
/* 11900 */	loadi   | wc     << dst_ | tbbuk  << off_ ,
// cop06:
/* 11901 */	stmt    | 3635   << off_ ,	//cop06	mov xr (xs)  load table pointer
/* 11902 */	load    | xr     << dst_ | xs     << src_ ,
/* 11903 */	stmt    | 3636   << off_ ,	//	beq wc tblen(xr) cop09 jump to exit if all done
/* 11904 */	load    | r2     << dst_ | xr     << src_ | tblen  << off_ ,
/* 11905 */	beq     | wc     << dst_ | r2     << src_ | cop09  << off_ ,
/* 11906 */	stmt    | 3637   << off_ ,	//	mov wb wc  else copy offset
/* 11907 */	move    | wb     << dst_ | wc     << src_ ,
/* 11908 */	stmt    | 3638   << off_ ,	//	sub wb *tenxt  subtract link offset to merge
/* 11909 */	loadi   | r2     << dst_ | tenxt  << off_ ,
/* 11910 */	sub     | wb     << dst_ | r2     << src_ ,
/* 11911 */	stmt    | 3639   << off_ ,	//	add xr wb  next bucket header less link offset
/* 11912 */	add     | xr     << dst_ | wb     << src_ ,
/* 11913 */	stmt    | 3640   << off_ ,	//	ica wc   bump offset
/* 11914 */	ica     | wc     << dst_ ,
// cop07:
/* 11915 */	stmt    | 3641   << off_ ,	//cop07	mov xl tenxt(xr)  load pointer to next teblk
/* 11916 */	load    | xl     << dst_ | xr     << src_ | tenxt  << off_ ,
/* 11917 */	stmt    | 3642   << off_ ,	//	mov tenxt(xr) (xs)  set end of chain pointer in case
/* 11918 */	load    | r1     << dst_ | xs     << src_ ,
/* 11919 */	store   | r1     << dst_ | xr     << src_ | tenxt  << off_ ,
/* 11920 */	stmt    | 3643   << off_ ,	//	beq (xl) =b_tbt cop06 back for next bucket if chain end
/* 11921 */	load    | r1     << dst_ | xl     << src_ ,
/* 11922 */	loadi   | r2     << dst_ | b_tbt  << off_ ,
/* 11923 */	beq     | r1     << dst_ | r2     << src_ | cop06  << off_ ,
/* 11924 */	stmt    | 3644   << off_ ,	//	sub xr wb  point to head of previous block
/* 11925 */	sub     | xr     << dst_ | wb     << src_ ,
/* 11926 */	stmt    | 3645   << off_ ,	//	mov -(xs) xr  stack ptr to previous block
/* 11927 */	dca     | xs     << dst_ ,
/* 11928 */	store   | xr     << dst_ | xs     << src_ ,
/* 11929 */	stmt    | 3646   << off_ ,	//	mov wa *tesi_  set size of teblk
/* 11930 */	loadi   | wa     << dst_ | tesi_  << off_ ,
/* 11931 */	stmt    | 3647   << off_ ,	//	jsr alloc   allocate new teblk
/* 11932 */	call    | alloc  << off_ ,
/* 11933 */	stmt    | 3648   << off_ ,	//	mov -(xs) xr  stack ptr to new teblk
/* 11934 */	dca     | xs     << dst_ ,
/* 11935 */	store   | xr     << dst_ | xs     << src_ ,
/* 11936 */	stmt    | 3649   << off_ ,	//	mvw    copy old teblk to new teblk
/* 11937 */	mvw     ,
/* 11938 */	stmt    | 3650   << off_ ,	//	mov xr (xs)+  restore pointer to new teblk
/* 11939 */	load    | xr     << dst_ | xs     << src_ ,
/* 11940 */	ica     | xs     << dst_ ,
/* 11941 */	stmt    | 3651   << off_ ,	//	mov xl (xs)+  restore pointer to previous block
/* 11942 */	load    | xl     << dst_ | xs     << src_ ,
/* 11943 */	ica     | xs     << dst_ ,
/* 11944 */	stmt    | 3652   << off_ ,	//	add xl wb  add offset back in
/* 11945 */	add     | xl     << dst_ | wb     << src_ ,
/* 11946 */	stmt    | 3653   << off_ ,	//	mov tenxt(xl) xr  link new block to previous
/* 11947 */	store   | xr     << dst_ | xl     << src_ | tenxt  << off_ ,
/* 11948 */	stmt    | 3654   << off_ ,	//	mov xl xr  copy pointer to new block
/* 11949 */	move    | xl     << dst_ | xr     << src_ ,
// cop08:
/* 11950 */	stmt    | 3655   << off_ ,	//cop08	mov xl teval(xl)  load value
/* 11951 */	load    | xl     << dst_ | xl     << src_ | teval  << off_ ,
/* 11952 */	stmt    | 3656   << off_ ,	//	beq (xl) =b_trt cop08 loop back if trapped
/* 11953 */	load    | r1     << dst_ | xl     << src_ ,
/* 11954 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 11955 */	beq     | r1     << dst_ | r2     << src_ | cop08  << off_ ,
/* 11956 */	stmt    | 3657   << off_ ,	//	mov teval(xr) xl  store untrapped value in teblk
/* 11957 */	store   | xl     << dst_ | xr     << src_ | teval  << off_ ,
/* 11958 */	stmt    | 3658   << off_ ,	//	zer wb   zero offset within teblk
/* 11959 */	move    | wb     << dst_ ,
/* 11960 */	stmt    | 3659   << off_ ,	//	brn cop07   back for next teblk
/* 11961 */	brn     | cop07  << off_ ,
// cop09:
/* 11962 */	stmt    | 3660   << off_ ,	//cop09	mov xr (xs)+  load pointer to block
/* 11963 */	load    | xr     << dst_ | xs     << src_ ,
/* 11964 */	ica     | xs     << dst_ ,
/* 11965 */	stmt    | 3661   << off_ ,	//	exi    return
/* 11966 */	exi     | 300    << off_ ,
// cop10:
/* 11967 */	stmt    | 3662   << off_ ,	//cop10	exi 1   return
/* 11968 */	exi     | 301    << off_ ,
// cdgcg:
/* 11969 */	stmt    | 3663   << off_ ,	//cdgcg	prc e 0  entry point
/* 11970 */	stmt    | 3664   << off_ ,	//	mov xl cmopn(xr)  get unary goto operator
/* 11971 */	load    | xl     << dst_ | xr     << src_ | cmopn  << off_ ,
/* 11972 */	stmt    | 3665   << off_ ,	//	mov xr cmrop(xr)  point to goto operand
/* 11973 */	load    | xr     << dst_ | xr     << src_ | cmrop  << off_ ,
/* 11974 */	stmt    | 3666   << off_ ,	//	beq xl =opdvd cdgc2 jump if direct goto
/* 11975 */	loadi   | r2     << dst_ | opdvd  << off_ ,
/* 11976 */	beq     | xl     << dst_ | r2     << src_ | cdgc2  << off_ ,
/* 11977 */	stmt    | 3667   << off_ ,	//	jsr cdgnm   generate opnd by name if not direct
/* 11978 */	call    | cdgnm  << off_ ,
// cdgc1:
/* 11979 */	stmt    | 3668   << off_ ,	//cdgc1	mov wa xl  goto operator
/* 11980 */	move    | wa     << dst_ | xl     << src_ ,
/* 11981 */	stmt    | 3669   << off_ ,	//	jsr cdwrd   generate it
/* 11982 */	call    | cdwrd  << off_ ,
/* 11983 */	stmt    | 3670   << off_ ,	//	exi    return to caller
/* 11984 */	exi     | 0      << off_ ,
// cdgc2:
/* 11985 */	stmt    | 3671   << off_ ,	//cdgc2	jsr cdgvl   generate operand by value
/* 11986 */	call    | cdgvl  << off_ ,
/* 11987 */	stmt    | 3672   << off_ ,	//	brn cdgc1   merge to return
/* 11988 */	brn     | cdgc1  << off_ ,
// cdgex:
/* 11989 */	stmt    | 3673   << off_ ,	//cdgex	prc r 0  entry point, recursive
/* 11990 */	stmt    | 3674   << off_ ,	//	blo (xl) =b_vr_ cdgx1 jump if not variable
/* 11991 */	load    | r1     << dst_ | xl     << src_ ,
/* 11992 */	loadi   | r2     << dst_ | b_vr_  << off_ ,
/* 11993 */	blo     | r1     << dst_ | r2     << src_ | cdgx1  << off_ ,
/* 11994 */	stmt    | 3675   << off_ ,	//	mov wa *sesi_  set size of seblk
/* 11995 */	loadi   | wa     << dst_ | sesi_  << off_ ,
/* 11996 */	stmt    | 3676   << off_ ,	//	jsr alloc   allocate space for seblk
/* 11997 */	call    | alloc  << off_ ,
/* 11998 */	stmt    | 3677   << off_ ,	//	mov (xr) =b_sel  set type word
/* 11999 */	loadi   | r1     << dst_ | b_sel  << off_ ,
/* 12000 */	store   | r1     << dst_ | xr     << src_ ,
/* 12001 */	stmt    | 3678   << off_ ,	//	mov sevar(xr) xl  store vrblk pointer
/* 12002 */	store   | xl     << dst_ | xr     << src_ | sevar  << off_ ,
/* 12003 */	stmt    | 3679   << off_ ,	//	exi    return to cdgex caller
/* 12004 */	exi     | 0      << off_ ,
// cdgx1:
/* 12005 */	stmt    | 3680   << off_ ,	//cdgx1	mov xr xl  copy tree pointer
/* 12006 */	move    | xr     << dst_ | xl     << src_ ,
/* 12007 */	stmt    | 3681   << off_ ,	//	mov -(xs) wc  save wc
/* 12008 */	dca     | xs     << dst_ ,
/* 12009 */	store   | wc     << dst_ | xs     << src_ ,
/* 12010 */	stmt    | 3682   << off_ ,	//	mov xl cwcof  save current offset
/* 12011 */	load    | xl     << dst_ | cwcof  << off_ ,
/* 12012 */	stmt    | 3683   << off_ ,	//	bze wa cdgx2  jump if by value
/* 12013 */	bze     | wa     << dst_ | cdgx2  << off_ ,
/* 12014 */	stmt    | 3684   << off_ ,	//	mov wa (xr)  get type word
/* 12015 */	load    | wa     << dst_ | xr     << src_ ,
/* 12016 */	stmt    | 3685   << off_ ,	//	bne wa =b_cmt cdgx2 call by value if not cmblk
/* 12017 */	loadi   | r2     << dst_ | b_cmt  << off_ ,
/* 12018 */	bne     | wa     << dst_ | r2     << src_ | cdgx2  << off_ ,
/* 12019 */	stmt    | 3686   << off_ ,	//	bge cmtyp(xr) =c__nm cdgx2 jump if cmblk only by value
/* 12020 */	load    | r1     << dst_ | xr     << src_ | cmtyp  << off_ ,
/* 12021 */	loadi   | r2     << dst_ | c__nm  << off_ ,
/* 12022 */	bge     | r1     << dst_ | r2     << src_ | cdgx2  << off_ ,
/* 12023 */	stmt    | 3687   << off_ ,	//	jsr cdgnm   generate code by name
/* 12024 */	call    | cdgnm  << off_ ,
/* 12025 */	stmt    | 3688   << off_ ,	//	mov wa =ornm_  load return by name word
/* 12026 */	loadi   | wa     << dst_ | ornm_  << off_ ,
/* 12027 */	stmt    | 3689   << off_ ,	//	brn cdgx3   merge with value case
/* 12028 */	brn     | cdgx3  << off_ ,
// cdgx2:
/* 12029 */	stmt    | 3690   << off_ ,	//cdgx2	jsr cdgvl   generate code by value
/* 12030 */	call    | cdgvl  << off_ ,
/* 12031 */	stmt    | 3691   << off_ ,	//	mov wa =orvl_  load return by value word
/* 12032 */	loadi   | wa     << dst_ | orvl_  << off_ ,
// cdgx3:
/* 12033 */	stmt    | 3692   << off_ ,	//cdgx3	jsr cdwrd   generate return word
/* 12034 */	call    | cdwrd  << off_ ,
/* 12035 */	stmt    | 3693   << off_ ,	//	jsr exbld   build exblk
/* 12036 */	call    | exbld  << off_ ,
/* 12037 */	stmt    | 3694   << off_ ,	//	mov wc (xs)+  restore wc
/* 12038 */	load    | wc     << dst_ | xs     << src_ ,
/* 12039 */	ica     | xs     << dst_ ,
/* 12040 */	stmt    | 3695   << off_ ,	//	exi    return to cdgex caller
/* 12041 */	exi     | 0      << off_ ,
// cdgnm:
/* 12042 */	stmt    | 3696   << off_ ,	//cdgnm	prc r 0  entry point, recursive
/* 12043 */	stmt    | 3697   << off_ ,	//	mov -(xs) xl  save entry xl
/* 12044 */	dca     | xs     << dst_ ,
/* 12045 */	store   | xl     << dst_ | xs     << src_ ,
/* 12046 */	stmt    | 3698   << off_ ,	//	mov -(xs) wb  save entry wb
/* 12047 */	dca     | xs     << dst_ ,
/* 12048 */	store   | wb     << dst_ | xs     << src_ ,
/* 12049 */	stmt    | 3699   << off_ ,	//	chk    check for stack overflow
/* 12050 */	chk     ,
/* 12051 */	stmt    | 3700   << off_ ,	//	mov wa (xr)  load type word
/* 12052 */	load    | wa     << dst_ | xr     << src_ ,
/* 12053 */	stmt    | 3701   << off_ ,	//	beq wa =b_cmt cgn04 jump if cmblk
/* 12054 */	loadi   | r2     << dst_ | b_cmt  << off_ ,
/* 12055 */	beq     | wa     << dst_ | r2     << src_ | cgn04  << off_ ,
/* 12056 */	stmt    | 3702   << off_ ,	//	bhi wa =b_vr_ cgn02 jump if simple variable
/* 12057 */	loadi   | r2     << dst_ | b_vr_  << off_ ,
/* 12058 */	bhi     | wa     << dst_ | r2     << src_ | cgn02  << off_ ,
// cgn01:
/* 12059 */	stmt    | 3703   << off_ ,	//cgn01	erb 212 syntax error: value used where name is required
/* 12060 */	erb     | 212    << off_ ,
// cgn02:
/* 12061 */	stmt    | 3704   << off_ ,	//cgn02	mov wa =olvn_  load variable load call
/* 12062 */	loadi   | wa     << dst_ | olvn_  << off_ ,
/* 12063 */	stmt    | 3705   << off_ ,	//	jsr cdwrd   generate it
/* 12064 */	call    | cdwrd  << off_ ,
/* 12065 */	stmt    | 3706   << off_ ,	//	mov wa xr  copy vrblk pointer
/* 12066 */	move    | wa     << dst_ | xr     << src_ ,
/* 12067 */	stmt    | 3707   << off_ ,	//	jsr cdwrd   generate vrblk pointer
/* 12068 */	call    | cdwrd  << off_ ,
// cgn03:
/* 12069 */	stmt    | 3708   << off_ ,	//cgn03	mov wb (xs)+  restore entry wb
/* 12070 */	load    | wb     << dst_ | xs     << src_ ,
/* 12071 */	ica     | xs     << dst_ ,
/* 12072 */	stmt    | 3709   << off_ ,	//	mov xl (xs)+  restore entry xl
/* 12073 */	load    | xl     << dst_ | xs     << src_ ,
/* 12074 */	ica     | xs     << dst_ ,
/* 12075 */	stmt    | 3710   << off_ ,	//	exi    return to cdgnm caller
/* 12076 */	exi     | 0      << off_ ,
// cgn04:
/* 12077 */	stmt    | 3711   << off_ ,	//cgn04	mov xl xr  copy cmblk pointer
/* 12078 */	move    | xl     << dst_ | xr     << src_ ,
/* 12079 */	stmt    | 3712   << off_ ,	//	mov xr cmtyp(xr)  load cmblk type
/* 12080 */	load    | xr     << dst_ | xr     << src_ | cmtyp  << off_ ,
/* 12081 */	stmt    | 3713   << off_ ,	//	bge xr =c__nm cgn01 error if not name operand
/* 12082 */	loadi   | r2     << dst_ | c__nm  << off_ ,
/* 12083 */	bge     | xr     << dst_ | r2     << src_ | cgn01  << off_ ,
/* 12084 */	stmt    | 3714   << off_ ,	//	bsw xr c__nm  else switch on type
/* 12085 */	loadi   | r1     << dst_ | c__nm  << off_ ,
/* 12086 */	bsw     | xr     << dst_ | r1     << src_ ,
/* 12087 */	cgn05   ,
/* 12088 */	cgn08   ,
/* 12089 */	cgn09   ,
/* 12090 */	cgn10   ,
/* 12091 */	cgn11   ,
/* 12092 */	cgn08   ,
/* 12093 */	cgn08   ,
// cgn05:
/* 12094 */	stmt    | 3715   << off_ ,	//cgn05	mov wb *cmopn  point to array operand
/* 12095 */	loadi   | wb     << dst_ | cmopn  << off_ ,
// cgn06:
/* 12096 */	stmt    | 3716   << off_ ,	//cgn06	jsr cmgen   generate code for next operand
/* 12097 */	call    | cmgen  << off_ ,
/* 12098 */	stmt    | 3717   << off_ ,	//	mov wc cmlen(xl)  load length of cmblk
/* 12099 */	load    | wc     << dst_ | xl     << src_ | cmlen  << off_ ,
/* 12100 */	stmt    | 3718   << off_ ,	//	blt wb wc cgn06 loop till all generated
/* 12101 */	blt     | wb     << dst_ | wc     << src_ | cgn06  << off_ ,
/* 12102 */	stmt    | 3719   << off_ ,	//	mov wa =oaon_  load one-subscript case call
/* 12103 */	loadi   | wa     << dst_ | oaon_  << off_ ,
/* 12104 */	stmt    | 3720   << off_ ,	//	beq wc *cmar1 cgn07 jump to exit if one subscript case
/* 12105 */	loadi   | r2     << dst_ | cmar1  << off_ ,
/* 12106 */	beq     | wc     << dst_ | r2     << src_ | cgn07  << off_ ,
/* 12107 */	stmt    | 3721   << off_ ,	//	mov wa =oamn_  else load multi-subscript case call
/* 12108 */	loadi   | wa     << dst_ | oamn_  << off_ ,
/* 12109 */	stmt    | 3722   << off_ ,	//	jsr cdwrd   generate call
/* 12110 */	call    | cdwrd  << off_ ,
/* 12111 */	stmt    | 3723   << off_ ,	//	mov wa wc  copy cmblk length
/* 12112 */	move    | wa     << dst_ | wc     << src_ ,
/* 12113 */	stmt    | 3724   << off_ ,	//	btw wa   convert to words
/* 12114 */	stmt    | 3725   << off_ ,	//	sub wa =cmvls  calculate number of subscripts
/* 12115 */	loadi   | r2     << dst_ | cmvls  << off_ ,
/* 12116 */	sub     | wa     << dst_ | r2     << src_ ,
// cgn07:
/* 12117 */	stmt    | 3726   << off_ ,	//cgn07	mnz wc   set result non-constant
/* 12118 */	move    | wc     << dst_ | xs     << src_ ,
/* 12119 */	stmt    | 3727   << off_ ,	//	jsr cdwrd   generate word
/* 12120 */	call    | cdwrd  << off_ ,
/* 12121 */	stmt    | 3728   << off_ ,	//	brn cgn03   back to exit
/* 12122 */	brn     | cgn03  << off_ ,
// cgn08:
/* 12123 */	stmt    | 3729   << off_ ,	//cgn08	mov xr xl  copy cmblk pointer
/* 12124 */	move    | xr     << dst_ | xl     << src_ ,
/* 12125 */	stmt    | 3730   << off_ ,	//	jsr cdgvl   gen code by value for call
/* 12126 */	call    | cdgvl  << off_ ,
/* 12127 */	stmt    | 3731   << off_ ,	//	mov wa =ofne_  get extra call for by name
/* 12128 */	loadi   | wa     << dst_ | ofne_  << off_ ,
/* 12129 */	stmt    | 3732   << off_ ,	//	brn cgn07   back to generate and exit
/* 12130 */	brn     | cgn07  << off_ ,
// cgn09:
/* 12131 */	stmt    | 3733   << off_ ,	//cgn09	mov xr cmrop(xl)  check if variable
/* 12132 */	load    | xr     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 12133 */	stmt    | 3734   << off_ ,	//	bhi (xr) =b_vr_ cgn02 treat *variable as simple var
/* 12134 */	load    | r1     << dst_ | xr     << src_ ,
/* 12135 */	loadi   | r2     << dst_ | b_vr_  << off_ ,
/* 12136 */	bhi     | r1     << dst_ | r2     << src_ | cgn02  << off_ ,
/* 12137 */	stmt    | 3735   << off_ ,	//	mov xl xr  copy ptr to expression tree
/* 12138 */	move    | xl     << dst_ | xr     << src_ ,
/* 12139 */	stmt    | 3736   << off_ ,	//	mov wa =num01  return name
/* 12140 */	loadi   | wa     << dst_ | num01  << off_ ,
/* 12141 */	stmt    | 3737   << off_ ,	//	jsr cdgex   else build exblk
/* 12142 */	call    | cdgex  << off_ ,
/* 12143 */	stmt    | 3738   << off_ ,	//	mov wa =olex_  set call to load expr by name
/* 12144 */	loadi   | wa     << dst_ | olex_  << off_ ,
/* 12145 */	stmt    | 3739   << off_ ,	//	jsr cdwrd   generate it
/* 12146 */	call    | cdwrd  << off_ ,
/* 12147 */	stmt    | 3740   << off_ ,	//	mov wa xr  copy exblk pointer
/* 12148 */	move    | wa     << dst_ | xr     << src_ ,
/* 12149 */	stmt    | 3741   << off_ ,	//	jsr cdwrd   generate exblk pointer
/* 12150 */	call    | cdwrd  << off_ ,
/* 12151 */	stmt    | 3742   << off_ ,	//	brn cgn03   back to exit
/* 12152 */	brn     | cgn03  << off_ ,
// cgn10:
/* 12153 */	stmt    | 3743   << off_ ,	//cgn10	mov xr cmrop(xl)  get operand
/* 12154 */	load    | xr     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 12155 */	stmt    | 3744   << off_ ,	//	jsr cdgvl   generate code by value for it
/* 12156 */	call    | cdgvl  << off_ ,
/* 12157 */	stmt    | 3745   << off_ ,	//	mov wa =oinn_  load call for indirect by name
/* 12158 */	loadi   | wa     << dst_ | oinn_  << off_ ,
/* 12159 */	stmt    | 3746   << off_ ,	//	brn cgn12   merge
/* 12160 */	brn     | cgn12  << off_ ,
// cgn11:
/* 12161 */	stmt    | 3747   << off_ ,	//cgn11	mov xr cmrop(xl)  get operand
/* 12162 */	load    | xr     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 12163 */	stmt    | 3748   << off_ ,	//	jsr cdgnm   generate code by name for it
/* 12164 */	call    | cdgnm  << off_ ,
/* 12165 */	stmt    | 3749   << off_ ,	//	mov wa =okwn_  load call for keyword by name
/* 12166 */	loadi   | wa     << dst_ | okwn_  << off_ ,
// cgn12:
/* 12167 */	stmt    | 3750   << off_ ,	//cgn12	jsr cdwrd   generate code for operator
/* 12168 */	call    | cdwrd  << off_ ,
/* 12169 */	stmt    | 3751   << off_ ,	//	brn cgn03   exit
/* 12170 */	brn     | cgn03  << off_ ,
// cdgvl:
/* 12171 */	stmt    | 3752   << off_ ,	//cdgvl	prc r 0  entry point, recursive
/* 12172 */	stmt    | 3753   << off_ ,	//	mov wa (xr)  load type word
/* 12173 */	load    | wa     << dst_ | xr     << src_ ,
/* 12174 */	stmt    | 3754   << off_ ,	//	beq wa =b_cmt cgv01 jump if cmblk
/* 12175 */	loadi   | r2     << dst_ | b_cmt  << off_ ,
/* 12176 */	beq     | wa     << dst_ | r2     << src_ | cgv01  << off_ ,
/* 12177 */	stmt    | 3755   << off_ ,	//	blt wa =b_vra cgv00 jump if icblk, rcblk, scblk
/* 12178 */	loadi   | r2     << dst_ | b_vra  << off_ ,
/* 12179 */	blt     | wa     << dst_ | r2     << src_ | cgv00  << off_ ,
/* 12180 */	stmt    | 3756   << off_ ,	//	bnz vrlen(xr) cgvl0  jump if not system variable
/* 12181 */	load    | r1     << dst_ | xr     << src_ | vrlen  << off_ ,
/* 12182 */	bnz     | r1     << dst_ | cgvl0  << off_ ,
/* 12183 */	stmt    | 3757   << off_ ,	//	mov -(xs) xr  stack xr
/* 12184 */	dca     | xs     << dst_ ,
/* 12185 */	store   | xr     << dst_ | xs     << src_ ,
/* 12186 */	stmt    | 3758   << off_ ,	//	mov xr vrsvp(xr)  point to svblk
/* 12187 */	load    | xr     << dst_ | xr     << src_ | vrsvp  << off_ ,
/* 12188 */	stmt    | 3759   << off_ ,	//	mov wa svbit(xr)  get svblk property bits
/* 12189 */	load    | wa     << dst_ | xr     << src_ | svbit  << off_ ,
/* 12190 */	stmt    | 3760   << off_ ,	//	mov xr (xs)+  recover xr
/* 12191 */	load    | xr     << dst_ | xs     << src_ ,
/* 12192 */	ica     | xs     << dst_ ,
/* 12193 */	stmt    | 3761   << off_ ,	//	anb wa 4,btkwv  check if constant keyword value
/* 12194 */	load    | r2     << dst_ | btkwv  << off_ ,
/* 12195 */	anb     | wa     << dst_ | r2     << src_ ,
/* 12196 */	stmt    | 3762   << off_ ,	//	beq wa 4,btkwv cgv00 jump if constant keyword value
/* 12197 */	load    | r2     << dst_ | btkwv  << off_ ,
/* 12198 */	beq     | wa     << dst_ | r2     << src_ | cgv00  << off_ ,
// cgvl0:
/* 12199 */	stmt    | 3763   << off_ ,	//cgvl0	mnz wc   indicate non-constant value
/* 12200 */	move    | wc     << dst_ | xs     << src_ ,
// cgv00:
/* 12201 */	stmt    | 3764   << off_ ,	//cgv00	mov wa xr  copy ptr to var or constant
/* 12202 */	move    | wa     << dst_ | xr     << src_ ,
/* 12203 */	stmt    | 3765   << off_ ,	//	jsr cdwrd   generate as code word
/* 12204 */	call    | cdwrd  << off_ ,
/* 12205 */	stmt    | 3766   << off_ ,	//	exi    return to caller
/* 12206 */	exi     | 0      << off_ ,
// cgv01:
/* 12207 */	stmt    | 3767   << off_ ,	//cgv01	mov -(xs) wb  save entry wb
/* 12208 */	dca     | xs     << dst_ ,
/* 12209 */	store   | wb     << dst_ | xs     << src_ ,
/* 12210 */	stmt    | 3768   << off_ ,	//	mov -(xs) xl  save entry xl
/* 12211 */	dca     | xs     << dst_ ,
/* 12212 */	store   | xl     << dst_ | xs     << src_ ,
/* 12213 */	stmt    | 3769   << off_ ,	//	mov -(xs) wc  save entry constant flag
/* 12214 */	dca     | xs     << dst_ ,
/* 12215 */	store   | wc     << dst_ | xs     << src_ ,
/* 12216 */	stmt    | 3770   << off_ ,	//	mov -(xs) cwcof  save initial code offset
/* 12217 */	load    | r1     << dst_ | cwcof  << off_ ,
/* 12218 */	dca     | xs     << dst_ ,
/* 12219 */	store   | r1     << dst_ | xs     << src_ ,
/* 12220 */	stmt    | 3771   << off_ ,	//	chk    check for stack overflow
/* 12221 */	chk     ,
/* 12222 */	stmt    | 3772   << off_ ,	//	mov xl xr  copy cmblk pointer
/* 12223 */	move    | xl     << dst_ | xr     << src_ ,
/* 12224 */	stmt    | 3773   << off_ ,	//	mov xr cmtyp(xr)  load cmblk type
/* 12225 */	load    | xr     << dst_ | xr     << src_ | cmtyp  << off_ ,
/* 12226 */	stmt    | 3774   << off_ ,	//	mov wc cswno  reset constant flag
/* 12227 */	load    | wc     << dst_ | cswno  << off_ ,
/* 12228 */	stmt    | 3775   << off_ ,	//	ble xr =c_pr_ cgv02 jump if not predicate value
/* 12229 */	loadi   | r2     << dst_ | c_pr_  << off_ ,
/* 12230 */	ble     | xr     << dst_ | r2     << src_ | cgv02  << off_ ,
/* 12231 */	stmt    | 3776   << off_ ,	//	mnz wc   else force non-constant case
/* 12232 */	move    | wc     << dst_ | xs     << src_ ,
// cgv02:
/* 12233 */	stmt    | 3777   << off_ ,	//cgv02	bsw xr c__nv  switch to appropriate generator
/* 12234 */	loadi   | r1     << dst_ | c__nv  << off_ ,
/* 12235 */	bsw     | xr     << dst_ | r1     << src_ ,
/* 12236 */	cgv03   ,
/* 12237 */	cgv05   ,
/* 12238 */	cgv14   ,
/* 12239 */	cgv31   ,
/* 12240 */	cgv27   ,
/* 12241 */	cgv29   ,
/* 12242 */	cgv30   ,
/* 12243 */	cgv18   ,
/* 12244 */	cgv19   ,
/* 12245 */	cgv18   ,
/* 12246 */	cgv24   ,
/* 12247 */	cgv24   ,
/* 12248 */	cgv27   ,
/* 12249 */	cgv26   ,
/* 12250 */	cgv21   ,
/* 12251 */	cgv31   ,
/* 12252 */	cgv28   ,
/* 12253 */	cgv15   ,
/* 12254 */	cgv18   ,
// cgv03:
/* 12255 */	stmt    | 3778   << off_ ,	//cgv03	mov wb *cmopn  set offset to array operand
/* 12256 */	loadi   | wb     << dst_ | cmopn  << off_ ,
// cgv04:
/* 12257 */	stmt    | 3779   << off_ ,	//cgv04	jsr cmgen   gen value code for next operand
/* 12258 */	call    | cmgen  << off_ ,
/* 12259 */	stmt    | 3780   << off_ ,	//	mov wc cmlen(xl)  load cmblk length
/* 12260 */	load    | wc     << dst_ | xl     << src_ | cmlen  << off_ ,
/* 12261 */	stmt    | 3781   << off_ ,	//	blt wb wc cgv04 loop back if more to go
/* 12262 */	blt     | wb     << dst_ | wc     << src_ | cgv04  << off_ ,
/* 12263 */	stmt    | 3782   << off_ ,	//	mov wa =oaov_  set one subscript call in case
/* 12264 */	loadi   | wa     << dst_ | oaov_  << off_ ,
/* 12265 */	stmt    | 3783   << off_ ,	//	beq wc *cmar1 cgv32 jump to exit if 1-sub case
/* 12266 */	loadi   | r2     << dst_ | cmar1  << off_ ,
/* 12267 */	beq     | wc     << dst_ | r2     << src_ | cgv32  << off_ ,
/* 12268 */	stmt    | 3784   << off_ ,	//	mov wa =oamv_  else set call for multi-subscripts
/* 12269 */	loadi   | wa     << dst_ | oamv_  << off_ ,
/* 12270 */	stmt    | 3785   << off_ ,	//	jsr cdwrd   generate call
/* 12271 */	call    | cdwrd  << off_ ,
/* 12272 */	stmt    | 3786   << off_ ,	//	mov wa wc  copy length of cmblk
/* 12273 */	move    | wa     << dst_ | wc     << src_ ,
/* 12274 */	stmt    | 3787   << off_ ,	//	sub wa *cmvls  subtract standard length
/* 12275 */	loadi   | r2     << dst_ | cmvls  << off_ ,
/* 12276 */	sub     | wa     << dst_ | r2     << src_ ,
/* 12277 */	stmt    | 3788   << off_ ,	//	btw wa   get number of words
/* 12278 */	stmt    | 3789   << off_ ,	//	brn cgv32   jump to generate subscript count
/* 12279 */	brn     | cgv32  << off_ ,
// cgv05:
/* 12280 */	stmt    | 3790   << off_ ,	//cgv05	mov wb *cmvls  set offset to first argument
/* 12281 */	loadi   | wb     << dst_ | cmvls  << off_ ,
// cgv06:
/* 12282 */	stmt    | 3791   << off_ ,	//cgv06	beq wb cmlen(xl) cgv07 jump if all generated
/* 12283 */	load    | r2     << dst_ | xl     << src_ | cmlen  << off_ ,
/* 12284 */	beq     | wb     << dst_ | r2     << src_ | cgv07  << off_ ,
/* 12285 */	stmt    | 3792   << off_ ,	//	jsr cmgen   else gen value code for next arg
/* 12286 */	call    | cmgen  << off_ ,
/* 12287 */	stmt    | 3793   << off_ ,	//	brn cgv06   back to generate next argument
/* 12288 */	brn     | cgv06  << off_ ,
// cgv07:
/* 12289 */	stmt    | 3794   << off_ ,	//cgv07	sub wb *cmvls  get number of arg ptrs (bytes)
/* 12290 */	loadi   | r2     << dst_ | cmvls  << off_ ,
/* 12291 */	sub     | wb     << dst_ | r2     << src_ ,
/* 12292 */	stmt    | 3795   << off_ ,	//	btw wb   convert bytes to words
/* 12293 */	stmt    | 3796   << off_ ,	//	mov xr cmopn(xl)  load function vrblk pointer
/* 12294 */	load    | xr     << dst_ | xl     << src_ | cmopn  << off_ ,
/* 12295 */	stmt    | 3797   << off_ ,	//	bnz vrlen(xr) cgv12  jump if not system function
/* 12296 */	load    | r1     << dst_ | xr     << src_ | vrlen  << off_ ,
/* 12297 */	bnz     | r1     << dst_ | cgv12  << off_ ,
/* 12298 */	stmt    | 3798   << off_ ,	//	mov xl vrsvp(xr)  load svblk ptr if system var
/* 12299 */	load    | xl     << dst_ | xr     << src_ | vrsvp  << off_ ,
/* 12300 */	stmt    | 3799   << off_ ,	//	mov wa svbit(xl)  load bit mask
/* 12301 */	load    | wa     << dst_ | xl     << src_ | svbit  << off_ ,
/* 12302 */	stmt    | 3800   << off_ ,	//	anb wa 4,btffc  test for fast function call allowed
/* 12303 */	load    | r2     << dst_ | btffc  << off_ ,
/* 12304 */	anb     | wa     << dst_ | r2     << src_ ,
/* 12305 */	stmt    | 3801   << off_ ,	//	zrb wa cgv12  jump if not
/* 12306 */	zrb     | wa     << dst_ | cgv12  << off_ ,
/* 12307 */	stmt    | 3802   << off_ ,	//	mov wa svbit(xl)  reload bit indicators
/* 12308 */	load    | wa     << dst_ | xl     << src_ | svbit  << off_ ,
/* 12309 */	stmt    | 3803   << off_ ,	//	anb wa 4,btpre  test for preevaluation ok
/* 12310 */	load    | r2     << dst_ | btpre  << off_ ,
/* 12311 */	anb     | wa     << dst_ | r2     << src_ ,
/* 12312 */	stmt    | 3804   << off_ ,	//	nzb wa cgv08  jump if preevaluation permitted
/* 12313 */	nzb     | wa     << dst_ | cgv08  << off_ ,
/* 12314 */	stmt    | 3805   << off_ ,	//	mnz wc   else set result non-constant
/* 12315 */	move    | wc     << dst_ | xs     << src_ ,
// cgv08:
/* 12316 */	stmt    | 3806   << off_ ,	//cgv08	mov xl vrfnc(xr)  load ptr to svfnc field
/* 12317 */	load    | xl     << dst_ | xr     << src_ | vrfnc  << off_ ,
/* 12318 */	stmt    | 3807   << off_ ,	//	mov wa fargs(xl)  load svnar field value
/* 12319 */	load    | wa     << dst_ | xl     << src_ | fargs  << off_ ,
/* 12320 */	stmt    | 3808   << off_ ,	//	beq wa wb cgv11 jump if argument count is correct
/* 12321 */	beq     | wa     << dst_ | wb     << src_ | cgv11  << off_ ,
/* 12322 */	stmt    | 3809   << off_ ,	//	bhi wa wb cgv09 jump if too few arguments given
/* 12323 */	bhi     | wa     << dst_ | wb     << src_ | cgv09  << off_ ,
/* 12324 */	stmt    | 3810   << off_ ,	//	sub wb wa  get number of extra args
/* 12325 */	sub     | wb     << dst_ | wa     << src_ ,
/* 12326 */	stmt    | 3811   << off_ ,	//	lct wb wb  set as count to control loop
/* 12327 */	stmt    | 3812   << off_ ,	//	mov wa =opop_  set pop call
/* 12328 */	loadi   | wa     << dst_ | opop_  << off_ ,
/* 12329 */	stmt    | 3813   << off_ ,	//	brn cgv10   jump to common loop
/* 12330 */	brn     | cgv10  << off_ ,
// cgv09:
/* 12331 */	stmt    | 3814   << off_ ,	//cgv09	sub wa wb  get number of missing arguments
/* 12332 */	sub     | wa     << dst_ | wb     << src_ ,
/* 12333 */	stmt    | 3815   << off_ ,	//	lct wb wa  load as count to control loop
/* 12334 */	move    | wb     << dst_ | wa     << src_ ,
/* 12335 */	stmt    | 3816   << off_ ,	//	mov wa =nulls  load ptr to null constant
/* 12336 */	loadi   | wa     << dst_ | nulls  << off_ ,
// cgv10:
/* 12337 */	stmt    | 3817   << off_ ,	//cgv10	jsr cdwrd   generate one call
/* 12338 */	call    | cdwrd  << off_ ,
/* 12339 */	stmt    | 3818   << off_ ,	//	bct wb cgv10  loop till all generated
/* 12340 */	bct     | wb     << dst_ | cgv10  << off_ ,
// cgv11:
/* 12341 */	stmt    | 3819   << off_ ,	//cgv11	mov wa xl  copy pointer to svfnc field
/* 12342 */	move    | wa     << dst_ | xl     << src_ ,
/* 12343 */	stmt    | 3820   << off_ ,	//	brn cgv36   jump to generate call
/* 12344 */	brn     | cgv36  << off_ ,
// cgv12:
/* 12345 */	stmt    | 3821   << off_ ,	//cgv12	mov wa =ofns_  set one arg call in case
/* 12346 */	loadi   | wa     << dst_ | ofns_  << off_ ,
/* 12347 */	stmt    | 3822   << off_ ,	//	beq wb =num01 cgv13 jump if one arg case
/* 12348 */	loadi   | r2     << dst_ | num01  << off_ ,
/* 12349 */	beq     | wb     << dst_ | r2     << src_ | cgv13  << off_ ,
/* 12350 */	stmt    | 3823   << off_ ,	//	mov wa =ofnc_  else load call for more than 1 arg
/* 12351 */	loadi   | wa     << dst_ | ofnc_  << off_ ,
/* 12352 */	stmt    | 3824   << off_ ,	//	jsr cdwrd   generate it
/* 12353 */	call    | cdwrd  << off_ ,
/* 12354 */	stmt    | 3825   << off_ ,	//	mov wa wb  copy argument count
/* 12355 */	move    | wa     << dst_ | wb     << src_ ,
// cgv13:
/* 12356 */	stmt    | 3826   << off_ ,	//cgv13	jsr cdwrd   generate =o_fns or arg count
/* 12357 */	call    | cdwrd  << off_ ,
/* 12358 */	stmt    | 3827   << off_ ,	//	mov wa xr  copy vrblk pointer
/* 12359 */	move    | wa     << dst_ | xr     << src_ ,
/* 12360 */	stmt    | 3828   << off_ ,	//	brn cgv32   jump to generate vrblk ptr
/* 12361 */	brn     | cgv32  << off_ ,
// cgv14:
/* 12362 */	stmt    | 3829   << off_ ,	//cgv14	mov xl cmrop(xl)  point to expression tree
/* 12363 */	load    | xl     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 12364 */	stmt    | 3830   << off_ ,	//	zer wa   return value
/* 12365 */	move    | wa     << dst_ ,
/* 12366 */	stmt    | 3831   << off_ ,	//	jsr cdgex   build exblk or seblk
/* 12367 */	call    | cdgex  << off_ ,
/* 12368 */	stmt    | 3832   << off_ ,	//	mov wa xr  copy block ptr
/* 12369 */	move    | wa     << dst_ | xr     << src_ ,
/* 12370 */	stmt    | 3833   << off_ ,	//	jsr cdwrd   generate ptr to exblk or seblk
/* 12371 */	call    | cdwrd  << off_ ,
/* 12372 */	stmt    | 3834   << off_ ,	//	brn cgv34   jump to exit, constant test
/* 12373 */	brn     | cgv34  << off_ ,
// cgv15:
/* 12374 */	stmt    | 3835   << off_ ,	//cgv15	zer -(xs)   zero ptr to chain of forward jumps
/* 12375 */	dca     | xs     << dst_ ,
/* 12376 */	store   | r0     << dst_ | xs     << src_ ,
/* 12377 */	stmt    | 3836   << off_ ,	//	zer -(xs)   zero ptr to prev o_slc forward ptr
/* 12378 */	dca     | xs     << dst_ ,
/* 12379 */	store   | r0     << dst_ | xs     << src_ ,
/* 12380 */	stmt    | 3837   << off_ ,	//	mov wb *cmvls  point to first alternative
/* 12381 */	loadi   | wb     << dst_ | cmvls  << off_ ,
/* 12382 */	stmt    | 3838   << off_ ,	//	mov wa =osla_  set initial code word
/* 12383 */	loadi   | wa     << dst_ | osla_  << off_ ,
// cgv16:
/* 12384 */	stmt    | 3839   << off_ ,	//cgv16	jsr cdwrd   generate o_slc (o_sla first time)
/* 12385 */	call    | cdwrd  << off_ ,
/* 12386 */	stmt    | 3840   << off_ ,	//	mov (xs) cwcof  set current loc as ptr to fill in
/* 12387 */	load    | r1     << dst_ | cwcof  << off_ ,
/* 12388 */	store   | r1     << dst_ | xs     << src_ ,
/* 12389 */	stmt    | 3841   << off_ ,	//	jsr cdwrd   generate garbage word there for now
/* 12390 */	call    | cdwrd  << off_ ,
/* 12391 */	stmt    | 3842   << off_ ,	//	jsr cmgen   gen value code for alternative
/* 12392 */	call    | cmgen  << off_ ,
/* 12393 */	stmt    | 3843   << off_ ,	//	mov wa =oslb_  load o_slb pointer
/* 12394 */	loadi   | wa     << dst_ | oslb_  << off_ ,
/* 12395 */	stmt    | 3844   << off_ ,	//	jsr cdwrd   generate o_slb call
/* 12396 */	call    | cdwrd  << off_ ,
/* 12397 */	stmt    | 3845   << off_ ,	//	mov wa num01(xs)  load old chain ptr
/* 12398 */	load    | wa     << dst_ | xs     << src_ | num01  << off_ ,
/* 12399 */	stmt    | 3846   << off_ ,	//	mov num01(xs) cwcof  set current loc as new chain head
/* 12400 */	load    | r1     << dst_ | cwcof  << off_ ,
/* 12401 */	store   | r1     << dst_ | xs     << src_ | num01  << off_ ,
/* 12402 */	stmt    | 3847   << off_ ,	//	jsr cdwrd   generate forward chain link
/* 12403 */	call    | cdwrd  << off_ ,
/* 12404 */	stmt    | 3848   << off_ ,	//	mov xr (xs)  load offset to word to plug
/* 12405 */	load    | xr     << dst_ | xs     << src_ ,
/* 12406 */	stmt    | 3849   << off_ ,	//	add xr r_ccb  point to actual location to plug
/* 12407 */	load    | r2     << dst_ | r_ccb  << off_ ,
/* 12408 */	add     | xr     << dst_ | r2     << src_ ,
/* 12409 */	stmt    | 3850   << off_ ,	//	mov (xr) cwcof  plug proper offset in
/* 12410 */	load    | r1     << dst_ | cwcof  << off_ ,
/* 12411 */	store   | r1     << dst_ | xr     << src_ ,
/* 12412 */	stmt    | 3851   << off_ ,	//	mov wa =oslc_  load o_slc ptr for next alternative
/* 12413 */	loadi   | wa     << dst_ | oslc_  << off_ ,
/* 12414 */	stmt    | 3852   << off_ ,	//	mov xr wb  copy offset (destroy garbage xr)
/* 12415 */	move    | xr     << dst_ | wb     << src_ ,
/* 12416 */	stmt    | 3853   << off_ ,	//	ica xr   bump extra time for test
/* 12417 */	ica     | xr     << dst_ ,
/* 12418 */	stmt    | 3854   << off_ ,	//	blt xr cmlen(xl) cgv16 loop back if not last alternative
/* 12419 */	load    | r2     << dst_ | xl     << src_ | cmlen  << off_ ,
/* 12420 */	blt     | xr     << dst_ | r2     << src_ | cgv16  << off_ ,
/* 12421 */	stmt    | 3855   << off_ ,	//	mov wa =osld_  get header call
/* 12422 */	loadi   | wa     << dst_ | osld_  << off_ ,
/* 12423 */	stmt    | 3856   << off_ ,	//	jsr cdwrd   generate o_sld call
/* 12424 */	call    | cdwrd  << off_ ,
/* 12425 */	stmt    | 3857   << off_ ,	//	jsr cmgen   generate code for last alternative
/* 12426 */	call    | cmgen  << off_ ,
/* 12427 */	stmt    | 3858   << off_ ,	//	ica xs   pop offset ptr
/* 12428 */	ica     | xs     << dst_ ,
/* 12429 */	stmt    | 3859   << off_ ,	//	mov xr (xs)+  load chain ptr
/* 12430 */	load    | xr     << dst_ | xs     << src_ ,
/* 12431 */	ica     | xs     << dst_ ,
// cgv17:
/* 12432 */	stmt    | 3860   << off_ ,	//cgv17	add xr r_ccb  make next ptr absolute
/* 12433 */	load    | r2     << dst_ | r_ccb  << off_ ,
/* 12434 */	add     | xr     << dst_ | r2     << src_ ,
/* 12435 */	stmt    | 3861   << off_ ,	//	mov wa (xr)  load forward ptr
/* 12436 */	load    | wa     << dst_ | xr     << src_ ,
/* 12437 */	stmt    | 3862   << off_ ,	//	mov (xr) cwcof  plug required offset
/* 12438 */	load    | r1     << dst_ | cwcof  << off_ ,
/* 12439 */	store   | r1     << dst_ | xr     << src_ ,
/* 12440 */	stmt    | 3863   << off_ ,	//	mov xr wa  copy forward ptr
/* 12441 */	move    | xr     << dst_ | wa     << src_ ,
/* 12442 */	stmt    | 3864   << off_ ,	//	bnz wa cgv17  loop back if more to go
/* 12443 */	bnz     | wa     << dst_ | cgv17  << off_ ,
/* 12444 */	stmt    | 3865   << off_ ,	//	brn cgv33   else jump to exit (not constant)
/* 12445 */	brn     | cgv33  << off_ ,
// cgv18:
/* 12446 */	stmt    | 3866   << off_ ,	//cgv18	mov xr cmlop(xl)  load left operand pointer
/* 12447 */	load    | xr     << dst_ | xl     << src_ | cmlop  << off_ ,
/* 12448 */	stmt    | 3867   << off_ ,	//	jsr cdgvl   gen value code for left operand
/* 12449 */	call    | cdgvl  << off_ ,
// cgv19:
/* 12450 */	stmt    | 3868   << off_ ,	//cgv19	mov xr cmrop(xl)  load right (only) operand ptr
/* 12451 */	load    | xr     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 12452 */	stmt    | 3869   << off_ ,	//	jsr cdgvl   gen code by value
/* 12453 */	call    | cdgvl  << off_ ,
// cgv20:
/* 12454 */	stmt    | 3870   << off_ ,	//cgv20	mov wa cmopn(xl)  load operator call pointer
/* 12455 */	load    | wa     << dst_ | xl     << src_ | cmopn  << off_ ,
/* 12456 */	stmt    | 3871   << off_ ,	//	brn cgv36   jump to generate it with cons test
/* 12457 */	brn     | cgv36  << off_ ,
// cgv21:
/* 12458 */	stmt    | 3872   << off_ ,	//cgv21	mov xr cmlop(xl)  load left operand pointer
/* 12459 */	load    | xr     << dst_ | xl     << src_ | cmlop  << off_ ,
/* 12460 */	stmt    | 3873   << off_ ,	//	blo (xr) =b_vr_ cgv22 jump if not variable
/* 12461 */	load    | r1     << dst_ | xr     << src_ ,
/* 12462 */	loadi   | r2     << dst_ | b_vr_  << off_ ,
/* 12463 */	blo     | r1     << dst_ | r2     << src_ | cgv22  << off_ ,
/* 12464 */	stmt    | 3874   << off_ ,	//	mov xr cmrop(xl)  load right operand ptr
/* 12465 */	load    | xr     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 12466 */	stmt    | 3875   << off_ ,	//	jsr cdgvl   generate code by value
/* 12467 */	call    | cdgvl  << off_ ,
/* 12468 */	stmt    | 3876   << off_ ,	//	mov wa cmlop(xl)  reload left operand vrblk ptr
/* 12469 */	load    | wa     << dst_ | xl     << src_ | cmlop  << off_ ,
/* 12470 */	stmt    | 3877   << off_ ,	//	add wa *vrsto  point to vrsto field
/* 12471 */	loadi   | r2     << dst_ | vrsto  << off_ ,
/* 12472 */	add     | wa     << dst_ | r2     << src_ ,
/* 12473 */	stmt    | 3878   << off_ ,	//	brn cgv32   jump to generate store ptr
/* 12474 */	brn     | cgv32  << off_ ,
// cgv22:
/* 12475 */	stmt    | 3879   << off_ ,	//cgv22	jsr expap   test for pattern match on left side
/* 12476 */	call    | expap  << off_ ,
/* 12477 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 12478 */	ppm     | cgv23  << off_ ,
/* 12479 */	stmt    | 3880   << off_ ,	//	mov cmlop(xl) cmrop(xr)  save pattern ptr in safe place
/* 12480 */	load    | r1     << dst_ | xr     << src_ | cmrop  << off_ ,
/* 12481 */	store   | r1     << dst_ | xl     << src_ | cmlop  << off_ ,
/* 12482 */	stmt    | 3881   << off_ ,	//	mov xr cmlop(xr)  load subject ptr
/* 12483 */	load    | xr     << dst_ | xr     << src_ | cmlop  << off_ ,
/* 12484 */	stmt    | 3882   << off_ ,	//	jsr cdgnm   gen code by name for subject
/* 12485 */	call    | cdgnm  << off_ ,
/* 12486 */	stmt    | 3883   << off_ ,	//	mov xr cmlop(xl)  load pattern ptr
/* 12487 */	load    | xr     << dst_ | xl     << src_ | cmlop  << off_ ,
/* 12488 */	stmt    | 3884   << off_ ,	//	jsr cdgvl   gen code by value for pattern
/* 12489 */	call    | cdgvl  << off_ ,
/* 12490 */	stmt    | 3885   << off_ ,	//	mov wa =opmn_  load match by name call
/* 12491 */	loadi   | wa     << dst_ | opmn_  << off_ ,
/* 12492 */	stmt    | 3886   << off_ ,	//	jsr cdwrd   generate it
/* 12493 */	call    | cdwrd  << off_ ,
/* 12494 */	stmt    | 3887   << off_ ,	//	mov xr cmrop(xl)  load replacement value ptr
/* 12495 */	load    | xr     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 12496 */	stmt    | 3888   << off_ ,	//	jsr cdgvl   gen code by value
/* 12497 */	call    | cdgvl  << off_ ,
/* 12498 */	stmt    | 3889   << off_ ,	//	mov wa =orpl_  load replace call
/* 12499 */	loadi   | wa     << dst_ | orpl_  << off_ ,
/* 12500 */	stmt    | 3890   << off_ ,	//	brn cgv32   jump to gen and exit (not constant)
/* 12501 */	brn     | cgv32  << off_ ,
// cgv23:
/* 12502 */	stmt    | 3891   << off_ ,	//cgv23	mnz wc   inhibit pre-evaluation
/* 12503 */	move    | wc     << dst_ | xs     << src_ ,
/* 12504 */	stmt    | 3892   << off_ ,	//	jsr cdgnm   gen code by name for left side
/* 12505 */	call    | cdgnm  << off_ ,
/* 12506 */	stmt    | 3893   << off_ ,	//	brn cgv31   merge with unop circuit
/* 12507 */	brn     | cgv31  << off_ ,
// cgv24:
/* 12508 */	stmt    | 3894   << off_ ,	//cgv24	mov xr cmlop(xl)  load left operand ptr
/* 12509 */	load    | xr     << dst_ | xl     << src_ | cmlop  << off_ ,
/* 12510 */	stmt    | 3895   << off_ ,	//	bne (xr) =b_cmt cgv18 ordinary binop if not cmblk
/* 12511 */	load    | r1     << dst_ | xr     << src_ ,
/* 12512 */	loadi   | r2     << dst_ | b_cmt  << off_ ,
/* 12513 */	bne     | r1     << dst_ | r2     << src_ | cgv18  << off_ ,
/* 12514 */	stmt    | 3896   << off_ ,	//	mov wb cmtyp(xr)  load cmblk type code
/* 12515 */	load    | wb     << dst_ | xr     << src_ | cmtyp  << off_ ,
/* 12516 */	stmt    | 3897   << off_ ,	//	beq wb =c_int cgv25 special case if interrogation
/* 12517 */	loadi   | r2     << dst_ | c_int  << off_ ,
/* 12518 */	beq     | wb     << dst_ | r2     << src_ | cgv25  << off_ ,
/* 12519 */	stmt    | 3898   << off_ ,	//	beq wb =c_neg cgv25 or negation
/* 12520 */	loadi   | r2     << dst_ | c_neg  << off_ ,
/* 12521 */	beq     | wb     << dst_ | r2     << src_ | cgv25  << off_ ,
/* 12522 */	stmt    | 3899   << off_ ,	//	bne wb =c_fnc cgv18 else ordinary binop if not function
/* 12523 */	loadi   | r2     << dst_ | c_fnc  << off_ ,
/* 12524 */	bne     | wb     << dst_ | r2     << src_ | cgv18  << off_ ,
/* 12525 */	stmt    | 3900   << off_ ,	//	mov xr cmopn(xr)  else load function vrblk ptr
/* 12526 */	load    | xr     << dst_ | xr     << src_ | cmopn  << off_ ,
/* 12527 */	stmt    | 3901   << off_ ,	//	bnz vrlen(xr) cgv18  ordinary binop if not system var
/* 12528 */	load    | r1     << dst_ | xr     << src_ | vrlen  << off_ ,
/* 12529 */	bnz     | r1     << dst_ | cgv18  << off_ ,
/* 12530 */	stmt    | 3902   << off_ ,	//	mov xr vrsvp(xr)  else point to svblk
/* 12531 */	load    | xr     << dst_ | xr     << src_ | vrsvp  << off_ ,
/* 12532 */	stmt    | 3903   << off_ ,	//	mov wa svbit(xr)  load bit indicators
/* 12533 */	load    | wa     << dst_ | xr     << src_ | svbit  << off_ ,
/* 12534 */	stmt    | 3904   << off_ ,	//	anb wa 4,btprd  test for predicate function
/* 12535 */	load    | r2     << dst_ | btprd  << off_ ,
/* 12536 */	anb     | wa     << dst_ | r2     << src_ ,
/* 12537 */	stmt    | 3905   << off_ ,	//	zrb wa cgv18  ordinary binop if not
/* 12538 */	zrb     | wa     << dst_ | cgv18  << off_ ,
// cgv25:
/* 12539 */	stmt    | 3906   << off_ ,	//cgv25	mov xr cmlop(xl)  reload left arg
/* 12540 */	load    | xr     << dst_ | xl     << src_ | cmlop  << off_ ,
/* 12541 */	stmt    | 3907   << off_ ,	//	jsr cdgvl   gen code by value
/* 12542 */	call    | cdgvl  << off_ ,
/* 12543 */	stmt    | 3908   << off_ ,	//	mov wa =opop_  load pop call
/* 12544 */	loadi   | wa     << dst_ | opop_  << off_ ,
/* 12545 */	stmt    | 3909   << off_ ,	//	jsr cdwrd   generate it
/* 12546 */	call    | cdwrd  << off_ ,
/* 12547 */	stmt    | 3910   << off_ ,	//	mov xr cmrop(xl)  load right operand
/* 12548 */	load    | xr     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 12549 */	stmt    | 3911   << off_ ,	//	jsr cdgvl   gen code by value as result code
/* 12550 */	call    | cdgvl  << off_ ,
/* 12551 */	stmt    | 3912   << off_ ,	//	brn cgv33   exit (not constant)
/* 12552 */	brn     | cgv33  << off_ ,
// cgv26:
/* 12553 */	stmt    | 3913   << off_ ,	//cgv26	mov xr cmlop(xl)  load left operand
/* 12554 */	load    | xr     << dst_ | xl     << src_ | cmlop  << off_ ,
/* 12555 */	stmt    | 3914   << off_ ,	//	jsr cdgvl   gen code by value, merge
/* 12556 */	call    | cdgvl  << off_ ,
// cgv27:
/* 12557 */	stmt    | 3915   << off_ ,	//cgv27	mov xr cmrop(xl)  load right operand ptr
/* 12558 */	load    | xr     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 12559 */	stmt    | 3916   << off_ ,	//	jsr cdgnm   gen code by name for right arg
/* 12560 */	call    | cdgnm  << off_ ,
/* 12561 */	stmt    | 3917   << off_ ,	//	mov xr cmopn(xl)  get operator code word
/* 12562 */	load    | xr     << dst_ | xl     << src_ | cmopn  << off_ ,
/* 12563 */	stmt    | 3918   << off_ ,	//	bne (xr) =o_kwv cgv20 gen call unless keyword value
/* 12564 */	load    | r1     << dst_ | xr     << src_ ,
/* 12565 */	loadi   | r2     << dst_ | o_kwv  << off_ ,
/* 12566 */	bne     | r1     << dst_ | r2     << src_ | cgv20  << off_ ,
/* 12567 */	stmt    | 3919   << off_ ,	//	bnz wc cgv20  gen call if non-constant (not var)
/* 12568 */	bnz     | wc     << dst_ | cgv20  << off_ ,
/* 12569 */	stmt    | 3920   << off_ ,	//	mnz wc   else set non-constant in case
/* 12570 */	move    | wc     << dst_ | xs     << src_ ,
/* 12571 */	stmt    | 3921   << off_ ,	//	mov xr cmrop(xl)  load ptr to operand vrblk
/* 12572 */	load    | xr     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 12573 */	stmt    | 3922   << off_ ,	//	bnz vrlen(xr) cgv20  gen (non-constant) if not sys var
/* 12574 */	load    | r1     << dst_ | xr     << src_ | vrlen  << off_ ,
/* 12575 */	bnz     | r1     << dst_ | cgv20  << off_ ,
/* 12576 */	stmt    | 3923   << off_ ,	//	mov xr vrsvp(xr)  else load ptr to svblk
/* 12577 */	load    | xr     << dst_ | xr     << src_ | vrsvp  << off_ ,
/* 12578 */	stmt    | 3924   << off_ ,	//	mov wa svbit(xr)  load bit mask
/* 12579 */	load    | wa     << dst_ | xr     << src_ | svbit  << off_ ,
/* 12580 */	stmt    | 3925   << off_ ,	//	anb wa 4,btckw  test for constant keyword
/* 12581 */	load    | r2     << dst_ | btckw  << off_ ,
/* 12582 */	anb     | wa     << dst_ | r2     << src_ ,
/* 12583 */	stmt    | 3926   << off_ ,	//	zrb wa cgv20  go gen if not constant
/* 12584 */	zrb     | wa     << dst_ | cgv20  << off_ ,
/* 12585 */	stmt    | 3927   << off_ ,	//	zer wc   else set result constant
/* 12586 */	move    | wc     << dst_ ,
/* 12587 */	stmt    | 3928   << off_ ,	//	brn cgv20   and jump back to generate call
/* 12588 */	brn     | cgv20  << off_ ,
// cgv28:
/* 12589 */	stmt    | 3929   << off_ ,	//cgv28	mov wa =onta_  get initial word
/* 12590 */	loadi   | wa     << dst_ | onta_  << off_ ,
/* 12591 */	stmt    | 3930   << off_ ,	//	jsr cdwrd   generate it
/* 12592 */	call    | cdwrd  << off_ ,
/* 12593 */	stmt    | 3931   << off_ ,	//	mov wb cwcof  save next offset
/* 12594 */	load    | wb     << dst_ | cwcof  << off_ ,
/* 12595 */	stmt    | 3932   << off_ ,	//	jsr cdwrd   generate gunk word for now
/* 12596 */	call    | cdwrd  << off_ ,
/* 12597 */	stmt    | 3933   << off_ ,	//	mov xr cmrop(xl)  load right operand ptr
/* 12598 */	load    | xr     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 12599 */	stmt    | 3934   << off_ ,	//	jsr cdgvl   gen code by value
/* 12600 */	call    | cdgvl  << off_ ,
/* 12601 */	stmt    | 3935   << off_ ,	//	mov wa =ontb_  load end of evaluation call
/* 12602 */	loadi   | wa     << dst_ | ontb_  << off_ ,
/* 12603 */	stmt    | 3936   << off_ ,	//	jsr cdwrd   generate it
/* 12604 */	call    | cdwrd  << off_ ,
/* 12605 */	stmt    | 3937   << off_ ,	//	mov xr wb  copy offset to word to plug
/* 12606 */	move    | xr     << dst_ | wb     << src_ ,
/* 12607 */	stmt    | 3938   << off_ ,	//	add xr r_ccb  point to actual word to plug
/* 12608 */	load    | r2     << dst_ | r_ccb  << off_ ,
/* 12609 */	add     | xr     << dst_ | r2     << src_ ,
/* 12610 */	stmt    | 3939   << off_ ,	//	mov (xr) cwcof  plug word with current offset
/* 12611 */	load    | r1     << dst_ | cwcof  << off_ ,
/* 12612 */	store   | r1     << dst_ | xr     << src_ ,
/* 12613 */	stmt    | 3940   << off_ ,	//	mov wa =ontc_  load final call
/* 12614 */	loadi   | wa     << dst_ | ontc_  << off_ ,
/* 12615 */	stmt    | 3941   << off_ ,	//	brn cgv32   jump to generate it (not constant)
/* 12616 */	brn     | cgv32  << off_ ,
// cgv29:
/* 12617 */	stmt    | 3942   << off_ ,	//cgv29	mov xr cmlop(xl)  load left operand ptr
/* 12618 */	load    | xr     << dst_ | xl     << src_ | cmlop  << off_ ,
/* 12619 */	stmt    | 3943   << off_ ,	//	jsr cdgvl   generate code by value
/* 12620 */	call    | cdgvl  << off_ ,
// cgv30:
/* 12621 */	stmt    | 3944   << off_ ,	//cgv30	mov wb =c_uo_  set unop code + 1
/* 12622 */	loadi   | wb     << dst_ | c_uo_  << off_ ,
/* 12623 */	stmt    | 3945   << off_ ,	//	sub wb cmtyp(xl)  set number of args (1 or 2)
/* 12624 */	load    | r2     << dst_ | xl     << src_ | cmtyp  << off_ ,
/* 12625 */	sub     | wb     << dst_ | r2     << src_ ,
/* 12626 */	stmt    | 3946   << off_ ,	//	mov xr cmrop(xl)  load right (only) operand pointer
/* 12627 */	load    | xr     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 12628 */	stmt    | 3947   << off_ ,	//	jsr cdgvl   gen value code for right operand
/* 12629 */	call    | cdgvl  << off_ ,
/* 12630 */	stmt    | 3948   << off_ ,	//	mov xr cmopn(xl)  load pointer to operator dv
/* 12631 */	load    | xr     << dst_ | xl     << src_ | cmopn  << off_ ,
/* 12632 */	stmt    | 3949   << off_ ,	//	mov xr dvopn(xr)  load pointer offset
/* 12633 */	load    | xr     << dst_ | xr     << src_ | dvopn  << off_ ,
/* 12634 */	stmt    | 3950   << off_ ,	//	wtb xr   convert word offset to bytes
/* 12635 */	stmt    | 3951   << off_ ,	//	add xr =r_uba  point to proper function ptr
/* 12636 */	loadi   | r2     << dst_ | r_uba  << off_ ,
/* 12637 */	add     | xr     << dst_ | r2     << src_ ,
/* 12638 */	stmt    | 3952   << off_ ,	//	sub xr *vrfnc  set standard function offset
/* 12639 */	loadi   | r2     << dst_ | vrfnc  << off_ ,
/* 12640 */	sub     | xr     << dst_ | r2     << src_ ,
/* 12641 */	stmt    | 3953   << off_ ,	//	brn cgv12   merge with function call circuit
/* 12642 */	brn     | cgv12  << off_ ,
// cgv31:
/* 12643 */	stmt    | 3954   << off_ ,	//cgv31	mnz wc   set non constant
/* 12644 */	move    | wc     << dst_ | xs     << src_ ,
/* 12645 */	stmt    | 3955   << off_ ,	//	brn cgv19   merge
/* 12646 */	brn     | cgv19  << off_ ,
// cgv32:
/* 12647 */	stmt    | 3956   << off_ ,	//cgv32	jsr cdwrd   generate word, merge
/* 12648 */	call    | cdwrd  << off_ ,
// cgv33:
/* 12649 */	stmt    | 3957   << off_ ,	//cgv33	mnz wc   indicate result is not constant
/* 12650 */	move    | wc     << dst_ | xs     << src_ ,
// cgv34:
/* 12651 */	stmt    | 3958   << off_ ,	//cgv34	ica xs   pop initial code offset
/* 12652 */	ica     | xs     << dst_ ,
/* 12653 */	stmt    | 3959   << off_ ,	//	mov wa (xs)+  restore old constant flag
/* 12654 */	load    | wa     << dst_ | xs     << src_ ,
/* 12655 */	ica     | xs     << dst_ ,
/* 12656 */	stmt    | 3960   << off_ ,	//	mov xl (xs)+  restore entry xl
/* 12657 */	load    | xl     << dst_ | xs     << src_ ,
/* 12658 */	ica     | xs     << dst_ ,
/* 12659 */	stmt    | 3961   << off_ ,	//	mov wb (xs)+  restore entry wb
/* 12660 */	load    | wb     << dst_ | xs     << src_ ,
/* 12661 */	ica     | xs     << dst_ ,
/* 12662 */	stmt    | 3962   << off_ ,	//	bnz wc cgv35  jump if not constant
/* 12663 */	bnz     | wc     << dst_ | cgv35  << off_ ,
/* 12664 */	stmt    | 3963   << off_ ,	//	mov wc wa  else restore entry constant flag
/* 12665 */	move    | wc     << dst_ | wa     << src_ ,
// cgv35:
/* 12666 */	stmt    | 3964   << off_ ,	//cgv35	exi    return to cdgvl caller
/* 12667 */	exi     | 0      << off_ ,
// cgv36:
/* 12668 */	stmt    | 3965   << off_ ,	//cgv36	jsr cdwrd   generate word
/* 12669 */	call    | cdwrd  << off_ ,
/* 12670 */	stmt    | 3966   << off_ ,	//	bnz wc cgv34  jump to exit if not constant
/* 12671 */	bnz     | wc     << dst_ | cgv34  << off_ ,
/* 12672 */	stmt    | 3967   << off_ ,	//	mov wa =orvl_  load call to return value
/* 12673 */	loadi   | wa     << dst_ | orvl_  << off_ ,
/* 12674 */	stmt    | 3968   << off_ ,	//	jsr cdwrd   generate it
/* 12675 */	call    | cdwrd  << off_ ,
/* 12676 */	stmt    | 3969   << off_ ,	//	mov xl (xs)  load initial code offset
/* 12677 */	load    | xl     << dst_ | xs     << src_ ,
/* 12678 */	stmt    | 3970   << off_ ,	//	jsr exbld   build exblk for expression
/* 12679 */	call    | exbld  << off_ ,
/* 12680 */	stmt    | 3971   << off_ ,	//	zer wb   set to evaluate by value
/* 12681 */	move    | wb     << dst_ ,
/* 12682 */	stmt    | 3972   << off_ ,	//	jsr evalx   evaluate expression
/* 12683 */	call    | evalx  << off_ ,
/* 12684 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 12685 */	ppm     ,
/* 12686 */	stmt    | 3973   << off_ ,	//	mov wa (xr)  load type word of result
/* 12687 */	load    | wa     << dst_ | xr     << src_ ,
/* 12688 */	stmt    | 3974   << off_ ,	//	blo wa =p_aaa cgv37 jump if not pattern
/* 12689 */	loadi   | r2     << dst_ | p_aaa  << off_ ,
/* 12690 */	blo     | wa     << dst_ | r2     << src_ | cgv37  << off_ ,
/* 12691 */	stmt    | 3975   << off_ ,	//	mov wa =olpt_  else load special pattern load call
/* 12692 */	loadi   | wa     << dst_ | olpt_  << off_ ,
/* 12693 */	stmt    | 3976   << off_ ,	//	jsr cdwrd   generate it
/* 12694 */	call    | cdwrd  << off_ ,
// cgv37:
/* 12695 */	stmt    | 3977   << off_ ,	//cgv37	mov wa xr  copy constant pointer
/* 12696 */	move    | wa     << dst_ | xr     << src_ ,
/* 12697 */	stmt    | 3978   << off_ ,	//	jsr cdwrd   generate ptr
/* 12698 */	call    | cdwrd  << off_ ,
/* 12699 */	stmt    | 3979   << off_ ,	//	zer wc   set result constant
/* 12700 */	move    | wc     << dst_ ,
/* 12701 */	stmt    | 3980   << off_ ,	//	brn cgv34   jump back to exit
/* 12702 */	brn     | cgv34  << off_ ,
// cdwrd:
/* 12703 */	stmt    | 3981   << off_ ,	//cdwrd	prc e 0  entry point
/* 12704 */	stmt    | 3982   << off_ ,	//	mov -(xs) xr  save entry xr
/* 12705 */	dca     | xs     << dst_ ,
/* 12706 */	store   | xr     << dst_ | xs     << src_ ,
/* 12707 */	stmt    | 3983   << off_ ,	//	mov -(xs) wa  save code word to be generated
/* 12708 */	dca     | xs     << dst_ ,
/* 12709 */	store   | wa     << dst_ | xs     << src_ ,
// cdwd1:
/* 12710 */	stmt    | 3984   << off_ ,	//cdwd1	mov xr r_ccb  load ptr to ccblk being built
/* 12711 */	load    | xr     << dst_ | r_ccb  << off_ ,
/* 12712 */	stmt    | 3985   << off_ ,	//	bnz xr cdwd2  jump if block allocated
/* 12713 */	bnz     | xr     << dst_ | cdwd2  << off_ ,
/* 12714 */	stmt    | 3986   << off_ ,	//	mov wa *e_cbs  load initial length
/* 12715 */	loadi   | wa     << dst_ | e_cbs  << off_ ,
/* 12716 */	stmt    | 3987   << off_ ,	//	jsr alloc   allocate ccblk
/* 12717 */	call    | alloc  << off_ ,
/* 12718 */	stmt    | 3988   << off_ ,	//	mov (xr) =b_cct  store type word
/* 12719 */	loadi   | r1     << dst_ | b_cct  << off_ ,
/* 12720 */	store   | r1     << dst_ | xr     << src_ ,
/* 12721 */	stmt    | 3989   << off_ ,	//	mov cwcof *cccod  set initial offset
/* 12722 */	loadi   | r1     << dst_ | cccod  << off_ ,
/* 12723 */	store   | r1     << dst_ | cwcof  << off_ ,
/* 12724 */	stmt    | 3990   << off_ ,	//	mov cclen(xr) wa  store block length
/* 12725 */	store   | wa     << dst_ | xr     << src_ | cclen  << off_ ,
/* 12726 */	stmt    | 3991   << off_ ,	//	zer ccsln(xr)   zero line number
/* 12727 */	store   | r0     << dst_ | xr     << src_ | ccsln  << off_ ,
/* 12728 */	stmt    | 3992   << off_ ,	//	mov r_ccb xr  store ptr to new block
/* 12729 */	store   | xr     << dst_ | r_ccb  << off_ ,
// cdwd2:
/* 12730 */	stmt    | 3993   << off_ ,	//cdwd2	mov wa cwcof  load current offset
/* 12731 */	load    | wa     << dst_ | cwcof  << off_ ,
/* 12732 */	stmt    | 3994   << off_ ,	//	add wa *num05  adjust for test (five words)
/* 12733 */	loadi   | r2     << dst_ | num05  << off_ ,
/* 12734 */	add     | wa     << dst_ | r2     << src_ ,
/* 12735 */	stmt    | 3995   << off_ ,	//	blo wa cclen(xr) cdwd4 jump if room in this block
/* 12736 */	load    | r2     << dst_ | xr     << src_ | cclen  << off_ ,
/* 12737 */	blo     | wa     << dst_ | r2     << src_ | cdwd4  << off_ ,
/* 12738 */	stmt    | 3996   << off_ ,	//	bge wa mxlen cdwd5 jump if already at max size
/* 12739 */	load    | r2     << dst_ | mxlen  << off_ ,
/* 12740 */	bge     | wa     << dst_ | r2     << src_ | cdwd5  << off_ ,
/* 12741 */	stmt    | 3997   << off_ ,	//	add wa *e_cbs  else get new size
/* 12742 */	loadi   | r2     << dst_ | e_cbs  << off_ ,
/* 12743 */	add     | wa     << dst_ | r2     << src_ ,
/* 12744 */	stmt    | 3998   << off_ ,	//	mov -(xs) xl  save entry xl
/* 12745 */	dca     | xs     << dst_ ,
/* 12746 */	store   | xl     << dst_ | xs     << src_ ,
/* 12747 */	stmt    | 3999   << off_ ,	//	mov xl xr  copy pointer
/* 12748 */	move    | xl     << dst_ | xr     << src_ ,
/* 12749 */	stmt    | 4000   << off_ ,	//	blt wa mxlen cdwd3 jump if not too large
/* 12750 */	load    | r2     << dst_ | mxlen  << off_ ,
/* 12751 */	blt     | wa     << dst_ | r2     << src_ | cdwd3  << off_ ,
/* 12752 */	stmt    | 4001   << off_ ,	//	mov wa mxlen  else reset to max allowed size
/* 12753 */	load    | wa     << dst_ | mxlen  << off_ ,
// cdwd3:
/* 12754 */	stmt    | 4002   << off_ ,	//cdwd3	jsr alloc   allocate new block
/* 12755 */	call    | alloc  << off_ ,
/* 12756 */	stmt    | 4003   << off_ ,	//	mov r_ccb xr  store pointer to new block
/* 12757 */	store   | xr     << dst_ | r_ccb  << off_ ,
/* 12758 */	stmt    | 4004   << off_ ,	//	mov (xr)+ =b_cct  store type word in new block
/* 12759 */	loadi   | r1     << dst_ | b_cct  << off_ ,
/* 12760 */	store   | r1     << dst_ | xr     << src_ ,
/* 12761 */	ica     | xr     << dst_ ,
/* 12762 */	stmt    | 4005   << off_ ,	//	mov (xr)+ wa  store block length
/* 12763 */	store   | wa     << dst_ | xr     << src_ ,
/* 12764 */	ica     | xr     << dst_ ,
/* 12765 */	stmt    | 4006   << off_ ,	//	mov (xr)+ ccsln(xl)  copy source line number word
/* 12766 */	load    | r1     << dst_ | xl     << src_ | ccsln  << off_ ,
/* 12767 */	store   | r1     << dst_ | xr     << src_ ,
/* 12768 */	ica     | xr     << dst_ ,
/* 12769 */	stmt    | 4007   << off_ ,	//	add xl *ccuse  point to ccuse,cccod fields in old
/* 12770 */	loadi   | r2     << dst_ | ccuse  << off_ ,
/* 12771 */	add     | xl     << dst_ | r2     << src_ ,
/* 12772 */	stmt    | 4008   << off_ ,	//	mov wa (xl)  load ccuse value
/* 12773 */	load    | wa     << dst_ | xl     << src_ ,
/* 12774 */	stmt    | 4009   << off_ ,	//	mvw    copy useful words from old block
/* 12775 */	mvw     ,
/* 12776 */	stmt    | 4010   << off_ ,	//	mov xl (xs)+  restore xl
/* 12777 */	load    | xl     << dst_ | xs     << src_ ,
/* 12778 */	ica     | xs     << dst_ ,
/* 12779 */	stmt    | 4011   << off_ ,	//	brn cdwd1   merge back to try again
/* 12780 */	brn     | cdwd1  << off_ ,
// cdwd4:
/* 12781 */	stmt    | 4012   << off_ ,	//cdwd4	mov wa cwcof  load current offset
/* 12782 */	load    | wa     << dst_ | cwcof  << off_ ,
/* 12783 */	stmt    | 4013   << off_ ,	//	ica wa   get new offset
/* 12784 */	ica     | wa     << dst_ ,
/* 12785 */	stmt    | 4014   << off_ ,	//	mov cwcof wa  store new offset
/* 12786 */	store   | wa     << dst_ | cwcof  << off_ ,
/* 12787 */	stmt    | 4015   << off_ ,	//	mov ccuse(xr) wa  store in ccblk for gbcol
/* 12788 */	store   | wa     << dst_ | xr     << src_ | ccuse  << off_ ,
/* 12789 */	stmt    | 4016   << off_ ,	//	dca wa   restore ptr to this word
/* 12790 */	dca     | wa     << dst_ ,
/* 12791 */	stmt    | 4017   << off_ ,	//	add xr wa  point to current entry
/* 12792 */	add     | xr     << dst_ | wa     << src_ ,
/* 12793 */	stmt    | 4018   << off_ ,	//	mov wa (xs)+  reload word to generate
/* 12794 */	load    | wa     << dst_ | xs     << src_ ,
/* 12795 */	ica     | xs     << dst_ ,
/* 12796 */	stmt    | 4019   << off_ ,	//	mov (xr) wa  store word in block
/* 12797 */	store   | wa     << dst_ | xr     << src_ ,
/* 12798 */	stmt    | 4020   << off_ ,	//	mov xr (xs)+  restore entry xr
/* 12799 */	load    | xr     << dst_ | xs     << src_ ,
/* 12800 */	ica     | xs     << dst_ ,
/* 12801 */	stmt    | 4021   << off_ ,	//	exi    return to caller
/* 12802 */	exi     | 0      << off_ ,
// cdwd5:
/* 12803 */	stmt    | 4022   << off_ ,	//cdwd5	erb 213 syntax error: statement is too complicated.
/* 12804 */	erb     | 213    << off_ ,
// cmgen:
/* 12805 */	stmt    | 4023   << off_ ,	//cmgen	prc r 0  entry point, recursive
/* 12806 */	stmt    | 4024   << off_ ,	//	mov xr xl  copy cmblk pointer
/* 12807 */	move    | xr     << dst_ | xl     << src_ ,
/* 12808 */	stmt    | 4025   << off_ ,	//	add xr wb  point to cmblk pointer
/* 12809 */	add     | xr     << dst_ | wb     << src_ ,
/* 12810 */	stmt    | 4026   << off_ ,	//	mov xr (xr)  load cmblk pointer
/* 12811 */	load    | xr     << dst_ | xr     << src_ ,
/* 12812 */	stmt    | 4027   << off_ ,	//	jsr cdgvl   generate code by value
/* 12813 */	call    | cdgvl  << off_ ,
/* 12814 */	stmt    | 4028   << off_ ,	//	ica wb   bump offset
/* 12815 */	ica     | wb     << dst_ ,
/* 12816 */	stmt    | 4029   << off_ ,	//	exi    return to caller
/* 12817 */	exi     | 0      << off_ ,
// cmpil:
/* 12818 */	stmt    | 4030   << off_ ,	//cmpil	prc e 0  entry point
/* 12819 */	stmt    | 4031   << off_ ,	//	lct wb =cmnen  set number of stack work locations
/* 12820 */	loadi   | wb     << dst_ | cmnen  << off_ ,
// cmp00:
/* 12821 */	stmt    | 4032   << off_ ,	//cmp00	zer -(xs)   store a zero, make one entry
/* 12822 */	dca     | xs     << dst_ ,
/* 12823 */	store   | r0     << dst_ | xs     << src_ ,
/* 12824 */	stmt    | 4033   << off_ ,	//	bct wb cmp00  loop back until all set
/* 12825 */	bct     | wb     << dst_ | cmp00  << off_ ,
/* 12826 */	stmt    | 4034   << off_ ,	//	mov cmpxs xs  save stack pointer for error sec
/* 12827 */	store   | xs     << dst_ | cmpxs  << off_ ,
/* 12828 */	stmt    | 4035   << off_ ,	//	sss cmpss   save s-r stack pointer if any
// cmp01:
/* 12829 */	stmt    | 4036   << off_ ,	//cmp01	mov wb scnpt  set scan pointer offset
/* 12830 */	load    | wb     << dst_ | scnpt  << off_ ,
/* 12831 */	stmt    | 4037   << off_ ,	//	mov scnse wb  set start of element location
/* 12832 */	store   | wb     << dst_ | scnse  << off_ ,
/* 12833 */	stmt    | 4038   << off_ ,	//	mov wa =ocer_  point to compile error call
/* 12834 */	loadi   | wa     << dst_ | ocer_  << off_ ,
/* 12835 */	stmt    | 4039   << off_ ,	//	jsr cdwrd   generate as temporary cdfal
/* 12836 */	call    | cdwrd  << off_ ,
/* 12837 */	stmt    | 4040   << off_ ,	//	blt wb scnil cmp04 jump if chars left on this image
/* 12838 */	load    | r2     << dst_ | scnil  << off_ ,
/* 12839 */	blt     | wb     << dst_ | r2     << src_ | cmp04  << off_ ,
// cmpce:
/* 12840 */	stmt    | 4041   << off_ ,	//cmpce	zer xr   clear possible garbage xr value
/* 12841 */	move    | xr     << dst_ ,
/* 12842 */	stmt    | 4042   << off_ ,	//	bnz cnind cmpc2  if within include file
/* 12843 */	load    | r1     << dst_ | cnind  << off_ ,
/* 12844 */	bnz     | r1     << dst_ | cmpc2  << off_ ,
/* 12845 */	stmt    | 4043   << off_ ,	//	bne stage =stgic cmp02 skip unless initial compile
/* 12846 */	load    | r1     << dst_ | stage  << off_ ,
/* 12847 */	loadi   | r2     << dst_ | stgic  << off_ ,
/* 12848 */	bne     | r1     << dst_ | r2     << src_ | cmp02  << off_ ,
// cmpc2:
/* 12849 */	stmt    | 4044   << off_ ,	//cmpc2	jsr readr   read next input image
/* 12850 */	call    | readr  << off_ ,
/* 12851 */	stmt    | 4045   << off_ ,	//	bze xr cmp09  jump if no input available
/* 12852 */	bze     | xr     << dst_ | cmp09  << off_ ,
/* 12853 */	stmt    | 4046   << off_ ,	//	jsr nexts   acquire next source image
/* 12854 */	call    | nexts  << off_ ,
/* 12855 */	stmt    | 4047   << off_ ,	//	mov lstsn cmpsn  store stmt no for use by listr
/* 12856 */	load    | r1     << dst_ | cmpsn  << off_ ,
/* 12857 */	store   | r1     << dst_ | lstsn  << off_ ,
/* 12858 */	stmt    | 4048   << off_ ,	//	mov cmpln rdcln  store line number at start of stmt
/* 12859 */	load    | r1     << dst_ | rdcln  << off_ ,
/* 12860 */	store   | r1     << dst_ | cmpln  << off_ ,
/* 12861 */	stmt    | 4049   << off_ ,	//	zer scnpt   reset scan pointer
/* 12862 */	store   | r0     << dst_ | scnpt  << off_ ,
/* 12863 */	stmt    | 4050   << off_ ,	//	brn cmp04   go process image
/* 12864 */	brn     | cmp04  << off_ ,
// cmp02:
/* 12865 */	stmt    | 4051   << off_ ,	//cmp02	mov xr r_cim  get current image
/* 12866 */	load    | xr     << dst_ | r_cim  << off_ ,
/* 12867 */	stmt    | 4052   << off_ ,	//	mov wb scnpt  get current offset
/* 12868 */	load    | wb     << dst_ | scnpt  << off_ ,
/* 12869 */	stmt    | 4053   << off_ ,	//	plc xr wb  prepare to get chars
/* 12870 */	plc     | xr     << dst_ | wb     << src_ ,
// cmp03:
/* 12871 */	stmt    | 4054   << off_ ,	//cmp03	bge scnpt scnil cmp09 end loop if end of image
/* 12872 */	load    | r1     << dst_ | scnpt  << off_ ,
/* 12873 */	load    | r2     << dst_ | scnil  << off_ ,
/* 12874 */	bge     | r1     << dst_ | r2     << src_ | cmp09  << off_ ,
/* 12875 */	stmt    | 4055   << off_ ,	//	lch wc (xr)+  get char
/* 12876 */	load    | wc     << dst_ | xr     << src_ ,
/* 12877 */	ica     | xr     << dst_ ,
/* 12878 */	stmt    | 4056   << off_ ,	//	icv scnpt   advance offset
/* 12879 */	load    | r1     << dst_ | scnpt  << off_ ,
/* 12880 */	icv     | r1     << dst_ ,
/* 12881 */	store   | r1     << dst_ | scnpt  << off_ ,
/* 12882 */	stmt    | 4057   << off_ ,	//	bne wc =ch_sm cmp03 loop if not semi-colon
/* 12883 */	loadi   | r2     << dst_ | ch_sm  << off_ ,
/* 12884 */	bne     | wc     << dst_ | r2     << src_ | cmp03  << off_ ,
// cmp04:
/* 12885 */	stmt    | 4058   << off_ ,	//cmp04	mov xr r_cim  point to current image
/* 12886 */	load    | xr     << dst_ | r_cim  << off_ ,
/* 12887 */	stmt    | 4059   << off_ ,	//	mov wb scnpt  load current offset
/* 12888 */	load    | wb     << dst_ | scnpt  << off_ ,
/* 12889 */	stmt    | 4060   << off_ ,	//	mov wa wb  copy for label scan
/* 12890 */	move    | wa     << dst_ | wb     << src_ ,
/* 12891 */	stmt    | 4061   << off_ ,	//	plc xr wb  point to first character
/* 12892 */	plc     | xr     << dst_ | wb     << src_ ,
/* 12893 */	stmt    | 4062   << off_ ,	//	lch wc (xr)+  load first character
/* 12894 */	load    | wc     << dst_ | xr     << src_ ,
/* 12895 */	ica     | xr     << dst_ ,
/* 12896 */	stmt    | 4063   << off_ ,	//	beq wc =ch_sm cmp12 no label if semicolon
/* 12897 */	loadi   | r2     << dst_ | ch_sm  << off_ ,
/* 12898 */	beq     | wc     << dst_ | r2     << src_ | cmp12  << off_ ,
/* 12899 */	stmt    | 4064   << off_ ,	//	beq wc =ch_as cmpce loop back if comment card
/* 12900 */	loadi   | r2     << dst_ | ch_as  << off_ ,
/* 12901 */	beq     | wc     << dst_ | r2     << src_ | cmpce  << off_ ,
/* 12902 */	stmt    | 4065   << off_ ,	//	beq wc =ch_mn cmp32 jump if control card
/* 12903 */	loadi   | r2     << dst_ | ch_mn  << off_ ,
/* 12904 */	beq     | wc     << dst_ | r2     << src_ | cmp32  << off_ ,
/* 12905 */	stmt    | 4066   << off_ ,	//	mov r_cmp r_cim  about to destroy r_cim
/* 12906 */	load    | r1     << dst_ | r_cim  << off_ ,
/* 12907 */	store   | r1     << dst_ | r_cmp  << off_ ,
/* 12908 */	stmt    | 4067   << off_ ,	//	mov xl =cmlab  point to label work string
/* 12909 */	loadi   | xl     << dst_ | cmlab  << off_ ,
/* 12910 */	stmt    | 4068   << off_ ,	//	mov r_cim xl  scane is to scan work string
/* 12911 */	store   | xl     << dst_ | r_cim  << off_ ,
/* 12912 */	stmt    | 4069   << off_ ,	//	psc xl   point to first character position
/* 12913 */	psc     | xl     << dst_ ,
/* 12914 */	stmt    | 4070   << off_ ,	//	sch wc (xl)+  store char just loaded
/* 12915 */	store   | wc     << dst_ | xl     << src_ ,
/* 12916 */	ica     | xl     << dst_ ,
/* 12917 */	stmt    | 4071   << off_ ,	//	mov wc =ch_sm  get a semicolon
/* 12918 */	loadi   | wc     << dst_ | ch_sm  << off_ ,
/* 12919 */	stmt    | 4072   << off_ ,	//	sch wc (xl)  store after first char
/* 12920 */	store   | wc     << dst_ | xl     << src_ ,
/* 12921 */	stmt    | 4073   << off_ ,	//	csc xl   finished character storing
/* 12922 */	stmt    | 4074   << off_ ,	//	zer xl   clear pointer
/* 12923 */	move    | xl     << dst_ ,
/* 12924 */	stmt    | 4075   << off_ ,	//	zer scnpt   start at first character
/* 12925 */	store   | r0     << dst_ | scnpt  << off_ ,
/* 12926 */	stmt    | 4076   << off_ ,	//	mov -(xs) scnil  preserve image length
/* 12927 */	load    | r1     << dst_ | scnil  << off_ ,
/* 12928 */	dca     | xs     << dst_ ,
/* 12929 */	store   | r1     << dst_ | xs     << src_ ,
/* 12930 */	stmt    | 4077   << off_ ,	//	mov scnil =num02  read 2 chars at most
/* 12931 */	loadi   | r1     << dst_ | num02  << off_ ,
/* 12932 */	store   | r1     << dst_ | scnil  << off_ ,
/* 12933 */	stmt    | 4078   << off_ ,	//	jsr scane   scan first char for type
/* 12934 */	call    | scane  << off_ ,
/* 12935 */	stmt    | 4079   << off_ ,	//	mov scnil (xs)+  restore image length
/* 12936 */	load    | r1     << dst_ | xs     << src_ ,
/* 12937 */	ica     | xs     << dst_ ,
/* 12938 */	store   | r1     << dst_ | scnil  << off_ ,
/* 12939 */	stmt    | 4080   << off_ ,	//	mov wc xl  note return code
/* 12940 */	move    | wc     << dst_ | xl     << src_ ,
/* 12941 */	stmt    | 4081   << off_ ,	//	mov xl r_cmp  get old r_cim
/* 12942 */	load    | xl     << dst_ | r_cmp  << off_ ,
/* 12943 */	stmt    | 4082   << off_ ,	//	mov r_cim xl  put it back
/* 12944 */	store   | xl     << dst_ | r_cim  << off_ ,
/* 12945 */	stmt    | 4083   << off_ ,	//	mov scnpt wb  reinstate offset
/* 12946 */	store   | wb     << dst_ | scnpt  << off_ ,
/* 12947 */	stmt    | 4084   << off_ ,	//	bnz scnbl cmp12  blank seen - cant be label
/* 12948 */	load    | r1     << dst_ | scnbl  << off_ ,
/* 12949 */	bnz     | r1     << dst_ | cmp12  << off_ ,
/* 12950 */	stmt    | 4085   << off_ ,	//	mov xr xl  point to current image
/* 12951 */	move    | xr     << dst_ | xl     << src_ ,
/* 12952 */	stmt    | 4086   << off_ ,	//	plc xr wb  point to first char again
/* 12953 */	plc     | xr     << dst_ | wb     << src_ ,
/* 12954 */	stmt    | 4087   << off_ ,	//	beq wc =t_var cmp06 ok if letter
/* 12955 */	loadi   | r2     << dst_ | t_var  << off_ ,
/* 12956 */	beq     | wc     << dst_ | r2     << src_ | cmp06  << off_ ,
/* 12957 */	stmt    | 4088   << off_ ,	//	beq wc =t_con cmp06 ok if digit
/* 12958 */	loadi   | r2     << dst_ | t_con  << off_ ,
/* 12959 */	beq     | wc     << dst_ | r2     << src_ | cmp06  << off_ ,
// cmple:
/* 12960 */	stmt    | 4089   << off_ ,	//cmple	mov r_cim r_cmp  point to bad line
/* 12961 */	load    | r1     << dst_ | r_cmp  << off_ ,
/* 12962 */	store   | r1     << dst_ | r_cim  << off_ ,
/* 12963 */	stmt    | 4090   << off_ ,	//	erb 214 bad label or misplaced continuation line
/* 12964 */	erb     | 214    << off_ ,
// cmp05:
/* 12965 */	stmt    | 4091   << off_ ,	//cmp05	beq wc =ch_sm cmp07 skip if semicolon
/* 12966 */	loadi   | r2     << dst_ | ch_sm  << off_ ,
/* 12967 */	beq     | wc     << dst_ | r2     << src_ | cmp07  << off_ ,
/* 12968 */	stmt    | 4092   << off_ ,	//	icv wa   bump offset
/* 12969 */	icv     | wa     << dst_ ,
/* 12970 */	stmt    | 4093   << off_ ,	//	beq wa scnil cmp07 jump if end of image (label end)
/* 12971 */	load    | r2     << dst_ | scnil  << off_ ,
/* 12972 */	beq     | wa     << dst_ | r2     << src_ | cmp07  << off_ ,
// cmp06:
/* 12973 */	stmt    | 4094   << off_ ,	//cmp06	lch wc (xr)+  else load next character
/* 12974 */	load    | wc     << dst_ | xr     << src_ ,
/* 12975 */	ica     | xr     << dst_ ,
/* 12976 */	stmt    | 4095   << off_ ,	//	beq wc =ch_ht cmp07 jump if horizontal tab
/* 12977 */	loadi   | r2     << dst_ | ch_ht  << off_ ,
/* 12978 */	beq     | wc     << dst_ | r2     << src_ | cmp07  << off_ ,
/* 12979 */	stmt    | 4096   << off_ ,	//	bne wc =ch_bl cmp05 loop back if non-blank
/* 12980 */	loadi   | r2     << dst_ | ch_bl  << off_ ,
/* 12981 */	bne     | wc     << dst_ | r2     << src_ | cmp05  << off_ ,
// cmp07:
/* 12982 */	stmt    | 4097   << off_ ,	//cmp07	mov scnpt wa  save updated scan offset
/* 12983 */	store   | wa     << dst_ | scnpt  << off_ ,
/* 12984 */	stmt    | 4098   << off_ ,	//	sub wa wb  get length of label
/* 12985 */	sub     | wa     << dst_ | wb     << src_ ,
/* 12986 */	stmt    | 4099   << off_ ,	//	bze wa cmp12  skip if label length zero
/* 12987 */	bze     | wa     << dst_ | cmp12  << off_ ,
/* 12988 */	stmt    | 4100   << off_ ,	//	zer xr   clear garbage xr value
/* 12989 */	move    | xr     << dst_ ,
/* 12990 */	stmt    | 4101   << off_ ,	//	jsr sbstr   build scblk for label name
/* 12991 */	call    | sbstr  << off_ ,
/* 12992 */	stmt    | 4102   << off_ ,	//	jsr gtnvr   locate/contruct vrblk
/* 12993 */	call    | gtnvr  << off_ ,
/* 12994 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 12995 */	ppm     ,
/* 12996 */	stmt    | 4103   << off_ ,	//	mov cmlbl(xs) xr  store label pointer
/* 12997 */	store   | xr     << dst_ | xs     << src_ | cmlbl  << off_ ,
/* 12998 */	stmt    | 4104   << off_ ,	//	bnz vrlen(xr) cmp11  jump if not system label
/* 12999 */	load    | r1     << dst_ | xr     << src_ | vrlen  << off_ ,
/* 13000 */	bnz     | r1     << dst_ | cmp11  << off_ ,
/* 13001 */	stmt    | 4105   << off_ ,	//	bne vrsvp(xr) =v_end cmp11 jump if not end label
/* 13002 */	load    | r1     << dst_ | xr     << src_ | vrsvp  << off_ ,
/* 13003 */	loadi   | r2     << dst_ | v_end  << off_ ,
/* 13004 */	bne     | r1     << dst_ | r2     << src_ | cmp11  << off_ ,
/* 13005 */	stmt    | 4106   << off_ ,	//	add stage =stgnd  adjust stage appropriately
/* 13006 */	load    | r1     << dst_ | stage  << off_ ,
/* 13007 */	loadi   | r2     << dst_ | stgnd  << off_ ,
/* 13008 */	add     | r1     << dst_ | r2     << src_ ,
/* 13009 */	store   | r1     << dst_ | stage  << off_ ,
/* 13010 */	stmt    | 4107   << off_ ,	//	jsr scane   scan out next element
/* 13011 */	call    | scane  << off_ ,
/* 13012 */	stmt    | 4108   << off_ ,	//	beq xl =t_smc cmp10 jump if end of image
/* 13013 */	loadi   | r2     << dst_ | t_smc  << off_ ,
/* 13014 */	beq     | xl     << dst_ | r2     << src_ | cmp10  << off_ ,
/* 13015 */	stmt    | 4109   << off_ ,	//	bne xl =t_var cmp08 else error if not variable
/* 13016 */	loadi   | r2     << dst_ | t_var  << off_ ,
/* 13017 */	bne     | xl     << dst_ | r2     << src_ | cmp08  << off_ ,
/* 13018 */	stmt    | 4110   << off_ ,	//	beq vrlbl(xr) =stndl cmp08 jump if not defined (error)
/* 13019 */	load    | r1     << dst_ | xr     << src_ | vrlbl  << off_ ,
/* 13020 */	loadi   | r2     << dst_ | stndl  << off_ ,
/* 13021 */	beq     | r1     << dst_ | r2     << src_ | cmp08  << off_ ,
/* 13022 */	stmt    | 4111   << off_ ,	//	mov cmtra(xs) vrlbl(xr)  else set initial entry pointer
/* 13023 */	load    | r1     << dst_ | xr     << src_ | vrlbl  << off_ ,
/* 13024 */	store   | r1     << dst_ | xs     << src_ | cmtra  << off_ ,
/* 13025 */	stmt    | 4112   << off_ ,	//	jsr scane   scan next element
/* 13026 */	call    | scane  << off_ ,
/* 13027 */	stmt    | 4113   << off_ ,	//	beq xl =t_smc cmp10 jump if ok (end of image)
/* 13028 */	loadi   | r2     << dst_ | t_smc  << off_ ,
/* 13029 */	beq     | xl     << dst_ | r2     << src_ | cmp10  << off_ ,
// cmp08:
/* 13030 */	stmt    | 4114   << off_ ,	//cmp08	erb 215 syntax error: undefined or erroneous entry label
/* 13031 */	erb     | 215    << off_ ,
// cmp09:
/* 13032 */	stmt    | 4115   << off_ ,	//cmp09	zer xr   clear garbage xr value
/* 13033 */	move    | xr     << dst_ ,
/* 13034 */	stmt    | 4116   << off_ ,	//	add stage =stgnd  adjust stage appropriately
/* 13035 */	load    | r1     << dst_ | stage  << off_ ,
/* 13036 */	loadi   | r2     << dst_ | stgnd  << off_ ,
/* 13037 */	add     | r1     << dst_ | r2     << src_ ,
/* 13038 */	store   | r1     << dst_ | stage  << off_ ,
/* 13039 */	stmt    | 4117   << off_ ,	//	beq stage =stgxe cmp10 jump if code call (ok)
/* 13040 */	load    | r1     << dst_ | stage  << off_ ,
/* 13041 */	loadi   | r2     << dst_ | stgxe  << off_ ,
/* 13042 */	beq     | r1     << dst_ | r2     << src_ | cmp10  << off_ ,
/* 13043 */	stmt    | 4118   << off_ ,	//	erb 216 syntax error: missing end line
/* 13044 */	erb     | 216    << off_ ,
// cmp10:
/* 13045 */	stmt    | 4119   << off_ ,	//cmp10	mov wa =ostp_  set stop call pointer
/* 13046 */	loadi   | wa     << dst_ | ostp_  << off_ ,
/* 13047 */	stmt    | 4120   << off_ ,	//	jsr cdwrd   generate as statement call
/* 13048 */	call    | cdwrd  << off_ ,
/* 13049 */	stmt    | 4121   << off_ ,	//	brn cmpse   jump to generate as failure
/* 13050 */	brn     | cmpse  << off_ ,
// cmp11:
/* 13051 */	stmt    | 4122   << off_ ,	//cmp11	bne stage =stgic cmp12 jump if code call - redef. ok
/* 13052 */	load    | r1     << dst_ | stage  << off_ ,
/* 13053 */	loadi   | r2     << dst_ | stgic  << off_ ,
/* 13054 */	bne     | r1     << dst_ | r2     << src_ | cmp12  << off_ ,
/* 13055 */	stmt    | 4123   << off_ ,	//	beq vrlbl(xr) =stndl cmp12 else check for redefinition
/* 13056 */	load    | r1     << dst_ | xr     << src_ | vrlbl  << off_ ,
/* 13057 */	loadi   | r2     << dst_ | stndl  << off_ ,
/* 13058 */	beq     | r1     << dst_ | r2     << src_ | cmp12  << off_ ,
/* 13059 */	stmt    | 4124   << off_ ,	//	zer cmlbl(xs)   leave first label decln undisturbed
/* 13060 */	store   | r0     << dst_ | xs     << src_ | cmlbl  << off_ ,
/* 13061 */	stmt    | 4125   << off_ ,	//	erb 217 syntax error: duplicate label
/* 13062 */	erb     | 217    << off_ ,
// cmp12:
/* 13063 */	stmt    | 4126   << off_ ,	//cmp12	zer wb   set flag for statement body
/* 13064 */	move    | wb     << dst_ ,
/* 13065 */	stmt    | 4127   << off_ ,	//	jsr expan   get tree for statement body
/* 13066 */	call    | expan  << off_ ,
/* 13067 */	stmt    | 4128   << off_ ,	//	mov cmstm(xs) xr  store for later use
/* 13068 */	store   | xr     << dst_ | xs     << src_ | cmstm  << off_ ,
/* 13069 */	stmt    | 4129   << off_ ,	//	zer cmsgo(xs)   clear success goto pointer
/* 13070 */	store   | r0     << dst_ | xs     << src_ | cmsgo  << off_ ,
/* 13071 */	stmt    | 4130   << off_ ,	//	zer cmfgo(xs)   clear failure goto pointer
/* 13072 */	store   | r0     << dst_ | xs     << src_ | cmfgo  << off_ ,
/* 13073 */	stmt    | 4131   << off_ ,	//	zer cmcgo(xs)   clear conditional goto flag
/* 13074 */	store   | r0     << dst_ | xs     << src_ | cmcgo  << off_ ,
/* 13075 */	stmt    | 4132   << off_ ,	//	jsr scane   scan next element
/* 13076 */	call    | scane  << off_ ,
/* 13077 */	stmt    | 4133   << off_ ,	//	beq xl =t_col cmp13 jump if colon (goto)
/* 13078 */	loadi   | r2     << dst_ | t_col  << off_ ,
/* 13079 */	beq     | xl     << dst_ | r2     << src_ | cmp13  << off_ ,
/* 13080 */	stmt    | 4134   << off_ ,	//	bnz cswno cmp18  jump if not optimizing
/* 13081 */	load    | r1     << dst_ | cswno  << off_ ,
/* 13082 */	bnz     | r1     << dst_ | cmp18  << off_ ,
/* 13083 */	stmt    | 4135   << off_ ,	//	bnz cmlbl(xs) cmp18  jump if label present
/* 13084 */	load    | r1     << dst_ | xs     << src_ | cmlbl  << off_ ,
/* 13085 */	bnz     | r1     << dst_ | cmp18  << off_ ,
/* 13086 */	stmt    | 4136   << off_ ,	//	mov xr cmstm(xs)  load tree ptr for statement body
/* 13087 */	load    | xr     << dst_ | xs     << src_ | cmstm  << off_ ,
/* 13088 */	stmt    | 4137   << off_ ,	//	mov wa (xr)  load type word
/* 13089 */	load    | wa     << dst_ | xr     << src_ ,
/* 13090 */	stmt    | 4138   << off_ ,	//	beq wa =b_cmt cmp18 jump if cmblk
/* 13091 */	loadi   | r2     << dst_ | b_cmt  << off_ ,
/* 13092 */	beq     | wa     << dst_ | r2     << src_ | cmp18  << off_ ,
/* 13093 */	stmt    | 4139   << off_ ,	//	bge wa =b_vra cmp18 jump if not icblk, scblk, or rcblk
/* 13094 */	loadi   | r2     << dst_ | b_vra  << off_ ,
/* 13095 */	bge     | wa     << dst_ | r2     << src_ | cmp18  << off_ ,
/* 13096 */	stmt    | 4140   << off_ ,	//	mov xl r_ccb  load ptr to ccblk
/* 13097 */	load    | xl     << dst_ | r_ccb  << off_ ,
/* 13098 */	stmt    | 4141   << off_ ,	//	mov ccuse(xl) *cccod  reset use offset in ccblk
/* 13099 */	loadi   | r1     << dst_ | cccod  << off_ ,
/* 13100 */	store   | r1     << dst_ | xl     << src_ | ccuse  << off_ ,
/* 13101 */	stmt    | 4142   << off_ ,	//	mov cwcof *cccod  and in global
/* 13102 */	loadi   | r1     << dst_ | cccod  << off_ ,
/* 13103 */	store   | r1     << dst_ | cwcof  << off_ ,
/* 13104 */	stmt    | 4143   << off_ ,	//	icv cmpsn   bump statement number
/* 13105 */	load    | r1     << dst_ | cmpsn  << off_ ,
/* 13106 */	icv     | r1     << dst_ ,
/* 13107 */	store   | r1     << dst_ | cmpsn  << off_ ,
/* 13108 */	stmt    | 4144   << off_ ,	//	brn cmp01   generate no code for statement
/* 13109 */	brn     | cmp01  << off_ ,
// cmp13:
/* 13110 */	stmt    | 4145   << off_ ,	//cmp13	mnz scngo   set goto flag
/* 13111 */	store   | xs     << dst_ | scngo  << off_ ,
/* 13112 */	stmt    | 4146   << off_ ,	//	jsr scane   scan next element
/* 13113 */	call    | scane  << off_ ,
/* 13114 */	stmt    | 4147   << off_ ,	//	beq xl =t_smc cmp31 jump if no fields left
/* 13115 */	loadi   | r2     << dst_ | t_smc  << off_ ,
/* 13116 */	beq     | xl     << dst_ | r2     << src_ | cmp31  << off_ ,
/* 13117 */	stmt    | 4148   << off_ ,	//	beq xl =t_sgo cmp14 jump if s for success goto
/* 13118 */	loadi   | r2     << dst_ | t_sgo  << off_ ,
/* 13119 */	beq     | xl     << dst_ | r2     << src_ | cmp14  << off_ ,
/* 13120 */	stmt    | 4149   << off_ ,	//	beq xl =t_fgo cmp16 jump if f for failure goto
/* 13121 */	loadi   | r2     << dst_ | t_fgo  << off_ ,
/* 13122 */	beq     | xl     << dst_ | r2     << src_ | cmp16  << off_ ,
/* 13123 */	stmt    | 4150   << off_ ,	//	mnz scnrs   set to rescan element not f,s
/* 13124 */	store   | xs     << dst_ | scnrs  << off_ ,
/* 13125 */	stmt    | 4151   << off_ ,	//	jsr scngf   scan out goto field
/* 13126 */	call    | scngf  << off_ ,
/* 13127 */	stmt    | 4152   << off_ ,	//	bnz cmfgo(xs) cmp17  error if fgoto already
/* 13128 */	load    | r1     << dst_ | xs     << src_ | cmfgo  << off_ ,
/* 13129 */	bnz     | r1     << dst_ | cmp17  << off_ ,
/* 13130 */	stmt    | 4153   << off_ ,	//	mov cmfgo(xs) xr  else set as fgoto
/* 13131 */	store   | xr     << dst_ | xs     << src_ | cmfgo  << off_ ,
/* 13132 */	stmt    | 4154   << off_ ,	//	brn cmp15   merge with sgoto circuit
/* 13133 */	brn     | cmp15  << off_ ,
// cmp14:
/* 13134 */	stmt    | 4155   << off_ ,	//cmp14	jsr scngf   scan success goto field
/* 13135 */	call    | scngf  << off_ ,
/* 13136 */	stmt    | 4156   << off_ ,	//	mov cmcgo(xs) =num01  set conditional goto flag
/* 13137 */	loadi   | r1     << dst_ | num01  << off_ ,
/* 13138 */	store   | r1     << dst_ | xs     << src_ | cmcgo  << off_ ,
// cmp15:
/* 13139 */	stmt    | 4157   << off_ ,	//cmp15	bnz cmsgo(xs) cmp17  error if sgoto already given
/* 13140 */	load    | r1     << dst_ | xs     << src_ | cmsgo  << off_ ,
/* 13141 */	bnz     | r1     << dst_ | cmp17  << off_ ,
/* 13142 */	stmt    | 4158   << off_ ,	//	mov cmsgo(xs) xr  else set sgoto
/* 13143 */	store   | xr     << dst_ | xs     << src_ | cmsgo  << off_ ,
/* 13144 */	stmt    | 4159   << off_ ,	//	brn cmp13   loop back for next goto field
/* 13145 */	brn     | cmp13  << off_ ,
// cmp16:
/* 13146 */	stmt    | 4160   << off_ ,	//cmp16	jsr scngf   scan goto field
/* 13147 */	call    | scngf  << off_ ,
/* 13148 */	stmt    | 4161   << off_ ,	//	mov cmcgo(xs) =num01  set conditonal goto flag
/* 13149 */	loadi   | r1     << dst_ | num01  << off_ ,
/* 13150 */	store   | r1     << dst_ | xs     << src_ | cmcgo  << off_ ,
/* 13151 */	stmt    | 4162   << off_ ,	//	bnz cmfgo(xs) cmp17  error if fgoto already given
/* 13152 */	load    | r1     << dst_ | xs     << src_ | cmfgo  << off_ ,
/* 13153 */	bnz     | r1     << dst_ | cmp17  << off_ ,
/* 13154 */	stmt    | 4163   << off_ ,	//	mov cmfgo(xs) xr  else store fgoto pointer
/* 13155 */	store   | xr     << dst_ | xs     << src_ | cmfgo  << off_ ,
/* 13156 */	stmt    | 4164   << off_ ,	//	brn cmp13   loop back for next field
/* 13157 */	brn     | cmp13  << off_ ,
// cmp17:
/* 13158 */	stmt    | 4165   << off_ ,	//cmp17	erb 218 syntax error: duplicated goto field
/* 13159 */	erb     | 218    << off_ ,
// cmp18:
/* 13160 */	stmt    | 4166   << off_ ,	//cmp18	zer scnse   stop positional error flags
/* 13161 */	store   | r0     << dst_ | scnse  << off_ ,
/* 13162 */	stmt    | 4167   << off_ ,	//	mov xr cmstm(xs)  load tree ptr for statement body
/* 13163 */	load    | xr     << dst_ | xs     << src_ | cmstm  << off_ ,
/* 13164 */	stmt    | 4168   << off_ ,	//	zer wb   collectable value for wb for cdgvl
/* 13165 */	move    | wb     << dst_ ,
/* 13166 */	stmt    | 4169   << off_ ,	//	zer wc   reset constant flag for cdgvl
/* 13167 */	move    | wc     << dst_ ,
/* 13168 */	stmt    | 4170   << off_ ,	//	jsr expap   test for pattern match
/* 13169 */	call    | expap  << off_ ,
/* 13170 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 13171 */	ppm     | cmp19  << off_ ,
/* 13172 */	stmt    | 4171   << off_ ,	//	mov cmopn(xr) =opms_  else set pattern match pointer
/* 13173 */	loadi   | r1     << dst_ | opms_  << off_ ,
/* 13174 */	store   | r1     << dst_ | xr     << src_ | cmopn  << off_ ,
/* 13175 */	stmt    | 4172   << off_ ,	//	mov cmtyp(xr) =c_pmt
/* 13176 */	loadi   | r1     << dst_ | c_pmt  << off_ ,
/* 13177 */	store   | r1     << dst_ | xr     << src_ | cmtyp  << off_ ,
// cmp19:
/* 13178 */	stmt    | 4173   << off_ ,	//cmp19	jsr cdgvl   generate code for body of statement
/* 13179 */	call    | cdgvl  << off_ ,
/* 13180 */	stmt    | 4174   << off_ ,	//	mov xr cmsgo(xs)  load sgoto pointer
/* 13181 */	load    | xr     << dst_ | xs     << src_ | cmsgo  << off_ ,
/* 13182 */	stmt    | 4175   << off_ ,	//	mov wa xr  copy it
/* 13183 */	move    | wa     << dst_ | xr     << src_ ,
/* 13184 */	stmt    | 4176   << off_ ,	//	bze xr cmp21  jump if no success goto
/* 13185 */	bze     | xr     << dst_ | cmp21  << off_ ,
/* 13186 */	stmt    | 4177   << off_ ,	//	zer cmsoc(xs)   clear success offset fillin ptr
/* 13187 */	store   | r0     << dst_ | xs     << src_ | cmsoc  << off_ ,
/* 13188 */	stmt    | 4178   << off_ ,	//	bhi xr state cmp20 jump if complex goto
/* 13189 */	load    | r2     << dst_ | state  << off_ ,
/* 13190 */	bhi     | xr     << dst_ | r2     << src_ | cmp20  << off_ ,
/* 13191 */	stmt    | 4179   << off_ ,	//	add wa *vrtra  point to vrtra field as required
/* 13192 */	loadi   | r2     << dst_ | vrtra  << off_ ,
/* 13193 */	add     | wa     << dst_ | r2     << src_ ,
/* 13194 */	stmt    | 4180   << off_ ,	//	jsr cdwrd   generate success goto
/* 13195 */	call    | cdwrd  << off_ ,
/* 13196 */	stmt    | 4181   << off_ ,	//	brn cmp22   jump to deal with fgoto
/* 13197 */	brn     | cmp22  << off_ ,
// cmp20:
/* 13198 */	stmt    | 4182   << off_ ,	//cmp20	beq xr cmfgo(xs) cmp22 no code if same as fgoto
/* 13199 */	load    | r2     << dst_ | xs     << src_ | cmfgo  << off_ ,
/* 13200 */	beq     | xr     << dst_ | r2     << src_ | cmp22  << off_ ,
/* 13201 */	stmt    | 4183   << off_ ,	//	zer wb   else set ok value for cdgvl in wb
/* 13202 */	move    | wb     << dst_ ,
/* 13203 */	stmt    | 4184   << off_ ,	//	jsr cdgcg   generate code for success goto
/* 13204 */	call    | cdgcg  << off_ ,
/* 13205 */	stmt    | 4185   << off_ ,	//	brn cmp22   jump to deal with fgoto
/* 13206 */	brn     | cmp22  << off_ ,
// cmp21:
/* 13207 */	stmt    | 4186   << off_ ,	//cmp21	mov cmsoc(xs) cwcof  set success fill in offset
/* 13208 */	load    | r1     << dst_ | cwcof  << off_ ,
/* 13209 */	store   | r1     << dst_ | xs     << src_ | cmsoc  << off_ ,
/* 13210 */	stmt    | 4187   << off_ ,	//	mov wa =ocer_  point to compile error call
/* 13211 */	loadi   | wa     << dst_ | ocer_  << off_ ,
/* 13212 */	stmt    | 4188   << off_ ,	//	jsr cdwrd   generate as temporary value
/* 13213 */	call    | cdwrd  << off_ ,
// cmp22:
/* 13214 */	stmt    | 4189   << off_ ,	//cmp22	mov xr cmfgo(xs)  load failure goto pointer
/* 13215 */	load    | xr     << dst_ | xs     << src_ | cmfgo  << off_ ,
/* 13216 */	stmt    | 4190   << off_ ,	//	mov wa xr  copy it
/* 13217 */	move    | wa     << dst_ | xr     << src_ ,
/* 13218 */	stmt    | 4191   << off_ ,	//	zer cmffc(xs)   set no fill in required yet
/* 13219 */	store   | r0     << dst_ | xs     << src_ | cmffc  << off_ ,
/* 13220 */	stmt    | 4192   << off_ ,	//	bze xr cmp23  jump if no failure goto given
/* 13221 */	bze     | xr     << dst_ | cmp23  << off_ ,
/* 13222 */	stmt    | 4193   << off_ ,	//	add wa *vrtra  point to vrtra field in case
/* 13223 */	loadi   | r2     << dst_ | vrtra  << off_ ,
/* 13224 */	add     | wa     << dst_ | r2     << src_ ,
/* 13225 */	stmt    | 4194   << off_ ,	//	blo xr state cmpse jump to gen if simple fgoto
/* 13226 */	load    | r2     << dst_ | state  << off_ ,
/* 13227 */	blo     | xr     << dst_ | r2     << src_ | cmpse  << off_ ,
/* 13228 */	stmt    | 4195   << off_ ,	//	mov wb cwcof  save offset to o_gof call
/* 13229 */	load    | wb     << dst_ | cwcof  << off_ ,
/* 13230 */	stmt    | 4196   << off_ ,	//	mov wa =ogof_  point to failure goto call
/* 13231 */	loadi   | wa     << dst_ | ogof_  << off_ ,
/* 13232 */	stmt    | 4197   << off_ ,	//	jsr cdwrd   generate
/* 13233 */	call    | cdwrd  << off_ ,
/* 13234 */	stmt    | 4198   << off_ ,	//	mov wa =ofif_  point to fail in fail word
/* 13235 */	loadi   | wa     << dst_ | ofif_  << off_ ,
/* 13236 */	stmt    | 4199   << off_ ,	//	jsr cdwrd   generate
/* 13237 */	call    | cdwrd  << off_ ,
/* 13238 */	stmt    | 4200   << off_ ,	//	jsr cdgcg   generate code for failure goto
/* 13239 */	call    | cdgcg  << off_ ,
/* 13240 */	stmt    | 4201   << off_ ,	//	mov wa wb  copy offset to o_gof for cdfal
/* 13241 */	move    | wa     << dst_ | wb     << src_ ,
/* 13242 */	stmt    | 4202   << off_ ,	//	mov wb =b_cdc  set complex case cdtyp
/* 13243 */	loadi   | wb     << dst_ | b_cdc  << off_ ,
/* 13244 */	stmt    | 4203   << off_ ,	//	brn cmp25   jump to build cdblk
/* 13245 */	brn     | cmp25  << off_ ,
// cmp23:
/* 13246 */	stmt    | 4204   << off_ ,	//cmp23	mov wa =ounf_  load unexpected failure call in cas
/* 13247 */	loadi   | wa     << dst_ | ounf_  << off_ ,
/* 13248 */	stmt    | 4205   << off_ ,	//	mov wc cswfl  get -nofail flag
/* 13249 */	load    | wc     << dst_ | cswfl  << off_ ,
/* 13250 */	stmt    | 4206   << off_ ,	//	orb wc cmcgo(xs)  check if conditional goto
/* 13251 */	load    | r2     << dst_ | xs     << src_ | cmcgo  << off_ ,
/* 13252 */	orb     | wc     << dst_ | r2     << src_ ,
/* 13253 */	stmt    | 4207   << off_ ,	//	zrb wc cmpse  jump if -nofail and no cond. goto
/* 13254 */	zrb     | wc     << dst_ | cmpse  << off_ ,
/* 13255 */	stmt    | 4208   << off_ ,	//	mnz cmffc(xs)   else set fill in flag
/* 13256 */	store   | xs     << dst_ | xs     << src_ | cmffc  << off_ ,
/* 13257 */	stmt    | 4209   << off_ ,	//	mov wa =ocer_  and set compile error for temporary
/* 13258 */	loadi   | wa     << dst_ | ocer_  << off_ ,
// cmpse:
/* 13259 */	stmt    | 4210   << off_ ,	//cmpse	mov wb =b_cds  set cdtyp for simple case
/* 13260 */	loadi   | wb     << dst_ | b_cds  << off_ ,
// cmp25:
/* 13261 */	stmt    | 4211   << off_ ,	//cmp25	mov xr r_ccb  point to ccblk
/* 13262 */	load    | xr     << dst_ | r_ccb  << off_ ,
/* 13263 */	stmt    | 4212   << off_ ,	//	mov xl cmlbl(xs)  get possible label pointer
/* 13264 */	load    | xl     << dst_ | xs     << src_ | cmlbl  << off_ ,
/* 13265 */	stmt    | 4213   << off_ ,	//	bze xl cmp26  skip if no label
/* 13266 */	bze     | xl     << dst_ | cmp26  << off_ ,
/* 13267 */	stmt    | 4214   << off_ ,	//	zer cmlbl(xs)   clear flag for next statement
/* 13268 */	store   | r0     << dst_ | xs     << src_ | cmlbl  << off_ ,
/* 13269 */	stmt    | 4215   << off_ ,	//	mov vrlbl(xl) xr  put cdblk ptr in vrblk label field
/* 13270 */	store   | xr     << dst_ | xl     << src_ | vrlbl  << off_ ,
// cmp26:
/* 13271 */	stmt    | 4216   << off_ ,	//cmp26	mov (xr) wb  set type word for new cdblk
/* 13272 */	store   | wb     << dst_ | xr     << src_ ,
/* 13273 */	stmt    | 4217   << off_ ,	//	mov cdfal(xr) wa  set failure word
/* 13274 */	store   | wa     << dst_ | xr     << src_ | cdfal  << off_ ,
/* 13275 */	stmt    | 4218   << off_ ,	//	mov xl xr  copy pointer to ccblk
/* 13276 */	move    | xl     << dst_ | xr     << src_ ,
/* 13277 */	stmt    | 4219   << off_ ,	//	mov wb ccuse(xr)  load length gen (= new cdlen)
/* 13278 */	load    | wb     << dst_ | xr     << src_ | ccuse  << off_ ,
/* 13279 */	stmt    | 4220   << off_ ,	//	mov wc cclen(xr)  load total ccblk length
/* 13280 */	load    | wc     << dst_ | xr     << src_ | cclen  << off_ ,
/* 13281 */	stmt    | 4221   << off_ ,	//	add xl wb  point past cdblk
/* 13282 */	add     | xl     << dst_ | wb     << src_ ,
/* 13283 */	stmt    | 4222   << off_ ,	//	sub wc wb  get length left for chop off
/* 13284 */	sub     | wc     << dst_ | wb     << src_ ,
/* 13285 */	stmt    | 4223   << off_ ,	//	mov (xl) =b_cct  set type code for new ccblk at end
/* 13286 */	loadi   | r1     << dst_ | b_cct  << off_ ,
/* 13287 */	store   | r1     << dst_ | xl     << src_ ,
/* 13288 */	stmt    | 4224   << off_ ,	//	mov ccuse(xl) *cccod  set initial code offset
/* 13289 */	loadi   | r1     << dst_ | cccod  << off_ ,
/* 13290 */	store   | r1     << dst_ | xl     << src_ | ccuse  << off_ ,
/* 13291 */	stmt    | 4225   << off_ ,	//	mov cwcof *cccod  reinitialise cwcof
/* 13292 */	loadi   | r1     << dst_ | cccod  << off_ ,
/* 13293 */	store   | r1     << dst_ | cwcof  << off_ ,
/* 13294 */	stmt    | 4226   << off_ ,	//	mov cclen(xl) wc  set new length
/* 13295 */	store   | wc     << dst_ | xl     << src_ | cclen  << off_ ,
/* 13296 */	stmt    | 4227   << off_ ,	//	mov r_ccb xl  set new ccblk pointer
/* 13297 */	store   | xl     << dst_ | r_ccb  << off_ ,
/* 13298 */	stmt    | 4228   << off_ ,	//	zer ccsln(xl)   initialize new line number
/* 13299 */	store   | r0     << dst_ | xl     << src_ | ccsln  << off_ ,
/* 13300 */	stmt    | 4229   << off_ ,	//	mov cdsln(xr) cmpln  set line number in old block
/* 13301 */	load    | r1     << dst_ | cmpln  << off_ ,
/* 13302 */	store   | r1     << dst_ | xr     << src_ | cdsln  << off_ ,
/* 13303 */	stmt    | 4230   << off_ ,	//	mov cdstm(xr) cmpsn  set statement number
/* 13304 */	load    | r1     << dst_ | cmpsn  << off_ ,
/* 13305 */	store   | r1     << dst_ | xr     << src_ | cdstm  << off_ ,
/* 13306 */	stmt    | 4231   << off_ ,	//	icv cmpsn   bump statement number
/* 13307 */	load    | r1     << dst_ | cmpsn  << off_ ,
/* 13308 */	icv     | r1     << dst_ ,
/* 13309 */	store   | r1     << dst_ | cmpsn  << off_ ,
/* 13310 */	stmt    | 4232   << off_ ,	//	mov xl cmpcd(xs)  load ptr to previous cdblk
/* 13311 */	load    | xl     << dst_ | xs     << src_ | cmpcd  << off_ ,
/* 13312 */	stmt    | 4233   << off_ ,	//	bze cmffp(xs) cmp27  jump if no failure fill in required
/* 13313 */	load    | r1     << dst_ | xs     << src_ | cmffp  << off_ ,
/* 13314 */	bze     | r1     << dst_ | cmp27  << off_ ,
/* 13315 */	stmt    | 4234   << off_ ,	//	mov cdfal(xl) xr  else set failure ptr in previous
/* 13316 */	store   | xr     << dst_ | xl     << src_ | cdfal  << off_ ,
// cmp27:
/* 13317 */	stmt    | 4235   << off_ ,	//cmp27	mov wa cmsop(xs)  load success offset
/* 13318 */	load    | wa     << dst_ | xs     << src_ | cmsop  << off_ ,
/* 13319 */	stmt    | 4236   << off_ ,	//	bze wa cmp28  jump if no fill in required
/* 13320 */	bze     | wa     << dst_ | cmp28  << off_ ,
/* 13321 */	stmt    | 4237   << off_ ,	//	add xl wa  else point to fill in location
/* 13322 */	add     | xl     << dst_ | wa     << src_ ,
/* 13323 */	stmt    | 4238   << off_ ,	//	mov (xl) xr  store forward pointer
/* 13324 */	store   | xr     << dst_ | xl     << src_ ,
/* 13325 */	stmt    | 4239   << off_ ,	//	zer xl   clear garbage xl value
/* 13326 */	move    | xl     << dst_ ,
// cmp28:
/* 13327 */	stmt    | 4240   << off_ ,	//cmp28	mov cmffp(xs) cmffc(xs)  copy failure fill in flag
/* 13328 */	load    | r1     << dst_ | xs     << src_ | cmffc  << off_ ,
/* 13329 */	store   | r1     << dst_ | xs     << src_ | cmffp  << off_ ,
/* 13330 */	stmt    | 4241   << off_ ,	//	mov cmsop(xs) cmsoc(xs)  copy success fill in offset
/* 13331 */	load    | r1     << dst_ | xs     << src_ | cmsoc  << off_ ,
/* 13332 */	store   | r1     << dst_ | xs     << src_ | cmsop  << off_ ,
/* 13333 */	stmt    | 4242   << off_ ,	//	mov cmpcd(xs) xr  save ptr to this cdblk
/* 13334 */	store   | xr     << dst_ | xs     << src_ | cmpcd  << off_ ,
/* 13335 */	stmt    | 4243   << off_ ,	//	bnz cmtra(xs) cmp29  jump if initial entry already set
/* 13336 */	load    | r1     << dst_ | xs     << src_ | cmtra  << off_ ,
/* 13337 */	bnz     | r1     << dst_ | cmp29  << off_ ,
/* 13338 */	stmt    | 4244   << off_ ,	//	mov cmtra(xs) xr  else set ptr here as default
/* 13339 */	store   | xr     << dst_ | xs     << src_ | cmtra  << off_ ,
// cmp29:
/* 13340 */	stmt    | 4245   << off_ ,	//cmp29	blt stage =stgce cmp01 jump if not end line just done
/* 13341 */	load    | r1     << dst_ | stage  << off_ ,
/* 13342 */	loadi   | r2     << dst_ | stgce  << off_ ,
/* 13343 */	blt     | r1     << dst_ | r2     << src_ | cmp01  << off_ ,
/* 13344 */	stmt    | 4246   << off_ ,	//	bze cswls cmp30  skip if -nolist
/* 13345 */	load    | r1     << dst_ | cswls  << off_ ,
/* 13346 */	bze     | r1     << dst_ | cmp30  << off_ ,
/* 13347 */	stmt    | 4247   << off_ ,	//	jsr listr   list last line
/* 13348 */	call    | listr  << off_ ,
// cmp30:
/* 13349 */	stmt    | 4248   << off_ ,	//cmp30	mov xr cmtra(xs)  load initial entry cdblk pointer
/* 13350 */	load    | xr     << dst_ | xs     << src_ | cmtra  << off_ ,
/* 13351 */	stmt    | 4249   << off_ ,	//	add xs *cmnen  pop work locations off stack
/* 13352 */	loadi   | r2     << dst_ | cmnen  << off_ ,
/* 13353 */	add     | xs     << dst_ | r2     << src_ ,
/* 13354 */	stmt    | 4250   << off_ ,	//	exi    and return to cmpil caller
/* 13355 */	exi     | 0      << off_ ,
// cmp31:
/* 13356 */	stmt    | 4251   << off_ ,	//cmp31	mov wb cmfgo(xs)  get fail goto
/* 13357 */	load    | wb     << dst_ | xs     << src_ | cmfgo  << off_ ,
/* 13358 */	stmt    | 4252   << off_ ,	//	orb wb cmsgo(xs)  or in success goto
/* 13359 */	load    | r2     << dst_ | xs     << src_ | cmsgo  << off_ ,
/* 13360 */	orb     | wb     << dst_ | r2     << src_ ,
/* 13361 */	stmt    | 4253   << off_ ,	//	bnz wb cmp18  ok if non-null field
/* 13362 */	bnz     | wb     << dst_ | cmp18  << off_ ,
/* 13363 */	stmt    | 4254   << off_ ,	//	erb 219 syntax error: empty goto field
/* 13364 */	erb     | 219    << off_ ,
// cmp32:
/* 13365 */	stmt    | 4255   << off_ ,	//cmp32	icv wb   point past ch_mn
/* 13366 */	icv     | wb     << dst_ ,
/* 13367 */	stmt    | 4256   << off_ ,	//	jsr cncrd   process control card
/* 13368 */	call    | cncrd  << off_ ,
/* 13369 */	stmt    | 4257   << off_ ,	//	zer scnse   clear start of element loc.
/* 13370 */	store   | r0     << dst_ | scnse  << off_ ,
/* 13371 */	stmt    | 4258   << off_ ,	//	brn cmpce   loop for next statement
/* 13372 */	brn     | cmpce  << off_ ,
// cncrd:
/* 13373 */	stmt    | 4259   << off_ ,	//cncrd	prc e 0  entry point
/* 13374 */	stmt    | 4260   << off_ ,	//	mov scnpt wb  offset for control card scan
/* 13375 */	store   | wb     << dst_ | scnpt  << off_ ,
/* 13376 */	stmt    | 4261   << off_ ,	//	mov wa =ccnoc  number of chars for comparison
/* 13377 */	loadi   | wa     << dst_ | ccnoc  << off_ ,
/* 13378 */	stmt    | 4262   << off_ ,	//	ctw wa 0  convert to word count
/* 13379 */	stmt    | 4263   << off_ ,	//	mov cnswc wa  save word count
/* 13380 */	store   | wa     << dst_ | cnswc  << off_ ,
// cnc01:
/* 13381 */	stmt    | 4264   << off_ ,	//cnc01	bge scnpt scnil cnc09 return if end of image
/* 13382 */	load    | r1     << dst_ | scnpt  << off_ ,
/* 13383 */	load    | r2     << dst_ | scnil  << off_ ,
/* 13384 */	bge     | r1     << dst_ | r2     << src_ | cnc09  << off_ ,
/* 13385 */	stmt    | 4265   << off_ ,	//	mov xr r_cim  point to image
/* 13386 */	load    | xr     << dst_ | r_cim  << off_ ,
/* 13387 */	stmt    | 4266   << off_ ,	//	plc xr scnpt  char ptr for first char
/* 13388 */	load    | r2     << dst_ | scnpt  << off_ ,
/* 13389 */	plc     | xr     << dst_ | r2     << src_ ,
/* 13390 */	stmt    | 4267   << off_ ,	//	lch wa (xr)+  get first char
/* 13391 */	load    | wa     << dst_ | xr     << src_ ,
/* 13392 */	ica     | xr     << dst_ ,
/* 13393 */	stmt    | 4268   << off_ ,	//	beq wa =ch_li cnc07 special case of -inxxx
/* 13394 */	loadi   | r2     << dst_ | ch_li  << off_ ,
/* 13395 */	beq     | wa     << dst_ | r2     << src_ | cnc07  << off_ ,
// cnc0a:
/* 13396 */	stmt    | 4269   << off_ ,	//cnc0a	mnz scncc   set flag for scane
/* 13397 */	store   | xs     << dst_ | scncc  << off_ ,
/* 13398 */	stmt    | 4270   << off_ ,	//	jsr scane   scan card name
/* 13399 */	call    | scane  << off_ ,
/* 13400 */	stmt    | 4271   << off_ ,	//	zer scncc   clear scane flag
/* 13401 */	store   | r0     << dst_ | scncc  << off_ ,
/* 13402 */	stmt    | 4272   << off_ ,	//	bnz xl cnc06  fail unless control card name
/* 13403 */	bnz     | xl     << dst_ | cnc06  << off_ ,
/* 13404 */	stmt    | 4273   << off_ ,	//	mov wa =ccnoc  no. of chars to be compared
/* 13405 */	loadi   | wa     << dst_ | ccnoc  << off_ ,
/* 13406 */	stmt    | 4274   << off_ ,	//	blt sclen(xr) wa cnc08 fail if too few chars
/* 13407 */	load    | r1     << dst_ | xr     << src_ | sclen  << off_ ,
/* 13408 */	blt     | r1     << dst_ | wa     << src_ | cnc08  << off_ ,
/* 13409 */	stmt    | 4275   << off_ ,	//	mov xl xr  point to control card name
/* 13410 */	move    | xl     << dst_ | xr     << src_ ,
/* 13411 */	stmt    | 4276   << off_ ,	//	zer wb   zero offset for substring
/* 13412 */	move    | wb     << dst_ ,
/* 13413 */	stmt    | 4277   << off_ ,	//	jsr sbstr   extract substring for comparison
/* 13414 */	call    | sbstr  << off_ ,
/* 13415 */	stmt    | 4278   << off_ ,	//	mov cnscc xr  keep control card substring ptr
/* 13416 */	store   | xr     << dst_ | cnscc  << off_ ,
/* 13417 */	stmt    | 4279   << off_ ,	//	mov xr =ccnms  point to list of standard names
/* 13418 */	loadi   | xr     << dst_ | ccnms  << off_ ,
/* 13419 */	stmt    | 4280   << off_ ,	//	zer wb   initialise name offset
/* 13420 */	move    | wb     << dst_ ,
/* 13421 */	stmt    | 4281   << off_ ,	//	lct wc =cc_nc  number of standard names
/* 13422 */	loadi   | wc     << dst_ | cc_nc  << off_ ,
// cnc02:
/* 13423 */	stmt    | 4282   << off_ ,	//cnc02	mov xl cnscc  point to name
/* 13424 */	load    | xl     << dst_ | cnscc  << off_ ,
/* 13425 */	stmt    | 4283   << off_ ,	//	lct wa cnswc  counter for inner loop
/* 13426 */	load    | wa     << dst_ | cnswc  << off_ ,
/* 13427 */	stmt    | 4284   << off_ ,	//	brn cnc04   jump into loop
/* 13428 */	brn     | cnc04  << off_ ,
// cnc03:
/* 13429 */	stmt    | 4285   << off_ ,	//cnc03	ica xr   bump standard names ptr
/* 13430 */	ica     | xr     << dst_ ,
/* 13431 */	stmt    | 4286   << off_ ,	//	ica xl   bump name pointer
/* 13432 */	ica     | xl     << dst_ ,
// cnc04:
/* 13433 */	stmt    | 4287   << off_ ,	//cnc04	cne schar(xl) (xr) cnc05 comp. up to cfp_c chars at once
/* 13434 */	load    | r1     << dst_ | xl     << src_ | schar  << off_ ,
/* 13435 */	load    | r2     << dst_ | xr     << src_ ,
/* 13436 */	cne     | r1     << dst_ | r2     << src_ | cnc05  << off_ ,
/* 13437 */	stmt    | 4288   << off_ ,	//	bct wa cnc03  loop if more words to compare
/* 13438 */	bct     | wa     << dst_ | cnc03  << off_ ,
/* 13439 */	stmt    | 4289   << off_ ,	//	mov xl wb  get name offset
/* 13440 */	move    | xl     << dst_ | wb     << src_ ,
/* 13441 */	stmt    | 4290   << off_ ,	//	bsw xl cc_nc cnc08 switch
/* 13442 */	loadi   | r1     << dst_ | cc_nc  << off_ ,
/* 13443 */	bsw     | xl     << dst_ | r1     << src_ | cnc08  << off_ ,
/* 13444 */	cnc10   ,
/* 13445 */	cnc08   ,
/* 13446 */	cnc11   ,
/* 13447 */	cnc41   ,
/* 13448 */	cnc12   ,
/* 13449 */	cnc13   ,
/* 13450 */	cnc14   ,
/* 13451 */	cnc15   ,
/* 13452 */	cnc41   ,
/* 13453 */	cnc44   ,
/* 13454 */	cnc16   ,
/* 13455 */	cnc17   ,
/* 13456 */	cnc18   ,
/* 13457 */	cnc19   ,
/* 13458 */	cnc20   ,
/* 13459 */	cnc21   ,
/* 13460 */	cnc22   ,
/* 13461 */	cnc24   ,
/* 13462 */	cnc25   ,
/* 13463 */	cnc27   ,
/* 13464 */	cnc28   ,
/* 13465 */	cnc31   ,
/* 13466 */	cnc32   ,
/* 13467 */	cnc36   ,
// cnc05:
/* 13468 */	stmt    | 4291   << off_ ,	//cnc05	ica xr   bump standard names ptr
/* 13469 */	ica     | xr     << dst_ ,
/* 13470 */	stmt    | 4292   << off_ ,	//	bct wa cnc05  loop
/* 13471 */	bct     | wa     << dst_ | cnc05  << off_ ,
/* 13472 */	stmt    | 4293   << off_ ,	//	icv wb   bump names offset
/* 13473 */	icv     | wb     << dst_ ,
/* 13474 */	stmt    | 4294   << off_ ,	//	bct wc cnc02  continue if more names
/* 13475 */	bct     | wc     << dst_ | cnc02  << off_ ,
/* 13476 */	stmt    | 4295   << off_ ,	//	brn cnc08   ignore unrecognized control card
/* 13477 */	brn     | cnc08  << off_ ,
// cnc06:
/* 13478 */	stmt    | 4296   << off_ ,	//cnc06	erb 247 invalid control statement
/* 13479 */	erb     | 247    << off_ ,
// cnc07:
/* 13480 */	stmt    | 4297   << off_ ,	//cnc07	lch wa (xr)+  get next char
/* 13481 */	load    | wa     << dst_ | xr     << src_ ,
/* 13482 */	ica     | xr     << dst_ ,
/* 13483 */	stmt    | 4298   << off_ ,	//	bne wa =ch_ln cnc0a if not letter n
/* 13484 */	loadi   | r2     << dst_ | ch_ln  << off_ ,
/* 13485 */	bne     | wa     << dst_ | r2     << src_ | cnc0a  << off_ ,
/* 13486 */	stmt    | 4299   << off_ ,	//	lch wa (xr)  get third char
/* 13487 */	load    | wa     << dst_ | xr     << src_ ,
/* 13488 */	stmt    | 4300   << off_ ,	//	blt wa =ch_d0 cnc0a if not digit
/* 13489 */	loadi   | r2     << dst_ | ch_d0  << off_ ,
/* 13490 */	blt     | wa     << dst_ | r2     << src_ | cnc0a  << off_ ,
/* 13491 */	stmt    | 4301   << off_ ,	//	bgt wa =ch_d9 cnc0a if not digit
/* 13492 */	loadi   | r2     << dst_ | ch_d9  << off_ ,
/* 13493 */	bgt     | wa     << dst_ | r2     << src_ | cnc0a  << off_ ,
/* 13494 */	stmt    | 4302   << off_ ,	//	add scnpt =num02  bump offset past -in
/* 13495 */	load    | r1     << dst_ | scnpt  << off_ ,
/* 13496 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 13497 */	add     | r1     << dst_ | r2     << src_ ,
/* 13498 */	store   | r1     << dst_ | scnpt  << off_ ,
/* 13499 */	stmt    | 4303   << off_ ,	//	jsr scane   scan integer after -in
/* 13500 */	call    | scane  << off_ ,
/* 13501 */	stmt    | 4304   << off_ ,	//	mov -(xs) xr  stack scanned item
/* 13502 */	dca     | xs     << dst_ ,
/* 13503 */	store   | xr     << dst_ | xs     << src_ ,
/* 13504 */	stmt    | 4305   << off_ ,	//	jsr gtsmi   check if integer
/* 13505 */	call    | gtsmi  << off_ ,
/* 13506 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/* 13507 */	ppm     | cnc06  << off_ ,
/* 13508 */	ppm     | cnc06  << off_ ,
/* 13509 */	stmt    | 4306   << off_ ,	//	mov cswin xr  keep integer
/* 13510 */	store   | xr     << dst_ | cswin  << off_ ,
// cnc08:
/* 13511 */	stmt    | 4307   << off_ ,	//cnc08	mov wa scnpt  preserve in case xeq time compile
/* 13512 */	load    | wa     << dst_ | scnpt  << off_ ,
/* 13513 */	stmt    | 4308   << off_ ,	//	jsr scane   look for comma
/* 13514 */	call    | scane  << off_ ,
/* 13515 */	stmt    | 4309   << off_ ,	//	beq xl =t_cma cnc01 loop if comma found
/* 13516 */	loadi   | r2     << dst_ | t_cma  << off_ ,
/* 13517 */	beq     | xl     << dst_ | r2     << src_ | cnc01  << off_ ,
/* 13518 */	stmt    | 4310   << off_ ,	//	mov scnpt wa  restore scnpt in case xeq time
/* 13519 */	store   | wa     << dst_ | scnpt  << off_ ,
// cnc09:
/* 13520 */	stmt    | 4311   << off_ ,	//cnc09	exi    return
/* 13521 */	exi     | 0      << off_ ,
// cnc10:
/* 13522 */	stmt    | 4312   << off_ ,	//cnc10	mnz cswdb   set switch
/* 13523 */	store   | xs     << dst_ | cswdb  << off_ ,
/* 13524 */	stmt    | 4313   << off_ ,	//	brn cnc08   merge
/* 13525 */	brn     | cnc08  << off_ ,
// cnc11:
/* 13526 */	stmt    | 4314   << off_ ,	//cnc11	jsr sysdm   call dumper
/* 13527 */	sys     | sysdm_ << off_ ,
/* 13528 */	stmt    | 4315   << off_ ,	//	brn cnc09   finished
/* 13529 */	brn     | cnc09  << off_ ,
// cnc12:
/* 13530 */	stmt    | 4316   << off_ ,	//cnc12	bze cswls cnc09  return if -nolist
/* 13531 */	load    | r1     << dst_ | cswls  << off_ ,
/* 13532 */	bze     | r1     << dst_ | cnc09  << off_ ,
/* 13533 */	stmt    | 4317   << off_ ,	//	jsr prtps   eject
/* 13534 */	call    | prtps  << off_ ,
/* 13535 */	stmt    | 4318   << off_ ,	//	jsr listt   list title
/* 13536 */	call    | listt  << off_ ,
/* 13537 */	stmt    | 4319   << off_ ,	//	brn cnc09   finished
/* 13538 */	brn     | cnc09  << off_ ,
// cnc13:
/* 13539 */	stmt    | 4320   << off_ ,	//cnc13	zer cswer   clear switch
/* 13540 */	store   | r0     << dst_ | cswer  << off_ ,
/* 13541 */	stmt    | 4321   << off_ ,	//	brn cnc08   merge
/* 13542 */	brn     | cnc08  << off_ ,
// cnc14:
/* 13543 */	stmt    | 4322   << off_ ,	//cnc14	zer cswex   clear switch
/* 13544 */	store   | r0     << dst_ | cswex  << off_ ,
/* 13545 */	stmt    | 4323   << off_ ,	//	brn cnc08   merge
/* 13546 */	brn     | cnc08  << off_ ,
// cnc15:
/* 13547 */	stmt    | 4324   << off_ ,	//cnc15	mnz cswfl   set switch
/* 13548 */	store   | xs     << dst_ | cswfl  << off_ ,
/* 13549 */	stmt    | 4325   << off_ ,	//	brn cnc08   merge
/* 13550 */	brn     | cnc08  << off_ ,
// cnc16:
/* 13551 */	stmt    | 4326   << off_ ,	//cnc16	mnz cswls   set switch
/* 13552 */	store   | xs     << dst_ | cswls  << off_ ,
/* 13553 */	stmt    | 4327   << off_ ,	//	beq stage =stgic cnc08 done if compile time
/* 13554 */	load    | r1     << dst_ | stage  << off_ ,
/* 13555 */	loadi   | r2     << dst_ | stgic  << off_ ,
/* 13556 */	beq     | r1     << dst_ | r2     << src_ | cnc08  << off_ ,
/* 13557 */	stmt    | 4328   << off_ ,	//	zer lstpf   permit listing
/* 13558 */	store   | r0     << dst_ | lstpf  << off_ ,
/* 13559 */	stmt    | 4329   << off_ ,	//	jsr listr   list line
/* 13560 */	call    | listr  << off_ ,
/* 13561 */	stmt    | 4330   << off_ ,	//	brn cnc08   merge
/* 13562 */	brn     | cnc08  << off_ ,
// cnc17:
/* 13563 */	stmt    | 4331   << off_ ,	//cnc17	mnz cswer   set switch
/* 13564 */	store   | xs     << dst_ | cswer  << off_ ,
/* 13565 */	stmt    | 4332   << off_ ,	//	brn cnc08   merge
/* 13566 */	brn     | cnc08  << off_ ,
// cnc18:
/* 13567 */	stmt    | 4333   << off_ ,	//cnc18	mnz cswex   set switch
/* 13568 */	store   | xs     << dst_ | cswex  << off_ ,
/* 13569 */	stmt    | 4334   << off_ ,	//	brn cnc08   merge
/* 13570 */	brn     | cnc08  << off_ ,
// cnc19:
/* 13571 */	stmt    | 4335   << off_ ,	//cnc19	zer cswfl   clear switch
/* 13572 */	store   | r0     << dst_ | cswfl  << off_ ,
/* 13573 */	stmt    | 4336   << off_ ,	//	brn cnc08   merge
/* 13574 */	brn     | cnc08  << off_ ,
// cnc20:
/* 13575 */	stmt    | 4337   << off_ ,	//cnc20	zer cswls   clear switch
/* 13576 */	store   | r0     << dst_ | cswls  << off_ ,
/* 13577 */	stmt    | 4338   << off_ ,	//	brn cnc08   merge
/* 13578 */	brn     | cnc08  << off_ ,
// cnc21:
/* 13579 */	stmt    | 4339   << off_ ,	//cnc21	mnz cswno   set switch
/* 13580 */	store   | xs     << dst_ | cswno  << off_ ,
/* 13581 */	stmt    | 4340   << off_ ,	//	brn cnc08   merge
/* 13582 */	brn     | cnc08  << off_ ,
// cnc22:
/* 13583 */	stmt    | 4341   << off_ ,	//cnc22	zer cswpr   clear switch
/* 13584 */	store   | r0     << dst_ | cswpr  << off_ ,
/* 13585 */	stmt    | 4342   << off_ ,	//	brn cnc08   merge
/* 13586 */	brn     | cnc08  << off_ ,
// cnc24:
/* 13587 */	stmt    | 4343   << off_ ,	//cnc24	zer cswno   clear switch
/* 13588 */	store   | r0     << dst_ | cswno  << off_ ,
/* 13589 */	stmt    | 4344   << off_ ,	//	brn cnc08   merge
/* 13590 */	brn     | cnc08  << off_ ,
// cnc25:
/* 13591 */	stmt    | 4345   << off_ ,	//cnc25	mnz cswpr   set switch
/* 13592 */	store   | xs     << dst_ | cswpr  << off_ ,
/* 13593 */	stmt    | 4346   << off_ ,	//	brn cnc08   merge
/* 13594 */	brn     | cnc08  << off_ ,
// cnc27:
/* 13595 */	stmt    | 4347   << off_ ,	//cnc27	zer cswdb   clear switch
/* 13596 */	store   | r0     << dst_ | cswdb  << off_ ,
/* 13597 */	stmt    | 4348   << off_ ,	//	brn cnc08   merge
/* 13598 */	brn     | cnc08  << off_ ,
// cnc28:
/* 13599 */	stmt    | 4349   << off_ ,	//cnc28	bze cswls cnc09  return if -nolist
/* 13600 */	load    | r1     << dst_ | cswls  << off_ ,
/* 13601 */	bze     | r1     << dst_ | cnc09  << off_ ,
/* 13602 */	stmt    | 4350   << off_ ,	//	jsr scane   scan integer after -space
/* 13603 */	call    | scane  << off_ ,
/* 13604 */	stmt    | 4351   << off_ ,	//	mov wc =num01  1 space in case
/* 13605 */	loadi   | wc     << dst_ | num01  << off_ ,
/* 13606 */	stmt    | 4352   << off_ ,	//	beq xr =t_smc cnc29 jump if no integer
/* 13607 */	loadi   | r2     << dst_ | t_smc  << off_ ,
/* 13608 */	beq     | xr     << dst_ | r2     << src_ | cnc29  << off_ ,
/* 13609 */	stmt    | 4353   << off_ ,	//	mov -(xs) xr  stack it
/* 13610 */	dca     | xs     << dst_ ,
/* 13611 */	store   | xr     << dst_ | xs     << src_ ,
/* 13612 */	stmt    | 4354   << off_ ,	//	jsr gtsmi   check integer
/* 13613 */	call    | gtsmi  << off_ ,
/* 13614 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/* 13615 */	ppm     | cnc06  << off_ ,
/* 13616 */	ppm     | cnc06  << off_ ,
/* 13617 */	stmt    | 4355   << off_ ,	//	bnz wc cnc29  jump if non zero
/* 13618 */	bnz     | wc     << dst_ | cnc29  << off_ ,
/* 13619 */	stmt    | 4356   << off_ ,	//	mov wc =num01  else 1 space
/* 13620 */	loadi   | wc     << dst_ | num01  << off_ ,
// cnc29:
/* 13621 */	stmt    | 4357   << off_ ,	//cnc29	add lstlc wc  bump line count
/* 13622 */	load    | r1     << dst_ | lstlc  << off_ ,
/* 13623 */	add     | r1     << dst_ | wc     << src_ ,
/* 13624 */	store   | r1     << dst_ | lstlc  << off_ ,
/* 13625 */	stmt    | 4358   << off_ ,	//	lct wc wc  convert to loop counter
/* 13626 */	stmt    | 4359   << off_ ,	//	blt lstlc lstnp cnc30 jump if fits on page
/* 13627 */	load    | r1     << dst_ | lstlc  << off_ ,
/* 13628 */	load    | r2     << dst_ | lstnp  << off_ ,
/* 13629 */	blt     | r1     << dst_ | r2     << src_ | cnc30  << off_ ,
/* 13630 */	stmt    | 4360   << off_ ,	//	jsr prtps   eject
/* 13631 */	call    | prtps  << off_ ,
/* 13632 */	stmt    | 4361   << off_ ,	//	jsr listt   list title
/* 13633 */	call    | listt  << off_ ,
/* 13634 */	stmt    | 4362   << off_ ,	//	brn cnc09   merge
/* 13635 */	brn     | cnc09  << off_ ,
// cnc30:
/* 13636 */	stmt    | 4363   << off_ ,	//cnc30	jsr prtnl   print a blank
/* 13637 */	call    | prtnl  << off_ ,
/* 13638 */	stmt    | 4364   << off_ ,	//	bct wc cnc30  loop
/* 13639 */	bct     | wc     << dst_ | cnc30  << off_ ,
/* 13640 */	stmt    | 4365   << off_ ,	//	brn cnc09   merge
/* 13641 */	brn     | cnc09  << off_ ,
// cnc31:
/* 13642 */	stmt    | 4366   << off_ ,	//cnc31	mov cnr_t =r_stl  ptr to r_stl
/* 13643 */	loadi   | r1     << dst_ | r_stl  << off_ ,
/* 13644 */	store   | r1     << dst_ | cnr_t  << off_ ,
/* 13645 */	stmt    | 4367   << off_ ,	//	brn cnc33   merge
/* 13646 */	brn     | cnc33  << off_ ,
// cnc32:
/* 13647 */	stmt    | 4368   << off_ ,	//cnc32	mov r_stl =nulls  clear subtitle
/* 13648 */	loadi   | r1     << dst_ | nulls  << off_ ,
/* 13649 */	store   | r1     << dst_ | r_stl  << off_ ,
/* 13650 */	stmt    | 4369   << off_ ,	//	mov cnr_t =r_ttl  ptr to r_ttl
/* 13651 */	loadi   | r1     << dst_ | r_ttl  << off_ ,
/* 13652 */	store   | r1     << dst_ | cnr_t  << off_ ,
// cnc33:
/* 13653 */	stmt    | 4370   << off_ ,	//cnc33	mov xr =nulls  null in case needed
/* 13654 */	loadi   | xr     << dst_ | nulls  << off_ ,
/* 13655 */	stmt    | 4371   << off_ ,	//	mnz cnttl   set flag for next listr call
/* 13656 */	store   | xs     << dst_ | cnttl  << off_ ,
/* 13657 */	stmt    | 4372   << off_ ,	//	mov wb =ccofs  offset to title/subtitle
/* 13658 */	loadi   | wb     << dst_ | ccofs  << off_ ,
/* 13659 */	stmt    | 4373   << off_ ,	//	mov wa scnil  input image length
/* 13660 */	load    | wa     << dst_ | scnil  << off_ ,
/* 13661 */	stmt    | 4374   << off_ ,	//	blo wa wb cnc34 jump if no chars left
/* 13662 */	blo     | wa     << dst_ | wb     << src_ | cnc34  << off_ ,
/* 13663 */	stmt    | 4375   << off_ ,	//	sub wa wb  no of chars to extract
/* 13664 */	sub     | wa     << dst_ | wb     << src_ ,
/* 13665 */	stmt    | 4376   << off_ ,	//	mov xl r_cim  point to image
/* 13666 */	load    | xl     << dst_ | r_cim  << off_ ,
/* 13667 */	stmt    | 4377   << off_ ,	//	jsr sbstr   get title/subtitle
/* 13668 */	call    | sbstr  << off_ ,
// cnc34:
/* 13669 */	stmt    | 4378   << off_ ,	//cnc34	mov xl cnr_t  point to storage location
/* 13670 */	load    | xl     << dst_ | cnr_t  << off_ ,
/* 13671 */	stmt    | 4379   << off_ ,	//	mov (xl) xr  store title/subtitle
/* 13672 */	store   | xr     << dst_ | xl     << src_ ,
/* 13673 */	stmt    | 4380   << off_ ,	//	beq xl =r_stl cnc09 return if stitl
/* 13674 */	loadi   | r2     << dst_ | r_stl  << off_ ,
/* 13675 */	beq     | xl     << dst_ | r2     << src_ | cnc09  << off_ ,
/* 13676 */	stmt    | 4381   << off_ ,	//	bnz precl cnc09  return if extended listing
/* 13677 */	load    | r1     << dst_ | precl  << off_ ,
/* 13678 */	bnz     | r1     << dst_ | cnc09  << off_ ,
/* 13679 */	stmt    | 4382   << off_ ,	//	bze prich cnc09  return if regular printer
/* 13680 */	load    | r1     << dst_ | prich  << off_ ,
/* 13681 */	bze     | r1     << dst_ | cnc09  << off_ ,
/* 13682 */	stmt    | 4383   << off_ ,	//	mov xl sclen(xr)  get length of title
/* 13683 */	load    | xl     << dst_ | xr     << src_ | sclen  << off_ ,
/* 13684 */	stmt    | 4384   << off_ ,	//	mov wa xl  copy it
/* 13685 */	move    | wa     << dst_ | xl     << src_ ,
/* 13686 */	stmt    | 4385   << off_ ,	//	bze xl cnc35  jump if null
/* 13687 */	bze     | xl     << dst_ | cnc35  << off_ ,
/* 13688 */	stmt    | 4386   << off_ ,	//	add xl =num10  increment
/* 13689 */	loadi   | r2     << dst_ | num10  << off_ ,
/* 13690 */	add     | xl     << dst_ | r2     << src_ ,
/* 13691 */	stmt    | 4387   << off_ ,	//	bhi xl prlen cnc09 use default lstp0 val if too long
/* 13692 */	load    | r2     << dst_ | prlen  << off_ ,
/* 13693 */	bhi     | xl     << dst_ | r2     << src_ | cnc09  << off_ ,
/* 13694 */	stmt    | 4388   << off_ ,	//	add wa =num04  point just past title
/* 13695 */	loadi   | r2     << dst_ | num04  << off_ ,
/* 13696 */	add     | wa     << dst_ | r2     << src_ ,
// cnc35:
/* 13697 */	stmt    | 4389   << off_ ,	//cnc35	mov lstpo wa  store offset
/* 13698 */	store   | wa     << dst_ | lstpo  << off_ ,
/* 13699 */	stmt    | 4390   << off_ ,	//	brn cnc09   return
/* 13700 */	brn     | cnc09  << off_ ,
// cnc36:
/* 13701 */	stmt    | 4391   << off_ ,	//cnc36	jsr systt   toggle switch
/* 13702 */	sys     | systt_ << off_ ,
/* 13703 */	stmt    | 4392   << off_ ,	//	brn cnc08   merge
/* 13704 */	brn     | cnc08  << off_ ,
// cnc41:
/* 13705 */	stmt    | 4393   << off_ ,	//cnc41	mnz scncc   set flag for scane
/* 13706 */	store   | xs     << dst_ | scncc  << off_ ,
/* 13707 */	stmt    | 4394   << off_ ,	//	jsr scane   scan quoted file name
/* 13708 */	call    | scane  << off_ ,
/* 13709 */	stmt    | 4395   << off_ ,	//	zer scncc   clear scane flag
/* 13710 */	store   | r0     << dst_ | scncc  << off_ ,
/* 13711 */	stmt    | 4396   << off_ ,	//	bne xl =t_con cnc06 if not constant
/* 13712 */	loadi   | r2     << dst_ | t_con  << off_ ,
/* 13713 */	bne     | xl     << dst_ | r2     << src_ | cnc06  << off_ ,
/* 13714 */	stmt    | 4397   << off_ ,	//	bne (xr) =b_scl cnc06 if not string constant
/* 13715 */	load    | r1     << dst_ | xr     << src_ ,
/* 13716 */	loadi   | r2     << dst_ | b_scl  << off_ ,
/* 13717 */	bne     | r1     << dst_ | r2     << src_ | cnc06  << off_ ,
/* 13718 */	stmt    | 4398   << off_ ,	//	mov r_ifn xr  save file name
/* 13719 */	store   | xr     << dst_ | r_ifn  << off_ ,
/* 13720 */	stmt    | 4399   << off_ ,	//	mov xl r_inc  examine include file name table
/* 13721 */	load    | xl     << dst_ | r_inc  << off_ ,
/* 13722 */	stmt    | 4400   << off_ ,	//	zer wb   lookup by value
/* 13723 */	move    | wb     << dst_ ,
/* 13724 */	stmt    | 4401   << off_ ,	//	jsr tfind   do lookup
/* 13725 */	call    | tfind  << off_ ,
/* 13726 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 13727 */	ppm     ,
/* 13728 */	stmt    | 4402   << off_ ,	//	beq xr =inton cnc09 ignore if already in table
/* 13729 */	loadi   | r2     << dst_ | inton  << off_ ,
/* 13730 */	beq     | xr     << dst_ | r2     << src_ | cnc09  << off_ ,
/* 13731 */	stmt    | 4403   << off_ ,	//	mnz wb   set for trim
/* 13732 */	move    | wb     << dst_ | xs     << src_ ,
/* 13733 */	stmt    | 4404   << off_ ,	//	mov xr r_ifn  file name
/* 13734 */	load    | xr     << dst_ | r_ifn  << off_ ,
/* 13735 */	stmt    | 4405   << off_ ,	//	jsr trimr   remove trailing blanks
/* 13736 */	call    | trimr  << off_ ,
/* 13737 */	stmt    | 4406   << off_ ,	//	mov xl r_inc  include file name table
/* 13738 */	load    | xl     << dst_ | r_inc  << off_ ,
/* 13739 */	stmt    | 4407   << off_ ,	//	mnz wb   lookup by name this time
/* 13740 */	move    | wb     << dst_ | xs     << src_ ,
/* 13741 */	stmt    | 4408   << off_ ,	//	jsr tfind   do lookup
/* 13742 */	call    | tfind  << off_ ,
/* 13743 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 13744 */	ppm     ,
/* 13745 */	stmt    | 4409   << off_ ,	//	mov teval(xl) =inton  make table value integer 1
/* 13746 */	loadi   | r1     << dst_ | inton  << off_ ,
/* 13747 */	store   | r1     << dst_ | xl     << src_ | teval  << off_ ,
/* 13748 */	stmt    | 4410   << off_ ,	//	icv cnind   increase nesting level
/* 13749 */	load    | r1     << dst_ | cnind  << off_ ,
/* 13750 */	icv     | r1     << dst_ ,
/* 13751 */	store   | r1     << dst_ | cnind  << off_ ,
/* 13752 */	stmt    | 4411   << off_ ,	//	mov wa cnind  load new nest level
/* 13753 */	load    | wa     << dst_ | cnind  << off_ ,
/* 13754 */	stmt    | 4412   << off_ ,	//	bgt wa =ccinm cnc42 fail if excessive nesting
/* 13755 */	loadi   | r2     << dst_ | ccinm  << off_ ,
/* 13756 */	bgt     | wa     << dst_ | r2     << src_ | cnc42  << off_ ,
/* 13757 */	stmt    | 4413   << off_ ,	//	mov xl r_ifa  array of nested file names
/* 13758 */	load    | xl     << dst_ | r_ifa  << off_ ,
/* 13759 */	stmt    | 4414   << off_ ,	//	add wa =vcvlb  compute offset in words
/* 13760 */	loadi   | r2     << dst_ | vcvlb  << off_ ,
/* 13761 */	add     | wa     << dst_ | r2     << src_ ,
/* 13762 */	stmt    | 4415   << off_ ,	//	wtb wa   convert to bytes
/* 13763 */	stmt    | 4416   << off_ ,	//	add xl wa  point to element
/* 13764 */	add     | xl     << dst_ | wa     << src_ ,
/* 13765 */	stmt    | 4417   << off_ ,	//	mov (xl) r_sfc  record current file name
/* 13766 */	load    | r1     << dst_ | r_sfc  << off_ ,
/* 13767 */	store   | r1     << dst_ | xl     << src_ ,
/* 13768 */	stmt    | 4418   << off_ ,	//	mov xl wa  preserve nesting byte offset
/* 13769 */	move    | xl     << dst_ | wa     << src_ ,
/* 13770 */	stmt    | 4419   << off_ ,	//	mti rdnln   fetch source line number as integer
/* 13771 */	load    | ia     << dst_ | rdnln  << off_ ,
/* 13772 */	stmt    | 4420   << off_ ,	//	jsr icbld   convert to icblk
/* 13773 */	call    | icbld  << off_ ,
/* 13774 */	stmt    | 4421   << off_ ,	//	add xl r_ifl  entry in nested line number array
/* 13775 */	load    | r2     << dst_ | r_ifl  << off_ ,
/* 13776 */	add     | xl     << dst_ | r2     << src_ ,
/* 13777 */	stmt    | 4422   << off_ ,	//	mov (xl) xr  record in array
/* 13778 */	store   | xr     << dst_ | xl     << src_ ,
/* 13779 */	stmt    | 4423   << off_ ,	//	mov wa cswin  max read length
/* 13780 */	load    | wa     << dst_ | cswin  << off_ ,
/* 13781 */	stmt    | 4424   << off_ ,	//	mov xl r_ifn  include file name
/* 13782 */	load    | xl     << dst_ | r_ifn  << off_ ,
/* 13783 */	stmt    | 4425   << off_ ,	//	jsr alocs   get buffer for complete file name
/* 13784 */	call    | alocs  << off_ ,
/* 13785 */	stmt    | 4426   << off_ ,	//	jsr sysif   open include file
/* 13786 */	sys     | sysif_ << off_ ,
/* 13787 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 13788 */	ppm     | cnc43  << off_ ,
/* 13789 */	stmt    | 4427   << off_ ,	//	zer wb   do not trim trailing blanks
/* 13790 */	move    | wb     << dst_ ,
/* 13791 */	stmt    | 4428   << off_ ,	//	jsr trimr   adjust scblk for actual length
/* 13792 */	call    | trimr  << off_ ,
/* 13793 */	stmt    | 4429   << off_ ,	//	mov r_sfc xr  save ptr to file name
/* 13794 */	store   | xr     << dst_ | r_sfc  << off_ ,
/* 13795 */	stmt    | 4430   << off_ ,	//	mti cmpsn   current statement as integer
/* 13796 */	load    | ia     << dst_ | cmpsn  << off_ ,
/* 13797 */	stmt    | 4431   << off_ ,	//	jsr icbld   build icblk for stmt number
/* 13798 */	call    | icbld  << off_ ,
/* 13799 */	stmt    | 4432   << off_ ,	//	mov xl r_sfn  file name table
/* 13800 */	load    | xl     << dst_ | r_sfn  << off_ ,
/* 13801 */	stmt    | 4433   << off_ ,	//	mnz wb   lookup statement number by name
/* 13802 */	move    | wb     << dst_ | xs     << src_ ,
/* 13803 */	stmt    | 4434   << off_ ,	//	jsr tfind   allocate new teblk
/* 13804 */	call    | tfind  << off_ ,
/* 13805 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 13806 */	ppm     ,
/* 13807 */	stmt    | 4435   << off_ ,	//	mov teval(xl) r_sfc  record file name as entry value
/* 13808 */	load    | r1     << dst_ | r_sfc  << off_ ,
/* 13809 */	store   | r1     << dst_ | xl     << src_ | teval  << off_ ,
/* 13810 */	stmt    | 4436   << off_ ,	//	zer rdnln   restart line counter for new file
/* 13811 */	store   | r0     << dst_ | rdnln  << off_ ,
/* 13812 */	stmt    | 4437   << off_ ,	//	beq stage =stgic cnc09 if initial compile
/* 13813 */	load    | r1     << dst_ | stage  << off_ ,
/* 13814 */	loadi   | r2     << dst_ | stgic  << off_ ,
/* 13815 */	beq     | r1     << dst_ | r2     << src_ | cnc09  << off_ ,
/* 13816 */	stmt    | 4438   << off_ ,	//	bne cnind =num01 cnc09 if not first execute-time nesting
/* 13817 */	load    | r1     << dst_ | cnind  << off_ ,
/* 13818 */	loadi   | r2     << dst_ | num01  << off_ ,
/* 13819 */	bne     | r1     << dst_ | r2     << src_ | cnc09  << off_ ,
/* 13820 */	stmt    | 4439   << off_ ,	//	mov r_ici r_cim  remember code argument string
/* 13821 */	load    | r1     << dst_ | r_cim  << off_ ,
/* 13822 */	store   | r1     << dst_ | r_ici  << off_ ,
/* 13823 */	stmt    | 4440   << off_ ,	//	mov cnspt scnpt  save position in string
/* 13824 */	load    | r1     << dst_ | scnpt  << off_ ,
/* 13825 */	store   | r1     << dst_ | cnspt  << off_ ,
/* 13826 */	stmt    | 4441   << off_ ,	//	mov cnsil scnil  and length of string
/* 13827 */	load    | r1     << dst_ | scnil  << off_ ,
/* 13828 */	store   | r1     << dst_ | cnsil  << off_ ,
/* 13829 */	stmt    | 4442   << off_ ,	//	brn cnc09   all done, merge
/* 13830 */	brn     | cnc09  << off_ ,
// cnc42:
/* 13831 */	stmt    | 4443   << off_ ,	//cnc42	erb 284 excessively nested include files
/* 13832 */	erb     | 284    << off_ ,
// cnc43:
/* 13833 */	stmt    | 4444   << off_ ,	//cnc43	mov dnamp xr  release allocated scblk
/* 13834 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 13835 */	stmt    | 4445   << off_ ,	//	erb 285 include file cannot be opened
/* 13836 */	erb     | 285    << off_ ,
// cnc44:
/* 13837 */	stmt    | 4446   << off_ ,	//cnc44	jsr scane   scan integer after -line
/* 13838 */	call    | scane  << off_ ,
/* 13839 */	stmt    | 4447   << off_ ,	//	bne xl =t_con cnc06 jump if no line number
/* 13840 */	loadi   | r2     << dst_ | t_con  << off_ ,
/* 13841 */	bne     | xl     << dst_ | r2     << src_ | cnc06  << off_ ,
/* 13842 */	stmt    | 4448   << off_ ,	//	bne (xr) =b_icl cnc06 jump if not integer
/* 13843 */	load    | r1     << dst_ | xr     << src_ ,
/* 13844 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/* 13845 */	bne     | r1     << dst_ | r2     << src_ | cnc06  << off_ ,
/* 13846 */	stmt    | 4449   << off_ ,	//	ldi icval(xr)   fetch integer line number
/* 13847 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/* 13848 */	ldi     | r1     << dst_ ,
/* 13849 */	stmt    | 4450   << off_ ,	//	ile cnc06   error if negative or zero
/* 13850 */	ile     | cnc06  << off_ ,
/* 13851 */	stmt    | 4451   << off_ ,	//	beq stage =stgic cnc45 skip if initial compile
/* 13852 */	load    | r1     << dst_ | stage  << off_ ,
/* 13853 */	loadi   | r2     << dst_ | stgic  << off_ ,
/* 13854 */	beq     | r1     << dst_ | r2     << src_ | cnc45  << off_ ,
/* 13855 */	stmt    | 4452   << off_ ,	//	mfi cmpln   set directly for other compiles
/* 13856 */	store   | ia     << dst_ | cmpln  << off_ ,
/* 13857 */	stmt    | 4453   << off_ ,	//	brn cnc46   no need to set rdnln
/* 13858 */	brn     | cnc46  << off_ ,
// cnc45:
/* 13859 */	stmt    | 4454   << off_ ,	//cnc45	sbi 4,intv1   adjust number by one
/* 13860 */	load    | r1     << dst_ | intv1  << off_ ,
/* 13861 */	sbi     | r1     << dst_ ,
/* 13862 */	stmt    | 4455   << off_ ,	//	mfi rdnln   save line number
/* 13863 */	store   | ia     << dst_ | rdnln  << off_ ,
// cnc46:
/* 13864 */	stmt    | 4456   << off_ ,	//cnc46	mnz scncc   set flag for scane
/* 13865 */	store   | xs     << dst_ | scncc  << off_ ,
/* 13866 */	stmt    | 4457   << off_ ,	//	jsr scane   scan quoted file name
/* 13867 */	call    | scane  << off_ ,
/* 13868 */	stmt    | 4458   << off_ ,	//	zer scncc   clear scane flag
/* 13869 */	store   | r0     << dst_ | scncc  << off_ ,
/* 13870 */	stmt    | 4459   << off_ ,	//	beq xl =t_smc cnc47 done if no file name
/* 13871 */	loadi   | r2     << dst_ | t_smc  << off_ ,
/* 13872 */	beq     | xl     << dst_ | r2     << src_ | cnc47  << off_ ,
/* 13873 */	stmt    | 4460   << off_ ,	//	bne xl =t_con cnc06 error if not constant
/* 13874 */	loadi   | r2     << dst_ | t_con  << off_ ,
/* 13875 */	bne     | xl     << dst_ | r2     << src_ | cnc06  << off_ ,
/* 13876 */	stmt    | 4461   << off_ ,	//	bne (xr) =b_scl cnc06 if not string constant
/* 13877 */	load    | r1     << dst_ | xr     << src_ ,
/* 13878 */	loadi   | r2     << dst_ | b_scl  << off_ ,
/* 13879 */	bne     | r1     << dst_ | r2     << src_ | cnc06  << off_ ,
/* 13880 */	stmt    | 4462   << off_ ,	//	jsr newfn   record new file name
/* 13881 */	call    | newfn  << off_ ,
/* 13882 */	stmt    | 4463   << off_ ,	//	brn cnc09   merge
/* 13883 */	brn     | cnc09  << off_ ,
// cnc47:
/* 13884 */	stmt    | 4464   << off_ ,	//cnc47	dcv scnpt   set to rescan the terminator
/* 13885 */	load    | r1     << dst_ | scnpt  << off_ ,
/* 13886 */	dcv     | r1     << dst_ ,
/* 13887 */	store   | r1     << dst_ | scnpt  << off_ ,
/* 13888 */	stmt    | 4465   << off_ ,	//	brn cnc09   merge
/* 13889 */	brn     | cnc09  << off_ ,
// dffnc:
/* 13890 */	stmt    | 4466   << off_ ,	//dffnc	prc e 0  entry point
/* 13891 */	stmt    | 4467   << off_ ,	//	bne (xl) =b_efc dffn1 skip if new function not external
/* 13892 */	load    | r1     << dst_ | xl     << src_ ,
/* 13893 */	loadi   | r2     << dst_ | b_efc  << off_ ,
/* 13894 */	bne     | r1     << dst_ | r2     << src_ | dffn1  << off_ ,
/* 13895 */	stmt    | 4468   << off_ ,	//	icv efuse(xl)   else increment its use count
/* 13896 */	load    | r1     << dst_ | xl     << src_ | efuse  << off_ ,
/* 13897 */	icv     | r1     << dst_ ,
/* 13898 */	store   | r1     << dst_ | xl     << src_ | efuse  << off_ ,
// dffn1:
/* 13899 */	stmt    | 4469   << off_ ,	//dffn1	mov wa xr  save vrblk pointer
/* 13900 */	move    | wa     << dst_ | xr     << src_ ,
/* 13901 */	stmt    | 4470   << off_ ,	//	mov xr vrfnc(xr)  load old function pointer
/* 13902 */	load    | xr     << dst_ | xr     << src_ | vrfnc  << off_ ,
/* 13903 */	stmt    | 4471   << off_ ,	//	bne (xr) =b_efc dffn2 jump if old function not external
/* 13904 */	load    | r1     << dst_ | xr     << src_ ,
/* 13905 */	loadi   | r2     << dst_ | b_efc  << off_ ,
/* 13906 */	bne     | r1     << dst_ | r2     << src_ | dffn2  << off_ ,
/* 13907 */	stmt    | 4472   << off_ ,	//	mov wb efuse(xr)  else get use count
/* 13908 */	load    | wb     << dst_ | xr     << src_ | efuse  << off_ ,
/* 13909 */	stmt    | 4473   << off_ ,	//	dcv wb   decrement
/* 13910 */	dcv     | wb     << dst_ ,
/* 13911 */	stmt    | 4474   << off_ ,	//	mov efuse(xr) wb  store decremented value
/* 13912 */	store   | wb     << dst_ | xr     << src_ | efuse  << off_ ,
/* 13913 */	stmt    | 4475   << off_ ,	//	bnz wb dffn2  jump if use count still non-zero
/* 13914 */	bnz     | wb     << dst_ | dffn2  << off_ ,
/* 13915 */	stmt    | 4476   << off_ ,	//	jsr sysul   else call system unload function
/* 13916 */	sys     | sysul_ << off_ ,
// dffn2:
/* 13917 */	stmt    | 4477   << off_ ,	//dffn2	mov xr wa  restore vrblk pointer
/* 13918 */	move    | xr     << dst_ | wa     << src_ ,
/* 13919 */	stmt    | 4478   << off_ ,	//	mov wa xl  copy function block ptr
/* 13920 */	move    | wa     << dst_ | xl     << src_ ,
/* 13921 */	stmt    | 4479   << off_ ,	//	blt xr =r_yyy dffn3 skip checks if opsyn op definition
/* 13922 */	loadi   | r2     << dst_ | r_yyy  << off_ ,
/* 13923 */	blt     | xr     << dst_ | r2     << src_ | dffn3  << off_ ,
/* 13924 */	stmt    | 4480   << off_ ,	//	bnz vrlen(xr) dffn3  jump if not system variable
/* 13925 */	load    | r1     << dst_ | xr     << src_ | vrlen  << off_ ,
/* 13926 */	bnz     | r1     << dst_ | dffn3  << off_ ,
/* 13927 */	stmt    | 4481   << off_ ,	//	mov xl vrsvp(xr)  point to svblk
/* 13928 */	load    | xl     << dst_ | xr     << src_ | vrsvp  << off_ ,
/* 13929 */	stmt    | 4482   << off_ ,	//	mov wb svbit(xl)  load bit indicators
/* 13930 */	load    | wb     << dst_ | xl     << src_ | svbit  << off_ ,
/* 13931 */	stmt    | 4483   << off_ ,	//	anb wb 4,btfnc  is it a system function
/* 13932 */	load    | r2     << dst_ | btfnc  << off_ ,
/* 13933 */	anb     | wb     << dst_ | r2     << src_ ,
/* 13934 */	stmt    | 4484   << off_ ,	//	zrb wb dffn3  redef ok if not
/* 13935 */	zrb     | wb     << dst_ | dffn3  << off_ ,
/* 13936 */	stmt    | 4485   << off_ ,	//	erb 248 attempted redefinition of system function
/* 13937 */	erb     | 248    << off_ ,
// dffn3:
/* 13938 */	stmt    | 4486   << off_ ,	//dffn3	mov vrfnc(xr) wa  store new function pointer
/* 13939 */	store   | wa     << dst_ | xr     << src_ | vrfnc  << off_ ,
/* 13940 */	stmt    | 4487   << off_ ,	//	mov xl wa  restore function block pointer
/* 13941 */	move    | xl     << dst_ | wa     << src_ ,
/* 13942 */	stmt    | 4488   << off_ ,	//	exi    return to dffnc caller
/* 13943 */	exi     | 0      << off_ ,
// dtach:
/* 13944 */	stmt    | 4489   << off_ ,	//dtach	prc e 0  entry point
/* 13945 */	stmt    | 4490   << off_ ,	//	mov dtcnb xl  store name base (gbcol not called)
/* 13946 */	store   | xl     << dst_ | dtcnb  << off_ ,
/* 13947 */	stmt    | 4491   << off_ ,	//	add xl wa  point to name location
/* 13948 */	add     | xl     << dst_ | wa     << src_ ,
/* 13949 */	stmt    | 4492   << off_ ,	//	mov dtcnm xl  store it
/* 13950 */	store   | xl     << dst_ | dtcnm  << off_ ,
// dtch1:
/* 13951 */	stmt    | 4493   << off_ ,	//dtch1	mov xr xl  copy name pointer
/* 13952 */	move    | xr     << dst_ | xl     << src_ ,
// dtch2:
/* 13953 */	stmt    | 4494   << off_ ,	//dtch2	mov xl (xl)  point to next value
/* 13954 */	load    | xl     << dst_ | xl     << src_ ,
/* 13955 */	stmt    | 4495   << off_ ,	//	bne (xl) =b_trt dtch6 jump at chain end
/* 13956 */	load    | r1     << dst_ | xl     << src_ ,
/* 13957 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 13958 */	bne     | r1     << dst_ | r2     << src_ | dtch6  << off_ ,
/* 13959 */	stmt    | 4496   << off_ ,	//	mov wa trtyp(xl)  get trap block type
/* 13960 */	load    | wa     << dst_ | xl     << src_ | trtyp  << off_ ,
/* 13961 */	stmt    | 4497   << off_ ,	//	beq wa =trtin dtch3 jump if input
/* 13962 */	loadi   | r2     << dst_ | trtin  << off_ ,
/* 13963 */	beq     | wa     << dst_ | r2     << src_ | dtch3  << off_ ,
/* 13964 */	stmt    | 4498   << off_ ,	//	beq wa =trtou dtch3 jump if output
/* 13965 */	loadi   | r2     << dst_ | trtou  << off_ ,
/* 13966 */	beq     | wa     << dst_ | r2     << src_ | dtch3  << off_ ,
/* 13967 */	stmt    | 4499   << off_ ,	//	add xl *trnxt  point to next link
/* 13968 */	loadi   | r2     << dst_ | trnxt  << off_ ,
/* 13969 */	add     | xl     << dst_ | r2     << src_ ,
/* 13970 */	stmt    | 4500   << off_ ,	//	brn dtch1   loop
/* 13971 */	brn     | dtch1  << off_ ,
// dtch3:
/* 13972 */	stmt    | 4501   << off_ ,	//dtch3	mov (xr) trval(xl)  delete trblk
/* 13973 */	load    | r1     << dst_ | xl     << src_ | trval  << off_ ,
/* 13974 */	store   | r1     << dst_ | xr     << src_ ,
/* 13975 */	stmt    | 4502   << off_ ,	//	mov wa xl  dump xl ...
/* 13976 */	move    | wa     << dst_ | xl     << src_ ,
/* 13977 */	stmt    | 4503   << off_ ,	//	mov wb xr  ... and xr
/* 13978 */	move    | wb     << dst_ | xr     << src_ ,
/* 13979 */	stmt    | 4504   << off_ ,	//	mov xl trtrf(xl)  point to trtrf trap block
/* 13980 */	load    | xl     << dst_ | xl     << src_ | trtrf  << off_ ,
/* 13981 */	stmt    | 4505   << off_ ,	//	bze xl dtch5  jump if no iochn
/* 13982 */	bze     | xl     << dst_ | dtch5  << off_ ,
/* 13983 */	stmt    | 4506   << off_ ,	//	bne (xl) =b_trt dtch5 jump if input, output, terminal
/* 13984 */	load    | r1     << dst_ | xl     << src_ ,
/* 13985 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 13986 */	bne     | r1     << dst_ | r2     << src_ | dtch5  << off_ ,
// dtch4:
/* 13987 */	stmt    | 4507   << off_ ,	//dtch4	mov xr xl  remember link ptr
/* 13988 */	move    | xr     << dst_ | xl     << src_ ,
/* 13989 */	stmt    | 4508   << off_ ,	//	mov xl trtrf(xl)  point to next link
/* 13990 */	load    | xl     << dst_ | xl     << src_ | trtrf  << off_ ,
/* 13991 */	stmt    | 4509   << off_ ,	//	bze xl dtch5  jump if end of chain
/* 13992 */	bze     | xl     << dst_ | dtch5  << off_ ,
/* 13993 */	stmt    | 4510   << off_ ,	//	mov wc ionmb(xl)  get name base
/* 13994 */	load    | wc     << dst_ | xl     << src_ | ionmb  << off_ ,
/* 13995 */	stmt    | 4511   << off_ ,	//	add wc ionmo(xl)  add offset
/* 13996 */	load    | r2     << dst_ | xl     << src_ | ionmo  << off_ ,
/* 13997 */	add     | wc     << dst_ | r2     << src_ ,
/* 13998 */	stmt    | 4512   << off_ ,	//	bne wc dtcnm dtch4 loop if no match
/* 13999 */	load    | r2     << dst_ | dtcnm  << off_ ,
/* 14000 */	bne     | wc     << dst_ | r2     << src_ | dtch4  << off_ ,
/* 14001 */	stmt    | 4513   << off_ ,	//	mov trtrf(xr) trtrf(xl)  remove name from chain
/* 14002 */	load    | r1     << dst_ | xl     << src_ | trtrf  << off_ ,
/* 14003 */	store   | r1     << dst_ | xr     << src_ | trtrf  << off_ ,
// dtch5:
/* 14004 */	stmt    | 4514   << off_ ,	//dtch5	mov xl wa  recover xl ...
/* 14005 */	move    | xl     << dst_ | wa     << src_ ,
/* 14006 */	stmt    | 4515   << off_ ,	//	mov xr wb  ... and xr
/* 14007 */	move    | xr     << dst_ | wb     << src_ ,
/* 14008 */	stmt    | 4516   << off_ ,	//	add xl *trval  point to value field
/* 14009 */	loadi   | r2     << dst_ | trval  << off_ ,
/* 14010 */	add     | xl     << dst_ | r2     << src_ ,
/* 14011 */	stmt    | 4517   << off_ ,	//	brn dtch2   continue
/* 14012 */	brn     | dtch2  << off_ ,
// dtch6:
/* 14013 */	stmt    | 4518   << off_ ,	//dtch6	mov xr dtcnb  possible vrblk ptr
/* 14014 */	load    | xr     << dst_ | dtcnb  << off_ ,
/* 14015 */	stmt    | 4519   << off_ ,	//	jsr setvr   reset vrblk if necessary
/* 14016 */	call    | setvr  << off_ ,
/* 14017 */	stmt    | 4520   << off_ ,	//	exi    return
/* 14018 */	exi     | 0      << off_ ,
// dtype:
/* 14019 */	stmt    | 4521   << off_ ,	//dtype	prc e 0  entry point
/* 14020 */	stmt    | 4522   << off_ ,	//	beq (xr) =b_pdt dtyp1 jump if prog.defined
/* 14021 */	load    | r1     << dst_ | xr     << src_ ,
/* 14022 */	loadi   | r2     << dst_ | b_pdt  << off_ ,
/* 14023 */	beq     | r1     << dst_ | r2     << src_ | dtyp1  << off_ ,
/* 14024 */	stmt    | 4523   << off_ ,	//	mov xr (xr)  load type word
/* 14025 */	load    | xr     << dst_ | xr     << src_ ,
/* 14026 */	stmt    | 4524   << off_ ,	//	lei xr   get entry point id (block code)
/* 14027 */	lei     | xr     << dst_ ,
/* 14028 */	stmt    | 4525   << off_ ,	//	wtb xr   convert to byte offset
/* 14029 */	stmt    | 4526   << off_ ,	//	mov xr 14,scnmt(xr)  load table entry
/* 14030 */	load    | xr     << dst_ | xr     << src_ | scnmt  << off_ ,
/* 14031 */	stmt    | 4527   << off_ ,	//	exi    exit to dtype caller
/* 14032 */	exi     | 0      << off_ ,
// dtyp1:
/* 14033 */	stmt    | 4528   << off_ ,	//dtyp1	mov xr pddfp(xr)  point to dfblk
/* 14034 */	load    | xr     << dst_ | xr     << src_ | pddfp  << off_ ,
/* 14035 */	stmt    | 4529   << off_ ,	//	mov xr dfnam(xr)  get datatype name from dfblk
/* 14036 */	load    | xr     << dst_ | xr     << src_ | dfnam  << off_ ,
/* 14037 */	stmt    | 4530   << off_ ,	//	exi    return to dtype caller
/* 14038 */	exi     | 0      << off_ ,
// dumpr:
/* 14039 */	stmt    | 4531   << off_ ,	//dumpr	prc e 0  entry point
/* 14040 */	stmt    | 4532   << off_ ,	//	bze xr dmp28  skip dump if argument is zero
/* 14041 */	bze     | xr     << dst_ | dmp28  << off_ ,
/* 14042 */	stmt    | 4533   << off_ ,	//	bgt xr =num03 dmp29 jump if core dump required
/* 14043 */	loadi   | r2     << dst_ | num03  << off_ ,
/* 14044 */	bgt     | xr     << dst_ | r2     << src_ | dmp29  << off_ ,
/* 14045 */	stmt    | 4534   << off_ ,	//	zer xl   clear xl
/* 14046 */	move    | xl     << dst_ ,
/* 14047 */	stmt    | 4535   << off_ ,	//	zer wb   zero move offset
/* 14048 */	move    | wb     << dst_ ,
/* 14049 */	stmt    | 4536   << off_ ,	//	mov dmarg xr  save dump argument
/* 14050 */	store   | xr     << dst_ | dmarg  << off_ ,
/* 14051 */	stmt    | 4537   << off_ ,	//	zer dnams   collect sediment too
/* 14052 */	store   | r0     << dst_ | dnams  << off_ ,
/* 14053 */	stmt    | 4538   << off_ ,	//	jsr gbcol   collect garbage
/* 14054 */	call    | gbcol  << off_ ,
/* 14055 */	stmt    | 4539   << off_ ,	//	jsr prtpg   eject printer
/* 14056 */	call    | prtpg  << off_ ,
/* 14057 */	stmt    | 4540   << off_ ,	//	mov xr =dmhdv  point to heading for variables
/* 14058 */	loadi   | xr     << dst_ | dmhdv  << off_ ,
/* 14059 */	stmt    | 4541   << off_ ,	//	jsr prtst   print it
/* 14060 */	call    | prtst  << off_ ,
/* 14061 */	stmt    | 4542   << off_ ,	//	jsr prtnl   terminate print line
/* 14062 */	call    | prtnl  << off_ ,
/* 14063 */	stmt    | 4543   << off_ ,	//	jsr prtnl   and print a blank line
/* 14064 */	call    | prtnl  << off_ ,
/* 14065 */	stmt    | 4544   << off_ ,	//	zer dmvch   set null chain to start
/* 14066 */	store   | r0     << dst_ | dmvch  << off_ ,
/* 14067 */	stmt    | 4545   << off_ ,	//	mov wa hshtb  point to hash table
/* 14068 */	load    | wa     << dst_ | hshtb  << off_ ,
// dmp00:
/* 14069 */	stmt    | 4546   << off_ ,	//dmp00	mov xr wa  copy hash bucket pointer
/* 14070 */	move    | xr     << dst_ | wa     << src_ ,
/* 14071 */	stmt    | 4547   << off_ ,	//	ica wa   bump pointer
/* 14072 */	ica     | wa     << dst_ ,
/* 14073 */	stmt    | 4548   << off_ ,	//	sub xr *vrnxt  set offset to merge
/* 14074 */	loadi   | r2     << dst_ | vrnxt  << off_ ,
/* 14075 */	sub     | xr     << dst_ | r2     << src_ ,
// dmp01:
/* 14076 */	stmt    | 4549   << off_ ,	//dmp01	mov xr vrnxt(xr)  point to next vrblk on chain
/* 14077 */	load    | xr     << dst_ | xr     << src_ | vrnxt  << off_ ,
/* 14078 */	stmt    | 4550   << off_ ,	//	bze xr dmp09  jump if end of this hash chain
/* 14079 */	bze     | xr     << dst_ | dmp09  << off_ ,
/* 14080 */	stmt    | 4551   << off_ ,	//	mov xl xr  else copy vrblk pointer
/* 14081 */	move    | xl     << dst_ | xr     << src_ ,
// dmp02:
/* 14082 */	stmt    | 4552   << off_ ,	//dmp02	mov xl vrval(xl)  load value
/* 14083 */	load    | xl     << dst_ | xl     << src_ | vrval  << off_ ,
/* 14084 */	stmt    | 4553   << off_ ,	//	beq dmarg =num03 dmp2a skip null value check if dump(3)
/* 14085 */	load    | r1     << dst_ | dmarg  << off_ ,
/* 14086 */	loadi   | r2     << dst_ | num03  << off_ ,
/* 14087 */	beq     | r1     << dst_ | r2     << src_ | dmp2a  << off_ ,
/* 14088 */	stmt    | 4554   << off_ ,	//	beq xl =nulls dmp01 loop for next vrblk if null value
/* 14089 */	loadi   | r2     << dst_ | nulls  << off_ ,
/* 14090 */	beq     | xl     << dst_ | r2     << src_ | dmp01  << off_ ,
// dmp2a:
/* 14091 */	stmt    | 4555   << off_ ,	//dmp2a	beq (xl) =b_trt dmp02 loop back if value is trapped
/* 14092 */	load    | r1     << dst_ | xl     << src_ ,
/* 14093 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 14094 */	beq     | r1     << dst_ | r2     << src_ | dmp02  << off_ ,
/* 14095 */	stmt    | 4556   << off_ ,	//	mov wc xr  save vrblk pointer
/* 14096 */	move    | wc     << dst_ | xr     << src_ ,
/* 14097 */	stmt    | 4557   << off_ ,	//	add xr *vrsof  adjust ptr to be like scblk ptr
/* 14098 */	loadi   | r2     << dst_ | vrsof  << off_ ,
/* 14099 */	add     | xr     << dst_ | r2     << src_ ,
/* 14100 */	stmt    | 4558   << off_ ,	//	bnz sclen(xr) dmp03  jump if non-system variable
/* 14101 */	load    | r1     << dst_ | xr     << src_ | sclen  << off_ ,
/* 14102 */	bnz     | r1     << dst_ | dmp03  << off_ ,
/* 14103 */	stmt    | 4559   << off_ ,	//	mov xr vrsvo(xr)  else load ptr to name in svblk
/* 14104 */	load    | xr     << dst_ | xr     << src_ | vrsvo  << off_ ,
// dmp03:
/* 14105 */	stmt    | 4560   << off_ ,	//dmp03	mov wb xr  save pointer to chars
/* 14106 */	move    | wb     << dst_ | xr     << src_ ,
/* 14107 */	stmt    | 4561   << off_ ,	//	mov dmpsv wa  save hash bucket pointer
/* 14108 */	store   | wa     << dst_ | dmpsv  << off_ ,
/* 14109 */	stmt    | 4562   << off_ ,	//	mov wa =dmvch  point to chain head
/* 14110 */	loadi   | wa     << dst_ | dmvch  << off_ ,
// dmp04:
/* 14111 */	stmt    | 4563   << off_ ,	//dmp04	mov dmpch wa  save chain pointer
/* 14112 */	store   | wa     << dst_ | dmpch  << off_ ,
/* 14113 */	stmt    | 4564   << off_ ,	//	mov xl wa  copy it
/* 14114 */	move    | xl     << dst_ | wa     << src_ ,
/* 14115 */	stmt    | 4565   << off_ ,	//	mov xr (xl)  load pointer to next entry
/* 14116 */	load    | xr     << dst_ | xl     << src_ ,
/* 14117 */	stmt    | 4566   << off_ ,	//	bze xr dmp08  jump if end of chain to insert
/* 14118 */	bze     | xr     << dst_ | dmp08  << off_ ,
/* 14119 */	stmt    | 4567   << off_ ,	//	add xr *vrsof  else get name ptr for chained vrblk
/* 14120 */	loadi   | r2     << dst_ | vrsof  << off_ ,
/* 14121 */	add     | xr     << dst_ | r2     << src_ ,
/* 14122 */	stmt    | 4568   << off_ ,	//	bnz sclen(xr) dmp05  jump if not system variable
/* 14123 */	load    | r1     << dst_ | xr     << src_ | sclen  << off_ ,
/* 14124 */	bnz     | r1     << dst_ | dmp05  << off_ ,
/* 14125 */	stmt    | 4569   << off_ ,	//	mov xr vrsvo(xr)  else point to name in svblk
/* 14126 */	load    | xr     << dst_ | xr     << src_ | vrsvo  << off_ ,
// dmp05:
/* 14127 */	stmt    | 4570   << off_ ,	//dmp05	mov xl wb  point to entering vrblk string
/* 14128 */	move    | xl     << dst_ | wb     << src_ ,
/* 14129 */	stmt    | 4571   << off_ ,	//	mov wa sclen(xl)  load its length
/* 14130 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/* 14131 */	stmt    | 4572   << off_ ,	//	plc xl   point to chars of entering string
/* 14132 */	plc     | xl     << dst_ ,
/* 14133 */	stmt    | 4573   << off_ ,	//	bhi wa sclen(xr) dmp06 jump if entering length high
/* 14134 */	load    | r2     << dst_ | xr     << src_ | sclen  << off_ ,
/* 14135 */	bhi     | wa     << dst_ | r2     << src_ | dmp06  << off_ ,
/* 14136 */	stmt    | 4574   << off_ ,	//	plc xr   else point to chars of old string
/* 14137 */	plc     | xr     << dst_ ,
/* 14138 */	stmt    | 4575   << off_ ,	//	cmc dmp08 dmp07  compare, insert if new is llt old
/* 14139 */	loadi   | r1     << dst_ | dmp08  << src_ ,
/* 14140 */	loadi   | r2     << dst_ | dmp07  << src_ ,
/* 14141 */	cmc     ,
/* 14142 */	stmt    | 4576   << off_ ,	//	brn dmp08   or if leq (we had shorter length)
/* 14143 */	brn     | dmp08  << off_ ,
// dmp06:
/* 14144 */	stmt    | 4577   << off_ ,	//dmp06	mov wa sclen(xr)  load shorter length
/* 14145 */	load    | wa     << dst_ | xr     << src_ | sclen  << off_ ,
/* 14146 */	stmt    | 4578   << off_ ,	//	plc xr   point to chars of old string
/* 14147 */	plc     | xr     << dst_ ,
/* 14148 */	stmt    | 4579   << off_ ,	//	cmc dmp08 dmp07  compare, insert if new one low
/* 14149 */	loadi   | r1     << dst_ | dmp08  << src_ ,
/* 14150 */	loadi   | r2     << dst_ | dmp07  << src_ ,
/* 14151 */	cmc     ,
// dmp07:
/* 14152 */	stmt    | 4580   << off_ ,	//dmp07	mov xl dmpch  copy chain pointer
/* 14153 */	load    | xl     << dst_ | dmpch  << off_ ,
/* 14154 */	stmt    | 4581   << off_ ,	//	mov wa (xl)  move to next entry on chain
/* 14155 */	load    | wa     << dst_ | xl     << src_ ,
/* 14156 */	stmt    | 4582   << off_ ,	//	brn dmp04   loop back
/* 14157 */	brn     | dmp04  << off_ ,
// dmp08:
/* 14158 */	stmt    | 4583   << off_ ,	//dmp08	mov xl dmpch  copy chain pointer
/* 14159 */	load    | xl     << dst_ | dmpch  << off_ ,
/* 14160 */	stmt    | 4584   << off_ ,	//	mov wa dmpsv  restore hash bucket pointer
/* 14161 */	load    | wa     << dst_ | dmpsv  << off_ ,
/* 14162 */	stmt    | 4585   << off_ ,	//	mov xr wc  restore vrblk pointer
/* 14163 */	move    | xr     << dst_ | wc     << src_ ,
/* 14164 */	stmt    | 4586   << off_ ,	//	mov vrget(xr) (xl)  link vrblk to rest of chain
/* 14165 */	load    | r1     << dst_ | xl     << src_ ,
/* 14166 */	store   | r1     << dst_ | xr     << src_ | vrget  << off_ ,
/* 14167 */	stmt    | 4587   << off_ ,	//	mov (xl) xr  link vrblk into current chain loc
/* 14168 */	store   | xr     << dst_ | xl     << src_ ,
/* 14169 */	stmt    | 4588   << off_ ,	//	brn dmp01   loop back for next vrblk
/* 14170 */	brn     | dmp01  << off_ ,
// dmp09:
/* 14171 */	stmt    | 4589   << off_ ,	//dmp09	bne wa hshte dmp00 loop back if more buckets to go
/* 14172 */	load    | r2     << dst_ | hshte  << off_ ,
/* 14173 */	bne     | wa     << dst_ | r2     << src_ | dmp00  << off_ ,
// dmp10:
/* 14174 */	stmt    | 4590   << off_ ,	//dmp10	mov xr dmvch  load pointer to next entry on chain
/* 14175 */	load    | xr     << dst_ | dmvch  << off_ ,
/* 14176 */	stmt    | 4591   << off_ ,	//	bze xr dmp11  jump if end of chain
/* 14177 */	bze     | xr     << dst_ | dmp11  << off_ ,
/* 14178 */	stmt    | 4592   << off_ ,	//	mov dmvch (xr)  else update chain ptr to next entry
/* 14179 */	load    | r1     << dst_ | xr     << src_ ,
/* 14180 */	store   | r1     << dst_ | dmvch  << off_ ,
/* 14181 */	stmt    | 4593   << off_ ,	//	jsr setvr   restore vrget field
/* 14182 */	call    | setvr  << off_ ,
/* 14183 */	stmt    | 4594   << off_ ,	//	mov xl xr  copy vrblk pointer (name base)
/* 14184 */	move    | xl     << dst_ | xr     << src_ ,
/* 14185 */	stmt    | 4595   << off_ ,	//	mov wa *vrval  set offset for vrblk name
/* 14186 */	loadi   | wa     << dst_ | vrval  << off_ ,
/* 14187 */	stmt    | 4596   << off_ ,	//	jsr prtnv   print name = value
/* 14188 */	call    | prtnv  << off_ ,
/* 14189 */	stmt    | 4597   << off_ ,	//	brn dmp10   loop back till all printed
/* 14190 */	brn     | dmp10  << off_ ,
// dmp11:
/* 14191 */	stmt    | 4598   << off_ ,	//dmp11	jsr prtnl   print blank line
/* 14192 */	call    | prtnl  << off_ ,
/* 14193 */	stmt    | 4599   << off_ ,	//	jsr prtnl   and another
/* 14194 */	call    | prtnl  << off_ ,
/* 14195 */	stmt    | 4600   << off_ ,	//	mov xr =dmhdk  point to keyword heading
/* 14196 */	loadi   | xr     << dst_ | dmhdk  << off_ ,
/* 14197 */	stmt    | 4601   << off_ ,	//	jsr prtst   print heading
/* 14198 */	call    | prtst  << off_ ,
/* 14199 */	stmt    | 4602   << off_ ,	//	jsr prtnl   end line
/* 14200 */	call    | prtnl  << off_ ,
/* 14201 */	stmt    | 4603   << off_ ,	//	jsr prtnl   print one blank line
/* 14202 */	call    | prtnl  << off_ ,
/* 14203 */	stmt    | 4604   << off_ ,	//	mov xl =vdmkw  point to list of keyword svblk ptrs
/* 14204 */	loadi   | xl     << dst_ | vdmkw  << off_ ,
// dmp12:
/* 14205 */	stmt    | 4605   << off_ ,	//dmp12	mov xr (xl)+  load next svblk ptr from table
/* 14206 */	load    | xr     << dst_ | xl     << src_ ,
/* 14207 */	ica     | xl     << dst_ ,
/* 14208 */	stmt    | 4606   << off_ ,	//	bze xr dmp13  jump if end of list
/* 14209 */	bze     | xr     << dst_ | dmp13  << off_ ,
/* 14210 */	stmt    | 4607   << off_ ,	//	beq xr =num01 dmp12 &compare ignored if not implemented
/* 14211 */	loadi   | r2     << dst_ | num01  << off_ ,
/* 14212 */	beq     | xr     << dst_ | r2     << src_ | dmp12  << off_ ,
/* 14213 */	stmt    | 4608   << off_ ,	//	mov wa =ch_am  load ampersand
/* 14214 */	loadi   | wa     << dst_ | ch_am  << off_ ,
/* 14215 */	stmt    | 4609   << off_ ,	//	jsr prtch   print ampersand
/* 14216 */	call    | prtch  << off_ ,
/* 14217 */	stmt    | 4610   << off_ ,	//	jsr prtst   print keyword name
/* 14218 */	call    | prtst  << off_ ,
/* 14219 */	stmt    | 4611   << off_ ,	//	mov wa svlen(xr)  load name length from svblk
/* 14220 */	load    | wa     << dst_ | xr     << src_ | svlen  << off_ ,
/* 14221 */	stmt    | 4612   << off_ ,	//	ctb wa svchs  get length of name
/* 14222 */	ctb     | wa     << dst_ | svchs  << off_ ,
/* 14223 */	stmt    | 4613   << off_ ,	//	add xr wa  point to svknm field
/* 14224 */	add     | xr     << dst_ | wa     << src_ ,
/* 14225 */	stmt    | 4614   << off_ ,	//	mov dmpkn (xr)  store in dummy kvblk
/* 14226 */	load    | r1     << dst_ | xr     << src_ ,
/* 14227 */	store   | r1     << dst_ | dmpkn  << off_ ,
/* 14228 */	stmt    | 4615   << off_ ,	//	mov xr =tmbeb  point to blank-equal-blank
/* 14229 */	loadi   | xr     << dst_ | tmbeb  << off_ ,
/* 14230 */	stmt    | 4616   << off_ ,	//	jsr prtst   print it
/* 14231 */	call    | prtst  << off_ ,
/* 14232 */	stmt    | 4617   << off_ ,	//	mov dmpsv xl  save table pointer
/* 14233 */	store   | xl     << dst_ | dmpsv  << off_ ,
/* 14234 */	stmt    | 4618   << off_ ,	//	mov xl =dmpkb  point to dummy kvblk
/* 14235 */	loadi   | xl     << dst_ | dmpkb  << off_ ,
/* 14236 */	stmt    | 4619   << off_ ,	//	mov (xl) =b_kvt  build type word
/* 14237 */	loadi   | r1     << dst_ | b_kvt  << off_ ,
/* 14238 */	store   | r1     << dst_ | xl     << src_ ,
/* 14239 */	stmt    | 4620   << off_ ,	//	mov kvvar(xl) =trbkv  build ptr to dummy trace block
/* 14240 */	loadi   | r1     << dst_ | trbkv  << off_ ,
/* 14241 */	store   | r1     << dst_ | xl     << src_ | kvvar  << off_ ,
/* 14242 */	stmt    | 4621   << off_ ,	//	mov wa *kvvar  set zero offset
/* 14243 */	loadi   | wa     << dst_ | kvvar  << off_ ,
/* 14244 */	stmt    | 4622   << off_ ,	//	jsr acess   get keyword value
/* 14245 */	call    | acess  << off_ ,
/* 14246 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 14247 */	ppm     ,
/* 14248 */	stmt    | 4623   << off_ ,	//	jsr prtvl   print keyword value
/* 14249 */	call    | prtvl  << off_ ,
/* 14250 */	stmt    | 4624   << off_ ,	//	jsr prtnl   terminate print line
/* 14251 */	call    | prtnl  << off_ ,
/* 14252 */	stmt    | 4625   << off_ ,	//	mov xl dmpsv  restore table pointer
/* 14253 */	load    | xl     << dst_ | dmpsv  << off_ ,
/* 14254 */	stmt    | 4626   << off_ ,	//	brn dmp12   loop back till all printed
/* 14255 */	brn     | dmp12  << off_ ,
// dmp13:
/* 14256 */	stmt    | 4627   << off_ ,	//dmp13	beq dmarg =num01 dmp27 exit if partial dump complete
/* 14257 */	load    | r1     << dst_ | dmarg  << off_ ,
/* 14258 */	loadi   | r2     << dst_ | num01  << off_ ,
/* 14259 */	beq     | r1     << dst_ | r2     << src_ | dmp27  << off_ ,
/* 14260 */	stmt    | 4628   << off_ ,	//	mov xr dnamb  else point to first dynamic block
/* 14261 */	load    | xr     << dst_ | dnamb  << off_ ,
// dmp14:
/* 14262 */	stmt    | 4629   << off_ ,	//dmp14	beq xr dnamp dmp27 jump if end of used region
/* 14263 */	load    | r2     << dst_ | dnamp  << off_ ,
/* 14264 */	beq     | xr     << dst_ | r2     << src_ | dmp27  << off_ ,
/* 14265 */	stmt    | 4630   << off_ ,	//	mov wa (xr)  else load first word of block
/* 14266 */	load    | wa     << dst_ | xr     << src_ ,
/* 14267 */	stmt    | 4631   << off_ ,	//	beq wa =b_vct dmp16 jump if vector
/* 14268 */	loadi   | r2     << dst_ | b_vct  << off_ ,
/* 14269 */	beq     | wa     << dst_ | r2     << src_ | dmp16  << off_ ,
/* 14270 */	stmt    | 4632   << off_ ,	//	beq wa =b_art dmp17 jump if array
/* 14271 */	loadi   | r2     << dst_ | b_art  << off_ ,
/* 14272 */	beq     | wa     << dst_ | r2     << src_ | dmp17  << off_ ,
/* 14273 */	stmt    | 4633   << off_ ,	//	beq wa =b_pdt dmp18 jump if program defined
/* 14274 */	loadi   | r2     << dst_ | b_pdt  << off_ ,
/* 14275 */	beq     | wa     << dst_ | r2     << src_ | dmp18  << off_ ,
/* 14276 */	stmt    | 4634   << off_ ,	//	beq wa =b_tbt dmp19 jump if table
/* 14277 */	loadi   | r2     << dst_ | b_tbt  << off_ ,
/* 14278 */	beq     | wa     << dst_ | r2     << src_ | dmp19  << off_ ,
// dmp15:
/* 14279 */	stmt    | 4635   << off_ ,	//dmp15	jsr blkln   get length of block
/* 14280 */	call    | blkln  << off_ ,
/* 14281 */	stmt    | 4636   << off_ ,	//	add xr wa  point past this block
/* 14282 */	add     | xr     << dst_ | wa     << src_ ,
/* 14283 */	stmt    | 4637   << off_ ,	//	brn dmp14   loop back for next block
/* 14284 */	brn     | dmp14  << off_ ,
// dmp16:
/* 14285 */	stmt    | 4638   << off_ ,	//dmp16	mov wb *vcvls  set offset to first value
/* 14286 */	loadi   | wb     << dst_ | vcvls  << off_ ,
/* 14287 */	stmt    | 4639   << off_ ,	//	brn dmp19   jump to merge
/* 14288 */	brn     | dmp19  << off_ ,
// dmp17:
/* 14289 */	stmt    | 4640   << off_ ,	//dmp17	mov wb arofs(xr)  set offset to arpro field
/* 14290 */	load    | wb     << dst_ | xr     << src_ | arofs  << off_ ,
/* 14291 */	stmt    | 4641   << off_ ,	//	ica wb   bump to get offset to values
/* 14292 */	ica     | wb     << dst_ ,
/* 14293 */	stmt    | 4642   << off_ ,	//	brn dmp19   jump to merge
/* 14294 */	brn     | dmp19  << off_ ,
// dmp18:
/* 14295 */	stmt    | 4643   << off_ ,	//dmp18	mov wb *pdfld  point to values, merge
/* 14296 */	loadi   | wb     << dst_ | pdfld  << off_ ,
// dmp19:
/* 14297 */	stmt    | 4644   << off_ ,	//dmp19	bze idval(xr) dmp15  ignore block if zero id value
/* 14298 */	load    | r1     << dst_ | xr     << src_ | idval  << off_ ,
/* 14299 */	bze     | r1     << dst_ | dmp15  << off_ ,
/* 14300 */	stmt    | 4645   << off_ ,	//	jsr blkln   else get block length
/* 14301 */	call    | blkln  << off_ ,
/* 14302 */	stmt    | 4646   << off_ ,	//	mov xl xr  copy block pointer
/* 14303 */	move    | xl     << dst_ | xr     << src_ ,
/* 14304 */	stmt    | 4647   << off_ ,	//	mov dmpsv wa  save length
/* 14305 */	store   | wa     << dst_ | dmpsv  << off_ ,
/* 14306 */	stmt    | 4648   << off_ ,	//	mov wa wb  copy offset to first value
/* 14307 */	move    | wa     << dst_ | wb     << src_ ,
/* 14308 */	stmt    | 4649   << off_ ,	//	jsr prtnl   print blank line
/* 14309 */	call    | prtnl  << off_ ,
/* 14310 */	stmt    | 4650   << off_ ,	//	mov dmpsa wa  preserve offset
/* 14311 */	store   | wa     << dst_ | dmpsa  << off_ ,
/* 14312 */	stmt    | 4651   << off_ ,	//	jsr prtvl   print block value (for title)
/* 14313 */	call    | prtvl  << off_ ,
/* 14314 */	stmt    | 4652   << off_ ,	//	mov wa dmpsa  recover offset
/* 14315 */	load    | wa     << dst_ | dmpsa  << off_ ,
/* 14316 */	stmt    | 4653   << off_ ,	//	jsr prtnl   end print line
/* 14317 */	call    | prtnl  << off_ ,
/* 14318 */	stmt    | 4654   << off_ ,	//	beq (xr) =b_tbt dmp22 jump if table
/* 14319 */	load    | r1     << dst_ | xr     << src_ ,
/* 14320 */	loadi   | r2     << dst_ | b_tbt  << off_ ,
/* 14321 */	beq     | r1     << dst_ | r2     << src_ | dmp22  << off_ ,
/* 14322 */	stmt    | 4655   << off_ ,	//	dca wa   point before first word
/* 14323 */	dca     | wa     << dst_ ,
// dmp20:
/* 14324 */	stmt    | 4656   << off_ ,	//dmp20	mov xr xl  copy block pointer
/* 14325 */	move    | xr     << dst_ | xl     << src_ ,
/* 14326 */	stmt    | 4657   << off_ ,	//	ica wa   bump offset
/* 14327 */	ica     | wa     << dst_ ,
/* 14328 */	stmt    | 4658   << off_ ,	//	add xr wa  point to next value
/* 14329 */	add     | xr     << dst_ | wa     << src_ ,
/* 14330 */	stmt    | 4659   << off_ ,	//	beq wa dmpsv dmp14 exit if end (xr past block)
/* 14331 */	load    | r2     << dst_ | dmpsv  << off_ ,
/* 14332 */	beq     | wa     << dst_ | r2     << src_ | dmp14  << off_ ,
/* 14333 */	stmt    | 4660   << off_ ,	//	sub xr *vrval  subtract offset to merge into loop
/* 14334 */	loadi   | r2     << dst_ | vrval  << off_ ,
/* 14335 */	sub     | xr     << dst_ | r2     << src_ ,
// dmp21:
/* 14336 */	stmt    | 4661   << off_ ,	//dmp21	mov xr vrval(xr)  load next value
/* 14337 */	load    | xr     << dst_ | xr     << src_ | vrval  << off_ ,
/* 14338 */	stmt    | 4662   << off_ ,	//	beq dmarg =num03 dmp2b skip null value check if dump(3)
/* 14339 */	load    | r1     << dst_ | dmarg  << off_ ,
/* 14340 */	loadi   | r2     << dst_ | num03  << off_ ,
/* 14341 */	beq     | r1     << dst_ | r2     << src_ | dmp2b  << off_ ,
/* 14342 */	stmt    | 4663   << off_ ,	//	beq xr =nulls dmp20 loop back if null value
/* 14343 */	loadi   | r2     << dst_ | nulls  << off_ ,
/* 14344 */	beq     | xr     << dst_ | r2     << src_ | dmp20  << off_ ,
// dmp2b:
/* 14345 */	stmt    | 4664   << off_ ,	//dmp2b	beq (xr) =b_trt dmp21 loop back if trapped
/* 14346 */	load    | r1     << dst_ | xr     << src_ ,
/* 14347 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 14348 */	beq     | r1     << dst_ | r2     << src_ | dmp21  << off_ ,
/* 14349 */	stmt    | 4665   << off_ ,	//	jsr prtnv   else print name = value
/* 14350 */	call    | prtnv  << off_ ,
/* 14351 */	stmt    | 4666   << off_ ,	//	brn dmp20   loop back for next field
/* 14352 */	brn     | dmp20  << off_ ,
// dmp22:
/* 14353 */	stmt    | 4667   << off_ ,	//dmp22	mov wc *tbbuk  set offset to first bucket
/* 14354 */	loadi   | wc     << dst_ | tbbuk  << off_ ,
/* 14355 */	stmt    | 4668   << off_ ,	//	mov wa *teval  set name offset for all teblks
/* 14356 */	loadi   | wa     << dst_ | teval  << off_ ,
// dmp23:
/* 14357 */	stmt    | 4669   << off_ ,	//dmp23	mov -(xs) xl  save tbblk pointer
/* 14358 */	dca     | xs     << dst_ ,
/* 14359 */	store   | xl     << dst_ | xs     << src_ ,
/* 14360 */	stmt    | 4670   << off_ ,	//	add xl wc  point to next bucket header
/* 14361 */	add     | xl     << dst_ | wc     << src_ ,
/* 14362 */	stmt    | 4671   << off_ ,	//	ica wc   bump bucket offset
/* 14363 */	ica     | wc     << dst_ ,
/* 14364 */	stmt    | 4672   << off_ ,	//	sub xl *tenxt  subtract offset to merge into loop
/* 14365 */	loadi   | r2     << dst_ | tenxt  << off_ ,
/* 14366 */	sub     | xl     << dst_ | r2     << src_ ,
// dmp24:
/* 14367 */	stmt    | 4673   << off_ ,	//dmp24	mov xl tenxt(xl)  point to next teblk
/* 14368 */	load    | xl     << dst_ | xl     << src_ | tenxt  << off_ ,
/* 14369 */	stmt    | 4674   << off_ ,	//	beq xl (xs) dmp26 jump if end of chain
/* 14370 */	load    | r2     << dst_ | xs     << src_ ,
/* 14371 */	beq     | xl     << dst_ | r2     << src_ | dmp26  << off_ ,
/* 14372 */	stmt    | 4675   << off_ ,	//	mov xr xl  else copy teblk pointer
/* 14373 */	move    | xr     << dst_ | xl     << src_ ,
// dmp25:
/* 14374 */	stmt    | 4676   << off_ ,	//dmp25	mov xr teval(xr)  load next value
/* 14375 */	load    | xr     << dst_ | xr     << src_ | teval  << off_ ,
/* 14376 */	stmt    | 4677   << off_ ,	//	beq xr =nulls dmp24 ignore if null value
/* 14377 */	loadi   | r2     << dst_ | nulls  << off_ ,
/* 14378 */	beq     | xr     << dst_ | r2     << src_ | dmp24  << off_ ,
/* 14379 */	stmt    | 4678   << off_ ,	//	beq (xr) =b_trt dmp25 loop back if trapped
/* 14380 */	load    | r1     << dst_ | xr     << src_ ,
/* 14381 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 14382 */	beq     | r1     << dst_ | r2     << src_ | dmp25  << off_ ,
/* 14383 */	stmt    | 4679   << off_ ,	//	mov dmpsv wc  else save offset pointer
/* 14384 */	store   | wc     << dst_ | dmpsv  << off_ ,
/* 14385 */	stmt    | 4680   << off_ ,	//	jsr prtnv   print name = value
/* 14386 */	call    | prtnv  << off_ ,
/* 14387 */	stmt    | 4681   << off_ ,	//	mov wc dmpsv  reload offset
/* 14388 */	load    | wc     << dst_ | dmpsv  << off_ ,
/* 14389 */	stmt    | 4682   << off_ ,	//	brn dmp24   loop back for next teblk
/* 14390 */	brn     | dmp24  << off_ ,
// dmp26:
/* 14391 */	stmt    | 4683   << off_ ,	//dmp26	mov xl (xs)+  restore tbblk pointer
/* 14392 */	load    | xl     << dst_ | xs     << src_ ,
/* 14393 */	ica     | xs     << dst_ ,
/* 14394 */	stmt    | 4684   << off_ ,	//	bne wc tblen(xl) dmp23 loop back if more buckets to go
/* 14395 */	load    | r2     << dst_ | xl     << src_ | tblen  << off_ ,
/* 14396 */	bne     | wc     << dst_ | r2     << src_ | dmp23  << off_ ,
/* 14397 */	stmt    | 4685   << off_ ,	//	mov xr xl  else copy table pointer
/* 14398 */	move    | xr     << dst_ | xl     << src_ ,
/* 14399 */	stmt    | 4686   << off_ ,	//	add xr wc  point to following block
/* 14400 */	add     | xr     << dst_ | wc     << src_ ,
/* 14401 */	stmt    | 4687   << off_ ,	//	brn dmp14   loop back to process next block
/* 14402 */	brn     | dmp14  << off_ ,
// dmp27:
/* 14403 */	stmt    | 4688   << off_ ,	//dmp27	jsr prtpg   eject printer
/* 14404 */	call    | prtpg  << off_ ,
// dmp28:
/* 14405 */	stmt    | 4689   << off_ ,	//dmp28	exi    return to dump caller
/* 14406 */	exi     | 0      << off_ ,
// dmp29:
/* 14407 */	stmt    | 4690   << off_ ,	//dmp29	jsr sysdm   call it
/* 14408 */	sys     | sysdm_ << off_ ,
/* 14409 */	stmt    | 4691   << off_ ,	//	brn dmp28   return
/* 14410 */	brn     | dmp28  << off_ ,
// ermsg:
/* 14411 */	stmt    | 4692   << off_ ,	//ermsg	prc e 0  entry point
/* 14412 */	stmt    | 4693   << off_ ,	//	mov wa kvert  load error code
/* 14413 */	load    | wa     << dst_ | kvert  << off_ ,
/* 14414 */	stmt    | 4694   << off_ ,	//	mov xr =ermms  point to error message /error/
/* 14415 */	loadi   | xr     << dst_ | ermms  << off_ ,
/* 14416 */	stmt    | 4695   << off_ ,	//	jsr prtst   print it
/* 14417 */	call    | prtst  << off_ ,
/* 14418 */	stmt    | 4696   << off_ ,	//	jsr ertex   get error message text
/* 14419 */	call    | ertex  << off_ ,
/* 14420 */	stmt    | 4697   << off_ ,	//	add wa =thsnd  bump error code for print
/* 14421 */	loadi   | r2     << dst_ | thsnd  << off_ ,
/* 14422 */	add     | wa     << dst_ | r2     << src_ ,
/* 14423 */	stmt    | 4698   << off_ ,	//	mti wa   fail code in int acc
/* 14424 */	move    | ia     << dst_ | wa     << src_ ,
/* 14425 */	stmt    | 4699   << off_ ,	//	mov wb profs  save current buffer position
/* 14426 */	load    | wb     << dst_ | profs  << off_ ,
/* 14427 */	stmt    | 4700   << off_ ,	//	jsr prtin   print code (now have error1xxx)
/* 14428 */	call    | prtin  << off_ ,
/* 14429 */	stmt    | 4701   << off_ ,	//	mov xl prbuf  point to print buffer
/* 14430 */	load    | xl     << dst_ | prbuf  << off_ ,
/* 14431 */	stmt    | 4702   << off_ ,	//	psc xl wb  point to the 1
/* 14432 */	psc     | xl     << dst_ | wb     << src_ ,
/* 14433 */	stmt    | 4703   << off_ ,	//	mov wa =ch_bl  load a blank
/* 14434 */	loadi   | wa     << dst_ | ch_bl  << off_ ,
/* 14435 */	stmt    | 4704   << off_ ,	//	sch wa (xl)  store blank over 1 (error xxx)
/* 14436 */	store   | wa     << dst_ | xl     << src_ ,
/* 14437 */	stmt    | 4705   << off_ ,	//	csc xl   complete store characters
/* 14438 */	stmt    | 4706   << off_ ,	//	zer xl   clear garbage pointer in xl
/* 14439 */	move    | xl     << dst_ ,
/* 14440 */	stmt    | 4707   << off_ ,	//	mov wa xr  keep error text
/* 14441 */	move    | wa     << dst_ | xr     << src_ ,
/* 14442 */	stmt    | 4708   << off_ ,	//	mov xr =ermns  point to / -- /
/* 14443 */	loadi   | xr     << dst_ | ermns  << off_ ,
/* 14444 */	stmt    | 4709   << off_ ,	//	jsr prtst   print it
/* 14445 */	call    | prtst  << off_ ,
/* 14446 */	stmt    | 4710   << off_ ,	//	mov xr wa  get error text again
/* 14447 */	move    | xr     << dst_ | wa     << src_ ,
/* 14448 */	stmt    | 4711   << off_ ,	//	jsr prtst   print error message text
/* 14449 */	call    | prtst  << off_ ,
/* 14450 */	stmt    | 4712   << off_ ,	//	jsr prtis   print line
/* 14451 */	call    | prtis  << off_ ,
/* 14452 */	stmt    | 4713   << off_ ,	//	jsr prtis   print blank line
/* 14453 */	call    | prtis  << off_ ,
/* 14454 */	stmt    | 4714   << off_ ,	//	exi    return to ermsg caller
/* 14455 */	exi     | 0      << off_ ,
// ertex:
/* 14456 */	stmt    | 4715   << off_ ,	//ertex	prc e 0  entry point
/* 14457 */	stmt    | 4716   << off_ ,	//	mov ertwa wa  save wa
/* 14458 */	store   | wa     << dst_ | ertwa  << off_ ,
/* 14459 */	stmt    | 4717   << off_ ,	//	mov ertwb wb  save wb
/* 14460 */	store   | wb     << dst_ | ertwb  << off_ ,
/* 14461 */	stmt    | 4718   << off_ ,	//	jsr sysem   get failure message text
/* 14462 */	sys     | sysem_ << off_ ,
/* 14463 */	stmt    | 4719   << off_ ,	//	mov xl xr  copy pointer to it
/* 14464 */	move    | xl     << dst_ | xr     << src_ ,
/* 14465 */	stmt    | 4720   << off_ ,	//	mov wa sclen(xr)  get length of string
/* 14466 */	load    | wa     << dst_ | xr     << src_ | sclen  << off_ ,
/* 14467 */	stmt    | 4721   << off_ ,	//	bze wa ert02  jump if null
/* 14468 */	bze     | wa     << dst_ | ert02  << off_ ,
/* 14469 */	stmt    | 4722   << off_ ,	//	zer wb   offset of zero
/* 14470 */	move    | wb     << dst_ ,
/* 14471 */	stmt    | 4723   << off_ ,	//	jsr sbstr   copy into dynamic store
/* 14472 */	call    | sbstr  << off_ ,
/* 14473 */	stmt    | 4724   << off_ ,	//	mov r_etx xr  store for relocation
/* 14474 */	store   | xr     << dst_ | r_etx  << off_ ,
// ert01:
/* 14475 */	stmt    | 4725   << off_ ,	//ert01	mov wb ertwb  restore wb
/* 14476 */	load    | wb     << dst_ | ertwb  << off_ ,
/* 14477 */	stmt    | 4726   << off_ ,	//	mov wa ertwa  restore wa
/* 14478 */	load    | wa     << dst_ | ertwa  << off_ ,
/* 14479 */	stmt    | 4727   << off_ ,	//	exi    return to caller
/* 14480 */	exi     | 0      << off_ ,
// ert02:
/* 14481 */	stmt    | 4728   << off_ ,	//ert02	mov xr r_etx  get errtext
/* 14482 */	load    | xr     << dst_ | r_etx  << off_ ,
/* 14483 */	stmt    | 4729   << off_ ,	//	brn ert01   return
/* 14484 */	brn     | ert01  << off_ ,
// evali:
/* 14485 */	stmt    | 4730   << off_ ,	//evali	prc r 4  entry point (recursive)
/* 14486 */	stmt    | 4731   << off_ ,	//	jsr evalp   evaluate expression
/* 14487 */	call    | evalp  << off_ ,
/* 14488 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 14489 */	ppm     | evli1  << off_ ,
/* 14490 */	stmt    | 4732   << off_ ,	//	mov -(xs) xl  stack result for gtsmi
/* 14491 */	dca     | xs     << dst_ ,
/* 14492 */	store   | xl     << dst_ | xs     << src_ ,
/* 14493 */	stmt    | 4733   << off_ ,	//	mov xl pthen(xr)  load successor pointer
/* 14494 */	load    | xl     << dst_ | xr     << src_ | pthen  << off_ ,
/* 14495 */	stmt    | 4734   << off_ ,	//	mov evlio xr  save original node pointer
/* 14496 */	store   | xr     << dst_ | evlio  << off_ ,
/* 14497 */	stmt    | 4735   << off_ ,	//	mov evlif wc  zero if simple argument
/* 14498 */	store   | wc     << dst_ | evlif  << off_ ,
/* 14499 */	stmt    | 4736   << off_ ,	//	jsr gtsmi   convert arg to small integer
/* 14500 */	call    | gtsmi  << off_ ,
/* 14501 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/* 14502 */	ppm     | evli2  << off_ ,
/* 14503 */	ppm     | evli3  << off_ ,
/* 14504 */	stmt    | 4737   << off_ ,	//	mov evliv xr  store result in special dummy node
/* 14505 */	store   | xr     << dst_ | evliv  << off_ ,
/* 14506 */	stmt    | 4738   << off_ ,	//	mov xr =evlin  point to dummy node with result
/* 14507 */	loadi   | xr     << dst_ | evlin  << off_ ,
/* 14508 */	stmt    | 4739   << off_ ,	//	mov (xr) =p_len  dummy pattern block pcode
/* 14509 */	loadi   | r1     << dst_ | p_len  << off_ ,
/* 14510 */	store   | r1     << dst_ | xr     << src_ ,
/* 14511 */	stmt    | 4740   << off_ ,	//	mov pthen(xr) xl  store successor pointer
/* 14512 */	store   | xl     << dst_ | xr     << src_ | pthen  << off_ ,
/* 14513 */	stmt    | 4741   << off_ ,	//	exi 4   take successful exit
/* 14514 */	exi     | 4      << off_ ,
// evli1:
/* 14515 */	stmt    | 4742   << off_ ,	//evli1	exi 3   take failure return
/* 14516 */	exi     | 3      << off_ ,
// evli2:
/* 14517 */	stmt    | 4743   << off_ ,	//evli2	exi 1   take non-integer error exit
/* 14518 */	exi     | 1      << off_ ,
// evli3:
/* 14519 */	stmt    | 4744   << off_ ,	//evli3	exi 2   take out-of-range error exit
/* 14520 */	exi     | 2      << off_ ,
// evalp:
/* 14521 */	stmt    | 4745   << off_ ,	//evalp	prc r 1  entry point (recursive)
/* 14522 */	stmt    | 4746   << off_ ,	//	mov xl parm1(xr)  load expression pointer
/* 14523 */	load    | xl     << dst_ | xr     << src_ | parm1  << off_ ,
/* 14524 */	stmt    | 4747   << off_ ,	//	beq (xl) =b_exl evlp1 jump if exblk case
/* 14525 */	load    | r1     << dst_ | xl     << src_ ,
/* 14526 */	loadi   | r2     << dst_ | b_exl  << off_ ,
/* 14527 */	beq     | r1     << dst_ | r2     << src_ | evlp1  << off_ ,
/* 14528 */	stmt    | 4748   << off_ ,	//	mov xl sevar(xl)  load vrblk pointer
/* 14529 */	load    | xl     << dst_ | xl     << src_ | sevar  << off_ ,
/* 14530 */	stmt    | 4749   << off_ ,	//	mov xl vrval(xl)  load value of vrblk
/* 14531 */	load    | xl     << dst_ | xl     << src_ | vrval  << off_ ,
/* 14532 */	stmt    | 4750   << off_ ,	//	mov wa (xl)  load first word of value
/* 14533 */	load    | wa     << dst_ | xl     << src_ ,
/* 14534 */	stmt    | 4751   << off_ ,	//	bhi wa =b_t__ evlp3 jump if not seblk, trblk or exblk
/* 14535 */	loadi   | r2     << dst_ | b_t__  << off_ ,
/* 14536 */	bhi     | wa     << dst_ | r2     << src_ | evlp3  << off_ ,
// evlp1:
/* 14537 */	stmt    | 4752   << off_ ,	//evlp1	chk    check for stack space
/* 14538 */	chk     ,
/* 14539 */	stmt    | 4753   << off_ ,	//	mov -(xs) xr  stack node pointer
/* 14540 */	dca     | xs     << dst_ ,
/* 14541 */	store   | xr     << dst_ | xs     << src_ ,
/* 14542 */	stmt    | 4754   << off_ ,	//	mov -(xs) wb  stack cursor
/* 14543 */	dca     | xs     << dst_ ,
/* 14544 */	store   | wb     << dst_ | xs     << src_ ,
/* 14545 */	stmt    | 4755   << off_ ,	//	mov -(xs) r_pms  stack subject string pointer
/* 14546 */	load    | r1     << dst_ | r_pms  << off_ ,
/* 14547 */	dca     | xs     << dst_ ,
/* 14548 */	store   | r1     << dst_ | xs     << src_ ,
/* 14549 */	stmt    | 4756   << off_ ,	//	mov -(xs) pmssl  stack subject string length
/* 14550 */	load    | r1     << dst_ | pmssl  << off_ ,
/* 14551 */	dca     | xs     << dst_ ,
/* 14552 */	store   | r1     << dst_ | xs     << src_ ,
/* 14553 */	stmt    | 4757   << off_ ,	//	mov -(xs) pmdfl  stack dot flag
/* 14554 */	load    | r1     << dst_ | pmdfl  << off_ ,
/* 14555 */	dca     | xs     << dst_ ,
/* 14556 */	store   | r1     << dst_ | xs     << src_ ,
/* 14557 */	stmt    | 4758   << off_ ,	//	mov -(xs) pmhbs  stack history stack base pointer
/* 14558 */	load    | r1     << dst_ | pmhbs  << off_ ,
/* 14559 */	dca     | xs     << dst_ ,
/* 14560 */	store   | r1     << dst_ | xs     << src_ ,
/* 14561 */	stmt    | 4759   << off_ ,	//	mov xr parm1(xr)  load expression pointer
/* 14562 */	load    | xr     << dst_ | xr     << src_ | parm1  << off_ ,
// evlp2:
/* 14563 */	stmt    | 4760   << off_ ,	//evlp2	zer wb   set flag for by value
/* 14564 */	move    | wb     << dst_ ,
/* 14565 */	stmt    | 4761   << off_ ,	//	jsr evalx   evaluate expression
/* 14566 */	call    | evalx  << off_ ,
/* 14567 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 14568 */	ppm     | evlp4  << off_ ,
/* 14569 */	stmt    | 4762   << off_ ,	//	mov wa (xr)  else load first word of value
/* 14570 */	load    | wa     << dst_ | xr     << src_ ,
/* 14571 */	stmt    | 4763   << off_ ,	//	blo wa =b_e__ evlp2 loop back to reevaluate expression
/* 14572 */	loadi   | r2     << dst_ | b_e__  << off_ ,
/* 14573 */	blo     | wa     << dst_ | r2     << src_ | evlp2  << off_ ,
/* 14574 */	stmt    | 4764   << off_ ,	//	mov xl xr  copy result pointer
/* 14575 */	move    | xl     << dst_ | xr     << src_ ,
/* 14576 */	stmt    | 4765   << off_ ,	//	mov pmhbs (xs)+  restore history stack base pointer
/* 14577 */	load    | r1     << dst_ | xs     << src_ ,
/* 14578 */	ica     | xs     << dst_ ,
/* 14579 */	store   | r1     << dst_ | pmhbs  << off_ ,
/* 14580 */	stmt    | 4766   << off_ ,	//	mov pmdfl (xs)+  restore dot flag
/* 14581 */	load    | r1     << dst_ | xs     << src_ ,
/* 14582 */	ica     | xs     << dst_ ,
/* 14583 */	store   | r1     << dst_ | pmdfl  << off_ ,
/* 14584 */	stmt    | 4767   << off_ ,	//	mov pmssl (xs)+  restore subject string length
/* 14585 */	load    | r1     << dst_ | xs     << src_ ,
/* 14586 */	ica     | xs     << dst_ ,
/* 14587 */	store   | r1     << dst_ | pmssl  << off_ ,
/* 14588 */	stmt    | 4768   << off_ ,	//	mov r_pms (xs)+  restore subject string pointer
/* 14589 */	load    | r1     << dst_ | xs     << src_ ,
/* 14590 */	ica     | xs     << dst_ ,
/* 14591 */	store   | r1     << dst_ | r_pms  << off_ ,
/* 14592 */	stmt    | 4769   << off_ ,	//	mov wb (xs)+  restore cursor
/* 14593 */	load    | wb     << dst_ | xs     << src_ ,
/* 14594 */	ica     | xs     << dst_ ,
/* 14595 */	stmt    | 4770   << off_ ,	//	mov xr (xs)+  restore node pointer
/* 14596 */	load    | xr     << dst_ | xs     << src_ ,
/* 14597 */	ica     | xs     << dst_ ,
/* 14598 */	stmt    | 4771   << off_ ,	//	mov wc xr  non-zero for simple vrblk
/* 14599 */	move    | wc     << dst_ | xr     << src_ ,
/* 14600 */	stmt    | 4772   << off_ ,	//	exi    return to evalp caller
/* 14601 */	exi     | 0      << off_ ,
// evlp3:
/* 14602 */	stmt    | 4773   << off_ ,	//evlp3	zer wc   simple vrblk, no side effects
/* 14603 */	move    | wc     << dst_ ,
/* 14604 */	stmt    | 4774   << off_ ,	//	exi    return to evalp caller
/* 14605 */	exi     | 0      << off_ ,
// evlp4:
/* 14606 */	stmt    | 4775   << off_ ,	//evlp4	mov pmhbs (xs)+  restore history stack base pointer
/* 14607 */	load    | r1     << dst_ | xs     << src_ ,
/* 14608 */	ica     | xs     << dst_ ,
/* 14609 */	store   | r1     << dst_ | pmhbs  << off_ ,
/* 14610 */	stmt    | 4776   << off_ ,	//	mov pmdfl (xs)+  restore dot flag
/* 14611 */	load    | r1     << dst_ | xs     << src_ ,
/* 14612 */	ica     | xs     << dst_ ,
/* 14613 */	store   | r1     << dst_ | pmdfl  << off_ ,
/* 14614 */	stmt    | 4777   << off_ ,	//	mov pmssl (xs)+  restore subject string length
/* 14615 */	load    | r1     << dst_ | xs     << src_ ,
/* 14616 */	ica     | xs     << dst_ ,
/* 14617 */	store   | r1     << dst_ | pmssl  << off_ ,
/* 14618 */	stmt    | 4778   << off_ ,	//	mov r_pms (xs)+  restore subject string pointer
/* 14619 */	load    | r1     << dst_ | xs     << src_ ,
/* 14620 */	ica     | xs     << dst_ ,
/* 14621 */	store   | r1     << dst_ | r_pms  << off_ ,
/* 14622 */	stmt    | 4779   << off_ ,	//	add xs *num02  remove node ptr, cursor
/* 14623 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 14624 */	add     | xs     << dst_ | r2     << src_ ,
/* 14625 */	stmt    | 4780   << off_ ,	//	exi 1   take failure exit
/* 14626 */	exi     | 1      << off_ ,
// evals:
/* 14627 */	stmt    | 4781   << off_ ,	//evals	prc r 3  entry point (recursive)
/* 14628 */	stmt    | 4782   << off_ ,	//	jsr evalp   evaluate expression
/* 14629 */	call    | evalp  << off_ ,
/* 14630 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 14631 */	ppm     | evls1  << off_ ,
/* 14632 */	stmt    | 4783   << off_ ,	//	mov -(xs) pthen(xr)  save successor pointer
/* 14633 */	load    | r1     << dst_ | xr     << src_ | pthen  << off_ ,
/* 14634 */	dca     | xs     << dst_ ,
/* 14635 */	store   | r1     << dst_ | xs     << src_ ,
/* 14636 */	stmt    | 4784   << off_ ,	//	mov -(xs) wb  save cursor
/* 14637 */	dca     | xs     << dst_ ,
/* 14638 */	store   | wb     << dst_ | xs     << src_ ,
/* 14639 */	stmt    | 4785   << off_ ,	//	mov -(xs) xl  stack result ptr for patst
/* 14640 */	dca     | xs     << dst_ ,
/* 14641 */	store   | xl     << dst_ | xs     << src_ ,
/* 14642 */	stmt    | 4786   << off_ ,	//	zer wb   dummy pcode for one char string
/* 14643 */	move    | wb     << dst_ ,
/* 14644 */	stmt    | 4787   << off_ ,	//	zer wc   dummy pcode for expression arg
/* 14645 */	move    | wc     << dst_ ,
/* 14646 */	stmt    | 4788   << off_ ,	//	mov xl =p_brk  appropriate pcode for our use
/* 14647 */	loadi   | xl     << dst_ | p_brk  << off_ ,
/* 14648 */	stmt    | 4789   << off_ ,	//	jsr patst   call routine to build node
/* 14649 */	call    | patst  << off_ ,
/* 14650 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 14651 */	ppm     | evls2  << off_ ,
/* 14652 */	stmt    | 4790   << off_ ,	//	mov wb (xs)+  restore cursor
/* 14653 */	load    | wb     << dst_ | xs     << src_ ,
/* 14654 */	ica     | xs     << dst_ ,
/* 14655 */	stmt    | 4791   << off_ ,	//	mov pthen(xr) (xs)+  store successor pointer
/* 14656 */	load    | r1     << dst_ | xs     << src_ ,
/* 14657 */	ica     | xs     << dst_ ,
/* 14658 */	store   | r1     << dst_ | xr     << src_ | pthen  << off_ ,
/* 14659 */	stmt    | 4792   << off_ ,	//	exi 3   take success return
/* 14660 */	exi     | 3      << off_ ,
// evls1:
/* 14661 */	stmt    | 4793   << off_ ,	//evls1	exi 2   take failure return
/* 14662 */	exi     | 2      << off_ ,
// evls2:
/* 14663 */	stmt    | 4794   << off_ ,	//evls2	add xs *num02  pop successor and cursor
/* 14664 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 14665 */	add     | xs     << dst_ | r2     << src_ ,
/* 14666 */	stmt    | 4795   << off_ ,	//	exi 1   take non-string error exit
/* 14667 */	exi     | 1      << off_ ,
// evalx:
/* 14668 */	stmt    | 4796   << off_ ,	//evalx	prc r 1  entry point, recursive
/* 14669 */	stmt    | 4797   << off_ ,	//	beq (xr) =b_exl evlx2 jump if exblk case
/* 14670 */	load    | r1     << dst_ | xr     << src_ ,
/* 14671 */	loadi   | r2     << dst_ | b_exl  << off_ ,
/* 14672 */	beq     | r1     << dst_ | r2     << src_ | evlx2  << off_ ,
/* 14673 */	stmt    | 4798   << off_ ,	//	mov xl sevar(xr)  load vrblk pointer (name base)
/* 14674 */	load    | xl     << dst_ | xr     << src_ | sevar  << off_ ,
/* 14675 */	stmt    | 4799   << off_ ,	//	mov wa *vrval  set name offset
/* 14676 */	loadi   | wa     << dst_ | vrval  << off_ ,
/* 14677 */	stmt    | 4800   << off_ ,	//	bnz wb evlx1  jump if called by name
/* 14678 */	bnz     | wb     << dst_ | evlx1  << off_ ,
/* 14679 */	stmt    | 4801   << off_ ,	//	jsr acess   call routine to access value
/* 14680 */	call    | acess  << off_ ,
/* 14681 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 14682 */	ppm     | evlx9  << off_ ,
// evlx1:
/* 14683 */	stmt    | 4802   << off_ ,	//evlx1	exi    return to evalx caller
/* 14684 */	exi     | 0      << off_ ,
// evlx2:
/* 14685 */	stmt    | 4803   << off_ ,	//evlx2	scp wc   get code pointer
/* 14686 */	scp     | wc     << dst_ ,
/* 14687 */	stmt    | 4804   << off_ ,	//	mov wa r_cod  load code block pointer
/* 14688 */	load    | wa     << dst_ | r_cod  << off_ ,
/* 14689 */	stmt    | 4805   << off_ ,	//	sub wc wa  get code pointer as offset
/* 14690 */	sub     | wc     << dst_ | wa     << src_ ,
/* 14691 */	stmt    | 4806   << off_ ,	//	mov -(xs) wa  stack old code block pointer
/* 14692 */	dca     | xs     << dst_ ,
/* 14693 */	store   | wa     << dst_ | xs     << src_ ,
/* 14694 */	stmt    | 4807   << off_ ,	//	mov -(xs) wc  stack relative code offset
/* 14695 */	dca     | xs     << dst_ ,
/* 14696 */	store   | wc     << dst_ | xs     << src_ ,
/* 14697 */	stmt    | 4808   << off_ ,	//	mov -(xs) flptr  stack old failure pointer
/* 14698 */	load    | r1     << dst_ | flptr  << off_ ,
/* 14699 */	dca     | xs     << dst_ ,
/* 14700 */	store   | r1     << dst_ | xs     << src_ ,
/* 14701 */	stmt    | 4809   << off_ ,	//	mov -(xs) wb  stack name/value indicator
/* 14702 */	dca     | xs     << dst_ ,
/* 14703 */	store   | wb     << dst_ | xs     << src_ ,
/* 14704 */	stmt    | 4810   << off_ ,	//	mov -(xs) *exflc  stack new fail offset
/* 14705 */	loadi   | r1     << dst_ | exflc  << off_ ,
/* 14706 */	dca     | xs     << dst_ ,
/* 14707 */	store   | r1     << dst_ | xs     << src_ ,
/* 14708 */	stmt    | 4811   << off_ ,	//	mov gtcef flptr  keep in case of error
/* 14709 */	load    | r1     << dst_ | flptr  << off_ ,
/* 14710 */	store   | r1     << dst_ | gtcef  << off_ ,
/* 14711 */	stmt    | 4812   << off_ ,	//	mov r_gtc r_cod  keep code block pointer similarly
/* 14712 */	load    | r1     << dst_ | r_cod  << off_ ,
/* 14713 */	store   | r1     << dst_ | r_gtc  << off_ ,
/* 14714 */	stmt    | 4813   << off_ ,	//	mov flptr xs  set new failure pointer
/* 14715 */	store   | xs     << dst_ | flptr  << off_ ,
/* 14716 */	stmt    | 4814   << off_ ,	//	mov r_cod xr  set new code block pointer
/* 14717 */	store   | xr     << dst_ | r_cod  << off_ ,
/* 14718 */	stmt    | 4815   << off_ ,	//	mov exstm(xr) kvstn  remember stmnt number
/* 14719 */	load    | r1     << dst_ | kvstn  << off_ ,
/* 14720 */	store   | r1     << dst_ | xr     << src_ | exstm  << off_ ,
/* 14721 */	stmt    | 4816   << off_ ,	//	add xr *excod  point to first code word
/* 14722 */	loadi   | r2     << dst_ | excod  << off_ ,
/* 14723 */	add     | xr     << dst_ | r2     << src_ ,
/* 14724 */	stmt    | 4817   << off_ ,	//	lcp xr   set code pointer
/* 14725 */	lcp     | xr     << dst_ ,
/* 14726 */	stmt    | 4818   << off_ ,	//	bne stage =stgxt evlx0 jump if not execution time
/* 14727 */	load    | r1     << dst_ | stage  << off_ ,
/* 14728 */	loadi   | r2     << dst_ | stgxt  << off_ ,
/* 14729 */	bne     | r1     << dst_ | r2     << src_ | evlx0  << off_ ,
/* 14730 */	stmt    | 4819   << off_ ,	//	mov stage =stgee  evaluating expression
/* 14731 */	loadi   | r1     << dst_ | stgee  << off_ ,
/* 14732 */	store   | r1     << dst_ | stage  << off_ ,
// evlx0:
/* 14733 */	stmt    | 4820   << off_ ,	//evlx0	zer xl   clear garbage xl
/* 14734 */	move    | xl     << dst_ ,
/* 14735 */	stmt    | 4821   << off_ ,	//	lcw xr   load first code word
/* 14736 */	lcw     | xr     << dst_ ,
/* 14737 */	stmt    | 4822   << off_ ,	//	bri (xr)   execute it
/* 14738 */	load    | r1     << dst_ | xr     << src_ ,
/* 14739 */	bri     | r1     << dst_ ,
// evlx3:
/* 14740 */	stmt    | 4823   << off_ ,	//evlx3	mov xr (xs)+  load value
/* 14741 */	load    | xr     << dst_ | xs     << src_ ,
/* 14742 */	ica     | xs     << dst_ ,
/* 14743 */	stmt    | 4824   << off_ ,	//	bze num01(xs) evlx5  jump if called by value
/* 14744 */	load    | r1     << dst_ | xs     << src_ | num01  << off_ ,
/* 14745 */	bze     | r1     << dst_ | evlx5  << off_ ,
/* 14746 */	stmt    | 4825   << off_ ,	//	erb 249 expression evaluated by name returned value
/* 14747 */	erb     | 249    << off_ ,
// evlx4:
/* 14748 */	stmt    | 4826   << off_ ,	//evlx4	mov wa (xs)+  load name offset
/* 14749 */	load    | wa     << dst_ | xs     << src_ ,
/* 14750 */	ica     | xs     << dst_ ,
/* 14751 */	stmt    | 4827   << off_ ,	//	mov xl (xs)+  load name base
/* 14752 */	load    | xl     << dst_ | xs     << src_ ,
/* 14753 */	ica     | xs     << dst_ ,
/* 14754 */	stmt    | 4828   << off_ ,	//	bnz num01(xs) evlx5  jump if called by name
/* 14755 */	load    | r1     << dst_ | xs     << src_ | num01  << off_ ,
/* 14756 */	bnz     | r1     << dst_ | evlx5  << off_ ,
/* 14757 */	stmt    | 4829   << off_ ,	//	jsr acess   else access value first
/* 14758 */	call    | acess  << off_ ,
/* 14759 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 14760 */	ppm     | evlx6  << off_ ,
// evlx5:
/* 14761 */	stmt    | 4830   << off_ ,	//evlx5	zer wb   note successful
/* 14762 */	move    | wb     << dst_ ,
/* 14763 */	stmt    | 4831   << off_ ,	//	brn evlx7   merge
/* 14764 */	brn     | evlx7  << off_ ,
// evlx6:
/* 14765 */	stmt    | 4832   << off_ ,	//evlx6	mnz wb   note unsuccessful
/* 14766 */	move    | wb     << dst_ | xs     << src_ ,
// evlx7:
/* 14767 */	stmt    | 4833   << off_ ,	//evlx7	bne stage =stgee evlx8 skip if was not previously xt
/* 14768 */	load    | r1     << dst_ | stage  << off_ ,
/* 14769 */	loadi   | r2     << dst_ | stgee  << off_ ,
/* 14770 */	bne     | r1     << dst_ | r2     << src_ | evlx8  << off_ ,
/* 14771 */	stmt    | 4834   << off_ ,	//	mov stage =stgxt  execute time
/* 14772 */	loadi   | r1     << dst_ | stgxt  << off_ ,
/* 14773 */	store   | r1     << dst_ | stage  << off_ ,
// evlx8:
/* 14774 */	stmt    | 4835   << off_ ,	//evlx8	add xs *num02  pop name/value indicator, *exfal
/* 14775 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 14776 */	add     | xs     << dst_ | r2     << src_ ,
/* 14777 */	stmt    | 4836   << off_ ,	//	mov flptr (xs)+  restore old failure pointer
/* 14778 */	load    | r1     << dst_ | xs     << src_ ,
/* 14779 */	ica     | xs     << dst_ ,
/* 14780 */	store   | r1     << dst_ | flptr  << off_ ,
/* 14781 */	stmt    | 4837   << off_ ,	//	mov wc (xs)+  load code offset
/* 14782 */	load    | wc     << dst_ | xs     << src_ ,
/* 14783 */	ica     | xs     << dst_ ,
/* 14784 */	stmt    | 4838   << off_ ,	//	add wc (xs)  make code pointer absolute
/* 14785 */	load    | r2     << dst_ | xs     << src_ ,
/* 14786 */	add     | wc     << dst_ | r2     << src_ ,
/* 14787 */	stmt    | 4839   << off_ ,	//	mov r_cod (xs)+  restore old code block pointer
/* 14788 */	load    | r1     << dst_ | xs     << src_ ,
/* 14789 */	ica     | xs     << dst_ ,
/* 14790 */	store   | r1     << dst_ | r_cod  << off_ ,
/* 14791 */	stmt    | 4840   << off_ ,	//	lcp wc   restore old code pointer
/* 14792 */	lcp     | wc     << dst_ ,
/* 14793 */	stmt    | 4841   << off_ ,	//	bze wb evlx1  jump for successful return
/* 14794 */	bze     | wb     << dst_ | evlx1  << off_ ,
// evlx9:
/* 14795 */	stmt    | 4842   << off_ ,	//evlx9	exi 1   take failure exit
/* 14796 */	exi     | 1      << off_ ,
// exbld:
/* 14797 */	stmt    | 4843   << off_ ,	//exbld	prc e 0  entry point
/* 14798 */	stmt    | 4844   << off_ ,	//	mov wa xl  copy offset to start of code
/* 14799 */	move    | wa     << dst_ | xl     << src_ ,
/* 14800 */	stmt    | 4845   << off_ ,	//	sub wa *excod  calc reduction in offset in exblk
/* 14801 */	loadi   | r2     << dst_ | excod  << off_ ,
/* 14802 */	sub     | wa     << dst_ | r2     << src_ ,
/* 14803 */	stmt    | 4846   << off_ ,	//	mov -(xs) wa  stack for later
/* 14804 */	dca     | xs     << dst_ ,
/* 14805 */	store   | wa     << dst_ | xs     << src_ ,
/* 14806 */	stmt    | 4847   << off_ ,	//	mov wa cwcof  load final offset
/* 14807 */	load    | wa     << dst_ | cwcof  << off_ ,
/* 14808 */	stmt    | 4848   << off_ ,	//	sub wa xl  compute length of code
/* 14809 */	sub     | wa     << dst_ | xl     << src_ ,
/* 14810 */	stmt    | 4849   << off_ ,	//	add wa *exsi_  add space for standard fields
/* 14811 */	loadi   | r2     << dst_ | exsi_  << off_ ,
/* 14812 */	add     | wa     << dst_ | r2     << src_ ,
/* 14813 */	stmt    | 4850   << off_ ,	//	jsr alloc   allocate space for exblk
/* 14814 */	call    | alloc  << off_ ,
/* 14815 */	stmt    | 4851   << off_ ,	//	mov -(xs) xr  save pointer to exblk
/* 14816 */	dca     | xs     << dst_ ,
/* 14817 */	store   | xr     << dst_ | xs     << src_ ,
/* 14818 */	stmt    | 4852   << off_ ,	//	mov extyp(xr) =b_exl  store type word
/* 14819 */	loadi   | r1     << dst_ | b_exl  << off_ ,
/* 14820 */	store   | r1     << dst_ | xr     << src_ | extyp  << off_ ,
/* 14821 */	stmt    | 4853   << off_ ,	//	zer exstm(xr)   zeroise stmnt number field
/* 14822 */	store   | r0     << dst_ | xr     << src_ | exstm  << off_ ,
/* 14823 */	stmt    | 4854   << off_ ,	//	mov exsln(xr) cmpln  set line number field
/* 14824 */	load    | r1     << dst_ | cmpln  << off_ ,
/* 14825 */	store   | r1     << dst_ | xr     << src_ | exsln  << off_ ,
/* 14826 */	stmt    | 4855   << off_ ,	//	mov exlen(xr) wa  store length
/* 14827 */	store   | wa     << dst_ | xr     << src_ | exlen  << off_ ,
/* 14828 */	stmt    | 4856   << off_ ,	//	mov exflc(xr) =ofex_  store failure word
/* 14829 */	loadi   | r1     << dst_ | ofex_  << off_ ,
/* 14830 */	store   | r1     << dst_ | xr     << src_ | exflc  << off_ ,
/* 14831 */	stmt    | 4857   << off_ ,	//	add xr *exsi_  set xr for mvw
/* 14832 */	loadi   | r2     << dst_ | exsi_  << off_ ,
/* 14833 */	add     | xr     << dst_ | r2     << src_ ,
/* 14834 */	stmt    | 4858   << off_ ,	//	mov cwcof xl  reset offset to start of code
/* 14835 */	store   | xl     << dst_ | cwcof  << off_ ,
/* 14836 */	stmt    | 4859   << off_ ,	//	add xl r_ccb  point to start of code
/* 14837 */	load    | r2     << dst_ | r_ccb  << off_ ,
/* 14838 */	add     | xl     << dst_ | r2     << src_ ,
/* 14839 */	stmt    | 4860   << off_ ,	//	sub wa *exsi_  length of code to move
/* 14840 */	loadi   | r2     << dst_ | exsi_  << off_ ,
/* 14841 */	sub     | wa     << dst_ | r2     << src_ ,
/* 14842 */	stmt    | 4861   << off_ ,	//	mov -(xs) wa  stack length of code
/* 14843 */	dca     | xs     << dst_ ,
/* 14844 */	store   | wa     << dst_ | xs     << src_ ,
/* 14845 */	stmt    | 4862   << off_ ,	//	mvw    move code to exblk
/* 14846 */	mvw     ,
/* 14847 */	stmt    | 4863   << off_ ,	//	mov wa (xs)+  get length of code
/* 14848 */	load    | wa     << dst_ | xs     << src_ ,
/* 14849 */	ica     | xs     << dst_ ,
/* 14850 */	stmt    | 4864   << off_ ,	//	btw wa   convert byte count to word count
/* 14851 */	stmt    | 4865   << off_ ,	//	lct wa wa  prepare counter for loop
/* 14852 */	stmt    | 4866   << off_ ,	//	mov xl (xs)  copy exblk ptr, dont unstack
/* 14853 */	load    | xl     << dst_ | xs     << src_ ,
/* 14854 */	stmt    | 4867   << off_ ,	//	add xl *excod  point to code itself
/* 14855 */	loadi   | r2     << dst_ | excod  << off_ ,
/* 14856 */	add     | xl     << dst_ | r2     << src_ ,
/* 14857 */	stmt    | 4868   << off_ ,	//	mov wb num01(xs)  get reduction in offset
/* 14858 */	load    | wb     << dst_ | xs     << src_ | num01  << off_ ,
// exbl1:
/* 14859 */	stmt    | 4869   << off_ ,	//exbl1	mov xr (xl)+  get next code word
/* 14860 */	load    | xr     << dst_ | xl     << src_ ,
/* 14861 */	ica     | xl     << dst_ ,
/* 14862 */	stmt    | 4870   << off_ ,	//	beq xr =osla_ exbl3 jump if selection found
/* 14863 */	loadi   | r2     << dst_ | osla_  << off_ ,
/* 14864 */	beq     | xr     << dst_ | r2     << src_ | exbl3  << off_ ,
/* 14865 */	stmt    | 4871   << off_ ,	//	beq xr =onta_ exbl3 jump if negation found
/* 14866 */	loadi   | r2     << dst_ | onta_  << off_ ,
/* 14867 */	beq     | xr     << dst_ | r2     << src_ | exbl3  << off_ ,
/* 14868 */	stmt    | 4872   << off_ ,	//	bct wa exbl1  loop to end of code
/* 14869 */	bct     | wa     << dst_ | exbl1  << off_ ,
// exbl2:
/* 14870 */	stmt    | 4873   << off_ ,	//exbl2	mov xr (xs)+  pop exblk ptr into xr
/* 14871 */	load    | xr     << dst_ | xs     << src_ ,
/* 14872 */	ica     | xs     << dst_ ,
/* 14873 */	stmt    | 4874   << off_ ,	//	mov xl (xs)+  pop reduction constant
/* 14874 */	load    | xl     << dst_ | xs     << src_ ,
/* 14875 */	ica     | xs     << dst_ ,
/* 14876 */	stmt    | 4875   << off_ ,	//	exi    return to caller
/* 14877 */	exi     | 0      << off_ ,
// exbl3:
/* 14878 */	stmt    | 4876   << off_ ,	//exbl3	sub (xl)+ wb  adjust offset
/* 14879 */	load    | r1     << dst_ | xl     << src_ ,
/* 14880 */	ica     | xl     << dst_ ,
/* 14881 */	sub     | r1     << dst_ | wb     << src_ ,
/* 14882 */	store   | r1     << dst_ | xl     << src_ ,
/* 14883 */	ica     | xl     << dst_ ,
/* 14884 */	stmt    | 4877   << off_ ,	//	bct wa exbl4  decrement count
/* 14885 */	bct     | wa     << dst_ | exbl4  << off_ ,
// exbl4:
/* 14886 */	stmt    | 4878   << off_ ,	//exbl4	bct wa exbl5  decrement count
/* 14887 */	bct     | wa     << dst_ | exbl5  << off_ ,
// exbl5:
/* 14888 */	stmt    | 4879   << off_ ,	//exbl5	mov xr (xl)+  get next code word
/* 14889 */	load    | xr     << dst_ | xl     << src_ ,
/* 14890 */	ica     | xl     << dst_ ,
/* 14891 */	stmt    | 4880   << off_ ,	//	beq xr =osla_ exbl3 jump if offset found
/* 14892 */	loadi   | r2     << dst_ | osla_  << off_ ,
/* 14893 */	beq     | xr     << dst_ | r2     << src_ | exbl3  << off_ ,
/* 14894 */	stmt    | 4881   << off_ ,	//	beq xr =oslb_ exbl3 jump if offset found
/* 14895 */	loadi   | r2     << dst_ | oslb_  << off_ ,
/* 14896 */	beq     | xr     << dst_ | r2     << src_ | exbl3  << off_ ,
/* 14897 */	stmt    | 4882   << off_ ,	//	beq xr =oslc_ exbl3 jump if offset found
/* 14898 */	loadi   | r2     << dst_ | oslc_  << off_ ,
/* 14899 */	beq     | xr     << dst_ | r2     << src_ | exbl3  << off_ ,
/* 14900 */	stmt    | 4883   << off_ ,	//	beq xr =onta_ exbl3 jump if offset found
/* 14901 */	loadi   | r2     << dst_ | onta_  << off_ ,
/* 14902 */	beq     | xr     << dst_ | r2     << src_ | exbl3  << off_ ,
/* 14903 */	stmt    | 4884   << off_ ,	//	bct wa exbl5  loop
/* 14904 */	bct     | wa     << dst_ | exbl5  << off_ ,
/* 14905 */	stmt    | 4885   << off_ ,	//	brn exbl2   merge to return
/* 14906 */	brn     | exbl2  << off_ ,
// expan:
/* 14907 */	stmt    | 4886   << off_ ,	//expan	prc e 0  entry point
/* 14908 */	stmt    | 4887   << off_ ,	//	zer -(xs)   set top of stack indicator
/* 14909 */	dca     | xs     << dst_ ,
/* 14910 */	store   | r0     << dst_ | xs     << src_ ,
/* 14911 */	stmt    | 4888   << off_ ,	//	zer wa   set initial state to zero
/* 14912 */	move    | wa     << dst_ ,
/* 14913 */	stmt    | 4889   << off_ ,	//	zer wc   zero counter value
/* 14914 */	move    | wc     << dst_ ,
// exp01:
/* 14915 */	stmt    | 4890   << off_ ,	//exp01	jsr scane   scan next element
/* 14916 */	call    | scane  << off_ ,
/* 14917 */	stmt    | 4891   << off_ ,	//	add xl wa  add state to syntax code
/* 14918 */	add     | xl     << dst_ | wa     << src_ ,
/* 14919 */	stmt    | 4892   << off_ ,	//	bsw xl t_nes  switch on element type/state
/* 14920 */	loadi   | r1     << dst_ | t_nes  << off_ ,
/* 14921 */	bsw     | xl     << dst_ | r1     << src_ ,
/* 14922 */	exp27   ,
/* 14923 */	exp27   ,
/* 14924 */	exp04   ,
/* 14925 */	exp06   ,
/* 14926 */	exp06   ,
/* 14927 */	exp04   ,
/* 14928 */	exp08   ,
/* 14929 */	exp08   ,
/* 14930 */	exp09   ,
/* 14931 */	exp02   ,
/* 14932 */	exp05   ,
/* 14933 */	exp11   ,
/* 14934 */	exp10   ,
/* 14935 */	exp10   ,
/* 14936 */	exp04   ,
/* 14937 */	exp03   ,
/* 14938 */	exp03   ,
/* 14939 */	exp04   ,
/* 14940 */	exp03   ,
/* 14941 */	exp03   ,
/* 14942 */	exp04   ,
/* 14943 */	exp05   ,
/* 14944 */	exp05   ,
/* 14945 */	exp26   ,
/* 14946 */	exp02   ,
/* 14947 */	exp05   ,
/* 14948 */	exp12   ,
/* 14949 */	exp02   ,
/* 14950 */	exp05   ,
/* 14951 */	exp18   ,
/* 14952 */	exp02   ,
/* 14953 */	exp05   ,
/* 14954 */	exp19   ,
/* 14955 */	exp02   ,
/* 14956 */	exp05   ,
/* 14957 */	exp19   ,
// exp02:
/* 14958 */	stmt    | 4893   << off_ ,	//exp02	mnz scnrs   set to rescan element
/* 14959 */	store   | xs     << dst_ | scnrs  << off_ ,
/* 14960 */	stmt    | 4894   << off_ ,	//	mov xr =nulls  point to null, merge
/* 14961 */	loadi   | xr     << dst_ | nulls  << off_ ,
// exp03:
/* 14962 */	stmt    | 4895   << off_ ,	//exp03	mov -(xs) xr  stack pointer to operand
/* 14963 */	dca     | xs     << dst_ ,
/* 14964 */	store   | xr     << dst_ | xs     << src_ ,
/* 14965 */	stmt    | 4896   << off_ ,	//	mov wa =num02  set state 2
/* 14966 */	loadi   | wa     << dst_ | num02  << off_ ,
/* 14967 */	stmt    | 4897   << off_ ,	//	brn exp01   jump for next element
/* 14968 */	brn     | exp01  << off_ ,
// exp04:
/* 14969 */	stmt    | 4898   << off_ ,	//exp04	mnz scnrs   set to rescan element
/* 14970 */	store   | xs     << dst_ | scnrs  << off_ ,
/* 14971 */	stmt    | 4899   << off_ ,	//	mov xr =opdvc  point to concat operator dv
/* 14972 */	loadi   | xr     << dst_ | opdvc  << off_ ,
/* 14973 */	stmt    | 4900   << off_ ,	//	bze wb exp4a  ok if at top level
/* 14974 */	bze     | wb     << dst_ | exp4a  << off_ ,
/* 14975 */	stmt    | 4901   << off_ ,	//	mov xr =opdvp  else point to unmistakable concat.
/* 14976 */	loadi   | xr     << dst_ | opdvp  << off_ ,
// exp4a:
/* 14977 */	stmt    | 4902   << off_ ,	//exp4a	bnz scnbl exp26  merge bop if blanks, else error
/* 14978 */	load    | r1     << dst_ | scnbl  << off_ ,
/* 14979 */	bnz     | r1     << dst_ | exp26  << off_ ,
/* 14980 */	stmt    | 4903   << off_ ,	//	erb 220 syntax error: missing operator
/* 14981 */	erb     | 220    << off_ ,
// exp05:
/* 14982 */	stmt    | 4904   << off_ ,	//exp05	erb 221 syntax error: missing operand
/* 14983 */	erb     | 221    << off_ ,
// exp06:
/* 14984 */	stmt    | 4905   << off_ ,	//exp06	mov xl =num04  set new level indicator
/* 14985 */	loadi   | xl     << dst_ | num04  << off_ ,
/* 14986 */	stmt    | 4906   << off_ ,	//	zer xr   set zero value for cmopn
/* 14987 */	move    | xr     << dst_ ,
// exp07:
/* 14988 */	stmt    | 4907   << off_ ,	//exp07	mov -(xs) xr  stack cmopn value
/* 14989 */	dca     | xs     << dst_ ,
/* 14990 */	store   | xr     << dst_ | xs     << src_ ,
/* 14991 */	stmt    | 4908   << off_ ,	//	mov -(xs) wc  stack old counter
/* 14992 */	dca     | xs     << dst_ ,
/* 14993 */	store   | wc     << dst_ | xs     << src_ ,
/* 14994 */	stmt    | 4909   << off_ ,	//	mov -(xs) wb  stack old level indicator
/* 14995 */	dca     | xs     << dst_ ,
/* 14996 */	store   | wb     << dst_ | xs     << src_ ,
/* 14997 */	stmt    | 4910   << off_ ,	//	chk    check for stack overflow
/* 14998 */	chk     ,
/* 14999 */	stmt    | 4911   << off_ ,	//	zer wa   set new state to zero
/* 15000 */	move    | wa     << dst_ ,
/* 15001 */	stmt    | 4912   << off_ ,	//	mov wb xl  set new level indicator
/* 15002 */	move    | wb     << dst_ | xl     << src_ ,
/* 15003 */	stmt    | 4913   << off_ ,	//	mov wc =num01  initialize new counter
/* 15004 */	loadi   | wc     << dst_ | num01  << off_ ,
/* 15005 */	stmt    | 4914   << off_ ,	//	brn exp01   jump to scan next element
/* 15006 */	brn     | exp01  << off_ ,
// exp08:
/* 15007 */	stmt    | 4915   << off_ ,	//exp08	erb 222 syntax error: invalid use of left bracket
/* 15008 */	erb     | 222    << off_ ,
// exp09:
/* 15009 */	stmt    | 4916   << off_ ,	//exp09	mov xr (xs)+  load array ptr for cmopn
/* 15010 */	load    | xr     << dst_ | xs     << src_ ,
/* 15011 */	ica     | xs     << dst_ ,
/* 15012 */	stmt    | 4917   << off_ ,	//	mov xl =num03  set new level indicator
/* 15013 */	loadi   | xl     << dst_ | num03  << off_ ,
/* 15014 */	stmt    | 4918   << off_ ,	//	brn exp07   jump to stack old and start new
/* 15015 */	brn     | exp07  << off_ ,
// exp10:
/* 15016 */	stmt    | 4919   << off_ ,	//exp10	mov xl =num05  set new lev indic (xr=vrblk=cmopn)
/* 15017 */	loadi   | xl     << dst_ | num05  << off_ ,
/* 15018 */	stmt    | 4920   << off_ ,	//	brn exp07   jump to stack old and start new
/* 15019 */	brn     | exp07  << off_ ,
// exp11:
/* 15020 */	stmt    | 4921   << off_ ,	//exp11	icv wc   increment counter
/* 15021 */	icv     | wc     << dst_ ,
/* 15022 */	stmt    | 4922   << off_ ,	//	jsr expdm   dump operators at this level
/* 15023 */	call    | expdm  << off_ ,
/* 15024 */	stmt    | 4923   << off_ ,	//	zer -(xs)   set new level for parameter
/* 15025 */	dca     | xs     << dst_ ,
/* 15026 */	store   | r0     << dst_ | xs     << src_ ,
/* 15027 */	stmt    | 4924   << off_ ,	//	zer wa   set new state
/* 15028 */	move    | wa     << dst_ ,
/* 15029 */	stmt    | 4925   << off_ ,	//	bgt wb =num02 exp01 loop back unless outer level
/* 15030 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 15031 */	bgt     | wb     << dst_ | r2     << src_ | exp01  << off_ ,
/* 15032 */	stmt    | 4926   << off_ ,	//	erb 223 syntax error: invalid use of comma
/* 15033 */	erb     | 223    << off_ ,
// exp12:
/* 15034 */	stmt    | 4927   << off_ ,	//exp12	beq wb =num01 exp20 end of normal goto
/* 15035 */	loadi   | r2     << dst_ | num01  << off_ ,
/* 15036 */	beq     | wb     << dst_ | r2     << src_ | exp20  << off_ ,
/* 15037 */	stmt    | 4928   << off_ ,	//	beq wb =num05 exp13 end of function arguments
/* 15038 */	loadi   | r2     << dst_ | num05  << off_ ,
/* 15039 */	beq     | wb     << dst_ | r2     << src_ | exp13  << off_ ,
/* 15040 */	stmt    | 4929   << off_ ,	//	beq wb =num04 exp14 end of grouping / selection
/* 15041 */	loadi   | r2     << dst_ | num04  << off_ ,
/* 15042 */	beq     | wb     << dst_ | r2     << src_ | exp14  << off_ ,
/* 15043 */	stmt    | 4930   << off_ ,	//	erb 224 syntax error: unbalanced right parenthesis
/* 15044 */	erb     | 224    << off_ ,
// exp13:
/* 15045 */	stmt    | 4931   << off_ ,	//exp13	mov xl =c_fnc  set cmtyp value for function
/* 15046 */	loadi   | xl     << dst_ | c_fnc  << off_ ,
/* 15047 */	stmt    | 4932   << off_ ,	//	brn exp15   jump to build cmblk
/* 15048 */	brn     | exp15  << off_ ,
// exp14:
/* 15049 */	stmt    | 4933   << off_ ,	//exp14	beq wc =num01 exp17 jump if end of grouping
/* 15050 */	loadi   | r2     << dst_ | num01  << off_ ,
/* 15051 */	beq     | wc     << dst_ | r2     << src_ | exp17  << off_ ,
/* 15052 */	stmt    | 4934   << off_ ,	//	mov xl =c_sel  else set cmtyp for selection
/* 15053 */	loadi   | xl     << dst_ | c_sel  << off_ ,
// exp15:
/* 15054 */	stmt    | 4935   << off_ ,	//exp15	jsr expdm   dump operators at this level
/* 15055 */	call    | expdm  << off_ ,
/* 15056 */	stmt    | 4936   << off_ ,	//	mov wa wc  copy count
/* 15057 */	move    | wa     << dst_ | wc     << src_ ,
/* 15058 */	stmt    | 4937   << off_ ,	//	add wa =cmvls  add for standard fields at start
/* 15059 */	loadi   | r2     << dst_ | cmvls  << off_ ,
/* 15060 */	add     | wa     << dst_ | r2     << src_ ,
/* 15061 */	stmt    | 4938   << off_ ,	//	wtb wa   convert length to bytes
/* 15062 */	stmt    | 4939   << off_ ,	//	jsr alloc   allocate space for cmblk
/* 15063 */	call    | alloc  << off_ ,
/* 15064 */	stmt    | 4940   << off_ ,	//	mov (xr) =b_cmt  store type code for cmblk
/* 15065 */	loadi   | r1     << dst_ | b_cmt  << off_ ,
/* 15066 */	store   | r1     << dst_ | xr     << src_ ,
/* 15067 */	stmt    | 4941   << off_ ,	//	mov cmtyp(xr) xl  store cmblk node type indicator
/* 15068 */	store   | xl     << dst_ | xr     << src_ | cmtyp  << off_ ,
/* 15069 */	stmt    | 4942   << off_ ,	//	mov cmlen(xr) wa  store length
/* 15070 */	store   | wa     << dst_ | xr     << src_ | cmlen  << off_ ,
/* 15071 */	stmt    | 4943   << off_ ,	//	add xr wa  point past end of block
/* 15072 */	add     | xr     << dst_ | wa     << src_ ,
/* 15073 */	stmt    | 4944   << off_ ,	//	lct wc wc  set loop counter
// exp16:
/* 15074 */	stmt    | 4945   << off_ ,	//exp16	mov -(xr) (xs)+  move one operand ptr from stack
/* 15075 */	load    | r1     << dst_ | xs     << src_ ,
/* 15076 */	ica     | xs     << dst_ ,
/* 15077 */	dca     | xr     << dst_ ,
/* 15078 */	store   | r1     << dst_ | xr     << src_ ,
/* 15079 */	stmt    | 4946   << off_ ,	//	mov wb (xs)+  pop to old level indicator
/* 15080 */	load    | wb     << dst_ | xs     << src_ ,
/* 15081 */	ica     | xs     << dst_ ,
/* 15082 */	stmt    | 4947   << off_ ,	//	bct wc exp16  loop till all moved
/* 15083 */	bct     | wc     << dst_ | exp16  << off_ ,
/* 15084 */	stmt    | 4948   << off_ ,	//	sub xr *cmvls  point back to start of block
/* 15085 */	loadi   | r2     << dst_ | cmvls  << off_ ,
/* 15086 */	sub     | xr     << dst_ | r2     << src_ ,
/* 15087 */	stmt    | 4949   << off_ ,	//	mov wc (xs)+  restore old counter
/* 15088 */	load    | wc     << dst_ | xs     << src_ ,
/* 15089 */	ica     | xs     << dst_ ,
/* 15090 */	stmt    | 4950   << off_ ,	//	mov cmopn(xr) (xs)  store operand ptr in cmblk
/* 15091 */	load    | r1     << dst_ | xs     << src_ ,
/* 15092 */	store   | r1     << dst_ | xr     << src_ | cmopn  << off_ ,
/* 15093 */	stmt    | 4951   << off_ ,	//	mov (xs) xr  stack cmblk pointer
/* 15094 */	store   | xr     << dst_ | xs     << src_ ,
/* 15095 */	stmt    | 4952   << off_ ,	//	mov wa =num02  set new state
/* 15096 */	loadi   | wa     << dst_ | num02  << off_ ,
/* 15097 */	stmt    | 4953   << off_ ,	//	brn exp01   back for next element
/* 15098 */	brn     | exp01  << off_ ,
// exp17:
/* 15099 */	stmt    | 4954   << off_ ,	//exp17	jsr expdm   dump operators at this level
/* 15100 */	call    | expdm  << off_ ,
/* 15101 */	stmt    | 4955   << off_ ,	//	mov xr (xs)+  restore xr
/* 15102 */	load    | xr     << dst_ | xs     << src_ ,
/* 15103 */	ica     | xs     << dst_ ,
/* 15104 */	stmt    | 4956   << off_ ,	//	mov wb (xs)+  restore outer level
/* 15105 */	load    | wb     << dst_ | xs     << src_ ,
/* 15106 */	ica     | xs     << dst_ ,
/* 15107 */	stmt    | 4957   << off_ ,	//	mov wc (xs)+  restore outer count
/* 15108 */	load    | wc     << dst_ | xs     << src_ ,
/* 15109 */	ica     | xs     << dst_ ,
/* 15110 */	stmt    | 4958   << off_ ,	//	mov (xs) xr  store opnd over unused cmopn val
/* 15111 */	store   | xr     << dst_ | xs     << src_ ,
/* 15112 */	stmt    | 4959   << off_ ,	//	mov wa =num02  set new state
/* 15113 */	loadi   | wa     << dst_ | num02  << off_ ,
/* 15114 */	stmt    | 4960   << off_ ,	//	brn exp01   back for next ele8ent
/* 15115 */	brn     | exp01  << off_ ,
// exp18:
/* 15116 */	stmt    | 4961   << off_ ,	//exp18	mov xl =c_arr  set cmtyp for array reference
/* 15117 */	loadi   | xl     << dst_ | c_arr  << off_ ,
/* 15118 */	stmt    | 4962   << off_ ,	//	beq wb =num03 exp15 jump to build cmblk if end arrayref
/* 15119 */	loadi   | r2     << dst_ | num03  << off_ ,
/* 15120 */	beq     | wb     << dst_ | r2     << src_ | exp15  << off_ ,
/* 15121 */	stmt    | 4963   << off_ ,	//	beq wb =num02 exp20 jump if end of direct goto
/* 15122 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 15123 */	beq     | wb     << dst_ | r2     << src_ | exp20  << off_ ,
/* 15124 */	stmt    | 4964   << off_ ,	//	erb 225 syntax error: unbalanced right bracket
/* 15125 */	erb     | 225    << off_ ,
// exp19:
/* 15126 */	stmt    | 4965   << off_ ,	//exp19	mnz scnrs   rescan terminator
/* 15127 */	store   | xs     << dst_ | scnrs  << off_ ,
/* 15128 */	stmt    | 4966   << off_ ,	//	mov xl wb  copy level indicator
/* 15129 */	move    | xl     << dst_ | wb     << src_ ,
/* 15130 */	stmt    | 4967   << off_ ,	//	bsw xl 6  switch on level indicator
/* 15131 */	loadi   | r1     << dst_ | 6      << off_ ,
/* 15132 */	bsw     | xl     << dst_ | r1     << src_ ,
/* 15133 */	exp20   ,
/* 15134 */	exp22   ,
/* 15135 */	exp23   ,
/* 15136 */	exp24   ,
/* 15137 */	exp21   ,
/* 15138 */	exp21   ,
// exp20:
/* 15139 */	stmt    | 4968   << off_ ,	//exp20	jsr expdm   dump remaining operators
/* 15140 */	call    | expdm  << off_ ,
/* 15141 */	stmt    | 4969   << off_ ,	//	mov xr (xs)+  load tree pointer
/* 15142 */	load    | xr     << dst_ | xs     << src_ ,
/* 15143 */	ica     | xs     << dst_ ,
/* 15144 */	stmt    | 4970   << off_ ,	//	ica xs   pop off bottom of stack marker
/* 15145 */	ica     | xs     << dst_ ,
/* 15146 */	stmt    | 4971   << off_ ,	//	exi    return to expan caller
/* 15147 */	exi     | 0      << off_ ,
// exp21:
/* 15148 */	stmt    | 4972   << off_ ,	//exp21	erb 226 syntax error: missing right paren
/* 15149 */	erb     | 226    << off_ ,
// exp22:
/* 15150 */	stmt    | 4973   << off_ ,	//exp22	erb 227 syntax error: right paren missing from goto
/* 15151 */	erb     | 227    << off_ ,
// exp23:
/* 15152 */	stmt    | 4974   << off_ ,	//exp23	erb 228 syntax error: right bracket missing from goto
/* 15153 */	erb     | 228    << off_ ,
// exp24:
/* 15154 */	stmt    | 4975   << off_ ,	//exp24	erb 229 syntax error: missing right array bracket
/* 15155 */	erb     | 229    << off_ ,
// exp25:
/* 15156 */	stmt    | 4976   << off_ ,	//exp25	mov expsv xr
/* 15157 */	store   | xr     << dst_ | expsv  << off_ ,
/* 15158 */	stmt    | 4977   << off_ ,	//	jsr expop   pop one operator
/* 15159 */	call    | expop  << off_ ,
/* 15160 */	stmt    | 4978   << off_ ,	//	mov xr expsv  restore op dv pointer and merge
/* 15161 */	load    | xr     << dst_ | expsv  << off_ ,
// exp26:
/* 15162 */	stmt    | 4979   << off_ ,	//exp26	mov xl num01(xs)  load operator dvptr from stack
/* 15163 */	load    | xl     << dst_ | xs     << src_ | num01  << off_ ,
/* 15164 */	stmt    | 4980   << off_ ,	//	ble xl =num05 exp27 jump if bottom of stack level
/* 15165 */	loadi   | r2     << dst_ | num05  << off_ ,
/* 15166 */	ble     | xl     << dst_ | r2     << src_ | exp27  << off_ ,
/* 15167 */	stmt    | 4981   << off_ ,	//	blt dvrpr(xr) dvlpr(xl) exp25 else pop if new prec is lo
/* 15168 */	load    | r1     << dst_ | xr     << src_ | dvrpr  << off_ ,
/* 15169 */	load    | r2     << dst_ | xl     << src_ | dvlpr  << off_ ,
/* 15170 */	blt     | r1     << dst_ | r2     << src_ | exp25  << off_ ,
// exp27:
/* 15171 */	stmt    | 4982   << off_ ,	//exp27	mov -(xs) xr  stack operator dvptr on stack
/* 15172 */	dca     | xs     << dst_ ,
/* 15173 */	store   | xr     << dst_ | xs     << src_ ,
/* 15174 */	stmt    | 4983   << off_ ,	//	chk    check for stack overflow
/* 15175 */	chk     ,
/* 15176 */	stmt    | 4984   << off_ ,	//	mov wa =num01  set new state
/* 15177 */	loadi   | wa     << dst_ | num01  << off_ ,
/* 15178 */	stmt    | 4985   << off_ ,	//	bne xr =opdvs exp01 back for next element unless =
/* 15179 */	loadi   | r2     << dst_ | opdvs  << off_ ,
/* 15180 */	bne     | xr     << dst_ | r2     << src_ | exp01  << off_ ,
/* 15181 */	stmt    | 4986   << off_ ,	//	zer wa   set state zero
/* 15182 */	move    | wa     << dst_ ,
/* 15183 */	stmt    | 4987   << off_ ,	//	brn exp01   jump for next element
/* 15184 */	brn     | exp01  << off_ ,
// expap:
/* 15185 */	stmt    | 4988   << off_ ,	//expap	prc e 1  entry point
/* 15186 */	stmt    | 4989   << off_ ,	//	mov -(xs) xl  save xl
/* 15187 */	dca     | xs     << dst_ ,
/* 15188 */	store   | xl     << dst_ | xs     << src_ ,
/* 15189 */	stmt    | 4990   << off_ ,	//	bne (xr) =b_cmt expp2 no match if not complex
/* 15190 */	load    | r1     << dst_ | xr     << src_ ,
/* 15191 */	loadi   | r2     << dst_ | b_cmt  << off_ ,
/* 15192 */	bne     | r1     << dst_ | r2     << src_ | expp2  << off_ ,
/* 15193 */	stmt    | 4991   << off_ ,	//	mov wa cmtyp(xr)  else load type code
/* 15194 */	load    | wa     << dst_ | xr     << src_ | cmtyp  << off_ ,
/* 15195 */	stmt    | 4992   << off_ ,	//	beq wa =c_cnc expp1 concatenation is a match
/* 15196 */	loadi   | r2     << dst_ | c_cnc  << off_ ,
/* 15197 */	beq     | wa     << dst_ | r2     << src_ | expp1  << off_ ,
/* 15198 */	stmt    | 4993   << off_ ,	//	beq wa =c_pmt expp1 binary question mark is a match
/* 15199 */	loadi   | r2     << dst_ | c_pmt  << off_ ,
/* 15200 */	beq     | wa     << dst_ | r2     << src_ | expp1  << off_ ,
/* 15201 */	stmt    | 4994   << off_ ,	//	bne wa =c_alt expp2 else not match unless alternation
/* 15202 */	loadi   | r2     << dst_ | c_alt  << off_ ,
/* 15203 */	bne     | wa     << dst_ | r2     << src_ | expp2  << off_ ,
/* 15204 */	stmt    | 4995   << off_ ,	//	mov xl cmlop(xr)  load left operand pointer
/* 15205 */	load    | xl     << dst_ | xr     << src_ | cmlop  << off_ ,
/* 15206 */	stmt    | 4996   << off_ ,	//	bne (xl) =b_cmt expp2 not match if left opnd not complex
/* 15207 */	load    | r1     << dst_ | xl     << src_ ,
/* 15208 */	loadi   | r2     << dst_ | b_cmt  << off_ ,
/* 15209 */	bne     | r1     << dst_ | r2     << src_ | expp2  << off_ ,
/* 15210 */	stmt    | 4997   << off_ ,	//	bne cmtyp(xl) =c_cnc expp2 not match if left op not conc
/* 15211 */	load    | r1     << dst_ | xl     << src_ | cmtyp  << off_ ,
/* 15212 */	loadi   | r2     << dst_ | c_cnc  << off_ ,
/* 15213 */	bne     | r1     << dst_ | r2     << src_ | expp2  << off_ ,
/* 15214 */	stmt    | 4998   << off_ ,	//	mov cmlop(xr) cmrop(xl)  xr points to (b / c)
/* 15215 */	load    | r1     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 15216 */	store   | r1     << dst_ | xr     << src_ | cmlop  << off_ ,
/* 15217 */	stmt    | 4999   << off_ ,	//	mov cmrop(xl) xr  set xl opnds to a, (b / c)
/* 15218 */	store   | xr     << dst_ | xl     << src_ | cmrop  << off_ ,
/* 15219 */	stmt    | 5000   << off_ ,	//	mov xr xl  point to this altered node
/* 15220 */	move    | xr     << dst_ | xl     << src_ ,
// expp1:
/* 15221 */	stmt    | 5001   << off_ ,	//expp1	mov xl (xs)+  restore entry xl
/* 15222 */	load    | xl     << dst_ | xs     << src_ ,
/* 15223 */	ica     | xs     << dst_ ,
/* 15224 */	stmt    | 5002   << off_ ,	//	exi    give pattern match return
/* 15225 */	exi     | 0      << off_ ,
// expp2:
/* 15226 */	stmt    | 5003   << off_ ,	//expp2	mov xl (xs)+  restore entry xl
/* 15227 */	load    | xl     << dst_ | xs     << src_ ,
/* 15228 */	ica     | xs     << dst_ ,
/* 15229 */	stmt    | 5004   << off_ ,	//	exi 1   give non-match return
/* 15230 */	exi     | 1      << off_ ,
// expdm:
/* 15231 */	stmt    | 5005   << off_ ,	//expdm	prc n 0  entry point
/* 15232 */	prc     | 4      << off_ ,
/* 15233 */	stmt    | 5006   << off_ ,	//	mov r_exs xl  save xl value
/* 15234 */	store   | xl     << dst_ | r_exs  << off_ ,
// exdm1:
/* 15235 */	stmt    | 5007   << off_ ,	//exdm1	ble num01(xs) =num05 exdm2 jump if stack bottom (saved level
/* 15236 */	load    | r1     << dst_ | xs     << src_ | num01  << off_ ,
/* 15237 */	loadi   | r2     << dst_ | num05  << off_ ,
/* 15238 */	ble     | r1     << dst_ | r2     << src_ | exdm2  << off_ ,
/* 15239 */	stmt    | 5008   << off_ ,	//	jsr expop   else pop one operator
/* 15240 */	call    | expop  << off_ ,
/* 15241 */	stmt    | 5009   << off_ ,	//	brn exdm1   and loop back
/* 15242 */	brn     | exdm1  << off_ ,
// exdm2:
/* 15243 */	stmt    | 5010   << off_ ,	//exdm2	mov xl r_exs  restore xl
/* 15244 */	load    | xl     << dst_ | r_exs  << off_ ,
/* 15245 */	stmt    | 5011   << off_ ,	//	zer r_exs   release save location
/* 15246 */	store   | r0     << dst_ | r_exs  << off_ ,
/* 15247 */	stmt    | 5012   << off_ ,	//	exi    return to expdm caller
/* 15248 */	exi     | 400    << off_ ,
// expop:
/* 15249 */	stmt    | 5013   << off_ ,	//expop	prc n 0  entry point
/* 15250 */	prc     | 5      << off_ ,
/* 15251 */	stmt    | 5014   << off_ ,	//	mov xr num01(xs)  load operator dv pointer
/* 15252 */	load    | xr     << dst_ | xs     << src_ | num01  << off_ ,
/* 15253 */	stmt    | 5015   << off_ ,	//	beq dvlpr(xr) =lluno expo2 jump if unary
/* 15254 */	load    | r1     << dst_ | xr     << src_ | dvlpr  << off_ ,
/* 15255 */	loadi   | r2     << dst_ | lluno  << off_ ,
/* 15256 */	beq     | r1     << dst_ | r2     << src_ | expo2  << off_ ,
/* 15257 */	stmt    | 5016   << off_ ,	//	mov wa *cmbs_  set size of binary operator cmblk
/* 15258 */	loadi   | wa     << dst_ | cmbs_  << off_ ,
/* 15259 */	stmt    | 5017   << off_ ,	//	jsr alloc   allocate space for cmblk
/* 15260 */	call    | alloc  << off_ ,
/* 15261 */	stmt    | 5018   << off_ ,	//	mov cmrop(xr) (xs)+  pop and store right operand ptr
/* 15262 */	load    | r1     << dst_ | xs     << src_ ,
/* 15263 */	ica     | xs     << dst_ ,
/* 15264 */	store   | r1     << dst_ | xr     << src_ | cmrop  << off_ ,
/* 15265 */	stmt    | 5019   << off_ ,	//	mov xl (xs)+  pop and load operator dv ptr
/* 15266 */	load    | xl     << dst_ | xs     << src_ ,
/* 15267 */	ica     | xs     << dst_ ,
/* 15268 */	stmt    | 5020   << off_ ,	//	mov cmlop(xr) (xs)  store left operand pointer
/* 15269 */	load    | r1     << dst_ | xs     << src_ ,
/* 15270 */	store   | r1     << dst_ | xr     << src_ | cmlop  << off_ ,
// expo1:
/* 15271 */	stmt    | 5021   << off_ ,	//expo1	mov (xr) =b_cmt  store type code for cmblk
/* 15272 */	loadi   | r1     << dst_ | b_cmt  << off_ ,
/* 15273 */	store   | r1     << dst_ | xr     << src_ ,
/* 15274 */	stmt    | 5022   << off_ ,	//	mov cmtyp(xr) dvtyp(xl)  store cmblk node type code
/* 15275 */	load    | r1     << dst_ | xl     << src_ | dvtyp  << off_ ,
/* 15276 */	store   | r1     << dst_ | xr     << src_ | cmtyp  << off_ ,
/* 15277 */	stmt    | 5023   << off_ ,	//	mov cmopn(xr) xl  store dvptr (=ptr to dac o_xxx)
/* 15278 */	store   | xl     << dst_ | xr     << src_ | cmopn  << off_ ,
/* 15279 */	stmt    | 5024   << off_ ,	//	mov cmlen(xr) wa  store cmblk length
/* 15280 */	store   | wa     << dst_ | xr     << src_ | cmlen  << off_ ,
/* 15281 */	stmt    | 5025   << off_ ,	//	mov (xs) xr  store resulting node ptr on stack
/* 15282 */	store   | xr     << dst_ | xs     << src_ ,
/* 15283 */	stmt    | 5026   << off_ ,	//	exi    return to expop caller
/* 15284 */	exi     | 500    << off_ ,
// expo2:
/* 15285 */	stmt    | 5027   << off_ ,	//expo2	mov wa *cmus_  set size of unary operator cmblk
/* 15286 */	loadi   | wa     << dst_ | cmus_  << off_ ,
/* 15287 */	stmt    | 5028   << off_ ,	//	jsr alloc   allocate space for cmblk
/* 15288 */	call    | alloc  << off_ ,
/* 15289 */	stmt    | 5029   << off_ ,	//	mov cmrop(xr) (xs)+  pop and store operand pointer
/* 15290 */	load    | r1     << dst_ | xs     << src_ ,
/* 15291 */	ica     | xs     << dst_ ,
/* 15292 */	store   | r1     << dst_ | xr     << src_ | cmrop  << off_ ,
/* 15293 */	stmt    | 5030   << off_ ,	//	mov xl (xs)  load operator dv pointer
/* 15294 */	load    | xl     << dst_ | xs     << src_ ,
/* 15295 */	stmt    | 5031   << off_ ,	//	brn expo1   merge back to exit
/* 15296 */	brn     | expo1  << off_ ,
// filnm:
/* 15297 */	stmt    | 5032   << off_ ,	//filnm	prc e 0  entry point
/* 15298 */	stmt    | 5033   << off_ ,	//	mov -(xs) wb  preserve wb
/* 15299 */	dca     | xs     << dst_ ,
/* 15300 */	store   | wb     << dst_ | xs     << src_ ,
/* 15301 */	stmt    | 5034   << off_ ,	//	bze wc filn3  return nulls if stno is zero
/* 15302 */	bze     | wc     << dst_ | filn3  << off_ ,
/* 15303 */	stmt    | 5035   << off_ ,	//	mov xl r_sfn  file name table
/* 15304 */	load    | xl     << dst_ | r_sfn  << off_ ,
/* 15305 */	stmt    | 5036   << off_ ,	//	bze xl filn3  if no table
/* 15306 */	bze     | xl     << dst_ | filn3  << off_ ,
/* 15307 */	stmt    | 5037   << off_ ,	//	mov wb tbbuk(xl)  get bucket entry
/* 15308 */	load    | wb     << dst_ | xl     << src_ | tbbuk  << off_ ,
/* 15309 */	stmt    | 5038   << off_ ,	//	beq wb r_sfn filn3 jump if no teblks on chain
/* 15310 */	load    | r2     << dst_ | r_sfn  << off_ ,
/* 15311 */	beq     | wb     << dst_ | r2     << src_ | filn3  << off_ ,
/* 15312 */	stmt    | 5039   << off_ ,	//	mov -(xs) xr  preserve xr
/* 15313 */	dca     | xs     << dst_ ,
/* 15314 */	store   | xr     << dst_ | xs     << src_ ,
/* 15315 */	stmt    | 5040   << off_ ,	//	mov xr wb  previous block pointer
/* 15316 */	move    | xr     << dst_ | wb     << src_ ,
/* 15317 */	stmt    | 5041   << off_ ,	//	mov -(xs) wc  preserve stmt number
/* 15318 */	dca     | xs     << dst_ ,
/* 15319 */	store   | wc     << dst_ | xs     << src_ ,
// filn1:
/* 15320 */	stmt    | 5042   << off_ ,	//filn1	mov xl xr  next element to examine
/* 15321 */	move    | xl     << dst_ | xr     << src_ ,
/* 15322 */	stmt    | 5043   << off_ ,	//	mov xr tesub(xl)  load subscript value (an icblk)
/* 15323 */	load    | xr     << dst_ | xl     << src_ | tesub  << off_ ,
/* 15324 */	stmt    | 5044   << off_ ,	//	ldi icval(xr)   load the statement number
/* 15325 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/* 15326 */	ldi     | r1     << dst_ ,
/* 15327 */	stmt    | 5045   << off_ ,	//	mfi wc   convert to address constant
/* 15328 */	move    | wc     << dst_ | ia     << src_ ,
/* 15329 */	stmt    | 5046   << off_ ,	//	blt (xs) wc filn2 compare arg with teblk stmt number
/* 15330 */	load    | r1     << dst_ | xs     << src_ ,
/* 15331 */	blt     | r1     << dst_ | wc     << src_ | filn2  << off_ ,
/* 15332 */	stmt    | 5047   << off_ ,	//	mov wb xl  save previous entry pointer
/* 15333 */	move    | wb     << dst_ | xl     << src_ ,
/* 15334 */	stmt    | 5048   << off_ ,	//	mov xr tenxt(xl)  point to next teblk on chain
/* 15335 */	load    | xr     << dst_ | xl     << src_ | tenxt  << off_ ,
/* 15336 */	stmt    | 5049   << off_ ,	//	bne xr r_sfn filn1 jump if there is one
/* 15337 */	load    | r2     << dst_ | r_sfn  << off_ ,
/* 15338 */	bne     | xr     << dst_ | r2     << src_ | filn1  << off_ ,
// filn2:
/* 15339 */	stmt    | 5050   << off_ ,	//filn2	mov xl wb  previous teblk
/* 15340 */	move    | xl     << dst_ | wb     << src_ ,
/* 15341 */	stmt    | 5051   << off_ ,	//	mov xl teval(xl)  get ptr to file name scblk
/* 15342 */	load    | xl     << dst_ | xl     << src_ | teval  << off_ ,
/* 15343 */	stmt    | 5052   << off_ ,	//	mov wc (xs)+  restore stmt number
/* 15344 */	load    | wc     << dst_ | xs     << src_ ,
/* 15345 */	ica     | xs     << dst_ ,
/* 15346 */	stmt    | 5053   << off_ ,	//	mov xr (xs)+  restore xr
/* 15347 */	load    | xr     << dst_ | xs     << src_ ,
/* 15348 */	ica     | xs     << dst_ ,
/* 15349 */	stmt    | 5054   << off_ ,	//	mov wb (xs)+  restore wb
/* 15350 */	load    | wb     << dst_ | xs     << src_ ,
/* 15351 */	ica     | xs     << dst_ ,
/* 15352 */	stmt    | 5055   << off_ ,	//	exi
/* 15353 */	exi     | 0      << off_ ,
// filn3:
/* 15354 */	stmt    | 5056   << off_ ,	//filn3	mov wb (xs)+  restore wb
/* 15355 */	load    | wb     << dst_ | xs     << src_ ,
/* 15356 */	ica     | xs     << dst_ ,
/* 15357 */	stmt    | 5057   << off_ ,	//	mov xl =nulls  return null string
/* 15358 */	loadi   | xl     << dst_ | nulls  << off_ ,
/* 15359 */	stmt    | 5058   << off_ ,	//	exi
/* 15360 */	exi     | 0      << off_ ,
// gbcol:
/* 15361 */	stmt    | 5059   << off_ ,	//gbcol	prc e 0  entry point
/* 15362 */	stmt    | 5060   << off_ ,	//	bnz dmvch gbc14  fail if in mid-dump
/* 15363 */	load    | r1     << dst_ | dmvch  << off_ ,
/* 15364 */	bnz     | r1     << dst_ | gbc14  << off_ ,
/* 15365 */	stmt    | 5061   << off_ ,	//	mnz gbcfl   note gbcol entered
/* 15366 */	store   | xs     << dst_ | gbcfl  << off_ ,
/* 15367 */	stmt    | 5062   << off_ ,	//	mov gbsva wa  save entry wa
/* 15368 */	store   | wa     << dst_ | gbsva  << off_ ,
/* 15369 */	stmt    | 5063   << off_ ,	//	mov gbsvb wb  save entry wb
/* 15370 */	store   | wb     << dst_ | gbsvb  << off_ ,
/* 15371 */	stmt    | 5064   << off_ ,	//	mov gbsvc wc  save entry wc
/* 15372 */	store   | wc     << dst_ | gbsvc  << off_ ,
/* 15373 */	stmt    | 5065   << off_ ,	//	mov -(xs) xl  save entry xl
/* 15374 */	dca     | xs     << dst_ ,
/* 15375 */	store   | xl     << dst_ | xs     << src_ ,
/* 15376 */	stmt    | 5066   << off_ ,	//	scp wa   get code pointer value
/* 15377 */	scp     | wa     << dst_ ,
/* 15378 */	stmt    | 5067   << off_ ,	//	sub wa r_cod  make relative
/* 15379 */	load    | r2     << dst_ | r_cod  << off_ ,
/* 15380 */	sub     | wa     << dst_ | r2     << src_ ,
/* 15381 */	stmt    | 5068   << off_ ,	//	lcp wa   and restore
/* 15382 */	lcp     | wa     << dst_ ,
/* 15383 */	stmt    | 5069   << off_ ,	//	bze wb gbc0a  check there is no move offset
/* 15384 */	bze     | wb     << dst_ | gbc0a  << off_ ,
/* 15385 */	stmt    | 5070   << off_ ,	//	zer dnams   collect sediment if must move it
/* 15386 */	store   | r0     << dst_ | dnams  << off_ ,
// gbc0a:
/* 15387 */	stmt    | 5071   << off_ ,	//gbc0a	mov wa dnamb  start of dynamic area
/* 15388 */	load    | wa     << dst_ | dnamb  << off_ ,
/* 15389 */	stmt    | 5072   << off_ ,	//	add wa dnams  size of sediment
/* 15390 */	load    | r2     << dst_ | dnams  << off_ ,
/* 15391 */	add     | wa     << dst_ | r2     << src_ ,
/* 15392 */	stmt    | 5073   << off_ ,	//	mov gbcsd wa  first location past sediment
/* 15393 */	store   | wa     << dst_ | gbcsd  << off_ ,
/* 15394 */	stmt    | 5074   << off_ ,	//	mov wa =p_yyy  last entry point
/* 15395 */	loadi   | wa     << dst_ | p_yyy  << off_ ,
/* 15396 */	stmt    | 5075   << off_ ,	//	icv wa   address past last entry point
/* 15397 */	icv     | wa     << dst_ ,
/* 15398 */	stmt    | 5076   << off_ ,	//	sub wa =b_aaa  size of entry point area
/* 15399 */	loadi   | r2     << dst_ | b_aaa  << off_ ,
/* 15400 */	sub     | wa     << dst_ | r2     << src_ ,
/* 15401 */	stmt    | 5077   << off_ ,	//	mov gbcmk wa  use to mark processed sed. blocks
/* 15402 */	store   | wa     << dst_ | gbcmk  << off_ ,
/* 15403 */	stmt    | 5078   << off_ ,	//	mnz xr   non-zero flags start of collection
/* 15404 */	move    | xr     << dst_ | xs     << src_ ,
/* 15405 */	stmt    | 5079   << off_ ,	//	mov wa dnamb  start of dynamic area
/* 15406 */	load    | wa     << dst_ | dnamb  << off_ ,
/* 15407 */	stmt    | 5080   << off_ ,	//	mov wb dnamp  next available location
/* 15408 */	load    | wb     << dst_ | dnamp  << off_ ,
/* 15409 */	stmt    | 5081   << off_ ,	//	mov wc dname  last available location + 1
/* 15410 */	load    | wc     << dst_ | dname  << off_ ,
/* 15411 */	stmt    | 5082   << off_ ,	//	jsr sysgc   inform of collection
/* 15412 */	sys     | sysgc_ << off_ ,
/* 15413 */	stmt    | 5083   << off_ ,	//	mov xr xs  point to stack front
/* 15414 */	move    | xr     << dst_ | xs     << src_ ,
/* 15415 */	stmt    | 5084   << off_ ,	//	mov xl stbas  point past end of stack
/* 15416 */	load    | xl     << dst_ | stbas  << off_ ,
/* 15417 */	stmt    | 5085   << off_ ,	//	bge xl xr gbc00 ok if d-stack
/* 15418 */	bge     | xl     << dst_ | xr     << src_ | gbc00  << off_ ,
/* 15419 */	stmt    | 5086   << off_ ,	//	mov xr xl  reverse if ...
/* 15420 */	move    | xr     << dst_ | xl     << src_ ,
/* 15421 */	stmt    | 5087   << off_ ,	//	mov xl xs  ... u-stack
/* 15422 */	move    | xl     << dst_ | xs     << src_ ,
// gbc00:
/* 15423 */	stmt    | 5088   << off_ ,	//gbc00	jsr gbcpf   process pointers on stack
/* 15424 */	call    | gbcpf  << off_ ,
/* 15425 */	stmt    | 5089   << off_ ,	//	mov xr =r_aaa  point to start of relocatable locs
/* 15426 */	loadi   | xr     << dst_ | r_aaa  << off_ ,
/* 15427 */	stmt    | 5090   << off_ ,	//	mov xl =r_yyy  point past end of relocatable locs
/* 15428 */	loadi   | xl     << dst_ | r_yyy  << off_ ,
/* 15429 */	stmt    | 5091   << off_ ,	//	jsr gbcpf   process work fields
/* 15430 */	call    | gbcpf  << off_ ,
/* 15431 */	stmt    | 5092   << off_ ,	//	mov wa hshtb  point to first hash slot pointer
/* 15432 */	load    | wa     << dst_ | hshtb  << off_ ,
// gbc01:
/* 15433 */	stmt    | 5093   << off_ ,	//gbc01	mov xl wa  point to next slot
/* 15434 */	move    | xl     << dst_ | wa     << src_ ,
/* 15435 */	stmt    | 5094   << off_ ,	//	ica wa   bump bucket pointer
/* 15436 */	ica     | wa     << dst_ ,
/* 15437 */	stmt    | 5095   << off_ ,	//	mov gbcnm wa  save bucket pointer
/* 15438 */	store   | wa     << dst_ | gbcnm  << off_ ,
// gbc02:
/* 15439 */	stmt    | 5096   << off_ ,	//gbc02	mov xr (xl)  load ptr to next vrblk
/* 15440 */	load    | xr     << dst_ | xl     << src_ ,
/* 15441 */	stmt    | 5097   << off_ ,	//	bze xr gbc03  jump if end of chain
/* 15442 */	bze     | xr     << dst_ | gbc03  << off_ ,
/* 15443 */	stmt    | 5098   << off_ ,	//	mov xl xr  else copy vrblk pointer
/* 15444 */	move    | xl     << dst_ | xr     << src_ ,
/* 15445 */	stmt    | 5099   << off_ ,	//	add xr *vrval  point to first reloc fld
/* 15446 */	loadi   | r2     << dst_ | vrval  << off_ ,
/* 15447 */	add     | xr     << dst_ | r2     << src_ ,
/* 15448 */	stmt    | 5100   << off_ ,	//	add xl *vrnxt  point past last (and to link ptr)
/* 15449 */	loadi   | r2     << dst_ | vrnxt  << off_ ,
/* 15450 */	add     | xl     << dst_ | r2     << src_ ,
/* 15451 */	stmt    | 5101   << off_ ,	//	jsr gbcpf   process reloc fields in vrblk
/* 15452 */	call    | gbcpf  << off_ ,
/* 15453 */	stmt    | 5102   << off_ ,	//	brn gbc02   loop back for next block
/* 15454 */	brn     | gbc02  << off_ ,
// gbc03:
/* 15455 */	stmt    | 5103   << off_ ,	//gbc03	mov wa gbcnm  restore bucket pointer
/* 15456 */	load    | wa     << dst_ | gbcnm  << off_ ,
/* 15457 */	stmt    | 5104   << off_ ,	//	bne wa hshte gbc01 loop back if more buckets to go
/* 15458 */	load    | r2     << dst_ | hshte  << off_ ,
/* 15459 */	bne     | wa     << dst_ | r2     << src_ | gbc01  << off_ ,
/* 15460 */	stmt    | 5105   << off_ ,	//	mov xr dnamb  point to first block
/* 15461 */	load    | xr     << dst_ | dnamb  << off_ ,
/* 15462 */	stmt    | 5106   << off_ ,	//	zer wb   accumulate size of dead blocks
/* 15463 */	move    | wb     << dst_ ,
// gbc04:
/* 15464 */	stmt    | 5107   << off_ ,	//gbc04	beq xr gbcsd gbc4c jump if end of sediment
/* 15465 */	load    | r2     << dst_ | gbcsd  << off_ ,
/* 15466 */	beq     | xr     << dst_ | r2     << src_ | gbc4c  << off_ ,
/* 15467 */	stmt    | 5108   << off_ ,	//	mov wa (xr)  else get first word
/* 15468 */	load    | wa     << dst_ | xr     << src_ ,
/* 15469 */	stmt    | 5109   << off_ ,	//	bhi wa =p_yyy gbc4a skip if not entry ptr (in use)
/* 15470 */	loadi   | r2     << dst_ | p_yyy  << off_ ,
/* 15471 */	bhi     | wa     << dst_ | r2     << src_ | gbc4a  << off_ ,
/* 15472 */	stmt    | 5110   << off_ ,	//	bhi wa =b_aaa gbc4b jump if entry pointer (unused)
/* 15473 */	loadi   | r2     << dst_ | b_aaa  << off_ ,
/* 15474 */	bhi     | wa     << dst_ | r2     << src_ | gbc4b  << off_ ,
// gbc4a:
/* 15475 */	stmt    | 5111   << off_ ,	//gbc4a	sub wa gbcmk  restore entry pointer
/* 15476 */	load    | r2     << dst_ | gbcmk  << off_ ,
/* 15477 */	sub     | wa     << dst_ | r2     << src_ ,
/* 15478 */	stmt    | 5112   << off_ ,	//	mov (xr) wa  restore first word
/* 15479 */	store   | wa     << dst_ | xr     << src_ ,
/* 15480 */	stmt    | 5113   << off_ ,	//	jsr blkln   get length of this block
/* 15481 */	call    | blkln  << off_ ,
/* 15482 */	stmt    | 5114   << off_ ,	//	add xr wa  bump actual pointer
/* 15483 */	add     | xr     << dst_ | wa     << src_ ,
/* 15484 */	stmt    | 5115   << off_ ,	//	brn gbc04   continue scan through sediment
/* 15485 */	brn     | gbc04  << off_ ,
// gbc4b:
/* 15486 */	stmt    | 5116   << off_ ,	//gbc4b	jsr blkln   get length of this block
/* 15487 */	call    | blkln  << off_ ,
/* 15488 */	stmt    | 5117   << off_ ,	//	add xr wa  bump actual pointer
/* 15489 */	add     | xr     << dst_ | wa     << src_ ,
/* 15490 */	stmt    | 5118   << off_ ,	//	add wb wa  count size of unused blocks
/* 15491 */	add     | wb     << dst_ | wa     << src_ ,
/* 15492 */	stmt    | 5119   << off_ ,	//	brn gbc04   continue scan through sediment
/* 15493 */	brn     | gbc04  << off_ ,
// gbc4c:
/* 15494 */	stmt    | 5120   << off_ ,	//gbc4c	mov gbcsf wb  size of sediment free space
/* 15495 */	store   | wb     << dst_ | gbcsf  << off_ ,
/* 15496 */	stmt    | 5121   << off_ ,	//	mov wc xr  set as first eventual location
/* 15497 */	move    | wc     << dst_ | xr     << src_ ,
/* 15498 */	stmt    | 5122   << off_ ,	//	add wc gbsvb  add offset for eventual move up
/* 15499 */	load    | r2     << dst_ | gbsvb  << off_ ,
/* 15500 */	add     | wc     << dst_ | r2     << src_ ,
/* 15501 */	stmt    | 5123   << off_ ,	//	zer gbcnm   clear initial forward pointer
/* 15502 */	store   | r0     << dst_ | gbcnm  << off_ ,
/* 15503 */	stmt    | 5124   << off_ ,	//	mov gbclm =gbcnm  initialize ptr to last move block
/* 15504 */	loadi   | r1     << dst_ | gbcnm  << off_ ,
/* 15505 */	store   | r1     << dst_ | gbclm  << off_ ,
/* 15506 */	stmt    | 5125   << off_ ,	//	mov gbcns xr  initialize first address
/* 15507 */	store   | xr     << dst_ | gbcns  << off_ ,
// gbc05:
/* 15508 */	stmt    | 5126   << off_ ,	//gbc05	beq xr dnamp gbc07 jump if end of used region
/* 15509 */	load    | r2     << dst_ | dnamp  << off_ ,
/* 15510 */	beq     | xr     << dst_ | r2     << src_ | gbc07  << off_ ,
/* 15511 */	stmt    | 5127   << off_ ,	//	mov wa (xr)  else get first word
/* 15512 */	load    | wa     << dst_ | xr     << src_ ,
/* 15513 */	stmt    | 5128   << off_ ,	//	bhi wa =p_yyy gbc06 skip if not entry ptr (in use)
/* 15514 */	loadi   | r2     << dst_ | p_yyy  << off_ ,
/* 15515 */	bhi     | wa     << dst_ | r2     << src_ | gbc06  << off_ ,
/* 15516 */	stmt    | 5129   << off_ ,	//	bhi wa =b_aaa gbc07 jump if entry pointer (unused)
/* 15517 */	loadi   | r2     << dst_ | b_aaa  << off_ ,
/* 15518 */	bhi     | wa     << dst_ | r2     << src_ | gbc07  << off_ ,
// gbc06:
/* 15519 */	stmt    | 5130   << off_ ,	//gbc06	mov xl wa  copy pointer
/* 15520 */	move    | xl     << dst_ | wa     << src_ ,
/* 15521 */	stmt    | 5131   << off_ ,	//	mov wa (xl)  load forward pointer
/* 15522 */	load    | wa     << dst_ | xl     << src_ ,
/* 15523 */	stmt    | 5132   << off_ ,	//	mov (xl) wc  relocate reference
/* 15524 */	store   | wc     << dst_ | xl     << src_ ,
/* 15525 */	stmt    | 5133   << off_ ,	//	bhi wa =p_yyy gbc06 loop back if not end of chain
/* 15526 */	loadi   | r2     << dst_ | p_yyy  << off_ ,
/* 15527 */	bhi     | wa     << dst_ | r2     << src_ | gbc06  << off_ ,
/* 15528 */	stmt    | 5134   << off_ ,	//	blo wa =b_aaa gbc06 loop back if not end of chain
/* 15529 */	loadi   | r2     << dst_ | b_aaa  << off_ ,
/* 15530 */	blo     | wa     << dst_ | r2     << src_ | gbc06  << off_ ,
/* 15531 */	stmt    | 5135   << off_ ,	//	mov (xr) wa  restore first word
/* 15532 */	store   | wa     << dst_ | xr     << src_ ,
/* 15533 */	stmt    | 5136   << off_ ,	//	jsr blkln   get length of this block
/* 15534 */	call    | blkln  << off_ ,
/* 15535 */	stmt    | 5137   << off_ ,	//	add xr wa  bump actual pointer
/* 15536 */	add     | xr     << dst_ | wa     << src_ ,
/* 15537 */	stmt    | 5138   << off_ ,	//	add wc wa  bump eventual pointer
/* 15538 */	add     | wc     << dst_ | wa     << src_ ,
/* 15539 */	stmt    | 5139   << off_ ,	//	brn gbc05   loop back for next block
/* 15540 */	brn     | gbc05  << off_ ,
// gbc07:
/* 15541 */	stmt    | 5140   << off_ ,	//gbc07	mov wa xr  copy pointer past last block
/* 15542 */	move    | wa     << dst_ | xr     << src_ ,
/* 15543 */	stmt    | 5141   << off_ ,	//	mov xl gbclm  point to previous move block
/* 15544 */	load    | xl     << dst_ | gbclm  << off_ ,
/* 15545 */	stmt    | 5142   << off_ ,	//	sub wa num01(xl)  subtract starting address
/* 15546 */	load    | r2     << dst_ | xl     << src_ | num01  << off_ ,
/* 15547 */	sub     | wa     << dst_ | r2     << src_ ,
/* 15548 */	stmt    | 5143   << off_ ,	//	mov num01(xl) wa  store length of block to be moved
/* 15549 */	store   | wa     << dst_ | xl     << src_ | num01  << off_ ,
// gbc08:
/* 15550 */	stmt    | 5144   << off_ ,	//gbc08	beq xr dnamp gbc10 jump if end of used region
/* 15551 */	load    | r2     << dst_ | dnamp  << off_ ,
/* 15552 */	beq     | xr     << dst_ | r2     << src_ | gbc10  << off_ ,
/* 15553 */	stmt    | 5145   << off_ ,	//	mov wa (xr)  else load first word of next block
/* 15554 */	load    | wa     << dst_ | xr     << src_ ,
/* 15555 */	stmt    | 5146   << off_ ,	//	bhi wa =p_yyy gbc09 jump if in use
/* 15556 */	loadi   | r2     << dst_ | p_yyy  << off_ ,
/* 15557 */	bhi     | wa     << dst_ | r2     << src_ | gbc09  << off_ ,
/* 15558 */	stmt    | 5147   << off_ ,	//	blo wa =b_aaa gbc09 jump if in use
/* 15559 */	loadi   | r2     << dst_ | b_aaa  << off_ ,
/* 15560 */	blo     | wa     << dst_ | r2     << src_ | gbc09  << off_ ,
/* 15561 */	stmt    | 5148   << off_ ,	//	jsr blkln   else get length of next block
/* 15562 */	call    | blkln  << off_ ,
/* 15563 */	stmt    | 5149   << off_ ,	//	add xr wa  push pointer
/* 15564 */	add     | xr     << dst_ | wa     << src_ ,
/* 15565 */	stmt    | 5150   << off_ ,	//	brn gbc08   and loop back
/* 15566 */	brn     | gbc08  << off_ ,
// gbc09:
/* 15567 */	stmt    | 5151   << off_ ,	//gbc09	sub xr *num02  point 2 words behind for move block
/* 15568 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 15569 */	sub     | xr     << dst_ | r2     << src_ ,
/* 15570 */	stmt    | 5152   << off_ ,	//	mov xl gbclm  point to previous move block
/* 15571 */	load    | xl     << dst_ | gbclm  << off_ ,
/* 15572 */	stmt    | 5153   << off_ ,	//	mov (xl) xr  set forward ptr in previous block
/* 15573 */	store   | xr     << dst_ | xl     << src_ ,
/* 15574 */	stmt    | 5154   << off_ ,	//	zer (xr)   zero forward ptr of new block
/* 15575 */	store   | r0     << dst_ | xr     << src_ ,
/* 15576 */	stmt    | 5155   << off_ ,	//	mov gbclm xr  remember address of this block
/* 15577 */	store   | xr     << dst_ | gbclm  << off_ ,
/* 15578 */	stmt    | 5156   << off_ ,	//	mov xl xr  copy ptr to move block
/* 15579 */	move    | xl     << dst_ | xr     << src_ ,
/* 15580 */	stmt    | 5157   << off_ ,	//	add xr *num02  point back to block in use
/* 15581 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 15582 */	add     | xr     << dst_ | r2     << src_ ,
/* 15583 */	stmt    | 5158   << off_ ,	//	mov num01(xl) xr  store starting address
/* 15584 */	store   | xr     << dst_ | xl     << src_ | num01  << off_ ,
/* 15585 */	stmt    | 5159   << off_ ,	//	brn gbc06   jump to process block in use
/* 15586 */	brn     | gbc06  << off_ ,
// gbc10:
/* 15587 */	stmt    | 5160   << off_ ,	//gbc10	mov xr gbcsd  point to storage above sediment
/* 15588 */	load    | xr     << dst_ | gbcsd  << off_ ,
/* 15589 */	stmt    | 5161   << off_ ,	//	add xr gbcns  bump past unmoved blocks at start
/* 15590 */	load    | r2     << dst_ | gbcns  << off_ ,
/* 15591 */	add     | xr     << dst_ | r2     << src_ ,
// gbc11:
/* 15592 */	stmt    | 5162   << off_ ,	//gbc11	mov xl gbcnm  point to next move block
/* 15593 */	load    | xl     << dst_ | gbcnm  << off_ ,
/* 15594 */	stmt    | 5163   << off_ ,	//	bze xl gbc12  jump if end of chain
/* 15595 */	bze     | xl     << dst_ | gbc12  << off_ ,
/* 15596 */	stmt    | 5164   << off_ ,	//	mov gbcnm (xl)+  move pointer down chain
/* 15597 */	load    | r1     << dst_ | xl     << src_ ,
/* 15598 */	ica     | xl     << dst_ ,
/* 15599 */	store   | r1     << dst_ | gbcnm  << off_ ,
/* 15600 */	stmt    | 5165   << off_ ,	//	mov wa (xl)+  get length to move
/* 15601 */	load    | wa     << dst_ | xl     << src_ ,
/* 15602 */	ica     | xl     << dst_ ,
/* 15603 */	stmt    | 5166   << off_ ,	//	mvw    perform move
/* 15604 */	mvw     ,
/* 15605 */	stmt    | 5167   << off_ ,	//	brn gbc11   loop back
/* 15606 */	brn     | gbc11  << off_ ,
// gbc12:
/* 15607 */	stmt    | 5168   << off_ ,	//gbc12	mov dnamp xr  set next available loc ptr
/* 15608 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 15609 */	stmt    | 5169   << off_ ,	//	mov wb gbsvb  reload move offset
/* 15610 */	load    | wb     << dst_ | gbsvb  << off_ ,
/* 15611 */	stmt    | 5170   << off_ ,	//	bze wb gbc13  jump if no move required
/* 15612 */	bze     | wb     << dst_ | gbc13  << off_ ,
/* 15613 */	stmt    | 5171   << off_ ,	//	mov xl xr  else copy old top of core
/* 15614 */	move    | xl     << dst_ | xr     << src_ ,
/* 15615 */	stmt    | 5172   << off_ ,	//	add xr wb  point to new top of core
/* 15616 */	add     | xr     << dst_ | wb     << src_ ,
/* 15617 */	stmt    | 5173   << off_ ,	//	mov dnamp xr  save new top of core pointer
/* 15618 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 15619 */	stmt    | 5174   << off_ ,	//	mov wa xl  copy old top
/* 15620 */	move    | wa     << dst_ | xl     << src_ ,
/* 15621 */	stmt    | 5175   << off_ ,	//	sub wa dnamb  minus old bottom = length
/* 15622 */	load    | r2     << dst_ | dnamb  << off_ ,
/* 15623 */	sub     | wa     << dst_ | r2     << src_ ,
/* 15624 */	stmt    | 5176   << off_ ,	//	add dnamb wb  bump bottom to get new value
/* 15625 */	load    | r1     << dst_ | dnamb  << off_ ,
/* 15626 */	add     | r1     << dst_ | wb     << src_ ,
/* 15627 */	store   | r1     << dst_ | dnamb  << off_ ,
/* 15628 */	stmt    | 5177   << off_ ,	//	mwb    perform move (backwards)
/* 15629 */	mwb     ,
// gbc13:
/* 15630 */	stmt    | 5178   << off_ ,	//gbc13	zer xr   clear garbage value in xr
/* 15631 */	move    | xr     << dst_ ,
/* 15632 */	stmt    | 5179   << off_ ,	//	mov gbcfl xr  note exit from gbcol
/* 15633 */	store   | xr     << dst_ | gbcfl  << off_ ,
/* 15634 */	stmt    | 5180   << off_ ,	//	mov wa dnamb  start of dynamic area
/* 15635 */	load    | wa     << dst_ | dnamb  << off_ ,
/* 15636 */	stmt    | 5181   << off_ ,	//	mov wb dnamp  next available location
/* 15637 */	load    | wb     << dst_ | dnamp  << off_ ,
/* 15638 */	stmt    | 5182   << off_ ,	//	mov wc dname  last available location + 1
/* 15639 */	load    | wc     << dst_ | dname  << off_ ,
/* 15640 */	stmt    | 5183   << off_ ,	//	jsr sysgc   inform sysgc of completion
/* 15641 */	sys     | sysgc_ << off_ ,
/* 15642 */	stmt    | 5184   << off_ ,	//	sti gbcia   save ia
/* 15643 */	store   | ia     << dst_ | gbcia  << off_ ,
/* 15644 */	stmt    | 5185   << off_ ,	//	zer xr   presume no sediment will remain
/* 15645 */	move    | xr     << dst_ ,
/* 15646 */	stmt    | 5186   << off_ ,	//	mov wb gbcsf  free space in sediment
/* 15647 */	load    | wb     << dst_ | gbcsf  << off_ ,
/* 15648 */	stmt    | 5187   << off_ ,	//	btw wb   convert bytes to words
/* 15649 */	stmt    | 5188   << off_ ,	//	mti wb   put sediment free store in ia
/* 15650 */	move    | ia     << dst_ | wb     << src_ ,
/* 15651 */	stmt    | 5189   << off_ ,	//	mli gbsed   multiply by sediment factor
/* 15652 */	load    | r1     << dst_ | gbsed  << off_ ,
/* 15653 */	mli     | r1     << dst_ ,
/* 15654 */	stmt    | 5190   << off_ ,	//	iov gb13a   jump if overflowed
/* 15655 */	iov     | gb13a  << off_ ,
/* 15656 */	stmt    | 5191   << off_ ,	//	mov wb dnamp  end of dynamic area in use
/* 15657 */	load    | wb     << dst_ | dnamp  << off_ ,
/* 15658 */	stmt    | 5192   << off_ ,	//	sub wb dnamb  minus start is sediment remaining
/* 15659 */	load    | r2     << dst_ | dnamb  << off_ ,
/* 15660 */	sub     | wb     << dst_ | r2     << src_ ,
/* 15661 */	stmt    | 5193   << off_ ,	//	btw wb   convert to words
/* 15662 */	stmt    | 5194   << off_ ,	//	mov gbcsf wb  store it
/* 15663 */	store   | wb     << dst_ | gbcsf  << off_ ,
/* 15664 */	stmt    | 5195   << off_ ,	//	sbi gbcsf   subtract from scaled up free store
/* 15665 */	load    | r1     << dst_ | gbcsf  << off_ ,
/* 15666 */	sbi     | r1     << dst_ ,
/* 15667 */	stmt    | 5196   << off_ ,	//	igt gb13a   jump if large free store in sedimnt
/* 15668 */	igt     | gb13a  << off_ ,
/* 15669 */	stmt    | 5197   << off_ ,	//	mov xr dnamp  below threshold, return sediment
/* 15670 */	load    | xr     << dst_ | dnamp  << off_ ,
/* 15671 */	stmt    | 5198   << off_ ,	//	sub xr dnamb  for use by caller
/* 15672 */	load    | r2     << dst_ | dnamb  << off_ ,
/* 15673 */	sub     | xr     << dst_ | r2     << src_ ,
// gb13a:
/* 15674 */	stmt    | 5199   << off_ ,	//gb13a	ldi gbcia   restore ia
/* 15675 */	load    | r1     << dst_ | gbcia  << off_ ,
/* 15676 */	ldi     | r1     << dst_ ,
/* 15677 */	stmt    | 5200   << off_ ,	//	mov wa gbsva  restore wa
/* 15678 */	load    | wa     << dst_ | gbsva  << off_ ,
/* 15679 */	stmt    | 5201   << off_ ,	//	mov wb gbsvb  restore wb
/* 15680 */	load    | wb     << dst_ | gbsvb  << off_ ,
/* 15681 */	stmt    | 5202   << off_ ,	//	scp wc   get code pointer
/* 15682 */	scp     | wc     << dst_ ,
/* 15683 */	stmt    | 5203   << off_ ,	//	add wc r_cod  make absolute again
/* 15684 */	load    | r2     << dst_ | r_cod  << off_ ,
/* 15685 */	add     | wc     << dst_ | r2     << src_ ,
/* 15686 */	stmt    | 5204   << off_ ,	//	lcp wc   and replace absolute value
/* 15687 */	lcp     | wc     << dst_ ,
/* 15688 */	stmt    | 5205   << off_ ,	//	mov wc gbsvc  restore wc
/* 15689 */	load    | wc     << dst_ | gbsvc  << off_ ,
/* 15690 */	stmt    | 5206   << off_ ,	//	mov xl (xs)+  restore entry xl
/* 15691 */	load    | xl     << dst_ | xs     << src_ ,
/* 15692 */	ica     | xs     << dst_ ,
/* 15693 */	stmt    | 5207   << off_ ,	//	icv gbcnt   increment count of collections
/* 15694 */	load    | r1     << dst_ | gbcnt  << off_ ,
/* 15695 */	icv     | r1     << dst_ ,
/* 15696 */	store   | r1     << dst_ | gbcnt  << off_ ,
/* 15697 */	stmt    | 5208   << off_ ,	//	exi    exit to gbcol caller
/* 15698 */	exi     | 0      << off_ ,
// gbc14:
/* 15699 */	stmt    | 5209   << off_ ,	//gbc14	icv errft   fatal error
/* 15700 */	load    | r1     << dst_ | errft  << off_ ,
/* 15701 */	icv     | r1     << dst_ ,
/* 15702 */	store   | r1     << dst_ | errft  << off_ ,
/* 15703 */	stmt    | 5210   << off_ ,	//	erb 250 insufficient memory to complete dump
/* 15704 */	erb     | 250    << off_ ,
// gbcpf:
/* 15705 */	stmt    | 5211   << off_ ,	//gbcpf	prc e 0  entry point
/* 15706 */	stmt    | 5212   << off_ ,	//	zer -(xs)   set zero to mark bottom of stack
/* 15707 */	dca     | xs     << dst_ ,
/* 15708 */	store   | r0     << dst_ | xs     << src_ ,
/* 15709 */	stmt    | 5213   << off_ ,	//	mov -(xs) xl  save end pointer
/* 15710 */	dca     | xs     << dst_ ,
/* 15711 */	store   | xl     << dst_ | xs     << src_ ,
// gpf01:
/* 15712 */	stmt    | 5214   << off_ ,	//gpf01	mov xl (xr)  load field contents
/* 15713 */	load    | xl     << dst_ | xr     << src_ ,
/* 15714 */	stmt    | 5215   << off_ ,	//	mov wc xr  save field pointer
/* 15715 */	move    | wc     << dst_ | xr     << src_ ,
/* 15716 */	stmt    | 5216   << off_ ,	//	blt xl dnamb gpf2a jump if not ptr into dynamic area
/* 15717 */	load    | r2     << dst_ | dnamb  << off_ ,
/* 15718 */	blt     | xl     << dst_ | r2     << src_ | gpf2a  << off_ ,
/* 15719 */	stmt    | 5217   << off_ ,	//	bge xl dnamp gpf2a jump if not ptr into dynamic area
/* 15720 */	load    | r2     << dst_ | dnamp  << off_ ,
/* 15721 */	bge     | xl     << dst_ | r2     << src_ | gpf2a  << off_ ,
/* 15722 */	stmt    | 5218   << off_ ,	//	mov wa (xl)  load ptr to chain (or entry ptr)
/* 15723 */	load    | wa     << dst_ | xl     << src_ ,
/* 15724 */	stmt    | 5219   << off_ ,	//	blt xl gbcsd gpf1a do not chain if within sediment
/* 15725 */	load    | r2     << dst_ | gbcsd  << off_ ,
/* 15726 */	blt     | xl     << dst_ | r2     << src_ | gpf1a  << off_ ,
/* 15727 */	stmt    | 5220   << off_ ,	//	mov (xl) xr  set this field as new head of chain
/* 15728 */	store   | xr     << dst_ | xl     << src_ ,
/* 15729 */	stmt    | 5221   << off_ ,	//	mov (xr) wa  set forward pointer
/* 15730 */	store   | wa     << dst_ | xr     << src_ ,
// gpf1a:
/* 15731 */	stmt    | 5222   << off_ ,	//gpf1a	bhi wa =p_yyy gpf2a jump if already processed
/* 15732 */	loadi   | r2     << dst_ | p_yyy  << off_ ,
/* 15733 */	bhi     | wa     << dst_ | r2     << src_ | gpf2a  << off_ ,
/* 15734 */	stmt    | 5223   << off_ ,	//	bhi wa =b_aaa gpf03 jump if not already processed
/* 15735 */	loadi   | r2     << dst_ | b_aaa  << off_ ,
/* 15736 */	bhi     | wa     << dst_ | r2     << src_ | gpf03  << off_ ,
// gpf02:
/* 15737 */	stmt    | 5224   << off_ ,	//gpf02	mov xr wc  restore field pointer
/* 15738 */	move    | xr     << dst_ | wc     << src_ ,
// gpf2a:
/* 15739 */	stmt    | 5225   << off_ ,	//gpf2a	ica xr   bump to next field
/* 15740 */	ica     | xr     << dst_ ,
/* 15741 */	stmt    | 5226   << off_ ,	//	bne xr (xs) gpf01 loop back if more to go
/* 15742 */	load    | r2     << dst_ | xs     << src_ ,
/* 15743 */	bne     | xr     << dst_ | r2     << src_ | gpf01  << off_ ,
/* 15744 */	stmt    | 5227   << off_ ,	//	mov xl (xs)+  restore pointer past end
/* 15745 */	load    | xl     << dst_ | xs     << src_ ,
/* 15746 */	ica     | xs     << dst_ ,
/* 15747 */	stmt    | 5228   << off_ ,	//	mov xr (xs)+  restore block pointer
/* 15748 */	load    | xr     << dst_ | xs     << src_ ,
/* 15749 */	ica     | xs     << dst_ ,
/* 15750 */	stmt    | 5229   << off_ ,	//	bnz xr gpf2a  continue loop unless outer levl
/* 15751 */	bnz     | xr     << dst_ | gpf2a  << off_ ,
/* 15752 */	stmt    | 5230   << off_ ,	//	exi    return to caller if outer level
/* 15753 */	exi     | 0      << off_ ,
// gpf03:
/* 15754 */	stmt    | 5231   << off_ ,	//gpf03	bge xl gbcsd gpf3a if not within sediment
/* 15755 */	load    | r2     << dst_ | gbcsd  << off_ ,
/* 15756 */	bge     | xl     << dst_ | r2     << src_ | gpf3a  << off_ ,
/* 15757 */	stmt    | 5232   << off_ ,	//	add (xl) gbcmk  mark by biasing entry point
/* 15758 */	load    | r1     << dst_ | xl     << src_ ,
/* 15759 */	load    | r2     << dst_ | gbcmk  << off_ ,
/* 15760 */	add     | r1     << dst_ | r2     << src_ ,
/* 15761 */	store   | r1     << dst_ | xl     << src_ ,
// gpf3a:
/* 15762 */	stmt    | 5233   << off_ ,	//gpf3a	mov xr xl  copy block pointer
/* 15763 */	move    | xr     << dst_ | xl     << src_ ,
/* 15764 */	stmt    | 5234   << off_ ,	//	mov xl wa  copy first word of block
/* 15765 */	move    | xl     << dst_ | wa     << src_ ,
/* 15766 */	stmt    | 5235   << off_ ,	//	lei xl   load entry point id (bl_xx)
/* 15767 */	lei     | xl     << dst_ ,
/* 15768 */	stmt    | 5236   << off_ ,	//	bsw xl bl___  switch on block type
/* 15769 */	loadi   | r1     << dst_ | bl___  << off_ ,
/* 15770 */	bsw     | xl     << dst_ | r1     << src_ ,
/* 15771 */	gpf06   ,
/* 15772 */	gpf19   ,
/* 15773 */	gpf17   ,
/* 15774 */	gpf02   ,
/* 15775 */	gpf10   ,
/* 15776 */	gpf10   ,
/* 15777 */	gpf12   ,
/* 15778 */	gpf12   ,
/* 15779 */	gpf02   ,
/* 15780 */	gpf02   ,
/* 15781 */	gpf02   ,
/* 15782 */	gpf08   ,
/* 15783 */	gpf08   ,
/* 15784 */	gpf02   ,
/* 15785 */	gpf09   ,
/* 15786 */	gpf02   ,
/* 15787 */	gpf13   ,
/* 15788 */	gpf16   ,
/* 15789 */	gpf02   ,
/* 15790 */	gpf07   ,
/* 15791 */	gpf04   ,
/* 15792 */	gpf02   ,
/* 15793 */	gpf02   ,
/* 15794 */	gpf02   ,
/* 15795 */	gpf10   ,
/* 15796 */	gpf11   ,
/* 15797 */	gpf02   ,
/* 15798 */	gpf14   ,
/* 15799 */	gpf15   ,
// gpf04:
/* 15800 */	stmt    | 5237   << off_ ,	//gpf04	mov wa cmlen(xr)  load length
/* 15801 */	load    | wa     << dst_ | xr     << src_ | cmlen  << off_ ,
/* 15802 */	stmt    | 5238   << off_ ,	//	mov wb *cmtyp  set offset
/* 15803 */	loadi   | wb     << dst_ | cmtyp  << off_ ,
// gpf05:
/* 15804 */	stmt    | 5239   << off_ ,	//gpf05	add wa xr  point past last reloc field
/* 15805 */	add     | wa     << dst_ | xr     << src_ ,
/* 15806 */	stmt    | 5240   << off_ ,	//	add xr wb  point to first reloc field
/* 15807 */	add     | xr     << dst_ | wb     << src_ ,
/* 15808 */	stmt    | 5241   << off_ ,	//	mov -(xs) wc  stack old field pointer
/* 15809 */	dca     | xs     << dst_ ,
/* 15810 */	store   | wc     << dst_ | xs     << src_ ,
/* 15811 */	stmt    | 5242   << off_ ,	//	mov -(xs) wa  stack new limit pointer
/* 15812 */	dca     | xs     << dst_ ,
/* 15813 */	store   | wa     << dst_ | xs     << src_ ,
/* 15814 */	stmt    | 5243   << off_ ,	//	chk    check for stack overflow
/* 15815 */	chk     ,
/* 15816 */	stmt    | 5244   << off_ ,	//	brn gpf01   if ok, back to process
/* 15817 */	brn     | gpf01  << off_ ,
// gpf06:
/* 15818 */	stmt    | 5245   << off_ ,	//gpf06	mov wa arlen(xr)  load length
/* 15819 */	load    | wa     << dst_ | xr     << src_ | arlen  << off_ ,
/* 15820 */	stmt    | 5246   << off_ ,	//	mov wb arofs(xr)  set offset to 1st reloc fld (arpro)
/* 15821 */	load    | wb     << dst_ | xr     << src_ | arofs  << off_ ,
/* 15822 */	stmt    | 5247   << off_ ,	//	brn gpf05   all set
/* 15823 */	brn     | gpf05  << off_ ,
// gpf07:
/* 15824 */	stmt    | 5248   << off_ ,	//gpf07	mov wa ccuse(xr)  set length in use
/* 15825 */	load    | wa     << dst_ | xr     << src_ | ccuse  << off_ ,
/* 15826 */	stmt    | 5249   << off_ ,	//	mov wb *ccuse  1st word (make sure at least one)
/* 15827 */	loadi   | wb     << dst_ | ccuse  << off_ ,
/* 15828 */	stmt    | 5250   << off_ ,	//	brn gpf05   all set
/* 15829 */	brn     | gpf05  << off_ ,
// gpf19:
/* 15830 */	stmt    | 5251   << off_ ,	//gpf19	mov wa cdlen(xr)  load length
/* 15831 */	load    | wa     << dst_ | xr     << src_ | cdlen  << off_ ,
/* 15832 */	stmt    | 5252   << off_ ,	//	mov wb *cdfal  set offset
/* 15833 */	loadi   | wb     << dst_ | cdfal  << off_ ,
/* 15834 */	stmt    | 5253   << off_ ,	//	brn gpf05   jump back
/* 15835 */	brn     | gpf05  << off_ ,
// gpf08:
/* 15836 */	stmt    | 5254   << off_ ,	//gpf08	mov wa offs2(xr)  load length
/* 15837 */	load    | wa     << dst_ | xr     << src_ | offs2  << off_ ,
/* 15838 */	stmt    | 5255   << off_ ,	//	mov wb *offs3  set offset
/* 15839 */	loadi   | wb     << dst_ | offs3  << off_ ,
/* 15840 */	stmt    | 5256   << off_ ,	//	brn gpf05   jump back
/* 15841 */	brn     | gpf05  << off_ ,
// gpf09:
/* 15842 */	stmt    | 5257   << off_ ,	//gpf09	mov wa xrlen(xr)  load length
/* 15843 */	load    | wa     << dst_ | xr     << src_ | xrlen  << off_ ,
/* 15844 */	stmt    | 5258   << off_ ,	//	mov wb *xrptr  set offset
/* 15845 */	loadi   | wb     << dst_ | xrptr  << off_ ,
/* 15846 */	stmt    | 5259   << off_ ,	//	brn gpf05   jump back
/* 15847 */	brn     | gpf05  << off_ ,
// gpf10:
/* 15848 */	stmt    | 5260   << off_ ,	//gpf10	mov wa *offs2  point past second field
/* 15849 */	loadi   | wa     << dst_ | offs2  << off_ ,
/* 15850 */	stmt    | 5261   << off_ ,	//	mov wb *offs1  offset is one (only reloc fld is 2)
/* 15851 */	loadi   | wb     << dst_ | offs1  << off_ ,
/* 15852 */	stmt    | 5262   << off_ ,	//	brn gpf05   all set
/* 15853 */	brn     | gpf05  << off_ ,
// gpf11:
/* 15854 */	stmt    | 5263   << off_ ,	//gpf11	mov wa *ffofs  set length
/* 15855 */	loadi   | wa     << dst_ | ffofs  << off_ ,
/* 15856 */	stmt    | 5264   << off_ ,	//	mov wb *ffnxt  set offset
/* 15857 */	loadi   | wb     << dst_ | ffnxt  << off_ ,
/* 15858 */	stmt    | 5265   << off_ ,	//	brn gpf05   all set
/* 15859 */	brn     | gpf05  << off_ ,
// gpf12:
/* 15860 */	stmt    | 5266   << off_ ,	//gpf12	mov wa *parm2  length (parm2 is non-relocatable)
/* 15861 */	loadi   | wa     << dst_ | parm2  << off_ ,
/* 15862 */	stmt    | 5267   << off_ ,	//	mov wb *pthen  set offset
/* 15863 */	loadi   | wb     << dst_ | pthen  << off_ ,
/* 15864 */	stmt    | 5268   << off_ ,	//	brn gpf05   all set
/* 15865 */	brn     | gpf05  << off_ ,
// gpf13:
/* 15866 */	stmt    | 5269   << off_ ,	//gpf13	mov xl pddfp(xr)  load ptr to dfblk
/* 15867 */	load    | xl     << dst_ | xr     << src_ | pddfp  << off_ ,
/* 15868 */	stmt    | 5270   << off_ ,	//	mov wa dfpdl(xl)  get pdblk length
/* 15869 */	load    | wa     << dst_ | xl     << src_ | dfpdl  << off_ ,
/* 15870 */	stmt    | 5271   << off_ ,	//	mov wb *pdfld  set offset
/* 15871 */	loadi   | wb     << dst_ | pdfld  << off_ ,
/* 15872 */	stmt    | 5272   << off_ ,	//	brn gpf05   all set
/* 15873 */	brn     | gpf05  << off_ ,
// gpf14:
/* 15874 */	stmt    | 5273   << off_ ,	//gpf14	mov wa *pfarg  length past last reloc
/* 15875 */	loadi   | wa     << dst_ | pfarg  << off_ ,
/* 15876 */	stmt    | 5274   << off_ ,	//	mov wb *pfcod  offset to first reloc
/* 15877 */	loadi   | wb     << dst_ | pfcod  << off_ ,
/* 15878 */	stmt    | 5275   << off_ ,	//	brn gpf05   all set
/* 15879 */	brn     | gpf05  << off_ ,
// gpf15:
/* 15880 */	stmt    | 5276   << off_ ,	//gpf15	mov wa *tesi_  set length
/* 15881 */	loadi   | wa     << dst_ | tesi_  << off_ ,
/* 15882 */	stmt    | 5277   << off_ ,	//	mov wb *tesub  and offset
/* 15883 */	loadi   | wb     << dst_ | tesub  << off_ ,
/* 15884 */	stmt    | 5278   << off_ ,	//	brn gpf05   all set
/* 15885 */	brn     | gpf05  << off_ ,
// gpf16:
/* 15886 */	stmt    | 5279   << off_ ,	//gpf16	mov wa *trsi_  set length
/* 15887 */	loadi   | wa     << dst_ | trsi_  << off_ ,
/* 15888 */	stmt    | 5280   << off_ ,	//	mov wb *trval  and offset
/* 15889 */	loadi   | wb     << dst_ | trval  << off_ ,
/* 15890 */	stmt    | 5281   << off_ ,	//	brn gpf05   all set
/* 15891 */	brn     | gpf05  << off_ ,
// gpf17:
/* 15892 */	stmt    | 5282   << off_ ,	//gpf17	mov wa exlen(xr)  load length
/* 15893 */	load    | wa     << dst_ | xr     << src_ | exlen  << off_ ,
/* 15894 */	stmt    | 5283   << off_ ,	//	mov wb *exflc  set offset
/* 15895 */	loadi   | wb     << dst_ | exflc  << off_ ,
/* 15896 */	stmt    | 5284   << off_ ,	//	brn gpf05   jump back
/* 15897 */	brn     | gpf05  << off_ ,
// gtarr:
/* 15898 */	stmt    | 5285   << off_ ,	//gtarr	prc e 2  entry point
/* 15899 */	stmt    | 5286   << off_ ,	//	mov gtawa wa  save wa indicator
/* 15900 */	store   | wa     << dst_ | gtawa  << off_ ,
/* 15901 */	stmt    | 5287   << off_ ,	//	mov wa (xr)  load type word
/* 15902 */	load    | wa     << dst_ | xr     << src_ ,
/* 15903 */	stmt    | 5288   << off_ ,	//	beq wa =b_art gtar8 exit if already an array
/* 15904 */	loadi   | r2     << dst_ | b_art  << off_ ,
/* 15905 */	beq     | wa     << dst_ | r2     << src_ | gtar8  << off_ ,
/* 15906 */	stmt    | 5289   << off_ ,	//	beq wa =b_vct gtar8 exit if already an array
/* 15907 */	loadi   | r2     << dst_ | b_vct  << off_ ,
/* 15908 */	beq     | wa     << dst_ | r2     << src_ | gtar8  << off_ ,
/* 15909 */	stmt    | 5290   << off_ ,	//	bne wa =b_tbt gta9a else fail if not a table (sgd02)
/* 15910 */	loadi   | r2     << dst_ | b_tbt  << off_ ,
/* 15911 */	bne     | wa     << dst_ | r2     << src_ | gta9a  << off_ ,
/* 15912 */	stmt    | 5291   << off_ ,	//	mov -(xs) xr  replace tbblk pointer on stack
/* 15913 */	dca     | xs     << dst_ ,
/* 15914 */	store   | xr     << dst_ | xs     << src_ ,
/* 15915 */	stmt    | 5292   << off_ ,	//	zer xr   signal first pass
/* 15916 */	move    | xr     << dst_ ,
/* 15917 */	stmt    | 5293   << off_ ,	//	zer wb   zero non-null element count
/* 15918 */	move    | wb     << dst_ ,
// gtar1:
/* 15919 */	stmt    | 5294   << off_ ,	//gtar1	mov xl (xs)  point to table
/* 15920 */	load    | xl     << dst_ | xs     << src_ ,
/* 15921 */	stmt    | 5295   << off_ ,	//	add xl tblen(xl)  point past last bucket
/* 15922 */	load    | r2     << dst_ | xl     << src_ | tblen  << off_ ,
/* 15923 */	add     | xl     << dst_ | r2     << src_ ,
/* 15924 */	stmt    | 5296   << off_ ,	//	sub xl *tbbuk  set first bucket offset
/* 15925 */	loadi   | r2     << dst_ | tbbuk  << off_ ,
/* 15926 */	sub     | xl     << dst_ | r2     << src_ ,
/* 15927 */	stmt    | 5297   << off_ ,	//	mov wa xl  copy adjusted pointer
/* 15928 */	move    | wa     << dst_ | xl     << src_ ,
// gtar2:
/* 15929 */	stmt    | 5298   << off_ ,	//gtar2	mov xl wa  copy bucket pointer
/* 15930 */	move    | xl     << dst_ | wa     << src_ ,
/* 15931 */	stmt    | 5299   << off_ ,	//	dca wa   decrement bucket pointer
/* 15932 */	dca     | wa     << dst_ ,
// gtar3:
/* 15933 */	stmt    | 5300   << off_ ,	//gtar3	mov xl tenxt(xl)  point to next teblk
/* 15934 */	load    | xl     << dst_ | xl     << src_ | tenxt  << off_ ,
/* 15935 */	stmt    | 5301   << off_ ,	//	beq xl (xs) gtar6 jump if chain end (tbblk ptr)
/* 15936 */	load    | r2     << dst_ | xs     << src_ ,
/* 15937 */	beq     | xl     << dst_ | r2     << src_ | gtar6  << off_ ,
/* 15938 */	stmt    | 5302   << off_ ,	//	mov cnvtp xl  else save teblk pointer
/* 15939 */	store   | xl     << dst_ | cnvtp  << off_ ,
// gtar4:
/* 15940 */	stmt    | 5303   << off_ ,	//gtar4	mov xl teval(xl)  load value
/* 15941 */	load    | xl     << dst_ | xl     << src_ | teval  << off_ ,
/* 15942 */	stmt    | 5304   << off_ ,	//	beq (xl) =b_trt gtar4 loop till value found
/* 15943 */	load    | r1     << dst_ | xl     << src_ ,
/* 15944 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 15945 */	beq     | r1     << dst_ | r2     << src_ | gtar4  << off_ ,
/* 15946 */	stmt    | 5305   << off_ ,	//	mov wc xl  copy value
/* 15947 */	move    | wc     << dst_ | xl     << src_ ,
/* 15948 */	stmt    | 5306   << off_ ,	//	mov xl cnvtp  restore teblk pointer
/* 15949 */	load    | xl     << dst_ | cnvtp  << off_ ,
/* 15950 */	stmt    | 5307   << off_ ,	//	beq wc =nulls gtar3 loop back to ignore null value
/* 15951 */	loadi   | r2     << dst_ | nulls  << off_ ,
/* 15952 */	beq     | wc     << dst_ | r2     << src_ | gtar3  << off_ ,
/* 15953 */	stmt    | 5308   << off_ ,	//	bnz xr gtar5  jump if second pass
/* 15954 */	bnz     | xr     << dst_ | gtar5  << off_ ,
/* 15955 */	stmt    | 5309   << off_ ,	//	icv wb   for the first pass, bump count
/* 15956 */	icv     | wb     << dst_ ,
/* 15957 */	stmt    | 5310   << off_ ,	//	brn gtar3   and loop back for next teblk
/* 15958 */	brn     | gtar3  << off_ ,
// gtar5:
/* 15959 */	stmt    | 5311   << off_ ,	//gtar5	bze gtawa gta5a  jump if address wanted
/* 15960 */	load    | r1     << dst_ | gtawa  << off_ ,
/* 15961 */	bze     | r1     << dst_ | gta5a  << off_ ,
/* 15962 */	stmt    | 5312   << off_ ,	//	mov (xr)+ tesub(xl)  store subscript name
/* 15963 */	load    | r1     << dst_ | xl     << src_ | tesub  << off_ ,
/* 15964 */	store   | r1     << dst_ | xr     << src_ ,
/* 15965 */	ica     | xr     << dst_ ,
/* 15966 */	stmt    | 5313   << off_ ,	//	mov (xr)+ wc  store value in arblk
/* 15967 */	store   | wc     << dst_ | xr     << src_ ,
/* 15968 */	ica     | xr     << dst_ ,
/* 15969 */	stmt    | 5314   << off_ ,	//	brn gtar3   loop back for next teblk
/* 15970 */	brn     | gtar3  << off_ ,
// gta5a:
/* 15971 */	stmt    | 5315   << off_ ,	//gta5a	mov (xr)+ xl  store teblk address in name
/* 15972 */	store   | xl     << dst_ | xr     << src_ ,
/* 15973 */	ica     | xr     << dst_ ,
/* 15974 */	stmt    | 5316   << off_ ,	//	mov (xr)+ xl  and value slots
/* 15975 */	store   | xl     << dst_ | xr     << src_ ,
/* 15976 */	ica     | xr     << dst_ ,
/* 15977 */	stmt    | 5317   << off_ ,	//	brn gtar3   loop back for next teblk
/* 15978 */	brn     | gtar3  << off_ ,
// gtar6:
/* 15979 */	stmt    | 5318   << off_ ,	//gtar6	bne wa (xs) gtar2 loop back if more buckets to go
/* 15980 */	load    | r2     << dst_ | xs     << src_ ,
/* 15981 */	bne     | wa     << dst_ | r2     << src_ | gtar2  << off_ ,
/* 15982 */	stmt    | 5319   << off_ ,	//	bnz xr gtar7  else jump if second pass
/* 15983 */	bnz     | xr     << dst_ | gtar7  << off_ ,
/* 15984 */	stmt    | 5320   << off_ ,	//	bze wb gtar9  fail if no non-null elements
/* 15985 */	bze     | wb     << dst_ | gtar9  << off_ ,
/* 15986 */	stmt    | 5321   << off_ ,	//	mov wa wb  else copy count
/* 15987 */	move    | wa     << dst_ | wb     << src_ ,
/* 15988 */	stmt    | 5322   << off_ ,	//	add wa wb  double (two words/element)
/* 15989 */	add     | wa     << dst_ | wb     << src_ ,
/* 15990 */	stmt    | 5323   << off_ ,	//	add wa =arvl2  add space for standard fields
/* 15991 */	loadi   | r2     << dst_ | arvl2  << off_ ,
/* 15992 */	add     | wa     << dst_ | r2     << src_ ,
/* 15993 */	stmt    | 5324   << off_ ,	//	wtb wa   convert length to bytes
/* 15994 */	stmt    | 5325   << off_ ,	//	bgt wa mxlen gta9b error if too long for array
/* 15995 */	load    | r2     << dst_ | mxlen  << off_ ,
/* 15996 */	bgt     | wa     << dst_ | r2     << src_ | gta9b  << off_ ,
/* 15997 */	stmt    | 5326   << off_ ,	//	jsr alloc   else allocate space for arblk
/* 15998 */	call    | alloc  << off_ ,
/* 15999 */	stmt    | 5327   << off_ ,	//	mov (xr) =b_art  store type word
/* 16000 */	loadi   | r1     << dst_ | b_art  << off_ ,
/* 16001 */	store   | r1     << dst_ | xr     << src_ ,
/* 16002 */	stmt    | 5328   << off_ ,	//	zer idval(xr)   zero id for the moment
/* 16003 */	store   | r0     << dst_ | xr     << src_ | idval  << off_ ,
/* 16004 */	stmt    | 5329   << off_ ,	//	mov arlen(xr) wa  store length
/* 16005 */	store   | wa     << dst_ | xr     << src_ | arlen  << off_ ,
/* 16006 */	stmt    | 5330   << off_ ,	//	mov arndm(xr) =num02  set dimensions = 2
/* 16007 */	loadi   | r1     << dst_ | num02  << off_ ,
/* 16008 */	store   | r1     << dst_ | xr     << src_ | arndm  << off_ ,
/* 16009 */	stmt    | 5331   << off_ ,	//	ldi 4,intv1   get integer one
/* 16010 */	load    | r1     << dst_ | intv1  << off_ ,
/* 16011 */	ldi     | r1     << dst_ ,
/* 16012 */	stmt    | 5332   << off_ ,	//	sti arlbd(xr)   store as lbd 1
/* 16013 */	store   | ia     << dst_ | xr     << src_ | arlbd  << off_ ,
/* 16014 */	stmt    | 5333   << off_ ,	//	sti arlb2(xr)   store as lbd 2
/* 16015 */	store   | ia     << dst_ | xr     << src_ | arlb2  << off_ ,
/* 16016 */	stmt    | 5334   << off_ ,	//	ldi 4,intv2   load integer two
/* 16017 */	load    | r1     << dst_ | intv2  << off_ ,
/* 16018 */	ldi     | r1     << dst_ ,
/* 16019 */	stmt    | 5335   << off_ ,	//	sti ardm2(xr)   store as dim 2
/* 16020 */	store   | ia     << dst_ | xr     << src_ | ardm2  << off_ ,
/* 16021 */	stmt    | 5336   << off_ ,	//	mti wb   get element count as integer
/* 16022 */	move    | ia     << dst_ | wb     << src_ ,
/* 16023 */	stmt    | 5337   << off_ ,	//	sti ardim(xr)   store as dim 1
/* 16024 */	store   | ia     << dst_ | xr     << src_ | ardim  << off_ ,
/* 16025 */	stmt    | 5338   << off_ ,	//	zer arpr2(xr)   zero prototype field for now
/* 16026 */	store   | r0     << dst_ | xr     << src_ | arpr2  << off_ ,
/* 16027 */	stmt    | 5339   << off_ ,	//	mov arofs(xr) *arpr2  set offset field (signal pass 2)
/* 16028 */	loadi   | r1     << dst_ | arpr2  << off_ ,
/* 16029 */	store   | r1     << dst_ | xr     << src_ | arofs  << off_ ,
/* 16030 */	stmt    | 5340   << off_ ,	//	mov wb xr  save arblk pointer
/* 16031 */	move    | wb     << dst_ | xr     << src_ ,
/* 16032 */	stmt    | 5341   << off_ ,	//	add xr *arvl2  point to first element location
/* 16033 */	loadi   | r2     << dst_ | arvl2  << off_ ,
/* 16034 */	add     | xr     << dst_ | r2     << src_ ,
/* 16035 */	stmt    | 5342   << off_ ,	//	brn gtar1   jump back to fill in elements
/* 16036 */	brn     | gtar1  << off_ ,
// gtar7:
/* 16037 */	stmt    | 5343   << off_ ,	//gtar7	mov xr wb  restore arblk pointer
/* 16038 */	move    | xr     << dst_ | wb     << src_ ,
/* 16039 */	stmt    | 5344   << off_ ,	//	mov (xs) wb  store as result
/* 16040 */	store   | wb     << dst_ | xs     << src_ ,
/* 16041 */	stmt    | 5345   << off_ ,	//	ldi ardim(xr)   get number of elements (nn)
/* 16042 */	load    | r1     << dst_ | xr     << src_ | ardim  << off_ ,
/* 16043 */	ldi     | r1     << dst_ ,
/* 16044 */	stmt    | 5346   << off_ ,	//	mli 4,intvh   multiply by 100
/* 16045 */	load    | r1     << dst_ | intvh  << off_ ,
/* 16046 */	mli     | r1     << dst_ ,
/* 16047 */	stmt    | 5347   << off_ ,	//	adi 4,intv2   add 2 (nn02)
/* 16048 */	load    | r1     << dst_ | intv2  << off_ ,
/* 16049 */	adi     | r1     << dst_ ,
/* 16050 */	stmt    | 5348   << off_ ,	//	jsr icbld   build integer
/* 16051 */	call    | icbld  << off_ ,
/* 16052 */	stmt    | 5349   << off_ ,	//	mov -(xs) xr  store ptr for gtstg
/* 16053 */	dca     | xs     << dst_ ,
/* 16054 */	store   | xr     << dst_ | xs     << src_ ,
/* 16055 */	stmt    | 5350   << off_ ,	//	jsr gtstg   convert to string
/* 16056 */	call    | gtstg  << off_ ,
/* 16057 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 16058 */	ppm     ,
/* 16059 */	stmt    | 5351   << off_ ,	//	mov xl xr  copy string pointer
/* 16060 */	move    | xl     << dst_ | xr     << src_ ,
/* 16061 */	stmt    | 5352   << off_ ,	//	mov xr (xs)+  reload arblk pointer
/* 16062 */	load    | xr     << dst_ | xs     << src_ ,
/* 16063 */	ica     | xs     << dst_ ,
/* 16064 */	stmt    | 5353   << off_ ,	//	mov arpr2(xr) xl  store prototype ptr (nn02)
/* 16065 */	store   | xl     << dst_ | xr     << src_ | arpr2  << off_ ,
/* 16066 */	stmt    | 5354   << off_ ,	//	sub wa =num02  adjust length to point to zero
/* 16067 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 16068 */	sub     | wa     << dst_ | r2     << src_ ,
/* 16069 */	stmt    | 5355   << off_ ,	//	psc xl wa  point to zero
/* 16070 */	psc     | xl     << dst_ | wa     << src_ ,
/* 16071 */	stmt    | 5356   << off_ ,	//	mov wb =ch_cm  load a comma
/* 16072 */	loadi   | wb     << dst_ | ch_cm  << off_ ,
/* 16073 */	stmt    | 5357   << off_ ,	//	sch wb (xl)  store a comma over the zero
/* 16074 */	store   | wb     << dst_ | xl     << src_ ,
/* 16075 */	stmt    | 5358   << off_ ,	//	csc xl   complete store characters
// gtar8:
/* 16076 */	stmt    | 5359   << off_ ,	//gtar8	exi    return to caller
/* 16077 */	exi     | 0      << off_ ,
// gtar9:
/* 16078 */	stmt    | 5360   << off_ ,	//gtar9	mov xr (xs)+  restore stack for conv err (sgd02)
/* 16079 */	load    | xr     << dst_ | xs     << src_ ,
/* 16080 */	ica     | xs     << dst_ ,
/* 16081 */	stmt    | 5361   << off_ ,	//	exi 1   return
/* 16082 */	exi     | 1      << off_ ,
// gta9a:
/* 16083 */	stmt    | 5362   << off_ ,	//gta9a	exi 2   return
/* 16084 */	exi     | 2      << off_ ,
// gta9b:
/* 16085 */	stmt    | 5363   << off_ ,	//gta9b	erb 260 conversion array size exceeds maximum permitted
/* 16086 */	erb     | 260    << off_ ,
// gtcod:
/* 16087 */	stmt    | 5364   << off_ ,	//gtcod	prc e 1  entry point
/* 16088 */	stmt    | 5365   << off_ ,	//	beq (xr) =b_cds gtcd1 jump if already code
/* 16089 */	load    | r1     << dst_ | xr     << src_ ,
/* 16090 */	loadi   | r2     << dst_ | b_cds  << off_ ,
/* 16091 */	beq     | r1     << dst_ | r2     << src_ | gtcd1  << off_ ,
/* 16092 */	stmt    | 5366   << off_ ,	//	beq (xr) =b_cdc gtcd1 jump if already code
/* 16093 */	load    | r1     << dst_ | xr     << src_ ,
/* 16094 */	loadi   | r2     << dst_ | b_cdc  << off_ ,
/* 16095 */	beq     | r1     << dst_ | r2     << src_ | gtcd1  << off_ ,
/* 16096 */	stmt    | 5367   << off_ ,	//	mov -(xs) xr  stack argument for gtstg
/* 16097 */	dca     | xs     << dst_ ,
/* 16098 */	store   | xr     << dst_ | xs     << src_ ,
/* 16099 */	stmt    | 5368   << off_ ,	//	jsr gtstg   convert argument to string
/* 16100 */	call    | gtstg  << off_ ,
/* 16101 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 16102 */	ppm     | gtcd2  << off_ ,
/* 16103 */	stmt    | 5369   << off_ ,	//	mov gtcef flptr  save fail ptr in case of error
/* 16104 */	load    | r1     << dst_ | flptr  << off_ ,
/* 16105 */	store   | r1     << dst_ | gtcef  << off_ ,
/* 16106 */	stmt    | 5370   << off_ ,	//	mov r_gtc r_cod  also save code ptr
/* 16107 */	load    | r1     << dst_ | r_cod  << off_ ,
/* 16108 */	store   | r1     << dst_ | r_gtc  << off_ ,
/* 16109 */	stmt    | 5371   << off_ ,	//	mov r_cim xr  else set image pointer
/* 16110 */	store   | xr     << dst_ | r_cim  << off_ ,
/* 16111 */	stmt    | 5372   << off_ ,	//	mov scnil wa  set image length
/* 16112 */	store   | wa     << dst_ | scnil  << off_ ,
/* 16113 */	stmt    | 5373   << off_ ,	//	zer scnpt   set scan pointer
/* 16114 */	store   | r0     << dst_ | scnpt  << off_ ,
/* 16115 */	stmt    | 5374   << off_ ,	//	mov stage =stgxc  set stage for execute compile
/* 16116 */	loadi   | r1     << dst_ | stgxc  << off_ ,
/* 16117 */	store   | r1     << dst_ | stage  << off_ ,
/* 16118 */	stmt    | 5375   << off_ ,	//	mov lstsn cmpsn  in case listr called
/* 16119 */	load    | r1     << dst_ | cmpsn  << off_ ,
/* 16120 */	store   | r1     << dst_ | lstsn  << off_ ,
/* 16121 */	stmt    | 5376   << off_ ,	//	icv cmpln   bump line number
/* 16122 */	load    | r1     << dst_ | cmpln  << off_ ,
/* 16123 */	icv     | r1     << dst_ ,
/* 16124 */	store   | r1     << dst_ | cmpln  << off_ ,
/* 16125 */	stmt    | 5377   << off_ ,	//	jsr cmpil   compile string
/* 16126 */	call    | cmpil  << off_ ,
/* 16127 */	stmt    | 5378   << off_ ,	//	mov stage =stgxt  reset stage for execute time
/* 16128 */	loadi   | r1     << dst_ | stgxt  << off_ ,
/* 16129 */	store   | r1     << dst_ | stage  << off_ ,
/* 16130 */	stmt    | 5379   << off_ ,	//	zer r_cim   clear image
/* 16131 */	store   | r0     << dst_ | r_cim  << off_ ,
// gtcd1:
/* 16132 */	stmt    | 5380   << off_ ,	//gtcd1	exi    give normal gtcod return
/* 16133 */	exi     | 0      << off_ ,
// gtcd2:
/* 16134 */	stmt    | 5381   << off_ ,	//gtcd2	exi 1   give error return
/* 16135 */	exi     | 1      << off_ ,
// gtexp:
/* 16136 */	stmt    | 5382   << off_ ,	//gtexp	prc e 1  entry point
/* 16137 */	stmt    | 5383   << off_ ,	//	blo (xr) =b_e__ gtex1 jump if already an expression
/* 16138 */	load    | r1     << dst_ | xr     << src_ ,
/* 16139 */	loadi   | r2     << dst_ | b_e__  << off_ ,
/* 16140 */	blo     | r1     << dst_ | r2     << src_ | gtex1  << off_ ,
/* 16141 */	stmt    | 5384   << off_ ,	//	mov -(xs) xr  store argument for gtstg
/* 16142 */	dca     | xs     << dst_ ,
/* 16143 */	store   | xr     << dst_ | xs     << src_ ,
/* 16144 */	stmt    | 5385   << off_ ,	//	jsr gtstg   convert argument to string
/* 16145 */	call    | gtstg  << off_ ,
/* 16146 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 16147 */	ppm     | gtex2  << off_ ,
/* 16148 */	stmt    | 5386   << off_ ,	//	mov xl xr  copy input string pointer
/* 16149 */	move    | xl     << dst_ | xr     << src_ ,
/* 16150 */	stmt    | 5387   << off_ ,	//	plc xl wa  point one past the string end
/* 16151 */	plc     | xl     << dst_ | wa     << src_ ,
/* 16152 */	stmt    | 5388   << off_ ,	//	lch xl -(xl)  fetch the last character
/* 16153 */	dca     | xl     << dst_ ,
/* 16154 */	load    | xl     << dst_ | xl     << src_ ,
/* 16155 */	stmt    | 5389   << off_ ,	//	beq xl =ch_cl gtex2 error if it is a semicolon
/* 16156 */	loadi   | r2     << dst_ | ch_cl  << off_ ,
/* 16157 */	beq     | xl     << dst_ | r2     << src_ | gtex2  << off_ ,
/* 16158 */	stmt    | 5390   << off_ ,	//	beq xl =ch_sm gtex2 or if it is a colon
/* 16159 */	loadi   | r2     << dst_ | ch_sm  << off_ ,
/* 16160 */	beq     | xl     << dst_ | r2     << src_ | gtex2  << off_ ,
/* 16161 */	stmt    | 5391   << off_ ,	//	mov r_cim xr  set input image pointer
/* 16162 */	store   | xr     << dst_ | r_cim  << off_ ,
/* 16163 */	stmt    | 5392   << off_ ,	//	zer scnpt   set scan pointer
/* 16164 */	store   | r0     << dst_ | scnpt  << off_ ,
/* 16165 */	stmt    | 5393   << off_ ,	//	mov scnil wa  set input image length
/* 16166 */	store   | wa     << dst_ | scnil  << off_ ,
/* 16167 */	stmt    | 5394   << off_ ,	//	mov -(xs) wb  save value/name flag
/* 16168 */	dca     | xs     << dst_ ,
/* 16169 */	store   | wb     << dst_ | xs     << src_ ,
/* 16170 */	stmt    | 5395   << off_ ,	//	zer wb   set code for normal scan
/* 16171 */	move    | wb     << dst_ ,
/* 16172 */	stmt    | 5396   << off_ ,	//	mov gtcef flptr  save fail ptr in case of error
/* 16173 */	load    | r1     << dst_ | flptr  << off_ ,
/* 16174 */	store   | r1     << dst_ | gtcef  << off_ ,
/* 16175 */	stmt    | 5397   << off_ ,	//	mov r_gtc r_cod  also save code ptr
/* 16176 */	load    | r1     << dst_ | r_cod  << off_ ,
/* 16177 */	store   | r1     << dst_ | r_gtc  << off_ ,
/* 16178 */	stmt    | 5398   << off_ ,	//	mov stage =stgev  adjust stage for compile
/* 16179 */	loadi   | r1     << dst_ | stgev  << off_ ,
/* 16180 */	store   | r1     << dst_ | stage  << off_ ,
/* 16181 */	stmt    | 5399   << off_ ,	//	mov scntp =t_uok  indicate unary operator acceptable
/* 16182 */	loadi   | r1     << dst_ | t_uok  << off_ ,
/* 16183 */	store   | r1     << dst_ | scntp  << off_ ,
/* 16184 */	stmt    | 5400   << off_ ,	//	jsr expan   build tree for expression
/* 16185 */	call    | expan  << off_ ,
/* 16186 */	stmt    | 5401   << off_ ,	//	zer scnrs   reset rescan flag
/* 16187 */	store   | r0     << dst_ | scnrs  << off_ ,
/* 16188 */	stmt    | 5402   << off_ ,	//	mov wa (xs)+  restore value/name flag
/* 16189 */	load    | wa     << dst_ | xs     << src_ ,
/* 16190 */	ica     | xs     << dst_ ,
/* 16191 */	stmt    | 5403   << off_ ,	//	bne scnpt scnil gtex2 error if not end of image
/* 16192 */	load    | r1     << dst_ | scnpt  << off_ ,
/* 16193 */	load    | r2     << dst_ | scnil  << off_ ,
/* 16194 */	bne     | r1     << dst_ | r2     << src_ | gtex2  << off_ ,
/* 16195 */	stmt    | 5404   << off_ ,	//	zer wb   set ok value for cdgex call
/* 16196 */	move    | wb     << dst_ ,
/* 16197 */	stmt    | 5405   << off_ ,	//	mov xl xr  copy tree pointer
/* 16198 */	move    | xl     << dst_ | xr     << src_ ,
/* 16199 */	stmt    | 5406   << off_ ,	//	jsr cdgex   build expression block
/* 16200 */	call    | cdgex  << off_ ,
/* 16201 */	stmt    | 5407   << off_ ,	//	zer r_cim   clear pointer
/* 16202 */	store   | r0     << dst_ | r_cim  << off_ ,
/* 16203 */	stmt    | 5408   << off_ ,	//	mov stage =stgxt  restore stage for execute time
/* 16204 */	loadi   | r1     << dst_ | stgxt  << off_ ,
/* 16205 */	store   | r1     << dst_ | stage  << off_ ,
// gtex1:
/* 16206 */	stmt    | 5409   << off_ ,	//gtex1	exi    return to gtexp caller
/* 16207 */	exi     | 0      << off_ ,
// gtex2:
/* 16208 */	stmt    | 5410   << off_ ,	//gtex2	exi 1   take error exit
/* 16209 */	exi     | 1      << off_ ,
// gtint:
/* 16210 */	stmt    | 5411   << off_ ,	//gtint	prc e 1  entry point
/* 16211 */	stmt    | 5412   << off_ ,	//	beq (xr) =b_icl gtin2 jump if already an integer
/* 16212 */	load    | r1     << dst_ | xr     << src_ ,
/* 16213 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/* 16214 */	beq     | r1     << dst_ | r2     << src_ | gtin2  << off_ ,
/* 16215 */	stmt    | 5413   << off_ ,	//	mov gtina wa  else save wa
/* 16216 */	store   | wa     << dst_ | gtina  << off_ ,
/* 16217 */	stmt    | 5414   << off_ ,	//	mov gtinb wb  save wb
/* 16218 */	store   | wb     << dst_ | gtinb  << off_ ,
/* 16219 */	stmt    | 5415   << off_ ,	//	jsr gtnum   convert to numeric
/* 16220 */	call    | gtnum  << off_ ,
/* 16221 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 16222 */	ppm     | gtin3  << off_ ,
/* 16223 */	stmt    | 5416   << off_ ,	//	beq wa =b_icl gtin1 jump if integer
/* 16224 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/* 16225 */	beq     | wa     << dst_ | r2     << src_ | gtin1  << off_ ,
/* 16226 */	stmt    | 5417   << off_ ,	//	ldr rcval(xr)   load real value
/* 16227 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/* 16228 */	ldr     | r1     << dst_ ,
/* 16229 */	stmt    | 5418   << off_ ,	//	rti gtin3   convert to integer (err if ovflow)
/* 16230 */	rti     | gtin3  << off_ ,
/* 16231 */	stmt    | 5419   << off_ ,	//	jsr icbld   if ok build icblk
/* 16232 */	call    | icbld  << off_ ,
// gtin1:
/* 16233 */	stmt    | 5420   << off_ ,	//gtin1	mov wa gtina  restore wa
/* 16234 */	load    | wa     << dst_ | gtina  << off_ ,
/* 16235 */	stmt    | 5421   << off_ ,	//	mov wb gtinb  restore wb
/* 16236 */	load    | wb     << dst_ | gtinb  << off_ ,
// gtin2:
/* 16237 */	stmt    | 5422   << off_ ,	//gtin2	exi    return to gtint caller
/* 16238 */	exi     | 0      << off_ ,
// gtin3:
/* 16239 */	stmt    | 5423   << off_ ,	//gtin3	exi 1   take convert error exit
/* 16240 */	exi     | 1      << off_ ,
// gtnum:
/* 16241 */	stmt    | 5424   << off_ ,	//gtnum	prc e 1  entry point
/* 16242 */	stmt    | 5425   << off_ ,	//	mov wa (xr)  load first word of block
/* 16243 */	load    | wa     << dst_ | xr     << src_ ,
/* 16244 */	stmt    | 5426   << off_ ,	//	beq wa =b_icl gtn34 jump if integer (no conversion)
/* 16245 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/* 16246 */	beq     | wa     << dst_ | r2     << src_ | gtn34  << off_ ,
/* 16247 */	stmt    | 5427   << off_ ,	//	beq wa =b_rcl gtn34 jump if real (no conversion)
/* 16248 */	loadi   | r2     << dst_ | b_rcl  << off_ ,
/* 16249 */	beq     | wa     << dst_ | r2     << src_ | gtn34  << off_ ,
/* 16250 */	stmt    | 5428   << off_ ,	//	mov -(xs) xr  stack argument in case convert err
/* 16251 */	dca     | xs     << dst_ ,
/* 16252 */	store   | xr     << dst_ | xs     << src_ ,
/* 16253 */	stmt    | 5429   << off_ ,	//	mov -(xs) xr  stack argument for gtstg
/* 16254 */	dca     | xs     << dst_ ,
/* 16255 */	store   | xr     << dst_ | xs     << src_ ,
/* 16256 */	stmt    | 5430   << off_ ,	//	jsr gtstg   convert argument to string
/* 16257 */	call    | gtstg  << off_ ,
/* 16258 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 16259 */	ppm     | gtn36  << off_ ,
/* 16260 */	stmt    | 5431   << off_ ,	//	ldi 4,intv0   initialize integer result to zero
/* 16261 */	load    | r1     << dst_ | intv0  << off_ ,
/* 16262 */	ldi     | r1     << dst_ ,
/* 16263 */	stmt    | 5432   << off_ ,	//	bze wa gtn32  jump to exit with zero if null
/* 16264 */	bze     | wa     << dst_ | gtn32  << off_ ,
/* 16265 */	stmt    | 5433   << off_ ,	//	lct wa wa  set bct counter for following loops
/* 16266 */	stmt    | 5434   << off_ ,	//	zer gtnnf   tentatively indicate result +
/* 16267 */	store   | r0     << dst_ | gtnnf  << off_ ,
/* 16268 */	stmt    | 5435   << off_ ,	//	sti gtnex   initialise exponent to zero
/* 16269 */	store   | ia     << dst_ | gtnex  << off_ ,
/* 16270 */	stmt    | 5436   << off_ ,	//	zer gtnsc   zero scale in case real
/* 16271 */	store   | r0     << dst_ | gtnsc  << off_ ,
/* 16272 */	stmt    | 5437   << off_ ,	//	zer gtndf   reset flag for dec point found
/* 16273 */	store   | r0     << dst_ | gtndf  << off_ ,
/* 16274 */	stmt    | 5438   << off_ ,	//	zer gtnrd   reset flag for digits found
/* 16275 */	store   | r0     << dst_ | gtnrd  << off_ ,
/* 16276 */	stmt    | 5439   << off_ ,	//	ldr 4,reav0   zero real accum in case real
/* 16277 */	load    | r1     << dst_ | reav0  << off_ ,
/* 16278 */	ldr     | r1     << dst_ ,
/* 16279 */	stmt    | 5440   << off_ ,	//	plc xr   point to argument characters
/* 16280 */	plc     | xr     << dst_ ,
// gtn01:
/* 16281 */	stmt    | 5441   << off_ ,	//gtn01	lch wb (xr)+  load first character
/* 16282 */	load    | wb     << dst_ | xr     << src_ ,
/* 16283 */	ica     | xr     << dst_ ,
/* 16284 */	stmt    | 5442   << off_ ,	//	blt wb =ch_d0 gtn02 jump if not digit
/* 16285 */	loadi   | r2     << dst_ | ch_d0  << off_ ,
/* 16286 */	blt     | wb     << dst_ | r2     << src_ | gtn02  << off_ ,
/* 16287 */	stmt    | 5443   << off_ ,	//	ble wb =ch_d9 gtn06 jump if first char is a digit
/* 16288 */	loadi   | r2     << dst_ | ch_d9  << off_ ,
/* 16289 */	ble     | wb     << dst_ | r2     << src_ | gtn06  << off_ ,
// gtn02:
/* 16290 */	stmt    | 5444   << off_ ,	//gtn02	bne wb =ch_bl gtn03 jump if non-blank
/* 16291 */	loadi   | r2     << dst_ | ch_bl  << off_ ,
/* 16292 */	bne     | wb     << dst_ | r2     << src_ | gtn03  << off_ ,
// gtna2:
/* 16293 */	stmt    | 5445   << off_ ,	//gtna2	bct wa gtn01  else decr count and loop back
/* 16294 */	bct     | wa     << dst_ | gtn01  << off_ ,
/* 16295 */	stmt    | 5446   << off_ ,	//	brn gtn07   jump to return zero if all blanks
/* 16296 */	brn     | gtn07  << off_ ,
// gtn03:
/* 16297 */	stmt    | 5447   << off_ ,	//gtn03	beq wb =ch_pl gtn04 jump if plus sign
/* 16298 */	loadi   | r2     << dst_ | ch_pl  << off_ ,
/* 16299 */	beq     | wb     << dst_ | r2     << src_ | gtn04  << off_ ,
/* 16300 */	stmt    | 5448   << off_ ,	//	beq wb =ch_ht gtna2 horizontal tab equiv to blank
/* 16301 */	loadi   | r2     << dst_ | ch_ht  << off_ ,
/* 16302 */	beq     | wb     << dst_ | r2     << src_ | gtna2  << off_ ,
/* 16303 */	stmt    | 5449   << off_ ,	//	bne wb =ch_mn gtn12 jump if not minus (may be real)
/* 16304 */	loadi   | r2     << dst_ | ch_mn  << off_ ,
/* 16305 */	bne     | wb     << dst_ | r2     << src_ | gtn12  << off_ ,
/* 16306 */	stmt    | 5450   << off_ ,	//	mnz gtnnf   if minus sign, set negative flag
/* 16307 */	store   | xs     << dst_ | gtnnf  << off_ ,
// gtn04:
/* 16308 */	stmt    | 5451   << off_ ,	//gtn04	bct wa gtn05  jump if chars left
/* 16309 */	bct     | wa     << dst_ | gtn05  << off_ ,
/* 16310 */	stmt    | 5452   << off_ ,	//	brn gtn36   else error
/* 16311 */	brn     | gtn36  << off_ ,
// gtn05:
/* 16312 */	stmt    | 5453   << off_ ,	//gtn05	lch wb (xr)+  load next character
/* 16313 */	load    | wb     << dst_ | xr     << src_ ,
/* 16314 */	ica     | xr     << dst_ ,
/* 16315 */	stmt    | 5454   << off_ ,	//	blt wb =ch_d0 gtn08 jump if not a digit
/* 16316 */	loadi   | r2     << dst_ | ch_d0  << off_ ,
/* 16317 */	blt     | wb     << dst_ | r2     << src_ | gtn08  << off_ ,
/* 16318 */	stmt    | 5455   << off_ ,	//	bgt wb =ch_d9 gtn08 jump if not a digit
/* 16319 */	loadi   | r2     << dst_ | ch_d9  << off_ ,
/* 16320 */	bgt     | wb     << dst_ | r2     << src_ | gtn08  << off_ ,
// gtn06:
/* 16321 */	stmt    | 5456   << off_ ,	//gtn06	sti gtnsi   save current value
/* 16322 */	store   | ia     << dst_ | gtnsi  << off_ ,
/* 16323 */	stmt    | 5457   << off_ ,	//	cvm gtn35   current*10-(new dig) jump if ovflow
/* 16324 */	cvm     | gtn35  << off_ ,
/* 16325 */	stmt    | 5458   << off_ ,	//	mnz gtnrd   set digit read flag
/* 16326 */	store   | xs     << dst_ | gtnrd  << off_ ,
/* 16327 */	stmt    | 5459   << off_ ,	//	bct wa gtn05  else loop back if more chars
/* 16328 */	bct     | wa     << dst_ | gtn05  << off_ ,
// gtn07:
/* 16329 */	stmt    | 5460   << off_ ,	//gtn07	bnz gtnnf gtn32  jump if negative (all set)
/* 16330 */	load    | r1     << dst_ | gtnnf  << off_ ,
/* 16331 */	bnz     | r1     << dst_ | gtn32  << off_ ,
/* 16332 */	stmt    | 5461   << off_ ,	//	ngi    else negate
/* 16333 */	ngi     ,
/* 16334 */	stmt    | 5462   << off_ ,	//	ino gtn32   jump if no overflow
/* 16335 */	ino     | gtn32  << off_ ,
/* 16336 */	stmt    | 5463   << off_ ,	//	brn gtn36   else signal error
/* 16337 */	brn     | gtn36  << off_ ,
// gtn08:
/* 16338 */	stmt    | 5464   << off_ ,	//gtn08	beq wb =ch_bl gtna9 jump if a blank
/* 16339 */	loadi   | r2     << dst_ | ch_bl  << off_ ,
/* 16340 */	beq     | wb     << dst_ | r2     << src_ | gtna9  << off_ ,
/* 16341 */	stmt    | 5465   << off_ ,	//	beq wb =ch_ht gtna9 jump if horizontal tab
/* 16342 */	loadi   | r2     << dst_ | ch_ht  << off_ ,
/* 16343 */	beq     | wb     << dst_ | r2     << src_ | gtna9  << off_ ,
/* 16344 */	stmt    | 5466   << off_ ,	//	itr    else convert integer to real
/* 16345 */	itr     ,
/* 16346 */	stmt    | 5467   << off_ ,	//	ngr    negate to get positive value
/* 16347 */	ngr     ,
/* 16348 */	stmt    | 5468   << off_ ,	//	brn gtn12   jump to try for real
/* 16349 */	brn     | gtn12  << off_ ,
// gtn09:
/* 16350 */	stmt    | 5469   << off_ ,	//gtn09	lch wb (xr)+  get next char
/* 16351 */	load    | wb     << dst_ | xr     << src_ ,
/* 16352 */	ica     | xr     << dst_ ,
/* 16353 */	stmt    | 5470   << off_ ,	//	beq wb =ch_ht gtna9 jump if horizontal tab
/* 16354 */	loadi   | r2     << dst_ | ch_ht  << off_ ,
/* 16355 */	beq     | wb     << dst_ | r2     << src_ | gtna9  << off_ ,
/* 16356 */	stmt    | 5471   << off_ ,	//	bne wb =ch_bl gtn36 error if non-blank
/* 16357 */	loadi   | r2     << dst_ | ch_bl  << off_ ,
/* 16358 */	bne     | wb     << dst_ | r2     << src_ | gtn36  << off_ ,
// gtna9:
/* 16359 */	stmt    | 5472   << off_ ,	//gtna9	bct wa gtn09  loop back if more chars to check
/* 16360 */	bct     | wa     << dst_ | gtn09  << off_ ,
/* 16361 */	stmt    | 5473   << off_ ,	//	brn gtn07   return integer if all blanks
/* 16362 */	brn     | gtn07  << off_ ,
// gtn10:
/* 16363 */	stmt    | 5474   << off_ ,	//gtn10	lch wb (xr)+  load next character
/* 16364 */	load    | wb     << dst_ | xr     << src_ ,
/* 16365 */	ica     | xr     << dst_ ,
/* 16366 */	stmt    | 5475   << off_ ,	//	blt wb =ch_d0 gtn12 jump if non-numeric
/* 16367 */	loadi   | r2     << dst_ | ch_d0  << off_ ,
/* 16368 */	blt     | wb     << dst_ | r2     << src_ | gtn12  << off_ ,
/* 16369 */	stmt    | 5476   << off_ ,	//	bgt wb =ch_d9 gtn12 jump if non-numeric
/* 16370 */	loadi   | r2     << dst_ | ch_d9  << off_ ,
/* 16371 */	bgt     | wb     << dst_ | r2     << src_ | gtn12  << off_ ,
// gtn11:
/* 16372 */	stmt    | 5477   << off_ ,	//gtn11	sub wb =ch_d0  convert digit to number
/* 16373 */	loadi   | r2     << dst_ | ch_d0  << off_ ,
/* 16374 */	sub     | wb     << dst_ | r2     << src_ ,
/* 16375 */	stmt    | 5478   << off_ ,	//	mlr 4,reavt   multiply real by 10.0
/* 16376 */	load    | r1     << dst_ | reavt  << off_ ,
/* 16377 */	mlr     | r1     << dst_ ,
/* 16378 */	stmt    | 5479   << off_ ,	//	rov gtn36   convert error if overflow
/* 16379 */	rov     | gtn36  << off_ ,
/* 16380 */	stmt    | 5480   << off_ ,	//	str gtnsr   save result
/* 16381 */	store   | ra     << dst_ | gtnsr  << off_ ,
/* 16382 */	stmt    | 5481   << off_ ,	//	mti wb   get new digit as integer
/* 16383 */	move    | ia     << dst_ | wb     << src_ ,
/* 16384 */	stmt    | 5482   << off_ ,	//	itr    convert new digit to real
/* 16385 */	itr     ,
/* 16386 */	stmt    | 5483   << off_ ,	//	adr gtnsr   add to get new total
/* 16387 */	load    | r1     << dst_ | gtnsr  << off_ ,
/* 16388 */	adr     | r1     << dst_ ,
/* 16389 */	stmt    | 5484   << off_ ,	//	add gtnsc gtndf  increment scale if after dec point
/* 16390 */	load    | r1     << dst_ | gtnsc  << off_ ,
/* 16391 */	load    | r2     << dst_ | gtndf  << off_ ,
/* 16392 */	add     | r1     << dst_ | r2     << src_ ,
/* 16393 */	store   | r1     << dst_ | gtnsc  << off_ ,
/* 16394 */	stmt    | 5485   << off_ ,	//	mnz gtnrd   set digit found flag
/* 16395 */	store   | xs     << dst_ | gtnrd  << off_ ,
/* 16396 */	stmt    | 5486   << off_ ,	//	bct wa gtn10  loop back if more chars
/* 16397 */	bct     | wa     << dst_ | gtn10  << off_ ,
/* 16398 */	stmt    | 5487   << off_ ,	//	brn gtn22   else jump to scale
/* 16399 */	brn     | gtn22  << off_ ,
// gtn12:
/* 16400 */	stmt    | 5488   << off_ ,	//gtn12	bne wb =ch_dt gtn13 jump if not dec point
/* 16401 */	loadi   | r2     << dst_ | ch_dt  << off_ ,
/* 16402 */	bne     | wb     << dst_ | r2     << src_ | gtn13  << off_ ,
/* 16403 */	stmt    | 5489   << off_ ,	//	bnz gtndf gtn36  if dec point, error if one already
/* 16404 */	load    | r1     << dst_ | gtndf  << off_ ,
/* 16405 */	bnz     | r1     << dst_ | gtn36  << off_ ,
/* 16406 */	stmt    | 5490   << off_ ,	//	mov gtndf =num01  else set flag for dec point
/* 16407 */	loadi   | r1     << dst_ | num01  << off_ ,
/* 16408 */	store   | r1     << dst_ | gtndf  << off_ ,
/* 16409 */	stmt    | 5491   << off_ ,	//	bct wa gtn10  loop back if more chars
/* 16410 */	bct     | wa     << dst_ | gtn10  << off_ ,
/* 16411 */	stmt    | 5492   << off_ ,	//	brn gtn22   else jump to scale
/* 16412 */	brn     | gtn22  << off_ ,
// gtn13:
/* 16413 */	stmt    | 5493   << off_ ,	//gtn13	beq wb =ch_le gtn15 jump if e for exponent
/* 16414 */	loadi   | r2     << dst_ | ch_le  << off_ ,
/* 16415 */	beq     | wb     << dst_ | r2     << src_ | gtn15  << off_ ,
/* 16416 */	stmt    | 5494   << off_ ,	//	beq wb =ch_ld gtn15 jump if d for exponent
/* 16417 */	loadi   | r2     << dst_ | ch_ld  << off_ ,
/* 16418 */	beq     | wb     << dst_ | r2     << src_ | gtn15  << off_ ,
// gtn14:
/* 16419 */	stmt    | 5495   << off_ ,	//gtn14	beq wb =ch_bl gtnb4 jump if blank
/* 16420 */	loadi   | r2     << dst_ | ch_bl  << off_ ,
/* 16421 */	beq     | wb     << dst_ | r2     << src_ | gtnb4  << off_ ,
/* 16422 */	stmt    | 5496   << off_ ,	//	beq wb =ch_ht gtnb4 jump if horizontal tab
/* 16423 */	loadi   | r2     << dst_ | ch_ht  << off_ ,
/* 16424 */	beq     | wb     << dst_ | r2     << src_ | gtnb4  << off_ ,
/* 16425 */	stmt    | 5497   << off_ ,	//	brn gtn36   error if non-blank
/* 16426 */	brn     | gtn36  << off_ ,
// gtnb4:
/* 16427 */	stmt    | 5498   << off_ ,	//gtnb4	lch wb (xr)+  get next character
/* 16428 */	load    | wb     << dst_ | xr     << src_ ,
/* 16429 */	ica     | xr     << dst_ ,
/* 16430 */	stmt    | 5499   << off_ ,	//	bct wa gtn14  loop back to check if more
/* 16431 */	bct     | wa     << dst_ | gtn14  << off_ ,
/* 16432 */	stmt    | 5500   << off_ ,	//	brn gtn22   else jump to scale
/* 16433 */	brn     | gtn22  << off_ ,
// gtn15:
/* 16434 */	stmt    | 5501   << off_ ,	//gtn15	zer gtnes   set exponent sign positive
/* 16435 */	store   | r0     << dst_ | gtnes  << off_ ,
/* 16436 */	stmt    | 5502   << off_ ,	//	ldi 4,intv0   initialize exponent to zero
/* 16437 */	load    | r1     << dst_ | intv0  << off_ ,
/* 16438 */	ldi     | r1     << dst_ ,
/* 16439 */	stmt    | 5503   << off_ ,	//	mnz gtndf   reset no dec point indication
/* 16440 */	store   | xs     << dst_ | gtndf  << off_ ,
/* 16441 */	stmt    | 5504   << off_ ,	//	bct wa gtn16  jump skipping past e or d
/* 16442 */	bct     | wa     << dst_ | gtn16  << off_ ,
/* 16443 */	stmt    | 5505   << off_ ,	//	brn gtn36   error if null exponent
/* 16444 */	brn     | gtn36  << off_ ,
// gtn16:
/* 16445 */	stmt    | 5506   << off_ ,	//gtn16	lch wb (xr)+  load first exponent character
/* 16446 */	load    | wb     << dst_ | xr     << src_ ,
/* 16447 */	ica     | xr     << dst_ ,
/* 16448 */	stmt    | 5507   << off_ ,	//	beq wb =ch_pl gtn17 jump if plus sign
/* 16449 */	loadi   | r2     << dst_ | ch_pl  << off_ ,
/* 16450 */	beq     | wb     << dst_ | r2     << src_ | gtn17  << off_ ,
/* 16451 */	stmt    | 5508   << off_ ,	//	bne wb =ch_mn gtn19 else jump if not minus sign
/* 16452 */	loadi   | r2     << dst_ | ch_mn  << off_ ,
/* 16453 */	bne     | wb     << dst_ | r2     << src_ | gtn19  << off_ ,
/* 16454 */	stmt    | 5509   << off_ ,	//	mnz gtnes   set sign negative if minus sign
/* 16455 */	store   | xs     << dst_ | gtnes  << off_ ,
// gtn17:
/* 16456 */	stmt    | 5510   << off_ ,	//gtn17	bct wa gtn18  jump if chars left
/* 16457 */	bct     | wa     << dst_ | gtn18  << off_ ,
/* 16458 */	stmt    | 5511   << off_ ,	//	brn gtn36   else error
/* 16459 */	brn     | gtn36  << off_ ,
// gtn18:
/* 16460 */	stmt    | 5512   << off_ ,	//gtn18	lch wb (xr)+  load next character
/* 16461 */	load    | wb     << dst_ | xr     << src_ ,
/* 16462 */	ica     | xr     << dst_ ,
// gtn19:
/* 16463 */	stmt    | 5513   << off_ ,	//gtn19	blt wb =ch_d0 gtn20 jump if not digit
/* 16464 */	loadi   | r2     << dst_ | ch_d0  << off_ ,
/* 16465 */	blt     | wb     << dst_ | r2     << src_ | gtn20  << off_ ,
/* 16466 */	stmt    | 5514   << off_ ,	//	bgt wb =ch_d9 gtn20 jump if not digit
/* 16467 */	loadi   | r2     << dst_ | ch_d9  << off_ ,
/* 16468 */	bgt     | wb     << dst_ | r2     << src_ | gtn20  << off_ ,
/* 16469 */	stmt    | 5515   << off_ ,	//	cvm gtn36   else current*10, subtract new digit
/* 16470 */	cvm     | gtn36  << off_ ,
/* 16471 */	stmt    | 5516   << off_ ,	//	bct wa gtn18  loop back if more chars
/* 16472 */	bct     | wa     << dst_ | gtn18  << off_ ,
/* 16473 */	stmt    | 5517   << off_ ,	//	brn gtn21   jump if exponent field is exhausted
/* 16474 */	brn     | gtn21  << off_ ,
// gtn20:
/* 16475 */	stmt    | 5518   << off_ ,	//gtn20	beq wb =ch_bl gtnc0 jump if blank
/* 16476 */	loadi   | r2     << dst_ | ch_bl  << off_ ,
/* 16477 */	beq     | wb     << dst_ | r2     << src_ | gtnc0  << off_ ,
/* 16478 */	stmt    | 5519   << off_ ,	//	beq wb =ch_ht gtnc0 jump if horizontal tab
/* 16479 */	loadi   | r2     << dst_ | ch_ht  << off_ ,
/* 16480 */	beq     | wb     << dst_ | r2     << src_ | gtnc0  << off_ ,
/* 16481 */	stmt    | 5520   << off_ ,	//	brn gtn36   error if non-blank
/* 16482 */	brn     | gtn36  << off_ ,
// gtnc0:
/* 16483 */	stmt    | 5521   << off_ ,	//gtnc0	lch wb (xr)+  get next character
/* 16484 */	load    | wb     << dst_ | xr     << src_ ,
/* 16485 */	ica     | xr     << dst_ ,
/* 16486 */	stmt    | 5522   << off_ ,	//	bct wa gtn20  loop back till all blanks scanned
/* 16487 */	bct     | wa     << dst_ | gtn20  << off_ ,
// gtn21:
/* 16488 */	stmt    | 5523   << off_ ,	//gtn21	sti gtnex   save collected exponent
/* 16489 */	store   | ia     << dst_ | gtnex  << off_ ,
/* 16490 */	stmt    | 5524   << off_ ,	//	bnz gtnes gtn22  jump if it was negative
/* 16491 */	load    | r1     << dst_ | gtnes  << off_ ,
/* 16492 */	bnz     | r1     << dst_ | gtn22  << off_ ,
/* 16493 */	stmt    | 5525   << off_ ,	//	ngi    else complement
/* 16494 */	ngi     ,
/* 16495 */	stmt    | 5526   << off_ ,	//	iov gtn36   error if overflow
/* 16496 */	iov     | gtn36  << off_ ,
/* 16497 */	stmt    | 5527   << off_ ,	//	sti gtnex   and store positive exponent
/* 16498 */	store   | ia     << dst_ | gtnex  << off_ ,
// gtn22:
/* 16499 */	stmt    | 5528   << off_ ,	//gtn22	bze gtnrd gtn36  error if not digits collected
/* 16500 */	load    | r1     << dst_ | gtnrd  << off_ ,
/* 16501 */	bze     | r1     << dst_ | gtn36  << off_ ,
/* 16502 */	stmt    | 5529   << off_ ,	//	bze gtndf gtn36  error if no exponent or dec point
/* 16503 */	load    | r1     << dst_ | gtndf  << off_ ,
/* 16504 */	bze     | r1     << dst_ | gtn36  << off_ ,
/* 16505 */	stmt    | 5530   << off_ ,	//	mti gtnsc   else load scale as integer
/* 16506 */	load    | ia     << dst_ | gtnsc  << off_ ,
/* 16507 */	stmt    | 5531   << off_ ,	//	sbi gtnex   subtract exponent
/* 16508 */	load    | r1     << dst_ | gtnex  << off_ ,
/* 16509 */	sbi     | r1     << dst_ ,
/* 16510 */	stmt    | 5532   << off_ ,	//	iov gtn36   error if overflow
/* 16511 */	iov     | gtn36  << off_ ,
/* 16512 */	stmt    | 5533   << off_ ,	//	ilt gtn26   jump if we must scale up
/* 16513 */	ilt     | gtn26  << off_ ,
/* 16514 */	stmt    | 5534   << off_ ,	//	mfi wa gtn36  load scale factor, err if ovflow
/* 16515 */	move    | wa     << dst_ | ia     << src_ ,
/* 16516 */	mfi     | gtn36  << off_ ,
// gtn23:
/* 16517 */	stmt    | 5535   << off_ ,	//gtn23	ble wa =num10 gtn24 jump if 10 or less to go
/* 16518 */	loadi   | r2     << dst_ | num10  << off_ ,
/* 16519 */	ble     | wa     << dst_ | r2     << src_ | gtn24  << off_ ,
/* 16520 */	stmt    | 5536   << off_ ,	//	dvr 4,reatt   else divide by 10**10
/* 16521 */	load    | r1     << dst_ | reatt  << off_ ,
/* 16522 */	dvr     | r1     << dst_ ,
/* 16523 */	stmt    | 5537   << off_ ,	//	sub wa =num10  decrement scale
/* 16524 */	loadi   | r2     << dst_ | num10  << off_ ,
/* 16525 */	sub     | wa     << dst_ | r2     << src_ ,
/* 16526 */	stmt    | 5538   << off_ ,	//	brn gtn23   and loop back
/* 16527 */	brn     | gtn23  << off_ ,
// gtn24:
/* 16528 */	stmt    | 5539   << off_ ,	//gtn24	bze wa gtn30  jump if scaled
/* 16529 */	bze     | wa     << dst_ | gtn30  << off_ ,
/* 16530 */	stmt    | 5540   << off_ ,	//	lct wb =cfp_r  else get indexing factor
/* 16531 */	loadi   | wb     << dst_ | cfp_r  << off_ ,
/* 16532 */	stmt    | 5541   << off_ ,	//	mov xr =reav1  point to powers of ten table
/* 16533 */	loadi   | xr     << dst_ | reav1  << off_ ,
/* 16534 */	stmt    | 5542   << off_ ,	//	wtb wa   convert remaining scale to byte ofs
// gtn25:
/* 16535 */	stmt    | 5543   << off_ ,	//gtn25	add xr wa  bump pointer
/* 16536 */	add     | xr     << dst_ | wa     << src_ ,
/* 16537 */	stmt    | 5544   << off_ ,	//	bct wb gtn25  once for each value word
/* 16538 */	bct     | wb     << dst_ | gtn25  << off_ ,
/* 16539 */	stmt    | 5545   << off_ ,	//	dvr (xr)   scale down as required
/* 16540 */	load    | r1     << dst_ | xr     << src_ ,
/* 16541 */	dvr     | r1     << dst_ ,
/* 16542 */	stmt    | 5546   << off_ ,	//	brn gtn30   and jump
/* 16543 */	brn     | gtn30  << off_ ,
// gtn26:
/* 16544 */	stmt    | 5547   << off_ ,	//gtn26	ngi    get absolute value of exponent
/* 16545 */	ngi     ,
/* 16546 */	stmt    | 5548   << off_ ,	//	iov gtn36   error if overflow
/* 16547 */	iov     | gtn36  << off_ ,
/* 16548 */	stmt    | 5549   << off_ ,	//	mfi wa gtn36  acquire scale, error if ovflow
/* 16549 */	move    | wa     << dst_ | ia     << src_ ,
/* 16550 */	mfi     | gtn36  << off_ ,
// gtn27:
/* 16551 */	stmt    | 5550   << off_ ,	//gtn27	ble wa =num10 gtn28 jump if 10 or less to go
/* 16552 */	loadi   | r2     << dst_ | num10  << off_ ,
/* 16553 */	ble     | wa     << dst_ | r2     << src_ | gtn28  << off_ ,
/* 16554 */	stmt    | 5551   << off_ ,	//	mlr 4,reatt   else multiply by 10**10
/* 16555 */	load    | r1     << dst_ | reatt  << off_ ,
/* 16556 */	mlr     | r1     << dst_ ,
/* 16557 */	stmt    | 5552   << off_ ,	//	rov gtn36   error if overflow
/* 16558 */	rov     | gtn36  << off_ ,
/* 16559 */	stmt    | 5553   << off_ ,	//	sub wa =num10  else decrement scale
/* 16560 */	loadi   | r2     << dst_ | num10  << off_ ,
/* 16561 */	sub     | wa     << dst_ | r2     << src_ ,
/* 16562 */	stmt    | 5554   << off_ ,	//	brn gtn27   and loop back
/* 16563 */	brn     | gtn27  << off_ ,
// gtn28:
/* 16564 */	stmt    | 5555   << off_ ,	//gtn28	bze wa gtn30  jump if scaled
/* 16565 */	bze     | wa     << dst_ | gtn30  << off_ ,
/* 16566 */	stmt    | 5556   << off_ ,	//	lct wb =cfp_r  else get indexing factor
/* 16567 */	loadi   | wb     << dst_ | cfp_r  << off_ ,
/* 16568 */	stmt    | 5557   << off_ ,	//	mov xr =reav1  point to powers of ten table
/* 16569 */	loadi   | xr     << dst_ | reav1  << off_ ,
/* 16570 */	stmt    | 5558   << off_ ,	//	wtb wa   convert remaining scale to byte ofs
// gtn29:
/* 16571 */	stmt    | 5559   << off_ ,	//gtn29	add xr wa  bump pointer
/* 16572 */	add     | xr     << dst_ | wa     << src_ ,
/* 16573 */	stmt    | 5560   << off_ ,	//	bct wb gtn29  once for each word in value
/* 16574 */	bct     | wb     << dst_ | gtn29  << off_ ,
/* 16575 */	stmt    | 5561   << off_ ,	//	mlr (xr)   scale up
/* 16576 */	load    | r1     << dst_ | xr     << src_ ,
/* 16577 */	mlr     | r1     << dst_ ,
/* 16578 */	stmt    | 5562   << off_ ,	//	rov gtn36   error if overflow
/* 16579 */	rov     | gtn36  << off_ ,
// gtn30:
/* 16580 */	stmt    | 5563   << off_ ,	//gtn30	bze gtnnf gtn31  jump if positive
/* 16581 */	load    | r1     << dst_ | gtnnf  << off_ ,
/* 16582 */	bze     | r1     << dst_ | gtn31  << off_ ,
/* 16583 */	stmt    | 5564   << off_ ,	//	ngr    else negate
/* 16584 */	ngr     ,
// gtn31:
/* 16585 */	stmt    | 5565   << off_ ,	//gtn31	jsr rcbld   build real block
/* 16586 */	call    | rcbld  << off_ ,
/* 16587 */	stmt    | 5566   << off_ ,	//	brn gtn33   merge to exit
/* 16588 */	brn     | gtn33  << off_ ,
// gtn32:
/* 16589 */	stmt    | 5567   << off_ ,	//gtn32	jsr icbld   build icblk
/* 16590 */	call    | icbld  << off_ ,
// gtn33:
/* 16591 */	stmt    | 5568   << off_ ,	//gtn33	mov wa (xr)  load first word of result block
/* 16592 */	load    | wa     << dst_ | xr     << src_ ,
/* 16593 */	stmt    | 5569   << off_ ,	//	ica xs   pop argument off stack
/* 16594 */	ica     | xs     << dst_ ,
// gtn34:
/* 16595 */	stmt    | 5570   << off_ ,	//gtn34	exi    return to gtnum caller
/* 16596 */	exi     | 0      << off_ ,
// gtn35:
/* 16597 */	stmt    | 5571   << off_ ,	//gtn35	lch wb -(xr)  reload current character
/* 16598 */	dca     | xr     << dst_ ,
/* 16599 */	load    | wb     << dst_ | xr     << src_ ,
/* 16600 */	stmt    | 5572   << off_ ,	//	lch wb (xr)+  bump character pointer
/* 16601 */	load    | wb     << dst_ | xr     << src_ ,
/* 16602 */	ica     | xr     << dst_ ,
/* 16603 */	stmt    | 5573   << off_ ,	//	ldi gtnsi   reload integer so far
/* 16604 */	load    | r1     << dst_ | gtnsi  << off_ ,
/* 16605 */	ldi     | r1     << dst_ ,
/* 16606 */	stmt    | 5574   << off_ ,	//	itr    convert to real
/* 16607 */	itr     ,
/* 16608 */	stmt    | 5575   << off_ ,	//	ngr    make value positive
/* 16609 */	ngr     ,
/* 16610 */	stmt    | 5576   << off_ ,	//	brn gtn11   merge with real circuit
/* 16611 */	brn     | gtn11  << off_ ,
// gtn36:
/* 16612 */	stmt    | 5577   << off_ ,	//gtn36	mov xr (xs)+  reload original argument
/* 16613 */	load    | xr     << dst_ | xs     << src_ ,
/* 16614 */	ica     | xs     << dst_ ,
/* 16615 */	stmt    | 5578   << off_ ,	//	exi 1   take convert-error exit
/* 16616 */	exi     | 1      << off_ ,
// gtnvr:
/* 16617 */	stmt    | 5579   << off_ ,	//gtnvr	prc e 1  entry point
/* 16618 */	stmt    | 5580   << off_ ,	//	bne (xr) =b_nml gnv02 jump if not name
/* 16619 */	load    | r1     << dst_ | xr     << src_ ,
/* 16620 */	loadi   | r2     << dst_ | b_nml  << off_ ,
/* 16621 */	bne     | r1     << dst_ | r2     << src_ | gnv02  << off_ ,
/* 16622 */	stmt    | 5581   << off_ ,	//	mov xr nmbas(xr)  else load name base if name
/* 16623 */	load    | xr     << dst_ | xr     << src_ | nmbas  << off_ ,
/* 16624 */	stmt    | 5582   << off_ ,	//	blo xr state gnv07 skip if vrblk (in static region)
/* 16625 */	load    | r2     << dst_ | state  << off_ ,
/* 16626 */	blo     | xr     << dst_ | r2     << src_ | gnv07  << off_ ,
// gnv01:
/* 16627 */	stmt    | 5583   << off_ ,	//gnv01	exi 1   take convert-error exit
/* 16628 */	exi     | 1      << off_ ,
// gnv02:
/* 16629 */	stmt    | 5584   << off_ ,	//gnv02	mov gnvsa wa  save wa
/* 16630 */	store   | wa     << dst_ | gnvsa  << off_ ,
/* 16631 */	stmt    | 5585   << off_ ,	//	mov gnvsb wb  save wb
/* 16632 */	store   | wb     << dst_ | gnvsb  << off_ ,
/* 16633 */	stmt    | 5586   << off_ ,	//	mov -(xs) xr  stack argument for gtstg
/* 16634 */	dca     | xs     << dst_ ,
/* 16635 */	store   | xr     << dst_ | xs     << src_ ,
/* 16636 */	stmt    | 5587   << off_ ,	//	jsr gtstg   convert argument to string
/* 16637 */	call    | gtstg  << off_ ,
/* 16638 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 16639 */	ppm     | gnv01  << off_ ,
/* 16640 */	stmt    | 5588   << off_ ,	//	bze wa gnv01  null string is an error
/* 16641 */	bze     | wa     << dst_ | gnv01  << off_ ,
/* 16642 */	stmt    | 5589   << off_ ,	//	mov -(xs) xl  save xl
/* 16643 */	dca     | xs     << dst_ ,
/* 16644 */	store   | xl     << dst_ | xs     << src_ ,
/* 16645 */	stmt    | 5590   << off_ ,	//	mov -(xs) xr  stack string ptr for later
/* 16646 */	dca     | xs     << dst_ ,
/* 16647 */	store   | xr     << dst_ | xs     << src_ ,
/* 16648 */	stmt    | 5591   << off_ ,	//	mov wb xr  copy string pointer
/* 16649 */	move    | wb     << dst_ | xr     << src_ ,
/* 16650 */	stmt    | 5592   << off_ ,	//	add wb *schar  point to characters of string
/* 16651 */	loadi   | r2     << dst_ | schar  << off_ ,
/* 16652 */	add     | wb     << dst_ | r2     << src_ ,
/* 16653 */	stmt    | 5593   << off_ ,	//	mov gnvst wb  save pointer to characters
/* 16654 */	store   | wb     << dst_ | gnvst  << off_ ,
/* 16655 */	stmt    | 5594   << off_ ,	//	mov wb wa  copy length
/* 16656 */	move    | wb     << dst_ | wa     << src_ ,
/* 16657 */	stmt    | 5595   << off_ ,	//	ctw wb 0  get number of words in name
/* 16658 */	stmt    | 5596   << off_ ,	//	mov gnvnw wb  save for later
/* 16659 */	store   | wb     << dst_ | gnvnw  << off_ ,
/* 16660 */	stmt    | 5597   << off_ ,	//	jsr hashs   compute hash index for string
/* 16661 */	call    | hashs  << off_ ,
/* 16662 */	stmt    | 5598   << off_ ,	//	rmi hshnb   compute hash offset by taking mod
/* 16663 */	load    | r1     << dst_ | hshnb  << off_ ,
/* 16664 */	rmi     | r1     << dst_ ,
/* 16665 */	stmt    | 5599   << off_ ,	//	mfi wc   get as offset
/* 16666 */	move    | wc     << dst_ | ia     << src_ ,
/* 16667 */	stmt    | 5600   << off_ ,	//	wtb wc   convert offset to bytes
/* 16668 */	stmt    | 5601   << off_ ,	//	add wc hshtb  point to proper hash chain
/* 16669 */	load    | r2     << dst_ | hshtb  << off_ ,
/* 16670 */	add     | wc     << dst_ | r2     << src_ ,
/* 16671 */	stmt    | 5602   << off_ ,	//	sub wc *vrnxt  subtract offset to merge into loop
/* 16672 */	loadi   | r2     << dst_ | vrnxt  << off_ ,
/* 16673 */	sub     | wc     << dst_ | r2     << src_ ,
// gnv03:
/* 16674 */	stmt    | 5603   << off_ ,	//gnv03	mov xl wc  copy hash chain pointer
/* 16675 */	move    | xl     << dst_ | wc     << src_ ,
/* 16676 */	stmt    | 5604   << off_ ,	//	mov xl vrnxt(xl)  point to next vrblk on chain
/* 16677 */	load    | xl     << dst_ | xl     << src_ | vrnxt  << off_ ,
/* 16678 */	stmt    | 5605   << off_ ,	//	bze xl gnv08  jump if end of chain
/* 16679 */	bze     | xl     << dst_ | gnv08  << off_ ,
/* 16680 */	stmt    | 5606   << off_ ,	//	mov wc xl  save pointer to this vrblk
/* 16681 */	move    | wc     << dst_ | xl     << src_ ,
/* 16682 */	stmt    | 5607   << off_ ,	//	bnz vrlen(xl) gnv04  jump if not system variable
/* 16683 */	load    | r1     << dst_ | xl     << src_ | vrlen  << off_ ,
/* 16684 */	bnz     | r1     << dst_ | gnv04  << off_ ,
/* 16685 */	stmt    | 5608   << off_ ,	//	mov xl vrsvp(xl)  else point to svblk
/* 16686 */	load    | xl     << dst_ | xl     << src_ | vrsvp  << off_ ,
/* 16687 */	stmt    | 5609   << off_ ,	//	sub xl *vrsof  adjust offset for merge
/* 16688 */	loadi   | r2     << dst_ | vrsof  << off_ ,
/* 16689 */	sub     | xl     << dst_ | r2     << src_ ,
// gnv04:
/* 16690 */	stmt    | 5610   << off_ ,	//gnv04	bne wa vrlen(xl) gnv03 back for next vrblk if lengths ne
/* 16691 */	load    | r2     << dst_ | xl     << src_ | vrlen  << off_ ,
/* 16692 */	bne     | wa     << dst_ | r2     << src_ | gnv03  << off_ ,
/* 16693 */	stmt    | 5611   << off_ ,	//	add xl *vrchs  else point to chars of chain entry
/* 16694 */	loadi   | r2     << dst_ | vrchs  << off_ ,
/* 16695 */	add     | xl     << dst_ | r2     << src_ ,
/* 16696 */	stmt    | 5612   << off_ ,	//	lct wb gnvnw  get word counter to control loop
/* 16697 */	load    | wb     << dst_ | gnvnw  << off_ ,
/* 16698 */	stmt    | 5613   << off_ ,	//	mov xr gnvst  point to chars of new name
/* 16699 */	load    | xr     << dst_ | gnvst  << off_ ,
// gnv05:
/* 16700 */	stmt    | 5614   << off_ ,	//gnv05	cne (xr) (xl) gnv03 jump if no match for next vrblk
/* 16701 */	load    | r1     << dst_ | xr     << src_ ,
/* 16702 */	load    | r2     << dst_ | xl     << src_ ,
/* 16703 */	cne     | r1     << dst_ | r2     << src_ | gnv03  << off_ ,
/* 16704 */	stmt    | 5615   << off_ ,	//	ica xr   bump new name pointer
/* 16705 */	ica     | xr     << dst_ ,
/* 16706 */	stmt    | 5616   << off_ ,	//	ica xl   bump vrblk in chain name pointer
/* 16707 */	ica     | xl     << dst_ ,
/* 16708 */	stmt    | 5617   << off_ ,	//	bct wb gnv05  else loop till all compared
/* 16709 */	bct     | wb     << dst_ | gnv05  << off_ ,
/* 16710 */	stmt    | 5618   << off_ ,	//	mov xr wc  we have found a match, get vrblk
/* 16711 */	move    | xr     << dst_ | wc     << src_ ,
// gnv06:
/* 16712 */	stmt    | 5619   << off_ ,	//gnv06	mov wa gnvsa  restore wa
/* 16713 */	load    | wa     << dst_ | gnvsa  << off_ ,
/* 16714 */	stmt    | 5620   << off_ ,	//	mov wb gnvsb  restore wb
/* 16715 */	load    | wb     << dst_ | gnvsb  << off_ ,
/* 16716 */	stmt    | 5621   << off_ ,	//	ica xs   pop string pointer
/* 16717 */	ica     | xs     << dst_ ,
/* 16718 */	stmt    | 5622   << off_ ,	//	mov xl (xs)+  restore xl
/* 16719 */	load    | xl     << dst_ | xs     << src_ ,
/* 16720 */	ica     | xs     << dst_ ,
// gnv07:
/* 16721 */	stmt    | 5623   << off_ ,	//gnv07	exi    return to gtnvr caller
/* 16722 */	exi     | 0      << off_ ,
// gnv08:
/* 16723 */	stmt    | 5624   << off_ ,	//gnv08	zer xr   clear garbage xr pointer
/* 16724 */	move    | xr     << dst_ ,
/* 16725 */	stmt    | 5625   << off_ ,	//	mov gnvhe wc  save ptr to end of hash chain
/* 16726 */	store   | wc     << dst_ | gnvhe  << off_ ,
/* 16727 */	stmt    | 5626   << off_ ,	//	bgt wa =num09 gnv14 cannot be system var if length gt 9
/* 16728 */	loadi   | r2     << dst_ | num09  << off_ ,
/* 16729 */	bgt     | wa     << dst_ | r2     << src_ | gnv14  << off_ ,
/* 16730 */	stmt    | 5627   << off_ ,	//	mov xl wa  else copy length
/* 16731 */	move    | xl     << dst_ | wa     << src_ ,
/* 16732 */	stmt    | 5628   << off_ ,	//	wtb xl   convert to byte offset
/* 16733 */	stmt    | 5629   << off_ ,	//	mov xl 14,vsrch(xl)  point to first svblk of this length
/* 16734 */	load    | xl     << dst_ | xl     << src_ | vsrch  << off_ ,
// gnv09:
/* 16735 */	stmt    | 5630   << off_ ,	//gnv09	mov gnvsp xl  save table pointer
/* 16736 */	store   | xl     << dst_ | gnvsp  << off_ ,
/* 16737 */	stmt    | 5631   << off_ ,	//	mov wc (xl)+  load svbit bit string
/* 16738 */	load    | wc     << dst_ | xl     << src_ ,
/* 16739 */	ica     | xl     << dst_ ,
/* 16740 */	stmt    | 5632   << off_ ,	//	mov wb (xl)+  load length from table entry
/* 16741 */	load    | wb     << dst_ | xl     << src_ ,
/* 16742 */	ica     | xl     << dst_ ,
/* 16743 */	stmt    | 5633   << off_ ,	//	bne wa wb gnv14 jump if end of right length entries
/* 16744 */	bne     | wa     << dst_ | wb     << src_ | gnv14  << off_ ,
/* 16745 */	stmt    | 5634   << off_ ,	//	lct wb gnvnw  get word counter to control loop
/* 16746 */	load    | wb     << dst_ | gnvnw  << off_ ,
/* 16747 */	stmt    | 5635   << off_ ,	//	mov xr gnvst  point to chars of new name
/* 16748 */	load    | xr     << dst_ | gnvst  << off_ ,
// gnv10:
/* 16749 */	stmt    | 5636   << off_ ,	//gnv10	cne (xr) (xl) gnv11 jump if name mismatch
/* 16750 */	load    | r1     << dst_ | xr     << src_ ,
/* 16751 */	load    | r2     << dst_ | xl     << src_ ,
/* 16752 */	cne     | r1     << dst_ | r2     << src_ | gnv11  << off_ ,
/* 16753 */	stmt    | 5637   << off_ ,	//	ica xr   else bump new name pointer
/* 16754 */	ica     | xr     << dst_ ,
/* 16755 */	stmt    | 5638   << off_ ,	//	ica xl   bump svblk pointer
/* 16756 */	ica     | xl     << dst_ ,
/* 16757 */	stmt    | 5639   << off_ ,	//	bct wb gnv10  else loop until all checked
/* 16758 */	bct     | wb     << dst_ | gnv10  << off_ ,
/* 16759 */	stmt    | 5640   << off_ ,	//	zer wc   set vrlen value zero
/* 16760 */	move    | wc     << dst_ ,
/* 16761 */	stmt    | 5641   << off_ ,	//	mov wa *vrsi_  set standard size
/* 16762 */	loadi   | wa     << dst_ | vrsi_  << off_ ,
/* 16763 */	stmt    | 5642   << off_ ,	//	brn gnv15   jump to build vrblk
/* 16764 */	brn     | gnv15  << off_ ,
// gnv11:
/* 16765 */	stmt    | 5643   << off_ ,	//gnv11	ica xl   bump past word of chars
/* 16766 */	ica     | xl     << dst_ ,
/* 16767 */	stmt    | 5644   << off_ ,	//	bct wb gnv11  loop back if more to go
/* 16768 */	bct     | wb     << dst_ | gnv11  << off_ ,
/* 16769 */	stmt    | 5645   << off_ ,	//	rsh wc svnbt  remove uninteresting bits
/* 16770 */	rsh     | wc     << dst_ | svnbt  << off_ ,
// gnv12:
/* 16771 */	stmt    | 5646   << off_ ,	//gnv12	mov wb 4,bits1  load bit to test
/* 16772 */	load    | wb     << dst_ | bits1  << off_ ,
/* 16773 */	stmt    | 5647   << off_ ,	//	anb wb wc  test for word present
/* 16774 */	anb     | wb     << dst_ | wc     << src_ ,
/* 16775 */	stmt    | 5648   << off_ ,	//	zrb wb gnv13  jump if not present
/* 16776 */	zrb     | wb     << dst_ | gnv13  << off_ ,
/* 16777 */	stmt    | 5649   << off_ ,	//	ica xl   else bump table pointer
/* 16778 */	ica     | xl     << dst_ ,
// gnv13:
/* 16779 */	stmt    | 5650   << off_ ,	//gnv13	rsh wc 1  remove bit already processed
/* 16780 */	rsh     | wc     << dst_ | 1      << off_ ,
/* 16781 */	stmt    | 5651   << off_ ,	//	nzb wc gnv12  loop back if more bits to test
/* 16782 */	nzb     | wc     << dst_ | gnv12  << off_ ,
/* 16783 */	stmt    | 5652   << off_ ,	//	brn gnv09   else loop back for next svblk
/* 16784 */	brn     | gnv09  << off_ ,
// gnv14:
/* 16785 */	stmt    | 5653   << off_ ,	//gnv14	mov wc wa  copy vrlen value
/* 16786 */	move    | wc     << dst_ | wa     << src_ ,
/* 16787 */	stmt    | 5654   << off_ ,	//	mov wa =vrchs  load standard size -chars
/* 16788 */	loadi   | wa     << dst_ | vrchs  << off_ ,
/* 16789 */	stmt    | 5655   << off_ ,	//	add wa gnvnw  adjust for chars of name
/* 16790 */	load    | r2     << dst_ | gnvnw  << off_ ,
/* 16791 */	add     | wa     << dst_ | r2     << src_ ,
/* 16792 */	stmt    | 5656   << off_ ,	//	wtb wa   convert length to bytes
// gnv15:
/* 16793 */	stmt    | 5657   << off_ ,	//gnv15	jsr alost   allocate space for vrblk (static)
/* 16794 */	call    | alost  << off_ ,
/* 16795 */	stmt    | 5658   << off_ ,	//	mov wb xr  save vrblk pointer
/* 16796 */	move    | wb     << dst_ | xr     << src_ ,
/* 16797 */	stmt    | 5659   << off_ ,	//	mov xl =stnvr  point to model variable block
/* 16798 */	loadi   | xl     << dst_ | stnvr  << off_ ,
/* 16799 */	stmt    | 5660   << off_ ,	//	mov wa *vrlen  set length of standard fields
/* 16800 */	loadi   | wa     << dst_ | vrlen  << off_ ,
/* 16801 */	stmt    | 5661   << off_ ,	//	mvw    set initial fields of new block
/* 16802 */	mvw     ,
/* 16803 */	stmt    | 5662   << off_ ,	//	mov xl gnvhe  load pointer to end of hash chain
/* 16804 */	load    | xl     << dst_ | gnvhe  << off_ ,
/* 16805 */	stmt    | 5663   << off_ ,	//	mov vrnxt(xl) wb  add new block to end of chain
/* 16806 */	store   | wb     << dst_ | xl     << src_ | vrnxt  << off_ ,
/* 16807 */	stmt    | 5664   << off_ ,	//	mov (xr)+ wc  set vrlen field, bump ptr
/* 16808 */	store   | wc     << dst_ | xr     << src_ ,
/* 16809 */	ica     | xr     << dst_ ,
/* 16810 */	stmt    | 5665   << off_ ,	//	mov wa gnvnw  get length in words
/* 16811 */	load    | wa     << dst_ | gnvnw  << off_ ,
/* 16812 */	stmt    | 5666   << off_ ,	//	wtb wa   convert to length in bytes
/* 16813 */	stmt    | 5667   << off_ ,	//	bze wc gnv16  jump if system variable
/* 16814 */	bze     | wc     << dst_ | gnv16  << off_ ,
/* 16815 */	stmt    | 5668   << off_ ,	//	mov xl (xs)  point back to string name
/* 16816 */	load    | xl     << dst_ | xs     << src_ ,
/* 16817 */	stmt    | 5669   << off_ ,	//	add xl *schar  point to chars of name
/* 16818 */	loadi   | r2     << dst_ | schar  << off_ ,
/* 16819 */	add     | xl     << dst_ | r2     << src_ ,
/* 16820 */	stmt    | 5670   << off_ ,	//	mvw    move characters into place
/* 16821 */	mvw     ,
/* 16822 */	stmt    | 5671   << off_ ,	//	mov xr wb  restore vrblk pointer
/* 16823 */	move    | xr     << dst_ | wb     << src_ ,
/* 16824 */	stmt    | 5672   << off_ ,	//	brn gnv06   jump back to exit
/* 16825 */	brn     | gnv06  << off_ ,
// gnv16:
/* 16826 */	stmt    | 5673   << off_ ,	//gnv16	mov xl gnvsp  load pointer to svblk
/* 16827 */	load    | xl     << dst_ | gnvsp  << off_ ,
/* 16828 */	stmt    | 5674   << off_ ,	//	mov (xr) xl  set svblk ptr in vrblk
/* 16829 */	store   | xl     << dst_ | xr     << src_ ,
/* 16830 */	stmt    | 5675   << off_ ,	//	mov xr wb  restore vrblk pointer
/* 16831 */	move    | xr     << dst_ | wb     << src_ ,
/* 16832 */	stmt    | 5676   << off_ ,	//	mov wb svbit(xl)  load bit indicators
/* 16833 */	load    | wb     << dst_ | xl     << src_ | svbit  << off_ ,
/* 16834 */	stmt    | 5677   << off_ ,	//	add xl *svchs  point to characters of name
/* 16835 */	loadi   | r2     << dst_ | svchs  << off_ ,
/* 16836 */	add     | xl     << dst_ | r2     << src_ ,
/* 16837 */	stmt    | 5678   << off_ ,	//	add xl wa  point past characters
/* 16838 */	add     | xl     << dst_ | wa     << src_ ,
/* 16839 */	stmt    | 5679   << off_ ,	//	mov wc 4,btknm  load test bit
/* 16840 */	load    | wc     << dst_ | btknm  << off_ ,
/* 16841 */	stmt    | 5680   << off_ ,	//	anb wc wb  and to test
/* 16842 */	anb     | wc     << dst_ | wb     << src_ ,
/* 16843 */	stmt    | 5681   << off_ ,	//	zrb wc gnv17  jump if no keyword number
/* 16844 */	zrb     | wc     << dst_ | gnv17  << off_ ,
/* 16845 */	stmt    | 5682   << off_ ,	//	ica xl   else bump pointer
/* 16846 */	ica     | xl     << dst_ ,
// gnv17:
/* 16847 */	stmt    | 5683   << off_ ,	//gnv17	mov wc 4,btfnc  get test bit
/* 16848 */	load    | wc     << dst_ | btfnc  << off_ ,
/* 16849 */	stmt    | 5684   << off_ ,	//	anb wc wb  and to test
/* 16850 */	anb     | wc     << dst_ | wb     << src_ ,
/* 16851 */	stmt    | 5685   << off_ ,	//	zrb wc gnv18  skip if no system function
/* 16852 */	zrb     | wc     << dst_ | gnv18  << off_ ,
/* 16853 */	stmt    | 5686   << off_ ,	//	mov vrfnc(xr) xl  else point vrfnc to svfnc field
/* 16854 */	store   | xl     << dst_ | xr     << src_ | vrfnc  << off_ ,
/* 16855 */	stmt    | 5687   << off_ ,	//	add xl *num02  and bump past svfnc, svnar fields
/* 16856 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 16857 */	add     | xl     << dst_ | r2     << src_ ,
// gnv18:
/* 16858 */	stmt    | 5688   << off_ ,	//gnv18	mov wc 4,btlbl  get test bit
/* 16859 */	load    | wc     << dst_ | btlbl  << off_ ,
/* 16860 */	stmt    | 5689   << off_ ,	//	anb wc wb  and to test
/* 16861 */	anb     | wc     << dst_ | wb     << src_ ,
/* 16862 */	stmt    | 5690   << off_ ,	//	zrb wc gnv19  jump if bit is off (no system labl)
/* 16863 */	zrb     | wc     << dst_ | gnv19  << off_ ,
/* 16864 */	stmt    | 5691   << off_ ,	//	mov vrlbl(xr) xl  else point vrlbl to svlbl field
/* 16865 */	store   | xl     << dst_ | xr     << src_ | vrlbl  << off_ ,
/* 16866 */	stmt    | 5692   << off_ ,	//	ica xl   bump past svlbl field
/* 16867 */	ica     | xl     << dst_ ,
// gnv19:
/* 16868 */	stmt    | 5693   << off_ ,	//gnv19	mov wc 4,btval  load test bit
/* 16869 */	load    | wc     << dst_ | btval  << off_ ,
/* 16870 */	stmt    | 5694   << off_ ,	//	anb wc wb  and to test
/* 16871 */	anb     | wc     << dst_ | wb     << src_ ,
/* 16872 */	stmt    | 5695   << off_ ,	//	zrb wc gnv06  all done if no value
/* 16873 */	zrb     | wc     << dst_ | gnv06  << off_ ,
/* 16874 */	stmt    | 5696   << off_ ,	//	mov vrval(xr) (xl)  else set initial value
/* 16875 */	load    | r1     << dst_ | xl     << src_ ,
/* 16876 */	store   | r1     << dst_ | xr     << src_ | vrval  << off_ ,
/* 16877 */	stmt    | 5697   << off_ ,	//	mov vrsto(xr) =b_vre  set error store access
/* 16878 */	loadi   | r1     << dst_ | b_vre  << off_ ,
/* 16879 */	store   | r1     << dst_ | xr     << src_ | vrsto  << off_ ,
/* 16880 */	stmt    | 5698   << off_ ,	//	brn gnv06   merge back to exit to caller
/* 16881 */	brn     | gnv06  << off_ ,
// gtpat:
/* 16882 */	stmt    | 5699   << off_ ,	//gtpat	prc e 1  entry point
/* 16883 */	stmt    | 5700   << off_ ,	//	bhi (xr) =p_aaa gtpt5 jump if pattern already
/* 16884 */	load    | r1     << dst_ | xr     << src_ ,
/* 16885 */	loadi   | r2     << dst_ | p_aaa  << off_ ,
/* 16886 */	bhi     | r1     << dst_ | r2     << src_ | gtpt5  << off_ ,
/* 16887 */	stmt    | 5701   << off_ ,	//	mov gtpsb wb  save wb
/* 16888 */	store   | wb     << dst_ | gtpsb  << off_ ,
/* 16889 */	stmt    | 5702   << off_ ,	//	mov -(xs) xr  stack argument for gtstg
/* 16890 */	dca     | xs     << dst_ ,
/* 16891 */	store   | xr     << dst_ | xs     << src_ ,
/* 16892 */	stmt    | 5703   << off_ ,	//	jsr gtstg   convert argument to string
/* 16893 */	call    | gtstg  << off_ ,
/* 16894 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 16895 */	ppm     | gtpt2  << off_ ,
/* 16896 */	stmt    | 5704   << off_ ,	//	bnz wa gtpt1  jump if non-null
/* 16897 */	bnz     | wa     << dst_ | gtpt1  << off_ ,
/* 16898 */	stmt    | 5705   << off_ ,	//	mov xr =ndnth  point to nothen node
/* 16899 */	loadi   | xr     << dst_ | ndnth  << off_ ,
/* 16900 */	stmt    | 5706   << off_ ,	//	brn gtpt4   jump to exit
/* 16901 */	brn     | gtpt4  << off_ ,
// gtpt1:
/* 16902 */	stmt    | 5707   << off_ ,	//gtpt1	mov wb =p_str  load pcode for multi-char string
/* 16903 */	loadi   | wb     << dst_ | p_str  << off_ ,
/* 16904 */	stmt    | 5708   << off_ ,	//	bne wa =num01 gtpt3 jump if multi-char string
/* 16905 */	loadi   | r2     << dst_ | num01  << off_ ,
/* 16906 */	bne     | wa     << dst_ | r2     << src_ | gtpt3  << off_ ,
/* 16907 */	stmt    | 5709   << off_ ,	//	plc xr   point to character
/* 16908 */	plc     | xr     << dst_ ,
/* 16909 */	stmt    | 5710   << off_ ,	//	lch wa (xr)  load character
/* 16910 */	load    | wa     << dst_ | xr     << src_ ,
/* 16911 */	stmt    | 5711   << off_ ,	//	mov xr wa  set as parm1
/* 16912 */	move    | xr     << dst_ | wa     << src_ ,
/* 16913 */	stmt    | 5712   << off_ ,	//	mov wb =p_ans  point to pcode for 1-char any
/* 16914 */	loadi   | wb     << dst_ | p_ans  << off_ ,
/* 16915 */	stmt    | 5713   << off_ ,	//	brn gtpt3   jump to build node
/* 16916 */	brn     | gtpt3  << off_ ,
// gtpt2:
/* 16917 */	stmt    | 5714   << off_ ,	//gtpt2	mov wb =p_exa  set pcode for expression in case
/* 16918 */	loadi   | wb     << dst_ | p_exa  << off_ ,
/* 16919 */	stmt    | 5715   << off_ ,	//	blo (xr) =b_e__ gtpt3 jump to build node if expression
/* 16920 */	load    | r1     << dst_ | xr     << src_ ,
/* 16921 */	loadi   | r2     << dst_ | b_e__  << off_ ,
/* 16922 */	blo     | r1     << dst_ | r2     << src_ | gtpt3  << off_ ,
/* 16923 */	stmt    | 5716   << off_ ,	//	exi 1   take convert error exit
/* 16924 */	exi     | 1      << off_ ,
// gtpt3:
/* 16925 */	stmt    | 5717   << off_ ,	//gtpt3	jsr pbild   call routine to build pattern node
/* 16926 */	call    | pbild  << off_ ,
// gtpt4:
/* 16927 */	stmt    | 5718   << off_ ,	//gtpt4	mov wb gtpsb  restore wb
/* 16928 */	load    | wb     << dst_ | gtpsb  << off_ ,
// gtpt5:
/* 16929 */	stmt    | 5719   << off_ ,	//gtpt5	exi    return to gtpat caller
/* 16930 */	exi     | 0      << off_ ,
// gtrea:
/* 16931 */	stmt    | 5720   << off_ ,	//gtrea	prc e 1  entry point
/* 16932 */	stmt    | 5721   << off_ ,	//	mov wa (xr)  get first word of block
/* 16933 */	load    | wa     << dst_ | xr     << src_ ,
/* 16934 */	stmt    | 5722   << off_ ,	//	beq wa =b_rcl gtre2 jump if real
/* 16935 */	loadi   | r2     << dst_ | b_rcl  << off_ ,
/* 16936 */	beq     | wa     << dst_ | r2     << src_ | gtre2  << off_ ,
/* 16937 */	stmt    | 5723   << off_ ,	//	jsr gtnum   else convert argument to numeric
/* 16938 */	call    | gtnum  << off_ ,
/* 16939 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 16940 */	ppm     | gtre3  << off_ ,
/* 16941 */	stmt    | 5724   << off_ ,	//	beq wa =b_rcl gtre2 jump if real was returned
/* 16942 */	loadi   | r2     << dst_ | b_rcl  << off_ ,
/* 16943 */	beq     | wa     << dst_ | r2     << src_ | gtre2  << off_ ,
// gtre1:
/* 16944 */	stmt    | 5725   << off_ ,	//gtre1	ldi icval(xr)   load integer
/* 16945 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/* 16946 */	ldi     | r1     << dst_ ,
/* 16947 */	stmt    | 5726   << off_ ,	//	itr    convert to real
/* 16948 */	itr     ,
/* 16949 */	stmt    | 5727   << off_ ,	//	jsr rcbld   build rcblk
/* 16950 */	call    | rcbld  << off_ ,
// gtre2:
/* 16951 */	stmt    | 5728   << off_ ,	//gtre2	exi    return to gtrea caller
/* 16952 */	exi     | 0      << off_ ,
// gtre3:
/* 16953 */	stmt    | 5729   << off_ ,	//gtre3	exi 1   take convert error exit
/* 16954 */	exi     | 1      << off_ ,
// gtsmi:
/* 16955 */	stmt    | 5730   << off_ ,	//gtsmi	prc n 2  entry point
/* 16956 */	prc     | 6      << off_ ,
/* 16957 */	stmt    | 5731   << off_ ,	//	mov xr (xs)+  load argument
/* 16958 */	load    | xr     << dst_ | xs     << src_ ,
/* 16959 */	ica     | xs     << dst_ ,
/* 16960 */	stmt    | 5732   << off_ ,	//	beq (xr) =b_icl gtsm1 skip if already an integer
/* 16961 */	load    | r1     << dst_ | xr     << src_ ,
/* 16962 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/* 16963 */	beq     | r1     << dst_ | r2     << src_ | gtsm1  << off_ ,
/* 16964 */	stmt    | 5733   << off_ ,	//	jsr gtint   convert argument to integer
/* 16965 */	call    | gtint  << off_ ,
/* 16966 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 16967 */	ppm     | gtsm2  << off_ ,
// gtsm1:
/* 16968 */	stmt    | 5734   << off_ ,	//gtsm1	ldi icval(xr)   load integer value
/* 16969 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/* 16970 */	ldi     | r1     << dst_ ,
/* 16971 */	stmt    | 5735   << off_ ,	//	mfi wc gtsm3  move as one word, jump if ovflow
/* 16972 */	move    | wc     << dst_ | ia     << src_ ,
/* 16973 */	mfi     | gtsm3  << off_ ,
/* 16974 */	stmt    | 5736   << off_ ,	//	bgt wc mxlen gtsm3 or if too large
/* 16975 */	load    | r2     << dst_ | mxlen  << off_ ,
/* 16976 */	bgt     | wc     << dst_ | r2     << src_ | gtsm3  << off_ ,
/* 16977 */	stmt    | 5737   << off_ ,	//	mov xr wc  copy result to xr
/* 16978 */	move    | xr     << dst_ | wc     << src_ ,
/* 16979 */	stmt    | 5738   << off_ ,	//	exi    return to gtsmi caller
/* 16980 */	exi     | 600    << off_ ,
// gtsm2:
/* 16981 */	stmt    | 5739   << off_ ,	//gtsm2	exi 1   take non-integer error exit
/* 16982 */	exi     | 601    << off_ ,
// gtsm3:
/* 16983 */	stmt    | 5740   << off_ ,	//gtsm3	exi 2   take out-of-range error exit
/* 16984 */	exi     | 602    << off_ ,
// gtstg:
/* 16985 */	stmt    | 5741   << off_ ,	//gtstg	prc n 1  entry point
/* 16986 */	prc     | 7      << off_ ,
/* 16987 */	stmt    | 5742   << off_ ,	//	mov xr (xs)+  load argument, pop stack
/* 16988 */	load    | xr     << dst_ | xs     << src_ ,
/* 16989 */	ica     | xs     << dst_ ,
/* 16990 */	stmt    | 5743   << off_ ,	//	beq (xr) =b_scl gts30 jump if already a string
/* 16991 */	load    | r1     << dst_ | xr     << src_ ,
/* 16992 */	loadi   | r2     << dst_ | b_scl  << off_ ,
/* 16993 */	beq     | r1     << dst_ | r2     << src_ | gts30  << off_ ,
// gts01:
/* 16994 */	stmt    | 5744   << off_ ,	//gts01	mov -(xs) xr  restack argument in case error
/* 16995 */	dca     | xs     << dst_ ,
/* 16996 */	store   | xr     << dst_ | xs     << src_ ,
/* 16997 */	stmt    | 5745   << off_ ,	//	mov -(xs) xl  save xl
/* 16998 */	dca     | xs     << dst_ ,
/* 16999 */	store   | xl     << dst_ | xs     << src_ ,
/* 17000 */	stmt    | 5746   << off_ ,	//	mov gtsvb wb  save wb
/* 17001 */	store   | wb     << dst_ | gtsvb  << off_ ,
/* 17002 */	stmt    | 5747   << off_ ,	//	mov gtsvc wc  save wc
/* 17003 */	store   | wc     << dst_ | gtsvc  << off_ ,
/* 17004 */	stmt    | 5748   << off_ ,	//	mov wa (xr)  load first word of block
/* 17005 */	load    | wa     << dst_ | xr     << src_ ,
/* 17006 */	stmt    | 5749   << off_ ,	//	beq wa =b_icl gts05 jump to convert integer
/* 17007 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/* 17008 */	beq     | wa     << dst_ | r2     << src_ | gts05  << off_ ,
/* 17009 */	stmt    | 5750   << off_ ,	//	beq wa =b_rcl gts10 jump to convert real
/* 17010 */	loadi   | r2     << dst_ | b_rcl  << off_ ,
/* 17011 */	beq     | wa     << dst_ | r2     << src_ | gts10  << off_ ,
/* 17012 */	stmt    | 5751   << off_ ,	//	beq wa =b_nml gts03 jump to convert name
/* 17013 */	loadi   | r2     << dst_ | b_nml  << off_ ,
/* 17014 */	beq     | wa     << dst_ | r2     << src_ | gts03  << off_ ,
// gts02:
/* 17015 */	stmt    | 5752   << off_ ,	//gts02	mov xl (xs)+  restore xl
/* 17016 */	load    | xl     << dst_ | xs     << src_ ,
/* 17017 */	ica     | xs     << dst_ ,
/* 17018 */	stmt    | 5753   << off_ ,	//	mov xr (xs)+  reload input argument
/* 17019 */	load    | xr     << dst_ | xs     << src_ ,
/* 17020 */	ica     | xs     << dst_ ,
/* 17021 */	stmt    | 5754   << off_ ,	//	exi 1   take convert error exit
/* 17022 */	exi     | 701    << off_ ,
// gts03:
/* 17023 */	stmt    | 5755   << off_ ,	//gts03	mov xl nmbas(xr)  load name base
/* 17024 */	load    | xl     << dst_ | xr     << src_ | nmbas  << off_ ,
/* 17025 */	stmt    | 5756   << off_ ,	//	bhi xl state gts02 error if not natural var (static)
/* 17026 */	load    | r2     << dst_ | state  << off_ ,
/* 17027 */	bhi     | xl     << dst_ | r2     << src_ | gts02  << off_ ,
/* 17028 */	stmt    | 5757   << off_ ,	//	add xl *vrsof  else point to possible string name
/* 17029 */	loadi   | r2     << dst_ | vrsof  << off_ ,
/* 17030 */	add     | xl     << dst_ | r2     << src_ ,
/* 17031 */	stmt    | 5758   << off_ ,	//	mov wa sclen(xl)  load length
/* 17032 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/* 17033 */	stmt    | 5759   << off_ ,	//	bnz wa gts04  jump if not system variable
/* 17034 */	bnz     | wa     << dst_ | gts04  << off_ ,
/* 17035 */	stmt    | 5760   << off_ ,	//	mov xl vrsvo(xl)  else point to svblk
/* 17036 */	load    | xl     << dst_ | xl     << src_ | vrsvo  << off_ ,
/* 17037 */	stmt    | 5761   << off_ ,	//	mov wa svlen(xl)  and load name length
/* 17038 */	load    | wa     << dst_ | xl     << src_ | svlen  << off_ ,
// gts04:
/* 17039 */	stmt    | 5762   << off_ ,	//gts04	zer wb   set offset to zero
/* 17040 */	move    | wb     << dst_ ,
/* 17041 */	stmt    | 5763   << off_ ,	//	jsr sbstr   use sbstr to copy string
/* 17042 */	call    | sbstr  << off_ ,
/* 17043 */	stmt    | 5764   << off_ ,	//	brn gts29   jump to exit
/* 17044 */	brn     | gts29  << off_ ,
// gts05:
/* 17045 */	stmt    | 5765   << off_ ,	//gts05	ldi icval(xr)   load integer value
/* 17046 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/* 17047 */	ldi     | r1     << dst_ ,
/* 17048 */	stmt    | 5766   << off_ ,	//	mov gtssf =num01  set sign flag negative
/* 17049 */	loadi   | r1     << dst_ | num01  << off_ ,
/* 17050 */	store   | r1     << dst_ | gtssf  << off_ ,
/* 17051 */	stmt    | 5767   << off_ ,	//	ilt gts06   skip if integer is negative
/* 17052 */	ilt     | gts06  << off_ ,
/* 17053 */	stmt    | 5768   << off_ ,	//	ngi    else negate integer
/* 17054 */	ngi     ,
/* 17055 */	stmt    | 5769   << off_ ,	//	zer gtssf   and reset negative flag
/* 17056 */	store   | r0     << dst_ | gtssf  << off_ ,
// gts06:
/* 17057 */	stmt    | 5770   << off_ ,	//gts06	mov xr gtswk  point to result work area
/* 17058 */	load    | xr     << dst_ | gtswk  << off_ ,
/* 17059 */	stmt    | 5771   << off_ ,	//	mov wb =nstmx  initialize counter to max length
/* 17060 */	loadi   | wb     << dst_ | nstmx  << off_ ,
/* 17061 */	stmt    | 5772   << off_ ,	//	psc xr wb  prepare to store (right-left)
/* 17062 */	psc     | xr     << dst_ | wb     << src_ ,
// gts07:
/* 17063 */	stmt    | 5773   << off_ ,	//gts07	cvd    convert one digit into wa
/* 17064 */	cvd     ,
/* 17065 */	stmt    | 5774   << off_ ,	//	sch wa -(xr)  store in work area
/* 17066 */	dca     | xr     << dst_ ,
/* 17067 */	store   | wa     << dst_ | xr     << src_ ,
/* 17068 */	stmt    | 5775   << off_ ,	//	dcv wb   decrement counter
/* 17069 */	dcv     | wb     << dst_ ,
/* 17070 */	stmt    | 5776   << off_ ,	//	ine gts07   loop if more digits to go
/* 17071 */	ine     | gts07  << off_ ,
/* 17072 */	stmt    | 5777   << off_ ,	//	csc xr   complete store characters
// gts08:
/* 17073 */	stmt    | 5778   << off_ ,	//gts08	mov wa =nstmx  get max number of characters
/* 17074 */	loadi   | wa     << dst_ | nstmx  << off_ ,
/* 17075 */	stmt    | 5779   << off_ ,	//	sub wa wb  compute length of result
/* 17076 */	sub     | wa     << dst_ | wb     << src_ ,
/* 17077 */	stmt    | 5780   << off_ ,	//	mov xl wa  remember length for move later on
/* 17078 */	move    | xl     << dst_ | wa     << src_ ,
/* 17079 */	stmt    | 5781   << off_ ,	//	add wa gtssf  add one for negative sign if needed
/* 17080 */	load    | r2     << dst_ | gtssf  << off_ ,
/* 17081 */	add     | wa     << dst_ | r2     << src_ ,
/* 17082 */	stmt    | 5782   << off_ ,	//	jsr alocs   allocate string for result
/* 17083 */	call    | alocs  << off_ ,
/* 17084 */	stmt    | 5783   << off_ ,	//	mov wc xr  save result pointer for the moment
/* 17085 */	move    | wc     << dst_ | xr     << src_ ,
/* 17086 */	stmt    | 5784   << off_ ,	//	psc xr   point to chars of result block
/* 17087 */	psc     | xr     << dst_ ,
/* 17088 */	stmt    | 5785   << off_ ,	//	bze gtssf gts09  skip if positive
/* 17089 */	load    | r1     << dst_ | gtssf  << off_ ,
/* 17090 */	bze     | r1     << dst_ | gts09  << off_ ,
/* 17091 */	stmt    | 5786   << off_ ,	//	mov wa =ch_mn  else load negative sign
/* 17092 */	loadi   | wa     << dst_ | ch_mn  << off_ ,
/* 17093 */	stmt    | 5787   << off_ ,	//	sch wa (xr)+  and store it
/* 17094 */	store   | wa     << dst_ | xr     << src_ ,
/* 17095 */	ica     | xr     << dst_ ,
/* 17096 */	stmt    | 5788   << off_ ,	//	csc xr   complete store characters
// gts09:
/* 17097 */	stmt    | 5789   << off_ ,	//gts09	mov wa xl  recall length to move
/* 17098 */	move    | wa     << dst_ | xl     << src_ ,
/* 17099 */	stmt    | 5790   << off_ ,	//	mov xl gtswk  point to result work area
/* 17100 */	load    | xl     << dst_ | gtswk  << off_ ,
/* 17101 */	stmt    | 5791   << off_ ,	//	plc xl wb  point to first result character
/* 17102 */	plc     | xl     << dst_ | wb     << src_ ,
/* 17103 */	stmt    | 5792   << off_ ,	//	mvc    move chars to result string
/* 17104 */	mvc     ,
/* 17105 */	stmt    | 5793   << off_ ,	//	mov xr wc  restore result pointer
/* 17106 */	move    | xr     << dst_ | wc     << src_ ,
/* 17107 */	stmt    | 5794   << off_ ,	//	brn gts29   jump to exit
/* 17108 */	brn     | gts29  << off_ ,
// gts10:
/* 17109 */	stmt    | 5795   << off_ ,	//gts10	ldr rcval(xr)   load real
/* 17110 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/* 17111 */	ldr     | r1     << dst_ ,
/* 17112 */	stmt    | 5796   << off_ ,	//	zer gtssf   reset negative flag
/* 17113 */	store   | r0     << dst_ | gtssf  << off_ ,
/* 17114 */	stmt    | 5797   << off_ ,	//	req gts31   skip if zero
/* 17115 */	req     | gts31  << off_ ,
/* 17116 */	stmt    | 5798   << off_ ,	//	rge gts11   jump if real is positive
/* 17117 */	rge     | gts11  << off_ ,
/* 17118 */	stmt    | 5799   << off_ ,	//	mov gtssf =num01  else set negative flag
/* 17119 */	loadi   | r1     << dst_ | num01  << off_ ,
/* 17120 */	store   | r1     << dst_ | gtssf  << off_ ,
/* 17121 */	stmt    | 5800   << off_ ,	//	ngr    and get absolute value of real
/* 17122 */	ngr     ,
// gts11:
/* 17123 */	stmt    | 5801   << off_ ,	//gts11	ldi 4,intv0   initialize exponent to zero
/* 17124 */	load    | r1     << dst_ | intv0  << off_ ,
/* 17125 */	ldi     | r1     << dst_ ,
// gts12:
/* 17126 */	stmt    | 5802   << off_ ,	//gts12	str gtsrs   save real value
/* 17127 */	store   | ra     << dst_ | gtsrs  << off_ ,
/* 17128 */	stmt    | 5803   << off_ ,	//	sbr 4,reap1   subtract 0.1 to compare
/* 17129 */	load    | r1     << dst_ | reap1  << off_ ,
/* 17130 */	sbr     | r1     << dst_ ,
/* 17131 */	stmt    | 5804   << off_ ,	//	rge gts13   jump if scale up not required
/* 17132 */	rge     | gts13  << off_ ,
/* 17133 */	stmt    | 5805   << off_ ,	//	ldr gtsrs   else reload value
/* 17134 */	load    | r1     << dst_ | gtsrs  << off_ ,
/* 17135 */	ldr     | r1     << dst_ ,
/* 17136 */	stmt    | 5806   << off_ ,	//	mlr 4,reatt   multiply by 10**10
/* 17137 */	load    | r1     << dst_ | reatt  << off_ ,
/* 17138 */	mlr     | r1     << dst_ ,
/* 17139 */	stmt    | 5807   << off_ ,	//	sbi 4,intvt   decrement exponent by 10
/* 17140 */	load    | r1     << dst_ | intvt  << off_ ,
/* 17141 */	sbi     | r1     << dst_ ,
/* 17142 */	stmt    | 5808   << off_ ,	//	brn gts12   loop back to test again
/* 17143 */	brn     | gts12  << off_ ,
// gts13:
/* 17144 */	stmt    | 5809   << off_ ,	//gts13	ldr gtsrs   reload value
/* 17145 */	load    | r1     << dst_ | gtsrs  << off_ ,
/* 17146 */	ldr     | r1     << dst_ ,
/* 17147 */	stmt    | 5810   << off_ ,	//	sbr 4,reav1   subtract 1.0
/* 17148 */	load    | r1     << dst_ | reav1  << off_ ,
/* 17149 */	sbr     | r1     << dst_ ,
/* 17150 */	stmt    | 5811   << off_ ,	//	rlt gts17   jump if no scale down required
/* 17151 */	rlt     | gts17  << off_ ,
/* 17152 */	stmt    | 5812   << off_ ,	//	ldr gtsrs   else reload value
/* 17153 */	load    | r1     << dst_ | gtsrs  << off_ ,
/* 17154 */	ldr     | r1     << dst_ ,
// gts14:
/* 17155 */	stmt    | 5813   << off_ ,	//gts14	sbr 4,reatt   subtract 10**10 to compare
/* 17156 */	load    | r1     << dst_ | reatt  << off_ ,
/* 17157 */	sbr     | r1     << dst_ ,
/* 17158 */	stmt    | 5814   << off_ ,	//	rlt gts15   jump if large step not required
/* 17159 */	rlt     | gts15  << off_ ,
/* 17160 */	stmt    | 5815   << off_ ,	//	ldr gtsrs   else restore value
/* 17161 */	load    | r1     << dst_ | gtsrs  << off_ ,
/* 17162 */	ldr     | r1     << dst_ ,
/* 17163 */	stmt    | 5816   << off_ ,	//	dvr 4,reatt   divide by 10**10
/* 17164 */	load    | r1     << dst_ | reatt  << off_ ,
/* 17165 */	dvr     | r1     << dst_ ,
/* 17166 */	stmt    | 5817   << off_ ,	//	str gtsrs   store new value
/* 17167 */	store   | ra     << dst_ | gtsrs  << off_ ,
/* 17168 */	stmt    | 5818   << off_ ,	//	adi 4,intvt   increment exponent by 10
/* 17169 */	load    | r1     << dst_ | intvt  << off_ ,
/* 17170 */	adi     | r1     << dst_ ,
/* 17171 */	stmt    | 5819   << off_ ,	//	brn gts14   loop back
/* 17172 */	brn     | gts14  << off_ ,
// gts15:
/* 17173 */	stmt    | 5820   << off_ ,	//gts15	mov xr =reav1  point to powers of ten table
/* 17174 */	loadi   | xr     << dst_ | reav1  << off_ ,
// gts16:
/* 17175 */	stmt    | 5821   << off_ ,	//gts16	ldr gtsrs   reload value
/* 17176 */	load    | r1     << dst_ | gtsrs  << off_ ,
/* 17177 */	ldr     | r1     << dst_ ,
/* 17178 */	stmt    | 5822   << off_ ,	//	adi 4,intv1   increment exponent
/* 17179 */	load    | r1     << dst_ | intv1  << off_ ,
/* 17180 */	adi     | r1     << dst_ ,
/* 17181 */	stmt    | 5823   << off_ ,	//	add xr *cfp_r  point to next entry in table
/* 17182 */	loadi   | r2     << dst_ | cfp_r  << off_ ,
/* 17183 */	add     | xr     << dst_ | r2     << src_ ,
/* 17184 */	stmt    | 5824   << off_ ,	//	sbr (xr)   subtract it to compare
/* 17185 */	load    | r1     << dst_ | xr     << src_ ,
/* 17186 */	sbr     | r1     << dst_ ,
/* 17187 */	stmt    | 5825   << off_ ,	//	rge gts16   loop till we find a larger entry
/* 17188 */	rge     | gts16  << off_ ,
/* 17189 */	stmt    | 5826   << off_ ,	//	ldr gtsrs   then reload the value
/* 17190 */	load    | r1     << dst_ | gtsrs  << off_ ,
/* 17191 */	ldr     | r1     << dst_ ,
/* 17192 */	stmt    | 5827   << off_ ,	//	dvr (xr)   and complete scaling
/* 17193 */	load    | r1     << dst_ | xr     << src_ ,
/* 17194 */	dvr     | r1     << dst_ ,
/* 17195 */	stmt    | 5828   << off_ ,	//	str gtsrs   store value
/* 17196 */	store   | ra     << dst_ | gtsrs  << off_ ,
// gts17:
/* 17197 */	stmt    | 5829   << off_ ,	//gts17	ldr gtsrs   get value again
/* 17198 */	load    | r1     << dst_ | gtsrs  << off_ ,
/* 17199 */	ldr     | r1     << dst_ ,
/* 17200 */	stmt    | 5830   << off_ ,	//	adr gtsrn   add rounding factor
/* 17201 */	load    | r1     << dst_ | gtsrn  << off_ ,
/* 17202 */	adr     | r1     << dst_ ,
/* 17203 */	stmt    | 5831   << off_ ,	//	str gtsrs   store result
/* 17204 */	store   | ra     << dst_ | gtsrs  << off_ ,
/* 17205 */	stmt    | 5832   << off_ ,	//	sbr 4,reav1   subtract 1.0 to compare
/* 17206 */	load    | r1     << dst_ | reav1  << off_ ,
/* 17207 */	sbr     | r1     << dst_ ,
/* 17208 */	stmt    | 5833   << off_ ,	//	rlt gts18   skip if ok
/* 17209 */	rlt     | gts18  << off_ ,
/* 17210 */	stmt    | 5834   << off_ ,	//	adi 4,intv1   else increment exponent
/* 17211 */	load    | r1     << dst_ | intv1  << off_ ,
/* 17212 */	adi     | r1     << dst_ ,
/* 17213 */	stmt    | 5835   << off_ ,	//	ldr gtsrs   reload value
/* 17214 */	load    | r1     << dst_ | gtsrs  << off_ ,
/* 17215 */	ldr     | r1     << dst_ ,
/* 17216 */	stmt    | 5836   << off_ ,	//	dvr 4,reavt   divide by 10.0 to rescale
/* 17217 */	load    | r1     << dst_ | reavt  << off_ ,
/* 17218 */	dvr     | r1     << dst_ ,
/* 17219 */	stmt    | 5837   << off_ ,	//	brn gts19   jump to merge
/* 17220 */	brn     | gts19  << off_ ,
// gts18:
/* 17221 */	stmt    | 5838   << off_ ,	//gts18	ldr gtsrs   reload rounded value
/* 17222 */	load    | r1     << dst_ | gtsrs  << off_ ,
/* 17223 */	ldr     | r1     << dst_ ,
// gts19:
/* 17224 */	stmt    | 5839   << off_ ,	//gts19	mov xl =cfp_s  set num dec digits = cfp_s
/* 17225 */	loadi   | xl     << dst_ | cfp_s  << off_ ,
/* 17226 */	stmt    | 5840   << off_ ,	//	mov gtses =ch_mn  set exponent sign negative
/* 17227 */	loadi   | r1     << dst_ | ch_mn  << off_ ,
/* 17228 */	store   | r1     << dst_ | gtses  << off_ ,
/* 17229 */	stmt    | 5841   << off_ ,	//	ilt gts21   all set if exponent is negative
/* 17230 */	ilt     | gts21  << off_ ,
/* 17231 */	stmt    | 5842   << off_ ,	//	mfi wa   else fetch exponent
/* 17232 */	move    | wa     << dst_ | ia     << src_ ,
/* 17233 */	stmt    | 5843   << off_ ,	//	ble wa =cfp_s gts20 skip if we can use special format
/* 17234 */	loadi   | r2     << dst_ | cfp_s  << off_ ,
/* 17235 */	ble     | wa     << dst_ | r2     << src_ | gts20  << off_ ,
/* 17236 */	stmt    | 5844   << off_ ,	//	mti wa   else restore exponent
/* 17237 */	move    | ia     << dst_ | wa     << src_ ,
/* 17238 */	stmt    | 5845   << off_ ,	//	ngi    set negative for cvd
/* 17239 */	ngi     ,
/* 17240 */	stmt    | 5846   << off_ ,	//	mov gtses =ch_pl  set plus sign for exponent sign
/* 17241 */	loadi   | r1     << dst_ | ch_pl  << off_ ,
/* 17242 */	store   | r1     << dst_ | gtses  << off_ ,
/* 17243 */	stmt    | 5847   << off_ ,	//	brn gts21   jump to generate exponent
/* 17244 */	brn     | gts21  << off_ ,
// gts20:
/* 17245 */	stmt    | 5848   << off_ ,	//gts20	sub xl wa  compute digits after decimal point
/* 17246 */	sub     | xl     << dst_ | wa     << src_ ,
/* 17247 */	stmt    | 5849   << off_ ,	//	ldi 4,intv0   reset exponent to zero
/* 17248 */	load    | r1     << dst_ | intv0  << off_ ,
/* 17249 */	ldi     | r1     << dst_ ,
// gts21:
/* 17250 */	stmt    | 5850   << off_ ,	//gts21	mov xr gtswk  point to work area
/* 17251 */	load    | xr     << dst_ | gtswk  << off_ ,
/* 17252 */	stmt    | 5851   << off_ ,	//	mov wb =nstmx  set character ctr to max length
/* 17253 */	loadi   | wb     << dst_ | nstmx  << off_ ,
/* 17254 */	stmt    | 5852   << off_ ,	//	psc xr wb  prepare to store (right to left)
/* 17255 */	psc     | xr     << dst_ | wb     << src_ ,
/* 17256 */	stmt    | 5853   << off_ ,	//	ieq gts23   skip exponent if it is zero
/* 17257 */	ieq     | gts23  << off_ ,
// gts22:
/* 17258 */	stmt    | 5854   << off_ ,	//gts22	cvd    convert a digit into wa
/* 17259 */	cvd     ,
/* 17260 */	stmt    | 5855   << off_ ,	//	sch wa -(xr)  store in work area
/* 17261 */	dca     | xr     << dst_ ,
/* 17262 */	store   | wa     << dst_ | xr     << src_ ,
/* 17263 */	stmt    | 5856   << off_ ,	//	dcv wb   decrement counter
/* 17264 */	dcv     | wb     << dst_ ,
/* 17265 */	stmt    | 5857   << off_ ,	//	ine gts22   loop back if more digits to go
/* 17266 */	ine     | gts22  << off_ ,
/* 17267 */	stmt    | 5858   << off_ ,	//	mov wa gtses  load exponent sign
/* 17268 */	load    | wa     << dst_ | gtses  << off_ ,
/* 17269 */	stmt    | 5859   << off_ ,	//	sch wa -(xr)  store in work area
/* 17270 */	dca     | xr     << dst_ ,
/* 17271 */	store   | wa     << dst_ | xr     << src_ ,
/* 17272 */	stmt    | 5860   << off_ ,	//	mov wa =ch_le  get character letter e
/* 17273 */	loadi   | wa     << dst_ | ch_le  << off_ ,
/* 17274 */	stmt    | 5861   << off_ ,	//	sch wa -(xr)  store in work area
/* 17275 */	dca     | xr     << dst_ ,
/* 17276 */	store   | wa     << dst_ | xr     << src_ ,
/* 17277 */	stmt    | 5862   << off_ ,	//	sub wb =num02  decrement counter for sign and e
/* 17278 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 17279 */	sub     | wb     << dst_ | r2     << src_ ,
// gts23:
/* 17280 */	stmt    | 5863   << off_ ,	//gts23	mlr gtssc   convert real to integer (10**cfp_s)
/* 17281 */	load    | r1     << dst_ | gtssc  << off_ ,
/* 17282 */	mlr     | r1     << dst_ ,
/* 17283 */	stmt    | 5864   << off_ ,	//	rti    get integer (overflow impossible)
/* 17284 */	rti     ,
/* 17285 */	stmt    | 5865   << off_ ,	//	ngi    negate as required by cvd
/* 17286 */	ngi     ,
// gts24:
/* 17287 */	stmt    | 5866   << off_ ,	//gts24	bze xl gts27  jump if no digits left to do
/* 17288 */	bze     | xl     << dst_ | gts27  << off_ ,
/* 17289 */	stmt    | 5867   << off_ ,	//	cvd    else convert one digit
/* 17290 */	cvd     ,
/* 17291 */	stmt    | 5868   << off_ ,	//	bne wa =ch_d0 gts26 jump if not a zero
/* 17292 */	loadi   | r2     << dst_ | ch_d0  << off_ ,
/* 17293 */	bne     | wa     << dst_ | r2     << src_ | gts26  << off_ ,
/* 17294 */	stmt    | 5869   << off_ ,	//	dcv xl   decrement counter
/* 17295 */	dcv     | xl     << dst_ ,
/* 17296 */	stmt    | 5870   << off_ ,	//	brn gts24   loop back for next digit
/* 17297 */	brn     | gts24  << off_ ,
// gts25:
/* 17298 */	stmt    | 5871   << off_ ,	//gts25	cvd    convert a digit into wa
/* 17299 */	cvd     ,
// gts26:
/* 17300 */	stmt    | 5872   << off_ ,	//gts26	sch wa -(xr)  store digit
/* 17301 */	dca     | xr     << dst_ ,
/* 17302 */	store   | wa     << dst_ | xr     << src_ ,
/* 17303 */	stmt    | 5873   << off_ ,	//	dcv wb   decrement counter
/* 17304 */	dcv     | wb     << dst_ ,
/* 17305 */	stmt    | 5874   << off_ ,	//	dcv xl   decrement counter
/* 17306 */	dcv     | xl     << dst_ ,
/* 17307 */	stmt    | 5875   << off_ ,	//	bnz xl gts25  loop back if more to go
/* 17308 */	bnz     | xl     << dst_ | gts25  << off_ ,
// gts27:
/* 17309 */	stmt    | 5876   << off_ ,	//gts27	mov wa =ch_dt  load decimal point
/* 17310 */	loadi   | wa     << dst_ | ch_dt  << off_ ,
/* 17311 */	stmt    | 5877   << off_ ,	//	sch wa -(xr)  store in work area
/* 17312 */	dca     | xr     << dst_ ,
/* 17313 */	store   | wa     << dst_ | xr     << src_ ,
/* 17314 */	stmt    | 5878   << off_ ,	//	dcv wb   decrement counter
/* 17315 */	dcv     | wb     << dst_ ,
// gts28:
/* 17316 */	stmt    | 5879   << off_ ,	//gts28	cvd    convert a digit into wa
/* 17317 */	cvd     ,
/* 17318 */	stmt    | 5880   << off_ ,	//	sch wa -(xr)  store in work area
/* 17319 */	dca     | xr     << dst_ ,
/* 17320 */	store   | wa     << dst_ | xr     << src_ ,
/* 17321 */	stmt    | 5881   << off_ ,	//	dcv wb   decrement counter
/* 17322 */	dcv     | wb     << dst_ ,
/* 17323 */	stmt    | 5882   << off_ ,	//	ine gts28   loop back if more to go
/* 17324 */	ine     | gts28  << off_ ,
/* 17325 */	stmt    | 5883   << off_ ,	//	csc xr   complete store characters
/* 17326 */	stmt    | 5884   << off_ ,	//	brn gts08   else jump back to exit
/* 17327 */	brn     | gts08  << off_ ,
// gts29:
/* 17328 */	stmt    | 5885   << off_ ,	//gts29	mov xl (xs)+  restore xl
/* 17329 */	load    | xl     << dst_ | xs     << src_ ,
/* 17330 */	ica     | xs     << dst_ ,
/* 17331 */	stmt    | 5886   << off_ ,	//	ica xs   pop argument
/* 17332 */	ica     | xs     << dst_ ,
/* 17333 */	stmt    | 5887   << off_ ,	//	mov wb gtsvb  restore wb
/* 17334 */	load    | wb     << dst_ | gtsvb  << off_ ,
/* 17335 */	stmt    | 5888   << off_ ,	//	mov wc gtsvc  restore wc
/* 17336 */	load    | wc     << dst_ | gtsvc  << off_ ,
// gts30:
/* 17337 */	stmt    | 5889   << off_ ,	//gts30	mov wa sclen(xr)  load string length
/* 17338 */	load    | wa     << dst_ | xr     << src_ | sclen  << off_ ,
/* 17339 */	stmt    | 5890   << off_ ,	//	exi    return to caller
/* 17340 */	exi     | 700    << off_ ,
// gts31:
/* 17341 */	stmt    | 5891   << off_ ,	//gts31	mov xl =scre0  point to string
/* 17342 */	loadi   | xl     << dst_ | scre0  << off_ ,
/* 17343 */	stmt    | 5892   << off_ ,	//	mov wa =num02  2 chars
/* 17344 */	loadi   | wa     << dst_ | num02  << off_ ,
/* 17345 */	stmt    | 5893   << off_ ,	//	zer wb   zero offset
/* 17346 */	move    | wb     << dst_ ,
/* 17347 */	stmt    | 5894   << off_ ,	//	jsr sbstr   copy string
/* 17348 */	call    | sbstr  << off_ ,
/* 17349 */	stmt    | 5895   << off_ ,	//	brn gts29   return
/* 17350 */	brn     | gts29  << off_ ,
// gtvar:
/* 17351 */	stmt    | 5896   << off_ ,	//gtvar	prc e 1  entry point
/* 17352 */	stmt    | 5897   << off_ ,	//	bne (xr) =b_nml gtvr2 jump if not a name
/* 17353 */	load    | r1     << dst_ | xr     << src_ ,
/* 17354 */	loadi   | r2     << dst_ | b_nml  << off_ ,
/* 17355 */	bne     | r1     << dst_ | r2     << src_ | gtvr2  << off_ ,
/* 17356 */	stmt    | 5898   << off_ ,	//	mov wa nmofs(xr)  else load name offset
/* 17357 */	load    | wa     << dst_ | xr     << src_ | nmofs  << off_ ,
/* 17358 */	stmt    | 5899   << off_ ,	//	mov xl nmbas(xr)  load name base
/* 17359 */	load    | xl     << dst_ | xr     << src_ | nmbas  << off_ ,
/* 17360 */	stmt    | 5900   << off_ ,	//	beq (xl) =b_evt gtvr1 error if expression variable
/* 17361 */	load    | r1     << dst_ | xl     << src_ ,
/* 17362 */	loadi   | r2     << dst_ | b_evt  << off_ ,
/* 17363 */	beq     | r1     << dst_ | r2     << src_ | gtvr1  << off_ ,
/* 17364 */	stmt    | 5901   << off_ ,	//	bne (xl) =b_kvt gtvr3 all ok if not keyword variable
/* 17365 */	load    | r1     << dst_ | xl     << src_ ,
/* 17366 */	loadi   | r2     << dst_ | b_kvt  << off_ ,
/* 17367 */	bne     | r1     << dst_ | r2     << src_ | gtvr3  << off_ ,
// gtvr1:
/* 17368 */	stmt    | 5902   << off_ ,	//gtvr1	exi 1   take convert error exit
/* 17369 */	exi     | 1      << off_ ,
// gtvr2:
/* 17370 */	stmt    | 5903   << off_ ,	//gtvr2	mov gtvrc wc  save wc
/* 17371 */	store   | wc     << dst_ | gtvrc  << off_ ,
/* 17372 */	stmt    | 5904   << off_ ,	//	jsr gtnvr   locate vrblk if possible
/* 17373 */	call    | gtnvr  << off_ ,
/* 17374 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 17375 */	ppm     | gtvr1  << off_ ,
/* 17376 */	stmt    | 5905   << off_ ,	//	mov xl xr  else copy vrblk name base
/* 17377 */	move    | xl     << dst_ | xr     << src_ ,
/* 17378 */	stmt    | 5906   << off_ ,	//	mov wa *vrval  and set offset
/* 17379 */	loadi   | wa     << dst_ | vrval  << off_ ,
/* 17380 */	stmt    | 5907   << off_ ,	//	mov wc gtvrc  restore wc
/* 17381 */	load    | wc     << dst_ | gtvrc  << off_ ,
// gtvr3:
/* 17382 */	stmt    | 5908   << off_ ,	//gtvr3	bhi xl state gtvr4 all ok if not natural variable
/* 17383 */	load    | r2     << dst_ | state  << off_ ,
/* 17384 */	bhi     | xl     << dst_ | r2     << src_ | gtvr4  << off_ ,
/* 17385 */	stmt    | 5909   << off_ ,	//	beq vrsto(xl) =b_vre gtvr1 error if protected variable
/* 17386 */	load    | r1     << dst_ | xl     << src_ | vrsto  << off_ ,
/* 17387 */	loadi   | r2     << dst_ | b_vre  << off_ ,
/* 17388 */	beq     | r1     << dst_ | r2     << src_ | gtvr1  << off_ ,
// gtvr4:
/* 17389 */	stmt    | 5910   << off_ ,	//gtvr4	exi    return to caller
/* 17390 */	exi     | 0      << off_ ,
// hashs:
/* 17391 */	stmt    | 5911   << off_ ,	//hashs	prc e 0  entry point
/* 17392 */	stmt    | 5912   << off_ ,	//	mov wc =e_hnw  get number of words to use
/* 17393 */	loadi   | wc     << dst_ | e_hnw  << off_ ,
/* 17394 */	stmt    | 5913   << off_ ,	//	bze wc hshsa  branch if one character per word
/* 17395 */	bze     | wc     << dst_ | hshsa  << off_ ,
/* 17396 */	stmt    | 5914   << off_ ,	//	mov wc sclen(xr)  load string length in characters
/* 17397 */	load    | wc     << dst_ | xr     << src_ | sclen  << off_ ,
/* 17398 */	stmt    | 5915   << off_ ,	//	mov wb wc  initialize with length
/* 17399 */	move    | wb     << dst_ | wc     << src_ ,
/* 17400 */	stmt    | 5916   << off_ ,	//	bze wc hshs3  jump if null string
/* 17401 */	bze     | wc     << dst_ | hshs3  << off_ ,
/* 17402 */	stmt    | 5917   << off_ ,	//	zgb wb   correct byte ordering if necessary
/* 17403 */	stmt    | 5918   << off_ ,	//	ctw wc 0  get number of words of chars
/* 17404 */	stmt    | 5919   << off_ ,	//	add xr *schar  point to characters of string
/* 17405 */	loadi   | r2     << dst_ | schar  << off_ ,
/* 17406 */	add     | xr     << dst_ | r2     << src_ ,
/* 17407 */	stmt    | 5920   << off_ ,	//	blo wc =e_hnw hshs1 use whole string if short
/* 17408 */	loadi   | r2     << dst_ | e_hnw  << off_ ,
/* 17409 */	blo     | wc     << dst_ | r2     << src_ | hshs1  << off_ ,
/* 17410 */	stmt    | 5921   << off_ ,	//	mov wc =e_hnw  else set to involve first e_hnw wds
/* 17411 */	loadi   | wc     << dst_ | e_hnw  << off_ ,
// hshs1:
/* 17412 */	stmt    | 5922   << off_ ,	//hshs1	lct wc wc  set counter to control loop
// hshs2:
/* 17413 */	stmt    | 5923   << off_ ,	//hshs2	xob wb (xr)+  exclusive or next word of chars
/* 17414 */	load    | r2     << dst_ | xr     << src_ ,
/* 17415 */	ica     | xr     << dst_ ,
/* 17416 */	xob     | wb     << dst_ | r2     << src_ ,
/* 17417 */	stmt    | 5924   << off_ ,	//	bct wc hshs2  loop till all processed
/* 17418 */	bct     | wc     << dst_ | hshs2  << off_ ,
// hshs3:
/* 17419 */	stmt    | 5925   << off_ ,	//hshs3	zgb wb   zeroise undefined bits
/* 17420 */	stmt    | 5926   << off_ ,	//	anb wb 4,bitsm  ensure in range 0 to cfp_m
/* 17421 */	load    | r2     << dst_ | bitsm  << off_ ,
/* 17422 */	anb     | wb     << dst_ | r2     << src_ ,
/* 17423 */	stmt    | 5927   << off_ ,	//	mti wb   move result as integer
/* 17424 */	move    | ia     << dst_ | wb     << src_ ,
/* 17425 */	stmt    | 5928   << off_ ,	//	zer xr   clear garbage value in xr
/* 17426 */	move    | xr     << dst_ ,
/* 17427 */	stmt    | 5929   << off_ ,	//	exi    return to hashs caller
/* 17428 */	exi     | 0      << off_ ,
// hshsa:
/* 17429 */	stmt    | 5930   << off_ ,	//hshsa	mov wc sclen(xr)  load string length in characters
/* 17430 */	load    | wc     << dst_ | xr     << src_ | sclen  << off_ ,
/* 17431 */	stmt    | 5931   << off_ ,	//	mov wb wc  initialize with length
/* 17432 */	move    | wb     << dst_ | wc     << src_ ,
/* 17433 */	stmt    | 5932   << off_ ,	//	bze wc hshs3  jump if null string
/* 17434 */	bze     | wc     << dst_ | hshs3  << off_ ,
/* 17435 */	stmt    | 5933   << off_ ,	//	zgb wb   correct byte ordering if necessary
/* 17436 */	stmt    | 5934   << off_ ,	//	ctw wc 0  get number of words of chars
/* 17437 */	stmt    | 5935   << off_ ,	//	plc xr
/* 17438 */	plc     | xr     << dst_ ,
/* 17439 */	stmt    | 5936   << off_ ,	//	mov -(xs) xl  save xl
/* 17440 */	dca     | xs     << dst_ ,
/* 17441 */	store   | xl     << dst_ | xs     << src_ ,
/* 17442 */	stmt    | 5937   << off_ ,	//	mov xl wc  load length for branch
/* 17443 */	move    | xl     << dst_ | wc     << src_ ,
/* 17444 */	stmt    | 5938   << off_ ,	//	bge xl =num25 hsh24 use first characters if longer
/* 17445 */	loadi   | r2     << dst_ | num25  << off_ ,
/* 17446 */	bge     | xl     << dst_ | r2     << src_ | hsh24  << off_ ,
/* 17447 */	stmt    | 5939   << off_ ,	//	bsw xl 25  merge to compute hash
/* 17448 */	loadi   | r1     << dst_ | 25     << off_ ,
/* 17449 */	bsw     | xl     << dst_ | r1     << src_ ,
/* 17450 */	hsh00   ,
/* 17451 */	hsh01   ,
/* 17452 */	hsh02   ,
/* 17453 */	hsh03   ,
/* 17454 */	hsh04   ,
/* 17455 */	hsh05   ,
/* 17456 */	hsh06   ,
/* 17457 */	hsh07   ,
/* 17458 */	hsh08   ,
/* 17459 */	hsh09   ,
/* 17460 */	hsh10   ,
/* 17461 */	hsh11   ,
/* 17462 */	hsh12   ,
/* 17463 */	hsh13   ,
/* 17464 */	hsh14   ,
/* 17465 */	hsh15   ,
/* 17466 */	hsh16   ,
/* 17467 */	hsh17   ,
/* 17468 */	hsh18   ,
/* 17469 */	hsh19   ,
/* 17470 */	hsh20   ,
/* 17471 */	hsh21   ,
/* 17472 */	hsh22   ,
/* 17473 */	hsh23   ,
/* 17474 */	hsh24   ,
// hsh24:
/* 17475 */	stmt    | 5940   << off_ ,	//hsh24	lch wc (xr)+  load next character
/* 17476 */	load    | wc     << dst_ | xr     << src_ ,
/* 17477 */	ica     | xr     << dst_ ,
/* 17478 */	stmt    | 5941   << off_ ,	//	lsh wc 24  shift for hash
/* 17479 */	lsh     | wc     << dst_ | 24     << off_ ,
/* 17480 */	stmt    | 5942   << off_ ,	//	xob wb wc  hash character
/* 17481 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh23:
/* 17482 */	stmt    | 5943   << off_ ,	//hsh23	lch wc (xr)+  load next character
/* 17483 */	load    | wc     << dst_ | xr     << src_ ,
/* 17484 */	ica     | xr     << dst_ ,
/* 17485 */	stmt    | 5944   << off_ ,	//	lsh wc 16  shift for hash
/* 17486 */	lsh     | wc     << dst_ | 16     << off_ ,
/* 17487 */	stmt    | 5945   << off_ ,	//	xob wb wc  hash character
/* 17488 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh22:
/* 17489 */	stmt    | 5946   << off_ ,	//hsh22	lch wc (xr)+  load next character
/* 17490 */	load    | wc     << dst_ | xr     << src_ ,
/* 17491 */	ica     | xr     << dst_ ,
/* 17492 */	stmt    | 5947   << off_ ,	//	lsh wc 8  shift for hash
/* 17493 */	lsh     | wc     << dst_ | 8      << off_ ,
/* 17494 */	stmt    | 5948   << off_ ,	//	xob wb wc  hash character
/* 17495 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh21:
/* 17496 */	stmt    | 5949   << off_ ,	//hsh21	lch wc (xr)+  load next character
/* 17497 */	load    | wc     << dst_ | xr     << src_ ,
/* 17498 */	ica     | xr     << dst_ ,
/* 17499 */	stmt    | 5950   << off_ ,	//	xob wb wc  hash character
/* 17500 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh20:
/* 17501 */	stmt    | 5951   << off_ ,	//hsh20	lch wc (xr)+  load next character
/* 17502 */	load    | wc     << dst_ | xr     << src_ ,
/* 17503 */	ica     | xr     << dst_ ,
/* 17504 */	stmt    | 5952   << off_ ,	//	lsh wc 24  shift for hash
/* 17505 */	lsh     | wc     << dst_ | 24     << off_ ,
/* 17506 */	stmt    | 5953   << off_ ,	//	xob wb wc  hash character
/* 17507 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh19:
/* 17508 */	stmt    | 5954   << off_ ,	//hsh19	lch wc (xr)+  load next character
/* 17509 */	load    | wc     << dst_ | xr     << src_ ,
/* 17510 */	ica     | xr     << dst_ ,
/* 17511 */	stmt    | 5955   << off_ ,	//	lsh wc 16  shift for hash
/* 17512 */	lsh     | wc     << dst_ | 16     << off_ ,
/* 17513 */	stmt    | 5956   << off_ ,	//	xob wb wc  hash character
/* 17514 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh18:
/* 17515 */	stmt    | 5957   << off_ ,	//hsh18	lch wc (xr)+  load next character
/* 17516 */	load    | wc     << dst_ | xr     << src_ ,
/* 17517 */	ica     | xr     << dst_ ,
/* 17518 */	stmt    | 5958   << off_ ,	//	lsh wc 8  shift for hash
/* 17519 */	lsh     | wc     << dst_ | 8      << off_ ,
/* 17520 */	stmt    | 5959   << off_ ,	//	xob wb wc  hash character
/* 17521 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh17:
/* 17522 */	stmt    | 5960   << off_ ,	//hsh17	lch wc (xr)+  load next character
/* 17523 */	load    | wc     << dst_ | xr     << src_ ,
/* 17524 */	ica     | xr     << dst_ ,
/* 17525 */	stmt    | 5961   << off_ ,	//	xob wb wc  hash character
/* 17526 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh16:
/* 17527 */	stmt    | 5962   << off_ ,	//hsh16	lch wc (xr)+  load next character
/* 17528 */	load    | wc     << dst_ | xr     << src_ ,
/* 17529 */	ica     | xr     << dst_ ,
/* 17530 */	stmt    | 5963   << off_ ,	//	lsh wc 24  shift for hash
/* 17531 */	lsh     | wc     << dst_ | 24     << off_ ,
/* 17532 */	stmt    | 5964   << off_ ,	//	xob wb wc  hash character
/* 17533 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh15:
/* 17534 */	stmt    | 5965   << off_ ,	//hsh15	lch wc (xr)+  load next character
/* 17535 */	load    | wc     << dst_ | xr     << src_ ,
/* 17536 */	ica     | xr     << dst_ ,
/* 17537 */	stmt    | 5966   << off_ ,	//	lsh wc 16  shift for hash
/* 17538 */	lsh     | wc     << dst_ | 16     << off_ ,
/* 17539 */	stmt    | 5967   << off_ ,	//	xob wb wc  hash character
/* 17540 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh14:
/* 17541 */	stmt    | 5968   << off_ ,	//hsh14	lch wc (xr)+  load next character
/* 17542 */	load    | wc     << dst_ | xr     << src_ ,
/* 17543 */	ica     | xr     << dst_ ,
/* 17544 */	stmt    | 5969   << off_ ,	//	lsh wc 8  shift for hash
/* 17545 */	lsh     | wc     << dst_ | 8      << off_ ,
/* 17546 */	stmt    | 5970   << off_ ,	//	xob wb wc  hash character
/* 17547 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh13:
/* 17548 */	stmt    | 5971   << off_ ,	//hsh13	lch wc (xr)+  load next character
/* 17549 */	load    | wc     << dst_ | xr     << src_ ,
/* 17550 */	ica     | xr     << dst_ ,
/* 17551 */	stmt    | 5972   << off_ ,	//	xob wb wc  hash character
/* 17552 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh12:
/* 17553 */	stmt    | 5973   << off_ ,	//hsh12	lch wc (xr)+  load next character
/* 17554 */	load    | wc     << dst_ | xr     << src_ ,
/* 17555 */	ica     | xr     << dst_ ,
/* 17556 */	stmt    | 5974   << off_ ,	//	lsh wc 24  shift for hash
/* 17557 */	lsh     | wc     << dst_ | 24     << off_ ,
/* 17558 */	stmt    | 5975   << off_ ,	//	xob wb wc  hash character
/* 17559 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh11:
/* 17560 */	stmt    | 5976   << off_ ,	//hsh11	lch wc (xr)+  load next character
/* 17561 */	load    | wc     << dst_ | xr     << src_ ,
/* 17562 */	ica     | xr     << dst_ ,
/* 17563 */	stmt    | 5977   << off_ ,	//	lsh wc 16  shift for hash
/* 17564 */	lsh     | wc     << dst_ | 16     << off_ ,
/* 17565 */	stmt    | 5978   << off_ ,	//	xob wb wc  hash character
/* 17566 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh10:
/* 17567 */	stmt    | 5979   << off_ ,	//hsh10	lch wc (xr)+  load next character
/* 17568 */	load    | wc     << dst_ | xr     << src_ ,
/* 17569 */	ica     | xr     << dst_ ,
/* 17570 */	stmt    | 5980   << off_ ,	//	lsh wc 8  shift for hash
/* 17571 */	lsh     | wc     << dst_ | 8      << off_ ,
/* 17572 */	stmt    | 5981   << off_ ,	//	xob wb wc  hash character
/* 17573 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh09:
/* 17574 */	stmt    | 5982   << off_ ,	//hsh09	lch wc (xr)+  load next character
/* 17575 */	load    | wc     << dst_ | xr     << src_ ,
/* 17576 */	ica     | xr     << dst_ ,
/* 17577 */	stmt    | 5983   << off_ ,	//	xob wb wc  hash character
/* 17578 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh08:
/* 17579 */	stmt    | 5984   << off_ ,	//hsh08	lch wc (xr)+  load next character
/* 17580 */	load    | wc     << dst_ | xr     << src_ ,
/* 17581 */	ica     | xr     << dst_ ,
/* 17582 */	stmt    | 5985   << off_ ,	//	lsh wc 24  shift for hash
/* 17583 */	lsh     | wc     << dst_ | 24     << off_ ,
/* 17584 */	stmt    | 5986   << off_ ,	//	xob wb wc  hash character
/* 17585 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh07:
/* 17586 */	stmt    | 5987   << off_ ,	//hsh07	lch wc (xr)+  load next character
/* 17587 */	load    | wc     << dst_ | xr     << src_ ,
/* 17588 */	ica     | xr     << dst_ ,
/* 17589 */	stmt    | 5988   << off_ ,	//	lsh wc 16  shift for hash
/* 17590 */	lsh     | wc     << dst_ | 16     << off_ ,
/* 17591 */	stmt    | 5989   << off_ ,	//	xob wb wc  hash character
/* 17592 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh06:
/* 17593 */	stmt    | 5990   << off_ ,	//hsh06	lch wc (xr)+  load next character
/* 17594 */	load    | wc     << dst_ | xr     << src_ ,
/* 17595 */	ica     | xr     << dst_ ,
/* 17596 */	stmt    | 5991   << off_ ,	//	lsh wc 8  shift for hash
/* 17597 */	lsh     | wc     << dst_ | 8      << off_ ,
/* 17598 */	stmt    | 5992   << off_ ,	//	xob wb wc  hash character
/* 17599 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh05:
/* 17600 */	stmt    | 5993   << off_ ,	//hsh05	lch wc (xr)+  load next character
/* 17601 */	load    | wc     << dst_ | xr     << src_ ,
/* 17602 */	ica     | xr     << dst_ ,
/* 17603 */	stmt    | 5994   << off_ ,	//	xob wb wc  hash character
/* 17604 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh04:
/* 17605 */	stmt    | 5995   << off_ ,	//hsh04	lch wc (xr)+  load next character
/* 17606 */	load    | wc     << dst_ | xr     << src_ ,
/* 17607 */	ica     | xr     << dst_ ,
/* 17608 */	stmt    | 5996   << off_ ,	//	lsh wc 24  shift for hash
/* 17609 */	lsh     | wc     << dst_ | 24     << off_ ,
/* 17610 */	stmt    | 5997   << off_ ,	//	xob wb wc  hash character
/* 17611 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh03:
/* 17612 */	stmt    | 5998   << off_ ,	//hsh03	lch wc (xr)+  load next character
/* 17613 */	load    | wc     << dst_ | xr     << src_ ,
/* 17614 */	ica     | xr     << dst_ ,
/* 17615 */	stmt    | 5999   << off_ ,	//	lsh wc 16  shift for hash
/* 17616 */	lsh     | wc     << dst_ | 16     << off_ ,
/* 17617 */	stmt    | 6000   << off_ ,	//	xob wb wc  hash character
/* 17618 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh02:
/* 17619 */	stmt    | 6001   << off_ ,	//hsh02	lch wc (xr)+  load next character
/* 17620 */	load    | wc     << dst_ | xr     << src_ ,
/* 17621 */	ica     | xr     << dst_ ,
/* 17622 */	stmt    | 6002   << off_ ,	//	lsh wc 8  shift for hash
/* 17623 */	lsh     | wc     << dst_ | 8      << off_ ,
/* 17624 */	stmt    | 6003   << off_ ,	//	xob wb wc  hash character
/* 17625 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh01:
/* 17626 */	stmt    | 6004   << off_ ,	//hsh01	lch wc (xr)+  load next character
/* 17627 */	load    | wc     << dst_ | xr     << src_ ,
/* 17628 */	ica     | xr     << dst_ ,
/* 17629 */	stmt    | 6005   << off_ ,	//	xob wb wc  hash character
/* 17630 */	xob     | wb     << dst_ | wc     << src_ ,
// hsh00:
/* 17631 */	stmt    | 6006   << off_ ,	//hsh00	mov xl (xs)+  restore xl
/* 17632 */	load    | xl     << dst_ | xs     << src_ ,
/* 17633 */	ica     | xs     << dst_ ,
/* 17634 */	stmt    | 6007   << off_ ,	//	brn hshs3   merge to complete hash
/* 17635 */	brn     | hshs3  << off_ ,
// icbld:
/* 17636 */	stmt    | 6008   << off_ ,	//icbld	prc e 0  entry point
/* 17637 */	stmt    | 6009   << off_ ,	//	mfi xr icbl1  copy small integers
/* 17638 */	move    | xr     << dst_ | ia     << src_ ,
/* 17639 */	mfi     | icbl1  << off_ ,
/* 17640 */	stmt    | 6010   << off_ ,	//	ble xr =num02 icbl3 jump if 0,1 or 2
/* 17641 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 17642 */	ble     | xr     << dst_ | r2     << src_ | icbl3  << off_ ,
// icbl1:
/* 17643 */	stmt    | 6011   << off_ ,	//icbl1	mov xr dnamp  load pointer to next available loc
/* 17644 */	load    | xr     << dst_ | dnamp  << off_ ,
/* 17645 */	stmt    | 6012   << off_ ,	//	add xr *icsi_  point past new icblk
/* 17646 */	loadi   | r2     << dst_ | icsi_  << off_ ,
/* 17647 */	add     | xr     << dst_ | r2     << src_ ,
/* 17648 */	stmt    | 6013   << off_ ,	//	blo xr dname icbl2 jump if there is room
/* 17649 */	load    | r2     << dst_ | dname  << off_ ,
/* 17650 */	blo     | xr     << dst_ | r2     << src_ | icbl2  << off_ ,
/* 17651 */	stmt    | 6014   << off_ ,	//	mov wa *icsi_  else load length of icblk
/* 17652 */	loadi   | wa     << dst_ | icsi_  << off_ ,
/* 17653 */	stmt    | 6015   << off_ ,	//	jsr alloc   use standard allocator to get block
/* 17654 */	call    | alloc  << off_ ,
/* 17655 */	stmt    | 6016   << off_ ,	//	add xr wa  point past block to merge
/* 17656 */	add     | xr     << dst_ | wa     << src_ ,
// icbl2:
/* 17657 */	stmt    | 6017   << off_ ,	//icbl2	mov dnamp xr  set new pointer
/* 17658 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 17659 */	stmt    | 6018   << off_ ,	//	sub xr *icsi_  point back to start of block
/* 17660 */	loadi   | r2     << dst_ | icsi_  << off_ ,
/* 17661 */	sub     | xr     << dst_ | r2     << src_ ,
/* 17662 */	stmt    | 6019   << off_ ,	//	mov (xr) =b_icl  store type word
/* 17663 */	loadi   | r1     << dst_ | b_icl  << off_ ,
/* 17664 */	store   | r1     << dst_ | xr     << src_ ,
/* 17665 */	stmt    | 6020   << off_ ,	//	sti icval(xr)   store integer value in icblk
/* 17666 */	store   | ia     << dst_ | xr     << src_ | icval  << off_ ,
/* 17667 */	stmt    | 6021   << off_ ,	//	exi    return to icbld caller
/* 17668 */	exi     | 0      << off_ ,
// icbl3:
/* 17669 */	stmt    | 6022   << off_ ,	//icbl3	wtb xr   convert integer to offset
/* 17670 */	stmt    | 6023   << off_ ,	//	mov xr 14,intab(xr)  point to pre-built icblk
/* 17671 */	load    | xr     << dst_ | xr     << src_ | intab  << off_ ,
/* 17672 */	stmt    | 6024   << off_ ,	//	exi    return
/* 17673 */	exi     | 0      << off_ ,
// ident:
/* 17674 */	stmt    | 6025   << off_ ,	//ident	prc e 1  entry point
/* 17675 */	stmt    | 6026   << off_ ,	//	beq xr xl iden7 jump if same pointer (ident)
/* 17676 */	beq     | xr     << dst_ | xl     << src_ | iden7  << off_ ,
/* 17677 */	stmt    | 6027   << off_ ,	//	mov wc (xr)  else load arg 1 type word
/* 17678 */	load    | wc     << dst_ | xr     << src_ ,
/* 17679 */	stmt    | 6028   << off_ ,	//	bne wc (xl) iden1 differ if arg 2 type word differ
/* 17680 */	load    | r2     << dst_ | xl     << src_ ,
/* 17681 */	bne     | wc     << dst_ | r2     << src_ | iden1  << off_ ,
/* 17682 */	stmt    | 6029   << off_ ,	//	beq wc =b_scl iden2 jump if strings
/* 17683 */	loadi   | r2     << dst_ | b_scl  << off_ ,
/* 17684 */	beq     | wc     << dst_ | r2     << src_ | iden2  << off_ ,
/* 17685 */	stmt    | 6030   << off_ ,	//	beq wc =b_icl iden4 jump if integers
/* 17686 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/* 17687 */	beq     | wc     << dst_ | r2     << src_ | iden4  << off_ ,
/* 17688 */	stmt    | 6031   << off_ ,	//	beq wc =b_rcl iden5 jump if reals
/* 17689 */	loadi   | r2     << dst_ | b_rcl  << off_ ,
/* 17690 */	beq     | wc     << dst_ | r2     << src_ | iden5  << off_ ,
/* 17691 */	stmt    | 6032   << off_ ,	//	beq wc =b_nml iden6 jump if names
/* 17692 */	loadi   | r2     << dst_ | b_nml  << off_ ,
/* 17693 */	beq     | wc     << dst_ | r2     << src_ | iden6  << off_ ,
// iden1:
/* 17694 */	stmt    | 6033   << off_ ,	//iden1	exi    take differ exit
/* 17695 */	exi     | 0      << off_ ,
// iden2:
/* 17696 */	stmt    | 6034   << off_ ,	//iden2	mov wc sclen(xr)  load arg 1 length
/* 17697 */	load    | wc     << dst_ | xr     << src_ | sclen  << off_ ,
/* 17698 */	stmt    | 6035   << off_ ,	//	bne wc sclen(xl) iden1 differ if lengths differ
/* 17699 */	load    | r2     << dst_ | xl     << src_ | sclen  << off_ ,
/* 17700 */	bne     | wc     << dst_ | r2     << src_ | iden1  << off_ ,
// idn2a:
/* 17701 */	stmt    | 6036   << off_ ,	//idn2a	add xr *schar  point to chars of arg 1
/* 17702 */	loadi   | r2     << dst_ | schar  << off_ ,
/* 17703 */	add     | xr     << dst_ | r2     << src_ ,
/* 17704 */	stmt    | 6037   << off_ ,	//	add xl *schar  point to chars of arg 2
/* 17705 */	loadi   | r2     << dst_ | schar  << off_ ,
/* 17706 */	add     | xl     << dst_ | r2     << src_ ,
/* 17707 */	stmt    | 6038   << off_ ,	//	ctw wc 0  get number of words in strings
/* 17708 */	stmt    | 6039   << off_ ,	//	lct wc wc  set loop counter
// iden3:
/* 17709 */	stmt    | 6040   << off_ ,	//iden3	cne (xr) (xl) iden8 differ if chars do not match
/* 17710 */	load    | r1     << dst_ | xr     << src_ ,
/* 17711 */	load    | r2     << dst_ | xl     << src_ ,
/* 17712 */	cne     | r1     << dst_ | r2     << src_ | iden8  << off_ ,
/* 17713 */	stmt    | 6041   << off_ ,	//	ica xr   else bump arg one pointer
/* 17714 */	ica     | xr     << dst_ ,
/* 17715 */	stmt    | 6042   << off_ ,	//	ica xl   bump arg two pointer
/* 17716 */	ica     | xl     << dst_ ,
/* 17717 */	stmt    | 6043   << off_ ,	//	bct wc iden3  loop back till all checked
/* 17718 */	bct     | wc     << dst_ | iden3  << off_ ,
/* 17719 */	stmt    | 6044   << off_ ,	//	zer xl   clear garbage value in xl
/* 17720 */	move    | xl     << dst_ ,
/* 17721 */	stmt    | 6045   << off_ ,	//	zer xr   clear garbage value in xr
/* 17722 */	move    | xr     << dst_ ,
/* 17723 */	stmt    | 6046   << off_ ,	//	exi 1   take ident exit
/* 17724 */	exi     | 1      << off_ ,
// iden4:
/* 17725 */	stmt    | 6047   << off_ ,	//iden4	ldi icval(xr)   load arg 1
/* 17726 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/* 17727 */	ldi     | r1     << dst_ ,
/* 17728 */	stmt    | 6048   << off_ ,	//	sbi icval(xl)   subtract arg 2 to compare
/* 17729 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/* 17730 */	sbi     | r1     << dst_ ,
/* 17731 */	stmt    | 6049   << off_ ,	//	iov iden1   differ if overflow
/* 17732 */	iov     | iden1  << off_ ,
/* 17733 */	stmt    | 6050   << off_ ,	//	ine iden1   differ if result is not zero
/* 17734 */	ine     | iden1  << off_ ,
/* 17735 */	stmt    | 6051   << off_ ,	//	exi 1   take ident exit
/* 17736 */	exi     | 1      << off_ ,
// iden5:
/* 17737 */	stmt    | 6052   << off_ ,	//iden5	ldr rcval(xr)   load arg 1
/* 17738 */	load    | r1     << dst_ | xr     << src_ | rcval  << off_ ,
/* 17739 */	ldr     | r1     << dst_ ,
/* 17740 */	stmt    | 6053   << off_ ,	//	sbr rcval(xl)   subtract arg 2 to compare
/* 17741 */	load    | r1     << dst_ | xl     << src_ | rcval  << off_ ,
/* 17742 */	sbr     | r1     << dst_ ,
/* 17743 */	stmt    | 6054   << off_ ,	//	rov iden1   differ if overflow
/* 17744 */	rov     | iden1  << off_ ,
/* 17745 */	stmt    | 6055   << off_ ,	//	rne iden1   differ if result is not zero
/* 17746 */	rne     | iden1  << off_ ,
/* 17747 */	stmt    | 6056   << off_ ,	//	exi 1   take ident exit
/* 17748 */	exi     | 1      << off_ ,
// iden6:
/* 17749 */	stmt    | 6057   << off_ ,	//iden6	bne nmofs(xr) nmofs(xl) iden1 differ if different offset
/* 17750 */	load    | r1     << dst_ | xr     << src_ | nmofs  << off_ ,
/* 17751 */	load    | r2     << dst_ | xl     << src_ | nmofs  << off_ ,
/* 17752 */	bne     | r1     << dst_ | r2     << src_ | iden1  << off_ ,
/* 17753 */	stmt    | 6058   << off_ ,	//	bne nmbas(xr) nmbas(xl) iden1 differ if different base
/* 17754 */	load    | r1     << dst_ | xr     << src_ | nmbas  << off_ ,
/* 17755 */	load    | r2     << dst_ | xl     << src_ | nmbas  << off_ ,
/* 17756 */	bne     | r1     << dst_ | r2     << src_ | iden1  << off_ ,
// iden7:
/* 17757 */	stmt    | 6059   << off_ ,	//iden7	exi 1   take ident exit
/* 17758 */	exi     | 1      << off_ ,
// iden8:
/* 17759 */	stmt    | 6060   << off_ ,	//iden8	zer xr   clear garbage ptr in xr
/* 17760 */	move    | xr     << dst_ ,
/* 17761 */	stmt    | 6061   << off_ ,	//	zer xl   clear garbage ptr in xl
/* 17762 */	move    | xl     << dst_ ,
/* 17763 */	stmt    | 6062   << off_ ,	//	exi    return to caller (differ)
/* 17764 */	exi     | 0      << off_ ,
// inout:
/* 17765 */	stmt    | 6063   << off_ ,	//inout	prc e 0  entry point
/* 17766 */	stmt    | 6064   << off_ ,	//	mov -(xs) wb  stack trblk type
/* 17767 */	dca     | xs     << dst_ ,
/* 17768 */	store   | wb     << dst_ | xs     << src_ ,
/* 17769 */	stmt    | 6065   << off_ ,	//	mov wa sclen(xl)  get name length
/* 17770 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/* 17771 */	stmt    | 6066   << off_ ,	//	zer wb   point to start of name
/* 17772 */	move    | wb     << dst_ ,
/* 17773 */	stmt    | 6067   << off_ ,	//	jsr sbstr   build a proper scblk
/* 17774 */	call    | sbstr  << off_ ,
/* 17775 */	stmt    | 6068   << off_ ,	//	jsr gtnvr   build vrblk
/* 17776 */	call    | gtnvr  << off_ ,
/* 17777 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 17778 */	ppm     ,
/* 17779 */	stmt    | 6069   << off_ ,	//	mov wc xr  save vrblk pointer
/* 17780 */	move    | wc     << dst_ | xr     << src_ ,
/* 17781 */	stmt    | 6070   << off_ ,	//	mov wb (xs)+  get trter field
/* 17782 */	load    | wb     << dst_ | xs     << src_ ,
/* 17783 */	ica     | xs     << dst_ ,
/* 17784 */	stmt    | 6071   << off_ ,	//	zer xl   zero trfpt
/* 17785 */	move    | xl     << dst_ ,
/* 17786 */	stmt    | 6072   << off_ ,	//	jsr trbld   build trblk
/* 17787 */	call    | trbld  << off_ ,
/* 17788 */	stmt    | 6073   << off_ ,	//	mov xl wc  recall vrblk pointer
/* 17789 */	move    | xl     << dst_ | wc     << src_ ,
/* 17790 */	stmt    | 6074   << off_ ,	//	mov trter(xr) vrsvp(xl)  store svblk pointer
/* 17791 */	load    | r1     << dst_ | xl     << src_ | vrsvp  << off_ ,
/* 17792 */	store   | r1     << dst_ | xr     << src_ | trter  << off_ ,
/* 17793 */	stmt    | 6075   << off_ ,	//	mov vrval(xl) xr  store trblk ptr in vrblk
/* 17794 */	store   | xr     << dst_ | xl     << src_ | vrval  << off_ ,
/* 17795 */	stmt    | 6076   << off_ ,	//	mov vrget(xl) =b_vra  set trapped access
/* 17796 */	loadi   | r1     << dst_ | b_vra  << off_ ,
/* 17797 */	store   | r1     << dst_ | xl     << src_ | vrget  << off_ ,
/* 17798 */	stmt    | 6077   << off_ ,	//	mov vrsto(xl) =b_vrv  set trapped store
/* 17799 */	loadi   | r1     << dst_ | b_vrv  << off_ ,
/* 17800 */	store   | r1     << dst_ | xl     << src_ | vrsto  << off_ ,
/* 17801 */	stmt    | 6078   << off_ ,	//	exi    return to caller
/* 17802 */	exi     | 0      << off_ ,
// insta:
/* 17803 */	stmt    | 6079   << off_ ,	//insta	prc e 0  entry point
/* 17804 */	stmt    | 6080   << off_ ,	//	mov wc prlen  no. of chars in print bfr
/* 17805 */	load    | wc     << dst_ | prlen  << off_ ,
/* 17806 */	stmt    | 6081   << off_ ,	//	mov prbuf xr  print bfr is put at static start
/* 17807 */	store   | xr     << dst_ | prbuf  << off_ ,
/* 17808 */	stmt    | 6082   << off_ ,	//	mov (xr)+ =b_scl  store string type code
/* 17809 */	loadi   | r1     << dst_ | b_scl  << off_ ,
/* 17810 */	store   | r1     << dst_ | xr     << src_ ,
/* 17811 */	ica     | xr     << dst_ ,
/* 17812 */	stmt    | 6083   << off_ ,	//	mov (xr)+ wc  and string length
/* 17813 */	store   | wc     << dst_ | xr     << src_ ,
/* 17814 */	ica     | xr     << dst_ ,
/* 17815 */	stmt    | 6084   << off_ ,	//	ctw wc 0  get number of words in buffer
/* 17816 */	stmt    | 6085   << off_ ,	//	mov prlnw wc  store for buffer clear
/* 17817 */	store   | wc     << dst_ | prlnw  << off_ ,
/* 17818 */	stmt    | 6086   << off_ ,	//	lct wc wc  words to clear
// inst1:
/* 17819 */	stmt    | 6087   << off_ ,	//inst1	mov (xr)+ 4,nullw  store blank
/* 17820 */	load    | r1     << dst_ | nullw  << off_ ,
/* 17821 */	store   | r1     << dst_ | xr     << src_ ,
/* 17822 */	ica     | xr     << dst_ ,
/* 17823 */	stmt    | 6088   << off_ ,	//	bct wc inst1  loop
/* 17824 */	bct     | wc     << dst_ | inst1  << off_ ,
/* 17825 */	stmt    | 6089   << off_ ,	//	mov wa =nstmx  get max num chars in output number
/* 17826 */	loadi   | wa     << dst_ | nstmx  << off_ ,
/* 17827 */	stmt    | 6090   << off_ ,	//	ctb wa scsi_  no of bytes needed
/* 17828 */	ctb     | wa     << dst_ | scsi_  << off_ ,
/* 17829 */	stmt    | 6091   << off_ ,	//	mov gtswk xr  store bfr adrs
/* 17830 */	store   | xr     << dst_ | gtswk  << off_ ,
/* 17831 */	stmt    | 6092   << off_ ,	//	add xr wa  bump for work bfr
/* 17832 */	add     | xr     << dst_ | wa     << src_ ,
/* 17833 */	stmt    | 6093   << off_ ,	//	mov kvalp xr  save alphabet pointer
/* 17834 */	store   | xr     << dst_ | kvalp  << off_ ,
/* 17835 */	stmt    | 6094   << off_ ,	//	mov (xr) =b_scl  string blk type
/* 17836 */	loadi   | r1     << dst_ | b_scl  << off_ ,
/* 17837 */	store   | r1     << dst_ | xr     << src_ ,
/* 17838 */	stmt    | 6095   << off_ ,	//	mov wc =cfp_a  no of chars in alphabet
/* 17839 */	loadi   | wc     << dst_ | cfp_a  << off_ ,
/* 17840 */	stmt    | 6096   << off_ ,	//	mov sclen(xr) wc  store as string length
/* 17841 */	store   | wc     << dst_ | xr     << src_ | sclen  << off_ ,
/* 17842 */	stmt    | 6097   << off_ ,	//	mov wb wc  copy char count
/* 17843 */	move    | wb     << dst_ | wc     << src_ ,
/* 17844 */	stmt    | 6098   << off_ ,	//	ctb wb scsi_  no. of bytes needed
/* 17845 */	ctb     | wb     << dst_ | scsi_  << off_ ,
/* 17846 */	stmt    | 6099   << off_ ,	//	add wb xr  current end address for static
/* 17847 */	add     | wb     << dst_ | xr     << src_ ,
/* 17848 */	stmt    | 6100   << off_ ,	//	mov wa wb  save adrs past alphabet string
/* 17849 */	move    | wa     << dst_ | wb     << src_ ,
/* 17850 */	stmt    | 6101   << off_ ,	//	lct wc wc  loop counter
/* 17851 */	stmt    | 6102   << off_ ,	//	psc xr   point to chars of string
/* 17852 */	psc     | xr     << dst_ ,
/* 17853 */	stmt    | 6103   << off_ ,	//	zer wb   set initial character value
/* 17854 */	move    | wb     << dst_ ,
// inst2:
/* 17855 */	stmt    | 6104   << off_ ,	//inst2	sch wb (xr)+  store next code
/* 17856 */	store   | wb     << dst_ | xr     << src_ ,
/* 17857 */	ica     | xr     << dst_ ,
/* 17858 */	stmt    | 6105   << off_ ,	//	icv wb   bump code value
/* 17859 */	icv     | wb     << dst_ ,
/* 17860 */	stmt    | 6106   << off_ ,	//	bct wc inst2  loop till all stored
/* 17861 */	bct     | wc     << dst_ | inst2  << off_ ,
/* 17862 */	stmt    | 6107   << off_ ,	//	csc xr   complete store characters
/* 17863 */	stmt    | 6108   << off_ ,	//	mov xr wa  return current static ptr
/* 17864 */	move    | xr     << dst_ | wa     << src_ ,
/* 17865 */	stmt    | 6109   << off_ ,	//	exi    return to caller
/* 17866 */	exi     | 0      << off_ ,
// iofcb:
/* 17867 */	stmt    | 6110   << off_ ,	//iofcb	prc n 3  entry point
/* 17868 */	prc     | 8      << off_ ,
/* 17869 */	stmt    | 6111   << off_ ,	//	jsr gtstg   get arg as string
/* 17870 */	call    | gtstg  << off_ ,
/* 17871 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 17872 */	ppm     | iofc2  << off_ ,
/* 17873 */	stmt    | 6112   << off_ ,	//	mov xl xr  copy string ptr
/* 17874 */	move    | xl     << dst_ | xr     << src_ ,
/* 17875 */	stmt    | 6113   << off_ ,	//	jsr gtnvr   get as natural variable
/* 17876 */	call    | gtnvr  << off_ ,
/* 17877 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 17878 */	ppm     | iofc3  << off_ ,
/* 17879 */	stmt    | 6114   << off_ ,	//	mov wb xl  copy string pointer again
/* 17880 */	move    | wb     << dst_ | xl     << src_ ,
/* 17881 */	stmt    | 6115   << off_ ,	//	mov xl xr  copy vrblk ptr for return
/* 17882 */	move    | xl     << dst_ | xr     << src_ ,
/* 17883 */	stmt    | 6116   << off_ ,	//	zer wa   in case no trblk found
/* 17884 */	move    | wa     << dst_ ,
// iofc1:
/* 17885 */	stmt    | 6117   << off_ ,	//iofc1	mov xr vrval(xr)  get possible trblk ptr
/* 17886 */	load    | xr     << dst_ | xr     << src_ | vrval  << off_ ,
/* 17887 */	stmt    | 6118   << off_ ,	//	bne (xr) =b_trt iofc4 fail if end of chain
/* 17888 */	load    | r1     << dst_ | xr     << src_ ,
/* 17889 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 17890 */	bne     | r1     << dst_ | r2     << src_ | iofc4  << off_ ,
/* 17891 */	stmt    | 6119   << off_ ,	//	bne trtyp(xr) =trtfc iofc1 loop if not file arg trblk
/* 17892 */	load    | r1     << dst_ | xr     << src_ | trtyp  << off_ ,
/* 17893 */	loadi   | r2     << dst_ | trtfc  << off_ ,
/* 17894 */	bne     | r1     << dst_ | r2     << src_ | iofc1  << off_ ,
/* 17895 */	stmt    | 6120   << off_ ,	//	mov wa trfpt(xr)  get fcblk ptr
/* 17896 */	load    | wa     << dst_ | xr     << src_ | trfpt  << off_ ,
/* 17897 */	stmt    | 6121   << off_ ,	//	mov xr wb  copy arg
/* 17898 */	move    | xr     << dst_ | wb     << src_ ,
/* 17899 */	stmt    | 6122   << off_ ,	//	exi    return
/* 17900 */	exi     | 800    << off_ ,
// iofc2:
/* 17901 */	stmt    | 6123   << off_ ,	//iofc2	exi 1   fail
/* 17902 */	exi     | 801    << off_ ,
// iofc3:
/* 17903 */	stmt    | 6124   << off_ ,	//iofc3	exi 2   null arg return
/* 17904 */	exi     | 802    << off_ ,
// iofc4:
/* 17905 */	stmt    | 6125   << off_ ,	//iofc4	exi 3   file not found return
/* 17906 */	exi     | 803    << off_ ,
// ioppf:
/* 17907 */	stmt    | 6126   << off_ ,	//ioppf	prc n 0  entry point
/* 17908 */	prc     | 9      << off_ ,
/* 17909 */	stmt    | 6127   << off_ ,	//	zer wb   to count fields extracted
/* 17910 */	move    | wb     << dst_ ,
// iopp1:
/* 17911 */	stmt    | 6128   << off_ ,	//iopp1	mov xl =iodel  get delimiter
/* 17912 */	loadi   | xl     << dst_ | iodel  << off_ ,
/* 17913 */	stmt    | 6129   << off_ ,	//	mov wc xl  copy it
/* 17914 */	move    | wc     << dst_ | xl     << src_ ,
/* 17915 */	stmt    | 6130   << off_ ,	//	zer wa   retain leading blanks in filearg2
/* 17916 */	move    | wa     << dst_ ,
/* 17917 */	stmt    | 6131   << off_ ,	//	jsr xscan   get next field
/* 17918 */	call    | xscan  << off_ ,
/* 17919 */	stmt    | 6132   << off_ ,	//	mov -(xs) xr  stack it
/* 17920 */	dca     | xs     << dst_ ,
/* 17921 */	store   | xr     << dst_ | xs     << src_ ,
/* 17922 */	stmt    | 6133   << off_ ,	//	icv wb   increment count
/* 17923 */	icv     | wb     << dst_ ,
/* 17924 */	stmt    | 6134   << off_ ,	//	bnz wa iopp1  loop
/* 17925 */	bnz     | wa     << dst_ | iopp1  << off_ ,
/* 17926 */	stmt    | 6135   << off_ ,	//	mov wc wb  count of fields
/* 17927 */	move    | wc     << dst_ | wb     << src_ ,
/* 17928 */	stmt    | 6136   << off_ ,	//	mov wb ioptt  i/o marker
/* 17929 */	load    | wb     << dst_ | ioptt  << off_ ,
/* 17930 */	stmt    | 6137   << off_ ,	//	mov wa r_iof  fcblk ptr or 0
/* 17931 */	load    | wa     << dst_ | r_iof  << off_ ,
/* 17932 */	stmt    | 6138   << off_ ,	//	mov xr r_io2  file arg2 ptr
/* 17933 */	load    | xr     << dst_ | r_io2  << off_ ,
/* 17934 */	stmt    | 6139   << off_ ,	//	mov xl r_io1  filearg1
/* 17935 */	load    | xl     << dst_ | r_io1  << off_ ,
/* 17936 */	stmt    | 6140   << off_ ,	//	exi    return
/* 17937 */	exi     | 900    << off_ ,
// ioput:
/* 17938 */	stmt    | 6141   << off_ ,	//ioput	prc n 7  entry point
/* 17939 */	prc     | 10     << off_ ,
/* 17940 */	stmt    | 6142   << off_ ,	//	zer r_iot   in case no trtrf block used
/* 17941 */	store   | r0     << dst_ | r_iot  << off_ ,
/* 17942 */	stmt    | 6143   << off_ ,	//	zer r_iof   in case no fcblk alocated
/* 17943 */	store   | r0     << dst_ | r_iof  << off_ ,
/* 17944 */	stmt    | 6144   << off_ ,	//	zer r_iop   in case sysio fails
/* 17945 */	store   | r0     << dst_ | r_iop  << off_ ,
/* 17946 */	stmt    | 6145   << off_ ,	//	mov ioptt wb  store i/o trace type
/* 17947 */	store   | wb     << dst_ | ioptt  << off_ ,
/* 17948 */	stmt    | 6146   << off_ ,	//	jsr xscni   prepare to scan filearg2
/* 17949 */	call    | xscni  << off_ ,
/* 17950 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/* 17951 */	ppm     | iop13  << off_ ,
/* 17952 */	ppm     | iopa0  << off_ ,
// iopa0:
/* 17953 */	stmt    | 6147   << off_ ,	//iopa0	mov r_io2 xr  keep file arg2
/* 17954 */	store   | xr     << dst_ | r_io2  << off_ ,
/* 17955 */	stmt    | 6148   << off_ ,	//	mov xl wa  copy length
/* 17956 */	move    | xl     << dst_ | wa     << src_ ,
/* 17957 */	stmt    | 6149   << off_ ,	//	jsr gtstg   convert filearg1 to string
/* 17958 */	call    | gtstg  << off_ ,
/* 17959 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 17960 */	ppm     | iop14  << off_ ,
/* 17961 */	stmt    | 6150   << off_ ,	//	mov r_io1 xr  keep filearg1 ptr
/* 17962 */	store   | xr     << dst_ | r_io1  << off_ ,
/* 17963 */	stmt    | 6151   << off_ ,	//	jsr gtnvr   convert to natural variable
/* 17964 */	call    | gtnvr  << off_ ,
/* 17965 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 17966 */	ppm     | iop00  << off_ ,
/* 17967 */	stmt    | 6152   << off_ ,	//	brn iop04   jump to process non-null args
/* 17968 */	brn     | iop04  << off_ ,
// iop00:
/* 17969 */	stmt    | 6153   << off_ ,	//iop00	bze xl iop01  skip if both args null
/* 17970 */	bze     | xl     << dst_ | iop01  << off_ ,
/* 17971 */	stmt    | 6154   << off_ ,	//	jsr ioppf   process filearg2
/* 17972 */	call    | ioppf  << off_ ,
/* 17973 */	stmt    | 6155   << off_ ,	//	jsr sysfc   call for filearg2 check
/* 17974 */	sys     | sysfc_ << off_ ,
/* 17975 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/* 17976 */	ppm     | iop16  << off_ ,
/* 17977 */	ppm     | iop26  << off_ ,
/* 17978 */	stmt    | 6156   << off_ ,	//	brn iop11   complete file association
/* 17979 */	brn     | iop11  << off_ ,
// iop01:
/* 17980 */	stmt    | 6157   << off_ ,	//iop01	mov wb ioptt  get trace type
/* 17981 */	load    | wb     << dst_ | ioptt  << off_ ,
/* 17982 */	stmt    | 6158   << off_ ,	//	mov xr r_iot  get 0 or trtrf ptr
/* 17983 */	load    | xr     << dst_ | r_iot  << off_ ,
/* 17984 */	stmt    | 6159   << off_ ,	//	jsr trbld   build trblk
/* 17985 */	call    | trbld  << off_ ,
/* 17986 */	stmt    | 6160   << off_ ,	//	mov wc xr  copy trblk pointer
/* 17987 */	move    | wc     << dst_ | xr     << src_ ,
/* 17988 */	stmt    | 6161   << off_ ,	//	mov xr (xs)+  get variable from stack
/* 17989 */	load    | xr     << dst_ | xs     << src_ ,
/* 17990 */	ica     | xs     << dst_ ,
/* 17991 */	stmt    | 6162   << off_ ,	//	mov -(xs) wc  make trblk collectable
/* 17992 */	dca     | xs     << dst_ ,
/* 17993 */	store   | wc     << dst_ | xs     << src_ ,
/* 17994 */	stmt    | 6163   << off_ ,	//	jsr gtvar   point to variable
/* 17995 */	call    | gtvar  << off_ ,
/* 17996 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 17997 */	ppm     | iop15  << off_ ,
/* 17998 */	stmt    | 6164   << off_ ,	//	mov wc (xs)+  recover trblk pointer
/* 17999 */	load    | wc     << dst_ | xs     << src_ ,
/* 18000 */	ica     | xs     << dst_ ,
/* 18001 */	stmt    | 6165   << off_ ,	//	mov r_ion xl  save name pointer
/* 18002 */	store   | xl     << dst_ | r_ion  << off_ ,
/* 18003 */	stmt    | 6166   << off_ ,	//	mov xr xl  copy name pointer
/* 18004 */	move    | xr     << dst_ | xl     << src_ ,
/* 18005 */	stmt    | 6167   << off_ ,	//	add xr wa  point to variable
/* 18006 */	add     | xr     << dst_ | wa     << src_ ,
/* 18007 */	stmt    | 6168   << off_ ,	//	sub xr *vrval  subtract offset,merge into loop
/* 18008 */	loadi   | r2     << dst_ | vrval  << off_ ,
/* 18009 */	sub     | xr     << dst_ | r2     << src_ ,
// iop02:
/* 18010 */	stmt    | 6169   << off_ ,	//iop02	mov xl xr  copy blk ptr
/* 18011 */	move    | xl     << dst_ | xr     << src_ ,
/* 18012 */	stmt    | 6170   << off_ ,	//	mov xr vrval(xr)  load ptr to next trblk
/* 18013 */	load    | xr     << dst_ | xr     << src_ | vrval  << off_ ,
/* 18014 */	stmt    | 6171   << off_ ,	//	bne (xr) =b_trt iop03 jump if not trapped
/* 18015 */	load    | r1     << dst_ | xr     << src_ ,
/* 18016 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 18017 */	bne     | r1     << dst_ | r2     << src_ | iop03  << off_ ,
/* 18018 */	stmt    | 6172   << off_ ,	//	bne trtyp(xr) ioptt iop02 loop if not same assocn
/* 18019 */	load    | r1     << dst_ | xr     << src_ | trtyp  << off_ ,
/* 18020 */	load    | r2     << dst_ | ioptt  << off_ ,
/* 18021 */	bne     | r1     << dst_ | r2     << src_ | iop02  << off_ ,
/* 18022 */	stmt    | 6173   << off_ ,	//	mov xr trnxt(xr)  get value and delete old trblk
/* 18023 */	load    | xr     << dst_ | xr     << src_ | trnxt  << off_ ,
// iop03:
/* 18024 */	stmt    | 6174   << off_ ,	//iop03	mov vrval(xl) wc  link to this trblk
/* 18025 */	store   | wc     << dst_ | xl     << src_ | vrval  << off_ ,
/* 18026 */	stmt    | 6175   << off_ ,	//	mov xl wc  copy pointer
/* 18027 */	move    | xl     << dst_ | wc     << src_ ,
/* 18028 */	stmt    | 6176   << off_ ,	//	mov trnxt(xl) xr  store value in trblk
/* 18029 */	store   | xr     << dst_ | xl     << src_ | trnxt  << off_ ,
/* 18030 */	stmt    | 6177   << off_ ,	//	mov xr r_ion  restore possible vrblk pointer
/* 18031 */	load    | xr     << dst_ | r_ion  << off_ ,
/* 18032 */	stmt    | 6178   << off_ ,	//	mov wb wa  keep offset to name
/* 18033 */	move    | wb     << dst_ | wa     << src_ ,
/* 18034 */	stmt    | 6179   << off_ ,	//	jsr setvr   if vrblk, set vrget,vrsto
/* 18035 */	call    | setvr  << off_ ,
/* 18036 */	stmt    | 6180   << off_ ,	//	mov xr r_iot  get 0 or trtrf ptr
/* 18037 */	load    | xr     << dst_ | r_iot  << off_ ,
/* 18038 */	stmt    | 6181   << off_ ,	//	bnz xr iop19  jump if trtrf block exists
/* 18039 */	bnz     | xr     << dst_ | iop19  << off_ ,
/* 18040 */	stmt    | 6182   << off_ ,	//	exi    return to caller
/* 18041 */	exi     | 1000   << off_ ,
// iop04:
/* 18042 */	stmt    | 6183   << off_ ,	//iop04	zer wa   in case no fcblk found
/* 18043 */	move    | wa     << dst_ ,
// iop05:
/* 18044 */	stmt    | 6184   << off_ ,	//iop05	mov wb xr  remember blk ptr
/* 18045 */	move    | wb     << dst_ | xr     << src_ ,
/* 18046 */	stmt    | 6185   << off_ ,	//	mov xr vrval(xr)  chain along
/* 18047 */	load    | xr     << dst_ | xr     << src_ | vrval  << off_ ,
/* 18048 */	stmt    | 6186   << off_ ,	//	bne (xr) =b_trt iop06 jump if end of trblk chain
/* 18049 */	load    | r1     << dst_ | xr     << src_ ,
/* 18050 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 18051 */	bne     | r1     << dst_ | r2     << src_ | iop06  << off_ ,
/* 18052 */	stmt    | 6187   << off_ ,	//	bne trtyp(xr) =trtfc iop05 loop if more to go
/* 18053 */	load    | r1     << dst_ | xr     << src_ | trtyp  << off_ ,
/* 18054 */	loadi   | r2     << dst_ | trtfc  << off_ ,
/* 18055 */	bne     | r1     << dst_ | r2     << src_ | iop05  << off_ ,
/* 18056 */	stmt    | 6188   << off_ ,	//	mov r_iot xr  point to file arg1 trblk
/* 18057 */	store   | xr     << dst_ | r_iot  << off_ ,
/* 18058 */	stmt    | 6189   << off_ ,	//	mov wa trfpt(xr)  get fcblk ptr from trblk
/* 18059 */	load    | wa     << dst_ | xr     << src_ | trfpt  << off_ ,
// iop06:
/* 18060 */	stmt    | 6190   << off_ ,	//iop06	mov r_iof wa  keep possible fcblk ptr
/* 18061 */	store   | wa     << dst_ | r_iof  << off_ ,
/* 18062 */	stmt    | 6191   << off_ ,	//	mov r_iop wb  keep preceding blk ptr
/* 18063 */	store   | wb     << dst_ | r_iop  << off_ ,
/* 18064 */	stmt    | 6192   << off_ ,	//	jsr ioppf   process filearg2
/* 18065 */	call    | ioppf  << off_ ,
/* 18066 */	stmt    | 6193   << off_ ,	//	jsr sysfc   see if fcblk required
/* 18067 */	sys     | sysfc_ << off_ ,
/* 18068 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/* 18069 */	ppm     | iop16  << off_ ,
/* 18070 */	ppm     | iop26  << off_ ,
/* 18071 */	stmt    | 6194   << off_ ,	//	bze wa iop12  skip if no new fcblk wanted
/* 18072 */	bze     | wa     << dst_ | iop12  << off_ ,
/* 18073 */	stmt    | 6195   << off_ ,	//	blt wc =num02 iop6a jump if fcblk in dynamic
/* 18074 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 18075 */	blt     | wc     << dst_ | r2     << src_ | iop6a  << off_ ,
/* 18076 */	stmt    | 6196   << off_ ,	//	jsr alost   get it in static
/* 18077 */	call    | alost  << off_ ,
/* 18078 */	stmt    | 6197   << off_ ,	//	brn iop6b   skip
/* 18079 */	brn     | iop6b  << off_ ,
// iop6a:
/* 18080 */	stmt    | 6198   << off_ ,	//iop6a	jsr alloc   get space for fcblk
/* 18081 */	call    | alloc  << off_ ,
// iop6b:
/* 18082 */	stmt    | 6199   << off_ ,	//iop6b	mov xl xr  point to fcblk
/* 18083 */	move    | xl     << dst_ | xr     << src_ ,
/* 18084 */	stmt    | 6200   << off_ ,	//	mov wb wa  copy its length
/* 18085 */	move    | wb     << dst_ | wa     << src_ ,
/* 18086 */	stmt    | 6201   << off_ ,	//	btw wb   get count as words (sgd apr80)
/* 18087 */	stmt    | 6202   << off_ ,	//	lct wb wb  loop counter
// iop07:
/* 18088 */	stmt    | 6203   << off_ ,	//iop07	zer (xr)+   clear a word
/* 18089 */	store   | r0     << dst_ | xr     << src_ ,
/* 18090 */	ica     | xr     << dst_ ,
/* 18091 */	stmt    | 6204   << off_ ,	//	bct wb iop07  loop
/* 18092 */	bct     | wb     << dst_ | iop07  << off_ ,
/* 18093 */	stmt    | 6205   << off_ ,	//	beq wc =num02 iop09 skip if in static - dont set fields
/* 18094 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 18095 */	beq     | wc     << dst_ | r2     << src_ | iop09  << off_ ,
/* 18096 */	stmt    | 6206   << off_ ,	//	mov (xl) =b_xnt  store xnblk code in case
/* 18097 */	loadi   | r1     << dst_ | b_xnt  << off_ ,
/* 18098 */	store   | r1     << dst_ | xl     << src_ ,
/* 18099 */	stmt    | 6207   << off_ ,	//	mov num01(xl) wa  store length
/* 18100 */	store   | wa     << dst_ | xl     << src_ | num01  << off_ ,
/* 18101 */	stmt    | 6208   << off_ ,	//	bnz wc iop09  jump if xnblk wanted
/* 18102 */	bnz     | wc     << dst_ | iop09  << off_ ,
/* 18103 */	stmt    | 6209   << off_ ,	//	mov (xl) =b_xrt  xrblk code requested
/* 18104 */	loadi   | r1     << dst_ | b_xrt  << off_ ,
/* 18105 */	store   | r1     << dst_ | xl     << src_ ,
// iop09:
/* 18106 */	stmt    | 6210   << off_ ,	//iop09	mov xr r_iot  get possible trblk ptr
/* 18107 */	load    | xr     << dst_ | r_iot  << off_ ,
/* 18108 */	stmt    | 6211   << off_ ,	//	mov r_iof xl  store fcblk ptr
/* 18109 */	store   | xl     << dst_ | r_iof  << off_ ,
/* 18110 */	stmt    | 6212   << off_ ,	//	bnz xr iop10  jump if trblk already found
/* 18111 */	bnz     | xr     << dst_ | iop10  << off_ ,
/* 18112 */	stmt    | 6213   << off_ ,	//	mov wb =trtfc  trtyp for fcblk trap blk
/* 18113 */	loadi   | wb     << dst_ | trtfc  << off_ ,
/* 18114 */	stmt    | 6214   << off_ ,	//	jsr trbld   make the block
/* 18115 */	call    | trbld  << off_ ,
/* 18116 */	stmt    | 6215   << off_ ,	//	mov r_iot xr  copy trtrf ptr
/* 18117 */	store   | xr     << dst_ | r_iot  << off_ ,
/* 18118 */	stmt    | 6216   << off_ ,	//	mov xl r_iop  point to preceding blk
/* 18119 */	load    | xl     << dst_ | r_iop  << off_ ,
/* 18120 */	stmt    | 6217   << off_ ,	//	mov vrval(xr) vrval(xl)  copy value field to trblk
/* 18121 */	load    | r1     << dst_ | xl     << src_ | vrval  << off_ ,
/* 18122 */	store   | r1     << dst_ | xr     << src_ | vrval  << off_ ,
/* 18123 */	stmt    | 6218   << off_ ,	//	mov vrval(xl) xr  link new trblk into chain
/* 18124 */	store   | xr     << dst_ | xl     << src_ | vrval  << off_ ,
/* 18125 */	stmt    | 6219   << off_ ,	//	mov xr xl  point to predecessor blk
/* 18126 */	move    | xr     << dst_ | xl     << src_ ,
/* 18127 */	stmt    | 6220   << off_ ,	//	jsr setvr   set trace intercepts
/* 18128 */	call    | setvr  << off_ ,
/* 18129 */	stmt    | 6221   << off_ ,	//	mov xr vrval(xr)  recover trblk ptr
/* 18130 */	load    | xr     << dst_ | xr     << src_ | vrval  << off_ ,
/* 18131 */	stmt    | 6222   << off_ ,	//	brn iop1a   store fcblk ptr
/* 18132 */	brn     | iop1a  << off_ ,
// iop10:
/* 18133 */	stmt    | 6223   << off_ ,	//iop10	zer r_iop   do not release if sysio fails
/* 18134 */	store   | r0     << dst_ | r_iop  << off_ ,
// iop1a:
/* 18135 */	stmt    | 6224   << off_ ,	//iop1a	mov trfpt(xr) r_iof  store fcblk ptr
/* 18136 */	load    | r1     << dst_ | r_iof  << off_ ,
/* 18137 */	store   | r1     << dst_ | xr     << src_ | trfpt  << off_ ,
// iop11:
/* 18138 */	stmt    | 6225   << off_ ,	//iop11	mov wa r_iof  copy fcblk ptr or 0
/* 18139 */	load    | wa     << dst_ | r_iof  << off_ ,
/* 18140 */	stmt    | 6226   << off_ ,	//	mov wb ioptt  get input/output flag
/* 18141 */	load    | wb     << dst_ | ioptt  << off_ ,
/* 18142 */	stmt    | 6227   << off_ ,	//	mov xr r_io2  get file arg2
/* 18143 */	load    | xr     << dst_ | r_io2  << off_ ,
/* 18144 */	stmt    | 6228   << off_ ,	//	mov xl r_io1  get file arg1
/* 18145 */	load    | xl     << dst_ | r_io1  << off_ ,
/* 18146 */	stmt    | 6229   << off_ ,	//	jsr sysio   associate to the file
/* 18147 */	sys     | sysio_ << off_ ,
/* 18148 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/* 18149 */	ppm     | iop17  << off_ ,
/* 18150 */	ppm     | iop18  << off_ ,
/* 18151 */	stmt    | 6230   << off_ ,	//	bnz r_iot iop01  not std input if non-null trtrf blk
/* 18152 */	load    | r1     << dst_ | r_iot  << off_ ,
/* 18153 */	bnz     | r1     << dst_ | iop01  << off_ ,
/* 18154 */	stmt    | 6231   << off_ ,	//	bnz ioptt iop01  jump if output
/* 18155 */	load    | r1     << dst_ | ioptt  << off_ ,
/* 18156 */	bnz     | r1     << dst_ | iop01  << off_ ,
/* 18157 */	stmt    | 6232   << off_ ,	//	bze wc iop01  no change to standard read length
/* 18158 */	bze     | wc     << dst_ | iop01  << off_ ,
/* 18159 */	stmt    | 6233   << off_ ,	//	mov cswin wc  store new read length for std file
/* 18160 */	store   | wc     << dst_ | cswin  << off_ ,
/* 18161 */	stmt    | 6234   << off_ ,	//	brn iop01   merge to finish the task
/* 18162 */	brn     | iop01  << off_ ,
// iop12:
/* 18163 */	stmt    | 6235   << off_ ,	//iop12	bnz xl iop09  jump if private fcblk
/* 18164 */	bnz     | xl     << dst_ | iop09  << off_ ,
/* 18165 */	stmt    | 6236   << off_ ,	//	brn iop11   finish the association
/* 18166 */	brn     | iop11  << off_ ,
// iop13:
/* 18167 */	stmt    | 6237   << off_ ,	//iop13	exi 1   3rd arg not a string
/* 18168 */	exi     | 1001   << off_ ,
// iop14:
/* 18169 */	stmt    | 6238   << off_ ,	//iop14	exi 2   2nd arg unsuitable
/* 18170 */	exi     | 1002   << off_ ,
// iop15:
/* 18171 */	stmt    | 6239   << off_ ,	//iop15	ica xs   discard trblk pointer
/* 18172 */	ica     | xs     << dst_ ,
/* 18173 */	stmt    | 6240   << off_ ,	//	exi 3   1st arg unsuitable
/* 18174 */	exi     | 1003   << off_ ,
// iop16:
/* 18175 */	stmt    | 6241   << off_ ,	//iop16	exi 4   file spec wrong
/* 18176 */	exi     | 1004   << off_ ,
// iop26:
/* 18177 */	stmt    | 6242   << off_ ,	//iop26	exi 7   fcblk in use
/* 18178 */	exi     | 1007   << off_ ,
// iop17:
/* 18179 */	stmt    | 6243   << off_ ,	//iop17	mov xr r_iop  is there a trblk to release
/* 18180 */	load    | xr     << dst_ | r_iop  << off_ ,
/* 18181 */	stmt    | 6244   << off_ ,	//	bze xr iopa7  if not
/* 18182 */	bze     | xr     << dst_ | iopa7  << off_ ,
/* 18183 */	stmt    | 6245   << off_ ,	//	mov xl vrval(xr)  point to trblk
/* 18184 */	load    | xl     << dst_ | xr     << src_ | vrval  << off_ ,
/* 18185 */	stmt    | 6246   << off_ ,	//	mov vrval(xr) vrval(xl)  unsplice it
/* 18186 */	load    | r1     << dst_ | xl     << src_ | vrval  << off_ ,
/* 18187 */	store   | r1     << dst_ | xr     << src_ | vrval  << off_ ,
/* 18188 */	stmt    | 6247   << off_ ,	//	jsr setvr   adjust trace intercepts
/* 18189 */	call    | setvr  << off_ ,
// iopa7:
/* 18190 */	stmt    | 6248   << off_ ,	//iopa7	exi 5   i/o file does not exist
/* 18191 */	exi     | 1005   << off_ ,
// iop18:
/* 18192 */	stmt    | 6249   << off_ ,	//iop18	mov xr r_iop  is there a trblk to release
/* 18193 */	load    | xr     << dst_ | r_iop  << off_ ,
/* 18194 */	stmt    | 6250   << off_ ,	//	bze xr iopa7  if not
/* 18195 */	bze     | xr     << dst_ | iopa7  << off_ ,
/* 18196 */	stmt    | 6251   << off_ ,	//	mov xl vrval(xr)  point to trblk
/* 18197 */	load    | xl     << dst_ | xr     << src_ | vrval  << off_ ,
/* 18198 */	stmt    | 6252   << off_ ,	//	mov vrval(xr) vrval(xl)  unsplice it
/* 18199 */	load    | r1     << dst_ | xl     << src_ | vrval  << off_ ,
/* 18200 */	store   | r1     << dst_ | xr     << src_ | vrval  << off_ ,
/* 18201 */	stmt    | 6253   << off_ ,	//	jsr setvr   adjust trace intercepts
/* 18202 */	call    | setvr  << off_ ,
// iopa8:
/* 18203 */	stmt    | 6254   << off_ ,	//iopa8	exi 6   i/o file cannot be read/written
/* 18204 */	exi     | 1006   << off_ ,
// iop19:
/* 18205 */	stmt    | 6255   << off_ ,	//iop19	mov wc r_ion  wc = name base, wb = name offset
/* 18206 */	load    | wc     << dst_ | r_ion  << off_ ,
// iop20:
/* 18207 */	stmt    | 6256   << off_ ,	//iop20	mov xr trtrf(xr)  next link of chain
/* 18208 */	load    | xr     << dst_ | xr     << src_ | trtrf  << off_ ,
/* 18209 */	stmt    | 6257   << off_ ,	//	bze xr iop21  not found
/* 18210 */	bze     | xr     << dst_ | iop21  << off_ ,
/* 18211 */	stmt    | 6258   << off_ ,	//	bne wc ionmb(xr) iop20 no match
/* 18212 */	load    | r2     << dst_ | xr     << src_ | ionmb  << off_ ,
/* 18213 */	bne     | wc     << dst_ | r2     << src_ | iop20  << off_ ,
/* 18214 */	stmt    | 6259   << off_ ,	//	beq wb ionmo(xr) iop22 exit if matched
/* 18215 */	load    | r2     << dst_ | xr     << src_ | ionmo  << off_ ,
/* 18216 */	beq     | wb     << dst_ | r2     << src_ | iop22  << off_ ,
/* 18217 */	stmt    | 6260   << off_ ,	//	brn iop20   loop
/* 18218 */	brn     | iop20  << off_ ,
// iop21:
/* 18219 */	stmt    | 6261   << off_ ,	//iop21	mov wa *num05  space needed
/* 18220 */	loadi   | wa     << dst_ | num05  << off_ ,
/* 18221 */	stmt    | 6262   << off_ ,	//	jsr alloc   get it
/* 18222 */	call    | alloc  << off_ ,
/* 18223 */	stmt    | 6263   << off_ ,	//	mov (xr) =b_xrt  store xrblk code
/* 18224 */	loadi   | r1     << dst_ | b_xrt  << off_ ,
/* 18225 */	store   | r1     << dst_ | xr     << src_ ,
/* 18226 */	stmt    | 6264   << off_ ,	//	mov num01(xr) wa  store length
/* 18227 */	store   | wa     << dst_ | xr     << src_ | num01  << off_ ,
/* 18228 */	stmt    | 6265   << off_ ,	//	mov ionmb(xr) wc  store name base
/* 18229 */	store   | wc     << dst_ | xr     << src_ | ionmb  << off_ ,
/* 18230 */	stmt    | 6266   << off_ ,	//	mov ionmo(xr) wb  store name offset
/* 18231 */	store   | wb     << dst_ | xr     << src_ | ionmo  << off_ ,
/* 18232 */	stmt    | 6267   << off_ ,	//	mov xl r_iot  point to trtrf blk
/* 18233 */	load    | xl     << dst_ | r_iot  << off_ ,
/* 18234 */	stmt    | 6268   << off_ ,	//	mov wa trtrf(xl)  get ptr field contents
/* 18235 */	load    | wa     << dst_ | xl     << src_ | trtrf  << off_ ,
/* 18236 */	stmt    | 6269   << off_ ,	//	mov trtrf(xl) xr  store ptr to new block
/* 18237 */	store   | xr     << dst_ | xl     << src_ | trtrf  << off_ ,
/* 18238 */	stmt    | 6270   << off_ ,	//	mov trtrf(xr) wa  complete the linking
/* 18239 */	store   | wa     << dst_ | xr     << src_ | trtrf  << off_ ,
// iop22:
/* 18240 */	stmt    | 6271   << off_ ,	//iop22	bze r_iof iop25  skip if no fcblk
/* 18241 */	load    | r1     << dst_ | r_iof  << off_ ,
/* 18242 */	bze     | r1     << dst_ | iop25  << off_ ,
/* 18243 */	stmt    | 6272   << off_ ,	//	mov xl r_fcb  ptr to head of existing chain
/* 18244 */	load    | xl     << dst_ | r_fcb  << off_ ,
// iop23:
/* 18245 */	stmt    | 6273   << off_ ,	//iop23	bze xl iop24  not on if end of chain
/* 18246 */	bze     | xl     << dst_ | iop24  << off_ ,
/* 18247 */	stmt    | 6274   << off_ ,	//	beq num03(xl) r_iof iop25 dont duplicate if find it
/* 18248 */	load    | r1     << dst_ | xl     << src_ | num03  << off_ ,
/* 18249 */	load    | r2     << dst_ | r_iof  << off_ ,
/* 18250 */	beq     | r1     << dst_ | r2     << src_ | iop25  << off_ ,
/* 18251 */	stmt    | 6275   << off_ ,	//	mov xl num02(xl)  get next link
/* 18252 */	load    | xl     << dst_ | xl     << src_ | num02  << off_ ,
/* 18253 */	stmt    | 6276   << off_ ,	//	brn iop23   loop
/* 18254 */	brn     | iop23  << off_ ,
// iop24:
/* 18255 */	stmt    | 6277   << off_ ,	//iop24	mov wa *num04  space needed
/* 18256 */	loadi   | wa     << dst_ | num04  << off_ ,
/* 18257 */	stmt    | 6278   << off_ ,	//	jsr alloc   get it
/* 18258 */	call    | alloc  << off_ ,
/* 18259 */	stmt    | 6279   << off_ ,	//	mov (xr) =b_xrt  store block code
/* 18260 */	loadi   | r1     << dst_ | b_xrt  << off_ ,
/* 18261 */	store   | r1     << dst_ | xr     << src_ ,
/* 18262 */	stmt    | 6280   << off_ ,	//	mov num01(xr) wa  store length
/* 18263 */	store   | wa     << dst_ | xr     << src_ | num01  << off_ ,
/* 18264 */	stmt    | 6281   << off_ ,	//	mov num02(xr) r_fcb  store previous link in this node
/* 18265 */	load    | r1     << dst_ | r_fcb  << off_ ,
/* 18266 */	store   | r1     << dst_ | xr     << src_ | num02  << off_ ,
/* 18267 */	stmt    | 6282   << off_ ,	//	mov num03(xr) r_iof  store fcblk ptr
/* 18268 */	load    | r1     << dst_ | r_iof  << off_ ,
/* 18269 */	store   | r1     << dst_ | xr     << src_ | num03  << off_ ,
/* 18270 */	stmt    | 6283   << off_ ,	//	mov r_fcb xr  insert node into fcblk chain
/* 18271 */	store   | xr     << dst_ | r_fcb  << off_ ,
// iop25:
/* 18272 */	stmt    | 6284   << off_ ,	//iop25	exi    return to caller
/* 18273 */	exi     | 1000   << off_ ,
// ktrex:
/* 18274 */	stmt    | 6285   << off_ ,	//ktrex	prc r 0  entry point (recursive)
/* 18275 */	stmt    | 6286   << off_ ,	//	bze xl ktrx3  immediate exit if keyword untraced
/* 18276 */	bze     | xl     << dst_ | ktrx3  << off_ ,
/* 18277 */	stmt    | 6287   << off_ ,	//	bze kvtra ktrx3  immediate exit if trace = 0
/* 18278 */	load    | r1     << dst_ | kvtra  << off_ ,
/* 18279 */	bze     | r1     << dst_ | ktrx3  << off_ ,
/* 18280 */	stmt    | 6288   << off_ ,	//	dcv kvtra   else decrement trace
/* 18281 */	load    | r1     << dst_ | kvtra  << off_ ,
/* 18282 */	dcv     | r1     << dst_ ,
/* 18283 */	store   | r1     << dst_ | kvtra  << off_ ,
/* 18284 */	stmt    | 6289   << off_ ,	//	mov -(xs) xr  save xr
/* 18285 */	dca     | xs     << dst_ ,
/* 18286 */	store   | xr     << dst_ | xs     << src_ ,
/* 18287 */	stmt    | 6290   << off_ ,	//	mov xr xl  copy trblk pointer
/* 18288 */	move    | xr     << dst_ | xl     << src_ ,
/* 18289 */	stmt    | 6291   << off_ ,	//	mov xl trkvr(xr)  load vrblk pointer (nmbas)
/* 18290 */	load    | xl     << dst_ | xr     << src_ | trkvr  << off_ ,
/* 18291 */	stmt    | 6292   << off_ ,	//	mov wa *vrval  set name offset
/* 18292 */	loadi   | wa     << dst_ | vrval  << off_ ,
/* 18293 */	stmt    | 6293   << off_ ,	//	bze trfnc(xr) ktrx1  jump if print trace
/* 18294 */	load    | r1     << dst_ | xr     << src_ | trfnc  << off_ ,
/* 18295 */	bze     | r1     << dst_ | ktrx1  << off_ ,
/* 18296 */	stmt    | 6294   << off_ ,	//	jsr trxeq   else execute full trace
/* 18297 */	call    | trxeq  << off_ ,
/* 18298 */	stmt    | 6295   << off_ ,	//	brn ktrx2   and jump to exit
/* 18299 */	brn     | ktrx2  << off_ ,
// ktrx1:
/* 18300 */	stmt    | 6296   << off_ ,	//ktrx1	mov -(xs) xl  stack vrblk ptr for kwnam
/* 18301 */	dca     | xs     << dst_ ,
/* 18302 */	store   | xl     << dst_ | xs     << src_ ,
/* 18303 */	stmt    | 6297   << off_ ,	//	mov -(xs) wa  stack offset for kwnam
/* 18304 */	dca     | xs     << dst_ ,
/* 18305 */	store   | wa     << dst_ | xs     << src_ ,
/* 18306 */	stmt    | 6298   << off_ ,	//	jsr prtsn   print statement number
/* 18307 */	call    | prtsn  << off_ ,
/* 18308 */	stmt    | 6299   << off_ ,	//	mov wa =ch_am  load ampersand
/* 18309 */	loadi   | wa     << dst_ | ch_am  << off_ ,
/* 18310 */	stmt    | 6300   << off_ ,	//	jsr prtch   print ampersand
/* 18311 */	call    | prtch  << off_ ,
/* 18312 */	stmt    | 6301   << off_ ,	//	jsr prtnm   print keyword name
/* 18313 */	call    | prtnm  << off_ ,
/* 18314 */	stmt    | 6302   << off_ ,	//	mov xr =tmbeb  point to blank-equal-blank
/* 18315 */	loadi   | xr     << dst_ | tmbeb  << off_ ,
/* 18316 */	stmt    | 6303   << off_ ,	//	jsr prtst   print blank-equal-blank
/* 18317 */	call    | prtst  << off_ ,
/* 18318 */	stmt    | 6304   << off_ ,	//	jsr kwnam   get keyword pseudo-variable name
/* 18319 */	call    | kwnam  << off_ ,
/* 18320 */	stmt    | 6305   << off_ ,	//	mov dnamp xr  reset ptr to delete kvblk
/* 18321 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 18322 */	stmt    | 6306   << off_ ,	//	jsr acess   get keyword value
/* 18323 */	call    | acess  << off_ ,
/* 18324 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 18325 */	ppm     ,
/* 18326 */	stmt    | 6307   << off_ ,	//	jsr prtvl   print keyword value
/* 18327 */	call    | prtvl  << off_ ,
/* 18328 */	stmt    | 6308   << off_ ,	//	jsr prtnl   terminate print line
/* 18329 */	call    | prtnl  << off_ ,
// ktrx2:
/* 18330 */	stmt    | 6309   << off_ ,	//ktrx2	mov xr (xs)+  restore entry xr
/* 18331 */	load    | xr     << dst_ | xs     << src_ ,
/* 18332 */	ica     | xs     << dst_ ,
// ktrx3:
/* 18333 */	stmt    | 6310   << off_ ,	//ktrx3	exi    return to ktrex caller
/* 18334 */	exi     | 0      << off_ ,
// kwnam:
/* 18335 */	stmt    | 6311   << off_ ,	//kwnam	prc n 0  entry point
/* 18336 */	prc     | 11     << off_ ,
/* 18337 */	stmt    | 6312   << off_ ,	//	ica xs   ignore name offset
/* 18338 */	ica     | xs     << dst_ ,
/* 18339 */	stmt    | 6313   << off_ ,	//	mov xr (xs)+  load name base
/* 18340 */	load    | xr     << dst_ | xs     << src_ ,
/* 18341 */	ica     | xs     << dst_ ,
/* 18342 */	stmt    | 6314   << off_ ,	//	bge xr state kwnm1 jump if not natural variable name
/* 18343 */	load    | r2     << dst_ | state  << off_ ,
/* 18344 */	bge     | xr     << dst_ | r2     << src_ | kwnm1  << off_ ,
/* 18345 */	stmt    | 6315   << off_ ,	//	bnz vrlen(xr) kwnm1  error if not system variable
/* 18346 */	load    | r1     << dst_ | xr     << src_ | vrlen  << off_ ,
/* 18347 */	bnz     | r1     << dst_ | kwnm1  << off_ ,
/* 18348 */	stmt    | 6316   << off_ ,	//	mov xr vrsvp(xr)  else point to svblk
/* 18349 */	load    | xr     << dst_ | xr     << src_ | vrsvp  << off_ ,
/* 18350 */	stmt    | 6317   << off_ ,	//	mov wa svbit(xr)  load bit mask
/* 18351 */	load    | wa     << dst_ | xr     << src_ | svbit  << off_ ,
/* 18352 */	stmt    | 6318   << off_ ,	//	anb wa 4,btknm  and with keyword bit
/* 18353 */	load    | r2     << dst_ | btknm  << off_ ,
/* 18354 */	anb     | wa     << dst_ | r2     << src_ ,
/* 18355 */	stmt    | 6319   << off_ ,	//	zrb wa kwnm1  error if no keyword association
/* 18356 */	zrb     | wa     << dst_ | kwnm1  << off_ ,
/* 18357 */	stmt    | 6320   << off_ ,	//	mov wa svlen(xr)  else load name length in characters
/* 18358 */	load    | wa     << dst_ | xr     << src_ | svlen  << off_ ,
/* 18359 */	stmt    | 6321   << off_ ,	//	ctb wa svchs  compute offset to field we want
/* 18360 */	ctb     | wa     << dst_ | svchs  << off_ ,
/* 18361 */	stmt    | 6322   << off_ ,	//	add xr wa  point to svknm field
/* 18362 */	add     | xr     << dst_ | wa     << src_ ,
/* 18363 */	stmt    | 6323   << off_ ,	//	mov wb (xr)  load svknm value
/* 18364 */	load    | wb     << dst_ | xr     << src_ ,
/* 18365 */	stmt    | 6324   << off_ ,	//	mov wa *kvsi_  set size of kvblk
/* 18366 */	loadi   | wa     << dst_ | kvsi_  << off_ ,
/* 18367 */	stmt    | 6325   << off_ ,	//	jsr alloc   allocate kvblk
/* 18368 */	call    | alloc  << off_ ,
/* 18369 */	stmt    | 6326   << off_ ,	//	mov (xr) =b_kvt  store type word
/* 18370 */	loadi   | r1     << dst_ | b_kvt  << off_ ,
/* 18371 */	store   | r1     << dst_ | xr     << src_ ,
/* 18372 */	stmt    | 6327   << off_ ,	//	mov kvnum(xr) wb  store keyword number
/* 18373 */	store   | wb     << dst_ | xr     << src_ | kvnum  << off_ ,
/* 18374 */	stmt    | 6328   << off_ ,	//	mov kvvar(xr) =trbkv  set dummy trblk pointer
/* 18375 */	loadi   | r1     << dst_ | trbkv  << off_ ,
/* 18376 */	store   | r1     << dst_ | xr     << src_ | kvvar  << off_ ,
/* 18377 */	stmt    | 6329   << off_ ,	//	mov xl xr  copy kvblk pointer
/* 18378 */	move    | xl     << dst_ | xr     << src_ ,
/* 18379 */	stmt    | 6330   << off_ ,	//	mov wa *kvvar  set proper offset
/* 18380 */	loadi   | wa     << dst_ | kvvar  << off_ ,
/* 18381 */	stmt    | 6331   << off_ ,	//	exi    return to kvnam caller
/* 18382 */	exi     | 1100   << off_ ,
// kwnm1:
/* 18383 */	stmt    | 6332   << off_ ,	//kwnm1	erb 251 keyword operand is not name of defined keyword
/* 18384 */	erb     | 251    << off_ ,
// lcomp:
/* 18385 */	stmt    | 6333   << off_ ,	//lcomp	prc n 5  entry point
/* 18386 */	prc     | 12     << off_ ,
/* 18387 */	stmt    | 6334   << off_ ,	//	jsr gtstg   convert second arg to string
/* 18388 */	call    | gtstg  << off_ ,
/* 18389 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 18390 */	ppm     | lcmp6  << off_ ,
/* 18391 */	stmt    | 6335   << off_ ,	//	mov xl xr  else save pointer
/* 18392 */	move    | xl     << dst_ | xr     << src_ ,
/* 18393 */	stmt    | 6336   << off_ ,	//	mov wc wa  and length
/* 18394 */	move    | wc     << dst_ | wa     << src_ ,
/* 18395 */	stmt    | 6337   << off_ ,	//	jsr gtstg   convert first argument to string
/* 18396 */	call    | gtstg  << off_ ,
/* 18397 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 18398 */	ppm     | lcmp5  << off_ ,
/* 18399 */	stmt    | 6338   << off_ ,	//	mov wb wa  save arg 1 length
/* 18400 */	move    | wb     << dst_ | wa     << src_ ,
/* 18401 */	stmt    | 6339   << off_ ,	//	plc xr   point to chars of arg 1
/* 18402 */	plc     | xr     << dst_ ,
/* 18403 */	stmt    | 6340   << off_ ,	//	plc xl   point to chars of arg 2
/* 18404 */	plc     | xl     << dst_ ,
/* 18405 */	stmt    | 6341   << off_ ,	//	blo wa wc lcmp1 jump if arg 1 length is smaller
/* 18406 */	blo     | wa     << dst_ | wc     << src_ | lcmp1  << off_ ,
/* 18407 */	stmt    | 6342   << off_ ,	//	mov wa wc  else set arg 2 length as smaller
/* 18408 */	move    | wa     << dst_ | wc     << src_ ,
// lcmp1:
/* 18409 */	stmt    | 6343   << off_ ,	//lcmp1	bze wa lcmp7  if null string, compare lengths
/* 18410 */	bze     | wa     << dst_ | lcmp7  << off_ ,
/* 18411 */	stmt    | 6344   << off_ ,	//	cmc lcmp4 lcmp3  compare strings, jump if unequal
/* 18412 */	loadi   | r1     << dst_ | lcmp4  << src_ ,
/* 18413 */	loadi   | r2     << dst_ | lcmp3  << src_ ,
/* 18414 */	cmc     ,
// lcmp7:
/* 18415 */	stmt    | 6345   << off_ ,	//lcmp7	bne wb wc lcmp2 if equal, jump if lengths unequal
/* 18416 */	bne     | wb     << dst_ | wc     << src_ | lcmp2  << off_ ,
/* 18417 */	stmt    | 6346   << off_ ,	//	exi 4   else identical strings, leq exit
/* 18418 */	exi     | 1204   << off_ ,
// lcmp2:
/* 18419 */	stmt    | 6347   << off_ ,	//lcmp2	bhi wb wc lcmp4 jump if arg 1 length gt arg 2 leng
/* 18420 */	bhi     | wb     << dst_ | wc     << src_ | lcmp4  << off_ ,
// lcmp3:
/* 18421 */	stmt    | 6348   << off_ ,	//lcmp3	exi 3   take llt exit
/* 18422 */	exi     | 1203   << off_ ,
// lcmp4:
/* 18423 */	stmt    | 6349   << off_ ,	//lcmp4	exi 5   take lgt exit
/* 18424 */	exi     | 1205   << off_ ,
// lcmp5:
/* 18425 */	stmt    | 6350   << off_ ,	//lcmp5	exi 1   take bad first arg exit
/* 18426 */	exi     | 1201   << off_ ,
// lcmp6:
/* 18427 */	stmt    | 6351   << off_ ,	//lcmp6	exi 2   take bad second arg error exit
/* 18428 */	exi     | 1202   << off_ ,
// listr:
/* 18429 */	stmt    | 6352   << off_ ,	//listr	prc e 0  entry point
/* 18430 */	stmt    | 6353   << off_ ,	//	bnz cnttl list5  jump if -title or -stitl
/* 18431 */	load    | r1     << dst_ | cnttl  << off_ ,
/* 18432 */	bnz     | r1     << dst_ | list5  << off_ ,
/* 18433 */	stmt    | 6354   << off_ ,	//	bnz lstpf list4  immediate exit if already listed
/* 18434 */	load    | r1     << dst_ | lstpf  << off_ ,
/* 18435 */	bnz     | r1     << dst_ | list4  << off_ ,
/* 18436 */	stmt    | 6355   << off_ ,	//	bge lstlc lstnp list6 jump if no room
/* 18437 */	load    | r1     << dst_ | lstlc  << off_ ,
/* 18438 */	load    | r2     << dst_ | lstnp  << off_ ,
/* 18439 */	bge     | r1     << dst_ | r2     << src_ | list6  << off_ ,
// list0:
/* 18440 */	stmt    | 6356   << off_ ,	//list0	mov xr r_cim  load pointer to current image
/* 18441 */	load    | xr     << dst_ | r_cim  << off_ ,
/* 18442 */	stmt    | 6357   << off_ ,	//	bze xr list4  jump if no image to print
/* 18443 */	bze     | xr     << dst_ | list4  << off_ ,
/* 18444 */	stmt    | 6358   << off_ ,	//	plc xr   point to characters
/* 18445 */	plc     | xr     << dst_ ,
/* 18446 */	stmt    | 6359   << off_ ,	//	lch wa (xr)  load first character
/* 18447 */	load    | wa     << dst_ | xr     << src_ ,
/* 18448 */	stmt    | 6360   << off_ ,	//	mov xr lstsn  load statement number
/* 18449 */	load    | xr     << dst_ | lstsn  << off_ ,
/* 18450 */	stmt    | 6361   << off_ ,	//	bze xr list2  jump if no statement number
/* 18451 */	bze     | xr     << dst_ | list2  << off_ ,
/* 18452 */	stmt    | 6362   << off_ ,	//	mti xr   else get stmnt number as integer
/* 18453 */	move    | ia     << dst_ | xr     << src_ ,
/* 18454 */	stmt    | 6363   << off_ ,	//	bne stage =stgic list1 skip if execute time
/* 18455 */	load    | r1     << dst_ | stage  << off_ ,
/* 18456 */	loadi   | r2     << dst_ | stgic  << off_ ,
/* 18457 */	bne     | r1     << dst_ | r2     << src_ | list1  << off_ ,
/* 18458 */	stmt    | 6364   << off_ ,	//	beq wa =ch_as list2 no stmnt number list if comment
/* 18459 */	loadi   | r2     << dst_ | ch_as  << off_ ,
/* 18460 */	beq     | wa     << dst_ | r2     << src_ | list2  << off_ ,
/* 18461 */	stmt    | 6365   << off_ ,	//	beq wa =ch_mn list2 no stmnt no. if control card
/* 18462 */	loadi   | r2     << dst_ | ch_mn  << off_ ,
/* 18463 */	beq     | wa     << dst_ | r2     << src_ | list2  << off_ ,
// list1:
/* 18464 */	stmt    | 6366   << off_ ,	//list1	jsr prtin   else print statement number
/* 18465 */	call    | prtin  << off_ ,
/* 18466 */	stmt    | 6367   << off_ ,	//	zer lstsn   and clear for next time in
/* 18467 */	store   | r0     << dst_ | lstsn  << off_ ,
// list2:
/* 18468 */	stmt    | 6368   << off_ ,	//list2	mov xr lstid  include depth of image
/* 18469 */	load    | xr     << dst_ | lstid  << off_ ,
/* 18470 */	stmt    | 6369   << off_ ,	//	bze xr list8  if not from an include file
/* 18471 */	bze     | xr     << dst_ | list8  << off_ ,
/* 18472 */	stmt    | 6370   << off_ ,	//	mov wa =stnpd  position for start of statement
/* 18473 */	loadi   | wa     << dst_ | stnpd  << off_ ,
/* 18474 */	stmt    | 6371   << off_ ,	//	sub wa =num03  position to place include depth
/* 18475 */	loadi   | r2     << dst_ | num03  << off_ ,
/* 18476 */	sub     | wa     << dst_ | r2     << src_ ,
/* 18477 */	stmt    | 6372   << off_ ,	//	mov profs wa  set as starting position
/* 18478 */	store   | wa     << dst_ | profs  << off_ ,
/* 18479 */	stmt    | 6373   << off_ ,	//	mti xr   include depth as integer
/* 18480 */	move    | ia     << dst_ | xr     << src_ ,
/* 18481 */	stmt    | 6374   << off_ ,	//	jsr prtin   print include depth
/* 18482 */	call    | prtin  << off_ ,
// list8:
/* 18483 */	stmt    | 6375   << off_ ,	//list8	mov profs =stnpd  point past statement number
/* 18484 */	loadi   | r1     << dst_ | stnpd  << off_ ,
/* 18485 */	store   | r1     << dst_ | profs  << off_ ,
/* 18486 */	stmt    | 6376   << off_ ,	//	mov xr r_cim  load pointer to current image
/* 18487 */	load    | xr     << dst_ | r_cim  << off_ ,
/* 18488 */	stmt    | 6377   << off_ ,	//	jsr prtst   print it
/* 18489 */	call    | prtst  << off_ ,
/* 18490 */	stmt    | 6378   << off_ ,	//	icv lstlc   bump line counter
/* 18491 */	load    | r1     << dst_ | lstlc  << off_ ,
/* 18492 */	icv     | r1     << dst_ ,
/* 18493 */	store   | r1     << dst_ | lstlc  << off_ ,
/* 18494 */	stmt    | 6379   << off_ ,	//	bnz erlst list3  jump if error copy to int.ch.
/* 18495 */	load    | r1     << dst_ | erlst  << off_ ,
/* 18496 */	bnz     | r1     << dst_ | list3  << off_ ,
/* 18497 */	stmt    | 6380   << off_ ,	//	jsr prtnl   terminate line
/* 18498 */	call    | prtnl  << off_ ,
/* 18499 */	stmt    | 6381   << off_ ,	//	bze cswdb list3  jump if -single mode
/* 18500 */	load    | r1     << dst_ | cswdb  << off_ ,
/* 18501 */	bze     | r1     << dst_ | list3  << off_ ,
/* 18502 */	stmt    | 6382   << off_ ,	//	jsr prtnl   else add a blank line
/* 18503 */	call    | prtnl  << off_ ,
/* 18504 */	stmt    | 6383   << off_ ,	//	icv lstlc   and bump line counter
/* 18505 */	load    | r1     << dst_ | lstlc  << off_ ,
/* 18506 */	icv     | r1     << dst_ ,
/* 18507 */	store   | r1     << dst_ | lstlc  << off_ ,
// list3:
/* 18508 */	stmt    | 6384   << off_ ,	//list3	mnz lstpf   set flag for line printed
/* 18509 */	store   | xs     << dst_ | lstpf  << off_ ,
// list4:
/* 18510 */	stmt    | 6385   << off_ ,	//list4	exi    return to listr caller
/* 18511 */	exi     | 0      << off_ ,
// list5:
/* 18512 */	stmt    | 6386   << off_ ,	//list5	zer cnttl   clear flag
/* 18513 */	store   | r0     << dst_ | cnttl  << off_ ,
// list6:
/* 18514 */	stmt    | 6387   << off_ ,	//list6	jsr prtps   eject
/* 18515 */	call    | prtps  << off_ ,
/* 18516 */	stmt    | 6388   << off_ ,	//	bze prich list7  skip if listing to regular printer
/* 18517 */	load    | r1     << dst_ | prich  << off_ ,
/* 18518 */	bze     | r1     << dst_ | list7  << off_ ,
/* 18519 */	stmt    | 6389   << off_ ,	//	beq r_ttl =nulls list0 terminal listing omits null title
/* 18520 */	load    | r1     << dst_ | r_ttl  << off_ ,
/* 18521 */	loadi   | r2     << dst_ | nulls  << off_ ,
/* 18522 */	beq     | r1     << dst_ | r2     << src_ | list0  << off_ ,
// list7:
/* 18523 */	stmt    | 6390   << off_ ,	//list7	jsr listt   list title
/* 18524 */	call    | listt  << off_ ,
/* 18525 */	stmt    | 6391   << off_ ,	//	brn list0   merge
/* 18526 */	brn     | list0  << off_ ,
// listt:
/* 18527 */	stmt    | 6392   << off_ ,	//listt	prc e 0  entry point
/* 18528 */	stmt    | 6393   << off_ ,	//	mov xr r_ttl  point to source listing title
/* 18529 */	load    | xr     << dst_ | r_ttl  << off_ ,
/* 18530 */	stmt    | 6394   << off_ ,	//	jsr prtst   print title
/* 18531 */	call    | prtst  << off_ ,
/* 18532 */	stmt    | 6395   << off_ ,	//	mov profs lstpo  set offset
/* 18533 */	load    | r1     << dst_ | lstpo  << off_ ,
/* 18534 */	store   | r1     << dst_ | profs  << off_ ,
/* 18535 */	stmt    | 6396   << off_ ,	//	mov xr =lstms  set page message
/* 18536 */	loadi   | xr     << dst_ | lstms  << off_ ,
/* 18537 */	stmt    | 6397   << off_ ,	//	jsr prtst   print page message
/* 18538 */	call    | prtst  << off_ ,
/* 18539 */	stmt    | 6398   << off_ ,	//	icv lstpg   bump page number
/* 18540 */	load    | r1     << dst_ | lstpg  << off_ ,
/* 18541 */	icv     | r1     << dst_ ,
/* 18542 */	store   | r1     << dst_ | lstpg  << off_ ,
/* 18543 */	stmt    | 6399   << off_ ,	//	mti lstpg   load page number as integer
/* 18544 */	load    | ia     << dst_ | lstpg  << off_ ,
/* 18545 */	stmt    | 6400   << off_ ,	//	jsr prtin   print page number
/* 18546 */	call    | prtin  << off_ ,
/* 18547 */	stmt    | 6401   << off_ ,	//	jsr prtnl   terminate title line
/* 18548 */	call    | prtnl  << off_ ,
/* 18549 */	stmt    | 6402   << off_ ,	//	add lstlc =num02  count title line and blank line
/* 18550 */	load    | r1     << dst_ | lstlc  << off_ ,
/* 18551 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 18552 */	add     | r1     << dst_ | r2     << src_ ,
/* 18553 */	store   | r1     << dst_ | lstlc  << off_ ,
/* 18554 */	stmt    | 6403   << off_ ,	//	mov xr r_stl  load pointer to sub-title
/* 18555 */	load    | xr     << dst_ | r_stl  << off_ ,
/* 18556 */	stmt    | 6404   << off_ ,	//	bze xr lstt1  jump if no sub-title
/* 18557 */	bze     | xr     << dst_ | lstt1  << off_ ,
/* 18558 */	stmt    | 6405   << off_ ,	//	jsr prtst   else print sub-title
/* 18559 */	call    | prtst  << off_ ,
/* 18560 */	stmt    | 6406   << off_ ,	//	jsr prtnl   terminate line
/* 18561 */	call    | prtnl  << off_ ,
/* 18562 */	stmt    | 6407   << off_ ,	//	icv lstlc   bump line count
/* 18563 */	load    | r1     << dst_ | lstlc  << off_ ,
/* 18564 */	icv     | r1     << dst_ ,
/* 18565 */	store   | r1     << dst_ | lstlc  << off_ ,
// lstt1:
/* 18566 */	stmt    | 6408   << off_ ,	//lstt1	jsr prtnl   print a blank line
/* 18567 */	call    | prtnl  << off_ ,
/* 18568 */	stmt    | 6409   << off_ ,	//	exi    return to caller
/* 18569 */	exi     | 0      << off_ ,
// newfn:
/* 18570 */	stmt    | 6410   << off_ ,	//newfn	prc e 0  entry point
/* 18571 */	stmt    | 6411   << off_ ,	//	mov -(xs) xr  save new name
/* 18572 */	dca     | xs     << dst_ ,
/* 18573 */	store   | xr     << dst_ | xs     << src_ ,
/* 18574 */	stmt    | 6412   << off_ ,	//	mov xl r_sfc  load previous name
/* 18575 */	load    | xl     << dst_ | r_sfc  << off_ ,
/* 18576 */	stmt    | 6413   << off_ ,	//	jsr ident   check for equality
/* 18577 */	call    | ident  << off_ ,
/* 18578 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 18579 */	ppm     | nwfn1  << off_ ,
/* 18580 */	stmt    | 6414   << off_ ,	//	mov xr (xs)+  different, restore name
/* 18581 */	load    | xr     << dst_ | xs     << src_ ,
/* 18582 */	ica     | xs     << dst_ ,
/* 18583 */	stmt    | 6415   << off_ ,	//	mov r_sfc xr  record current file name
/* 18584 */	store   | xr     << dst_ | r_sfc  << off_ ,
/* 18585 */	stmt    | 6416   << off_ ,	//	mov wb cmpsn  get current statement
/* 18586 */	load    | wb     << dst_ | cmpsn  << off_ ,
/* 18587 */	stmt    | 6417   << off_ ,	//	mti wb   convert to integer
/* 18588 */	move    | ia     << dst_ | wb     << src_ ,
/* 18589 */	stmt    | 6418   << off_ ,	//	jsr icbld   build icblk for stmt number
/* 18590 */	call    | icbld  << off_ ,
/* 18591 */	stmt    | 6419   << off_ ,	//	mov xl r_sfn  file name table
/* 18592 */	load    | xl     << dst_ | r_sfn  << off_ ,
/* 18593 */	stmt    | 6420   << off_ ,	//	mnz wb   lookup statement number by name
/* 18594 */	move    | wb     << dst_ | xs     << src_ ,
/* 18595 */	stmt    | 6421   << off_ ,	//	jsr tfind   allocate new teblk
/* 18596 */	call    | tfind  << off_ ,
/* 18597 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 18598 */	ppm     ,
/* 18599 */	stmt    | 6422   << off_ ,	//	mov teval(xl) r_sfc  record file name as entry value
/* 18600 */	load    | r1     << dst_ | r_sfc  << off_ ,
/* 18601 */	store   | r1     << dst_ | xl     << src_ | teval  << off_ ,
/* 18602 */	stmt    | 6423   << off_ ,	//	exi
/* 18603 */	exi     | 0      << off_ ,
// nwfn1:
/* 18604 */	stmt    | 6424   << off_ ,	//nwfn1	ica xs   pop stack
/* 18605 */	ica     | xs     << dst_ ,
/* 18606 */	stmt    | 6425   << off_ ,	//	exi
/* 18607 */	exi     | 0      << off_ ,
// nexts:
/* 18608 */	stmt    | 6426   << off_ ,	//nexts	prc e 0  entry point
/* 18609 */	stmt    | 6427   << off_ ,	//	bze cswls nxts2  jump if -nolist
/* 18610 */	load    | r1     << dst_ | cswls  << off_ ,
/* 18611 */	bze     | r1     << dst_ | nxts2  << off_ ,
/* 18612 */	stmt    | 6428   << off_ ,	//	mov xr r_cim  point to image
/* 18613 */	load    | xr     << dst_ | r_cim  << off_ ,
/* 18614 */	stmt    | 6429   << off_ ,	//	bze xr nxts2  jump if no image
/* 18615 */	bze     | xr     << dst_ | nxts2  << off_ ,
/* 18616 */	stmt    | 6430   << off_ ,	//	plc xr   get char ptr
/* 18617 */	plc     | xr     << dst_ ,
/* 18618 */	stmt    | 6431   << off_ ,	//	lch wa (xr)  get first char
/* 18619 */	load    | wa     << dst_ | xr     << src_ ,
/* 18620 */	stmt    | 6432   << off_ ,	//	bne wa =ch_mn nxts1 jump if not ctrl card
/* 18621 */	loadi   | r2     << dst_ | ch_mn  << off_ ,
/* 18622 */	bne     | wa     << dst_ | r2     << src_ | nxts1  << off_ ,
/* 18623 */	stmt    | 6433   << off_ ,	//	bze cswpr nxts2  jump if -noprint
/* 18624 */	load    | r1     << dst_ | cswpr  << off_ ,
/* 18625 */	bze     | r1     << dst_ | nxts2  << off_ ,
// nxts1:
/* 18626 */	stmt    | 6434   << off_ ,	//nxts1	jsr listr   list line
/* 18627 */	call    | listr  << off_ ,
// nxts2:
/* 18628 */	stmt    | 6435   << off_ ,	//nxts2	mov xr r_cni  point to next image
/* 18629 */	load    | xr     << dst_ | r_cni  << off_ ,
/* 18630 */	stmt    | 6436   << off_ ,	//	mov r_cim xr  set as next image
/* 18631 */	store   | xr     << dst_ | r_cim  << off_ ,
/* 18632 */	stmt    | 6437   << off_ ,	//	mov rdcln rdnln  set as current line number
/* 18633 */	load    | r1     << dst_ | rdnln  << off_ ,
/* 18634 */	store   | r1     << dst_ | rdcln  << off_ ,
/* 18635 */	stmt    | 6438   << off_ ,	//	mov lstid cnind  set as current include depth
/* 18636 */	load    | r1     << dst_ | cnind  << off_ ,
/* 18637 */	store   | r1     << dst_ | lstid  << off_ ,
/* 18638 */	stmt    | 6439   << off_ ,	//	zer r_cni   clear next image pointer
/* 18639 */	store   | r0     << dst_ | r_cni  << off_ ,
/* 18640 */	stmt    | 6440   << off_ ,	//	mov wa sclen(xr)  get input image length
/* 18641 */	load    | wa     << dst_ | xr     << src_ | sclen  << off_ ,
/* 18642 */	stmt    | 6441   << off_ ,	//	mov wb cswin  get max allowable length
/* 18643 */	load    | wb     << dst_ | cswin  << off_ ,
/* 18644 */	stmt    | 6442   << off_ ,	//	blo wa wb nxts3 skip if not too long
/* 18645 */	blo     | wa     << dst_ | wb     << src_ | nxts3  << off_ ,
/* 18646 */	stmt    | 6443   << off_ ,	//	mov wa wb  else truncate
/* 18647 */	move    | wa     << dst_ | wb     << src_ ,
// nxts3:
/* 18648 */	stmt    | 6444   << off_ ,	//nxts3	mov scnil wa  use as record length
/* 18649 */	store   | wa     << dst_ | scnil  << off_ ,
/* 18650 */	stmt    | 6445   << off_ ,	//	zer scnse   reset scnse
/* 18651 */	store   | r0     << dst_ | scnse  << off_ ,
/* 18652 */	stmt    | 6446   << off_ ,	//	zer lstpf   set line not listed yet
/* 18653 */	store   | r0     << dst_ | lstpf  << off_ ,
/* 18654 */	stmt    | 6447   << off_ ,	//	exi    return to nexts caller
/* 18655 */	exi     | 0      << off_ ,
// patin:
/* 18656 */	stmt    | 6448   << off_ ,	//patin	prc n 2  entry point
/* 18657 */	prc     | 13     << off_ ,
/* 18658 */	stmt    | 6449   << off_ ,	//	mov xl wa  preserve expression arg pcode
/* 18659 */	move    | xl     << dst_ | wa     << src_ ,
/* 18660 */	stmt    | 6450   << off_ ,	//	jsr gtsmi   try to convert arg as small integer
/* 18661 */	call    | gtsmi  << off_ ,
/* 18662 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/* 18663 */	ppm     | ptin2  << off_ ,
/* 18664 */	ppm     | ptin3  << off_ ,
// ptin1:
/* 18665 */	stmt    | 6451   << off_ ,	//ptin1	jsr pbild   build pattern node
/* 18666 */	call    | pbild  << off_ ,
/* 18667 */	stmt    | 6452   << off_ ,	//	exi    return to caller
/* 18668 */	exi     | 1300   << off_ ,
// ptin2:
/* 18669 */	stmt    | 6453   << off_ ,	//ptin2	mov wb xl  copy expr arg case pcode
/* 18670 */	move    | wb     << dst_ | xl     << src_ ,
/* 18671 */	stmt    | 6454   << off_ ,	//	blo (xr) =b_e__ ptin1 all ok if expression arg
/* 18672 */	load    | r1     << dst_ | xr     << src_ ,
/* 18673 */	loadi   | r2     << dst_ | b_e__  << off_ ,
/* 18674 */	blo     | r1     << dst_ | r2     << src_ | ptin1  << off_ ,
/* 18675 */	stmt    | 6455   << off_ ,	//	exi 1   else take error exit for wrong type
/* 18676 */	exi     | 1301   << off_ ,
// ptin3:
/* 18677 */	stmt    | 6456   << off_ ,	//ptin3	exi 2   take out-of-range error exit
/* 18678 */	exi     | 1302   << off_ ,
// patst:
/* 18679 */	stmt    | 6457   << off_ ,	//patst	prc n 1  entry point
/* 18680 */	prc     | 14     << off_ ,
/* 18681 */	stmt    | 6458   << off_ ,	//	jsr gtstg   convert argument as string
/* 18682 */	call    | gtstg  << off_ ,
/* 18683 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 18684 */	ppm     | pats7  << off_ ,
/* 18685 */	stmt    | 6459   << off_ ,	//	bze wa pats7  jump if null string (catspaw)
/* 18686 */	bze     | wa     << dst_ | pats7  << off_ ,
/* 18687 */	stmt    | 6460   << off_ ,	//	bne wa =num01 pats2 jump if not one char string
/* 18688 */	loadi   | r2     << dst_ | num01  << off_ ,
/* 18689 */	bne     | wa     << dst_ | r2     << src_ | pats2  << off_ ,
/* 18690 */	stmt    | 6461   << off_ ,	//	bze wb pats2  treat as multi-char if evals call
/* 18691 */	bze     | wb     << dst_ | pats2  << off_ ,
/* 18692 */	stmt    | 6462   << off_ ,	//	plc xr   point to character
/* 18693 */	plc     | xr     << dst_ ,
/* 18694 */	stmt    | 6463   << off_ ,	//	lch xr (xr)  load character
/* 18695 */	load    | xr     << dst_ | xr     << src_ ,
// pats1:
/* 18696 */	stmt    | 6464   << off_ ,	//pats1	jsr pbild   call routine to build node
/* 18697 */	call    | pbild  << off_ ,
/* 18698 */	stmt    | 6465   << off_ ,	//	exi    return to patst caller
/* 18699 */	exi     | 1400   << off_ ,
// pats2:
/* 18700 */	stmt    | 6466   << off_ ,	//pats2	mov -(xs) xl  save multi-char pcode
/* 18701 */	dca     | xs     << dst_ ,
/* 18702 */	store   | xl     << dst_ | xs     << src_ ,
/* 18703 */	stmt    | 6467   << off_ ,	//	mov wc ctmsk  load current mask bit
/* 18704 */	load    | wc     << dst_ | ctmsk  << off_ ,
/* 18705 */	stmt    | 6468   << off_ ,	//	beq xr r_cts pats6 jump if same as last string c3.738
/* 18706 */	load    | r2     << dst_ | r_cts  << off_ ,
/* 18707 */	beq     | xr     << dst_ | r2     << src_ | pats6  << off_ ,
/* 18708 */	stmt    | 6469   << off_ ,	//	mov -(xs) xr  save string pointer
/* 18709 */	dca     | xs     << dst_ ,
/* 18710 */	store   | xr     << dst_ | xs     << src_ ,
/* 18711 */	stmt    | 6470   << off_ ,	//	lsh wc 1  shift to next position
/* 18712 */	lsh     | wc     << dst_ | 1      << off_ ,
/* 18713 */	stmt    | 6471   << off_ ,	//	nzb wc pats4  skip if position left in this tbl
/* 18714 */	nzb     | wc     << dst_ | pats4  << off_ ,
/* 18715 */	stmt    | 6472   << off_ ,	//	mov wa *ctsi_  set size of ctblk
/* 18716 */	loadi   | wa     << dst_ | ctsi_  << off_ ,
/* 18717 */	stmt    | 6473   << off_ ,	//	jsr alloc   allocate ctblk
/* 18718 */	call    | alloc  << off_ ,
/* 18719 */	stmt    | 6474   << off_ ,	//	mov r_ctp xr  store ptr to new ctblk
/* 18720 */	store   | xr     << dst_ | r_ctp  << off_ ,
/* 18721 */	stmt    | 6475   << off_ ,	//	mov (xr)+ =b_ctt  store type code, bump ptr
/* 18722 */	loadi   | r1     << dst_ | b_ctt  << off_ ,
/* 18723 */	store   | r1     << dst_ | xr     << src_ ,
/* 18724 */	ica     | xr     << dst_ ,
/* 18725 */	stmt    | 6476   << off_ ,	//	lct wb =cfp_a  set number of words to clear
/* 18726 */	loadi   | wb     << dst_ | cfp_a  << off_ ,
/* 18727 */	stmt    | 6477   << off_ ,	//	mov wc 4,bits0  load all zero bits
/* 18728 */	load    | wc     << dst_ | bits0  << off_ ,
// pats3:
/* 18729 */	stmt    | 6478   << off_ ,	//pats3	mov (xr)+ wc  move word of zero bits
/* 18730 */	store   | wc     << dst_ | xr     << src_ ,
/* 18731 */	ica     | xr     << dst_ ,
/* 18732 */	stmt    | 6479   << off_ ,	//	bct wb pats3  loop till all cleared
/* 18733 */	bct     | wb     << dst_ | pats3  << off_ ,
/* 18734 */	stmt    | 6480   << off_ ,	//	mov wc 4,bits1  set initial bit position
/* 18735 */	load    | wc     << dst_ | bits1  << off_ ,
// pats4:
/* 18736 */	stmt    | 6481   << off_ ,	//pats4	mov ctmsk wc  save parm2 (new bit position)
/* 18737 */	store   | wc     << dst_ | ctmsk  << off_ ,
/* 18738 */	stmt    | 6482   << off_ ,	//	mov xl (xs)+  restore pointer to argument string
/* 18739 */	load    | xl     << dst_ | xs     << src_ ,
/* 18740 */	ica     | xs     << dst_ ,
/* 18741 */	stmt    | 6483   << off_ ,	//	mov r_cts xl  save for next time   c3.738
/* 18742 */	store   | xl     << dst_ | r_cts  << off_ ,
/* 18743 */	stmt    | 6484   << off_ ,	//	mov wb sclen(xl)  load string length
/* 18744 */	load    | wb     << dst_ | xl     << src_ | sclen  << off_ ,
/* 18745 */	stmt    | 6485   << off_ ,	//	bze wb pats6  jump if null string case
/* 18746 */	bze     | wb     << dst_ | pats6  << off_ ,
/* 18747 */	stmt    | 6486   << off_ ,	//	lct wb wb  else set loop counter
/* 18748 */	stmt    | 6487   << off_ ,	//	plc xl   point to characters in argument
/* 18749 */	plc     | xl     << dst_ ,
// pats5:
/* 18750 */	stmt    | 6488   << off_ ,	//pats5	lch wa (xl)+  load next character
/* 18751 */	load    | wa     << dst_ | xl     << src_ ,
/* 18752 */	ica     | xl     << dst_ ,
/* 18753 */	stmt    | 6489   << off_ ,	//	wtb wa   convert to byte offset
/* 18754 */	stmt    | 6490   << off_ ,	//	mov xr r_ctp  point to ctblk
/* 18755 */	load    | xr     << dst_ | r_ctp  << off_ ,
/* 18756 */	stmt    | 6491   << off_ ,	//	add xr wa  point to ctblk entry
/* 18757 */	add     | xr     << dst_ | wa     << src_ ,
/* 18758 */	stmt    | 6492   << off_ ,	//	mov wa wc  copy bit mask
/* 18759 */	move    | wa     << dst_ | wc     << src_ ,
/* 18760 */	stmt    | 6493   << off_ ,	//	orb wa ctchs(xr)  or in bits already set
/* 18761 */	load    | r2     << dst_ | xr     << src_ | ctchs  << off_ ,
/* 18762 */	orb     | wa     << dst_ | r2     << src_ ,
/* 18763 */	stmt    | 6494   << off_ ,	//	mov ctchs(xr) wa  store resulting bit string
/* 18764 */	store   | wa     << dst_ | xr     << src_ | ctchs  << off_ ,
/* 18765 */	stmt    | 6495   << off_ ,	//	bct wb pats5  loop till all bits set
/* 18766 */	bct     | wb     << dst_ | pats5  << off_ ,
// pats6:
/* 18767 */	stmt    | 6496   << off_ ,	//pats6	mov xr r_ctp  load ctblk ptr as parm1 for pbild
/* 18768 */	load    | xr     << dst_ | r_ctp  << off_ ,
/* 18769 */	stmt    | 6497   << off_ ,	//	zer xl   clear garbage ptr in xl
/* 18770 */	move    | xl     << dst_ ,
/* 18771 */	stmt    | 6498   << off_ ,	//	mov wb (xs)+  load pcode for multi-char str case
/* 18772 */	load    | wb     << dst_ | xs     << src_ ,
/* 18773 */	ica     | xs     << dst_ ,
/* 18774 */	stmt    | 6499   << off_ ,	//	brn pats1   back to exit (wc=bitstring=parm2)
/* 18775 */	brn     | pats1  << off_ ,
// pats7:
/* 18776 */	stmt    | 6500   << off_ ,	//pats7	mov wb wc  set pcode for expression argument
/* 18777 */	move    | wb     << dst_ | wc     << src_ ,
/* 18778 */	stmt    | 6501   << off_ ,	//	blo (xr) =b_e__ pats1 jump to exit if expression arg
/* 18779 */	load    | r1     << dst_ | xr     << src_ ,
/* 18780 */	loadi   | r2     << dst_ | b_e__  << off_ ,
/* 18781 */	blo     | r1     << dst_ | r2     << src_ | pats1  << off_ ,
/* 18782 */	stmt    | 6502   << off_ ,	//	exi 1   else take wrong type error exit
/* 18783 */	exi     | 1401   << off_ ,
// pbild:
/* 18784 */	stmt    | 6503   << off_ ,	//pbild	prc e 0  entry point
/* 18785 */	stmt    | 6504   << off_ ,	//	mov -(xs) xr  stack possible parm1
/* 18786 */	dca     | xs     << dst_ ,
/* 18787 */	store   | xr     << dst_ | xs     << src_ ,
/* 18788 */	stmt    | 6505   << off_ ,	//	mov xr wb  copy pcode
/* 18789 */	move    | xr     << dst_ | wb     << src_ ,
/* 18790 */	stmt    | 6506   << off_ ,	//	lei xr   load entry point id (bl_px)
/* 18791 */	lei     | xr     << dst_ ,
/* 18792 */	stmt    | 6507   << off_ ,	//	beq xr =bl_p1 pbld1 jump if one parameter
/* 18793 */	loadi   | r2     << dst_ | bl_p1  << off_ ,
/* 18794 */	beq     | xr     << dst_ | r2     << src_ | pbld1  << off_ ,
/* 18795 */	stmt    | 6508   << off_ ,	//	beq xr =bl_p0 pbld3 jump if no parameters
/* 18796 */	loadi   | r2     << dst_ | bl_p0  << off_ ,
/* 18797 */	beq     | xr     << dst_ | r2     << src_ | pbld3  << off_ ,
/* 18798 */	stmt    | 6509   << off_ ,	//	mov wa *pcsi_  set size of p2blk
/* 18799 */	loadi   | wa     << dst_ | pcsi_  << off_ ,
/* 18800 */	stmt    | 6510   << off_ ,	//	jsr alloc   allocate block
/* 18801 */	call    | alloc  << off_ ,
/* 18802 */	stmt    | 6511   << off_ ,	//	mov parm2(xr) wc  store second parameter
/* 18803 */	store   | wc     << dst_ | xr     << src_ | parm2  << off_ ,
/* 18804 */	stmt    | 6512   << off_ ,	//	brn pbld2   merge with one parm case
/* 18805 */	brn     | pbld2  << off_ ,
// pbld1:
/* 18806 */	stmt    | 6513   << off_ ,	//pbld1	mov wa *pbsi_  set size of p1blk
/* 18807 */	loadi   | wa     << dst_ | pbsi_  << off_ ,
/* 18808 */	stmt    | 6514   << off_ ,	//	jsr alloc   allocate node
/* 18809 */	call    | alloc  << off_ ,
// pbld2:
/* 18810 */	stmt    | 6515   << off_ ,	//pbld2	mov parm1(xr) (xs)  store first parameter
/* 18811 */	load    | r1     << dst_ | xs     << src_ ,
/* 18812 */	store   | r1     << dst_ | xr     << src_ | parm1  << off_ ,
/* 18813 */	stmt    | 6516   << off_ ,	//	brn pbld4   merge with no parameter case
/* 18814 */	brn     | pbld4  << off_ ,
// pbld3:
/* 18815 */	stmt    | 6517   << off_ ,	//pbld3	mov wa *pasi_  set size of p0blk
/* 18816 */	loadi   | wa     << dst_ | pasi_  << off_ ,
/* 18817 */	stmt    | 6518   << off_ ,	//	jsr alloc   allocate node
/* 18818 */	call    | alloc  << off_ ,
// pbld4:
/* 18819 */	stmt    | 6519   << off_ ,	//pbld4	mov (xr) wb  store pcode
/* 18820 */	store   | wb     << dst_ | xr     << src_ ,
/* 18821 */	stmt    | 6520   << off_ ,	//	ica xs   pop first parameter
/* 18822 */	ica     | xs     << dst_ ,
/* 18823 */	stmt    | 6521   << off_ ,	//	mov pthen(xr) =ndnth  set nothen successor pointer
/* 18824 */	loadi   | r1     << dst_ | ndnth  << off_ ,
/* 18825 */	store   | r1     << dst_ | xr     << src_ | pthen  << off_ ,
/* 18826 */	stmt    | 6522   << off_ ,	//	exi    return to pbild caller
/* 18827 */	exi     | 0      << off_ ,
// pconc:
/* 18828 */	stmt    | 6523   << off_ ,	//pconc	prc e 0  entry point
/* 18829 */	stmt    | 6524   << off_ ,	//	zer -(xs)   make room for one entry at bottom
/* 18830 */	dca     | xs     << dst_ ,
/* 18831 */	store   | r0     << dst_ | xs     << src_ ,
/* 18832 */	stmt    | 6525   << off_ ,	//	mov wc xs  store pointer to start of list
/* 18833 */	move    | wc     << dst_ | xs     << src_ ,
/* 18834 */	stmt    | 6526   << off_ ,	//	mov -(xs) =ndnth  stack nothen node as old node
/* 18835 */	loadi   | r1     << dst_ | ndnth  << off_ ,
/* 18836 */	dca     | xs     << dst_ ,
/* 18837 */	store   | r1     << dst_ | xs     << src_ ,
/* 18838 */	stmt    | 6527   << off_ ,	//	mov -(xs) xl  store right arg as copy of nothen
/* 18839 */	dca     | xs     << dst_ ,
/* 18840 */	store   | xl     << dst_ | xs     << src_ ,
/* 18841 */	stmt    | 6528   << off_ ,	//	mov xt xs  initialize pointer to stack entries
/* 18842 */	move    | xt     << dst_ | xs     << src_ ,
/* 18843 */	stmt    | 6529   << off_ ,	//	jsr pcopy   copy first node of left arg
/* 18844 */	call    | pcopy  << off_ ,
/* 18845 */	stmt    | 6530   << off_ ,	//	mov num02(xt) wa  store as result under list
/* 18846 */	store   | wa     << dst_ | xt     << src_ | num02  << off_ ,
// pcnc1:
/* 18847 */	stmt    | 6531   << off_ ,	//pcnc1	beq xt xs pcnc2 jump if all entries processed
/* 18848 */	beq     | xt     << dst_ | xs     << src_ | pcnc2  << off_ ,
/* 18849 */	stmt    | 6532   << off_ ,	//	mov xr -(xt)  else load next old address
/* 18850 */	dca     | xt     << dst_ ,
/* 18851 */	load    | xr     << dst_ | xt     << src_ ,
/* 18852 */	stmt    | 6533   << off_ ,	//	mov xr pthen(xr)  load pointer to successor
/* 18853 */	load    | xr     << dst_ | xr     << src_ | pthen  << off_ ,
/* 18854 */	stmt    | 6534   << off_ ,	//	jsr pcopy   copy successor node
/* 18855 */	call    | pcopy  << off_ ,
/* 18856 */	stmt    | 6535   << off_ ,	//	mov xr -(xt)  load pointer to new node (copy)
/* 18857 */	dca     | xt     << dst_ ,
/* 18858 */	load    | xr     << dst_ | xt     << src_ ,
/* 18859 */	stmt    | 6536   << off_ ,	//	mov pthen(xr) wa  store ptr to new successor
/* 18860 */	store   | wa     << dst_ | xr     << src_ | pthen  << off_ ,
/* 18861 */	stmt    | 6537   << off_ ,	//	bne (xr) =p_alt pcnc1 loop back if not
/* 18862 */	load    | r1     << dst_ | xr     << src_ ,
/* 18863 */	loadi   | r2     << dst_ | p_alt  << off_ ,
/* 18864 */	bne     | r1     << dst_ | r2     << src_ | pcnc1  << off_ ,
/* 18865 */	stmt    | 6538   << off_ ,	//	mov xr parm1(xr)  else load pointer to alternative
/* 18866 */	load    | xr     << dst_ | xr     << src_ | parm1  << off_ ,
/* 18867 */	stmt    | 6539   << off_ ,	//	jsr pcopy   copy it
/* 18868 */	call    | pcopy  << off_ ,
/* 18869 */	stmt    | 6540   << off_ ,	//	mov xr (xt)  restore ptr to new node
/* 18870 */	load    | xr     << dst_ | xt     << src_ ,
/* 18871 */	stmt    | 6541   << off_ ,	//	mov parm1(xr) wa  store ptr to copied alternative
/* 18872 */	store   | wa     << dst_ | xr     << src_ | parm1  << off_ ,
/* 18873 */	stmt    | 6542   << off_ ,	//	brn pcnc1   loop back for next entry
/* 18874 */	brn     | pcnc1  << off_ ,
// pcnc2:
/* 18875 */	stmt    | 6543   << off_ ,	//pcnc2	mov xs wc  restore stack pointer
/* 18876 */	move    | xs     << dst_ | wc     << src_ ,
/* 18877 */	stmt    | 6544   << off_ ,	//	mov xr (xs)+  load pointer to copy
/* 18878 */	load    | xr     << dst_ | xs     << src_ ,
/* 18879 */	ica     | xs     << dst_ ,
/* 18880 */	stmt    | 6545   << off_ ,	//	exi    return to pconc caller
/* 18881 */	exi     | 0      << off_ ,
// pcopy:
/* 18882 */	stmt    | 6546   << off_ ,	//pcopy	prc n 0  entry point
/* 18883 */	prc     | 15     << off_ ,
/* 18884 */	stmt    | 6547   << off_ ,	//	mov wb xt  save xt
/* 18885 */	move    | wb     << dst_ | xt     << src_ ,
/* 18886 */	stmt    | 6548   << off_ ,	//	mov xt wc  point to start of list
/* 18887 */	move    | xt     << dst_ | wc     << src_ ,
// pcop1:
/* 18888 */	stmt    | 6549   << off_ ,	//pcop1	dca xt   point to next entry on list
/* 18889 */	dca     | xt     << dst_ ,
/* 18890 */	stmt    | 6550   << off_ ,	//	beq xr (xt) pcop2 jump if match
/* 18891 */	load    | r2     << dst_ | xt     << src_ ,
/* 18892 */	beq     | xr     << dst_ | r2     << src_ | pcop2  << off_ ,
/* 18893 */	stmt    | 6551   << off_ ,	//	dca xt   else skip over copied address
/* 18894 */	dca     | xt     << dst_ ,
/* 18895 */	stmt    | 6552   << off_ ,	//	bne xt xs pcop1 loop back if more to test
/* 18896 */	bne     | xt     << dst_ | xs     << src_ | pcop1  << off_ ,
/* 18897 */	stmt    | 6553   << off_ ,	//	mov wa (xr)  load first word of block
/* 18898 */	load    | wa     << dst_ | xr     << src_ ,
/* 18899 */	stmt    | 6554   << off_ ,	//	jsr blkln   get length of block
/* 18900 */	call    | blkln  << off_ ,
/* 18901 */	stmt    | 6555   << off_ ,	//	mov xl xr  save pointer to old node
/* 18902 */	move    | xl     << dst_ | xr     << src_ ,
/* 18903 */	stmt    | 6556   << off_ ,	//	jsr alloc   allocate space for copy
/* 18904 */	call    | alloc  << off_ ,
/* 18905 */	stmt    | 6557   << off_ ,	//	mov -(xs) xl  store old address on list
/* 18906 */	dca     | xs     << dst_ ,
/* 18907 */	store   | xl     << dst_ | xs     << src_ ,
/* 18908 */	stmt    | 6558   << off_ ,	//	mov -(xs) xr  store new address on list
/* 18909 */	dca     | xs     << dst_ ,
/* 18910 */	store   | xr     << dst_ | xs     << src_ ,
/* 18911 */	stmt    | 6559   << off_ ,	//	chk    check for stack overflow
/* 18912 */	chk     ,
/* 18913 */	stmt    | 6560   << off_ ,	//	mvw    move words from old block to copy
/* 18914 */	mvw     ,
/* 18915 */	stmt    | 6561   << off_ ,	//	mov wa (xs)  load pointer to copy
/* 18916 */	load    | wa     << dst_ | xs     << src_ ,
/* 18917 */	stmt    | 6562   << off_ ,	//	brn pcop3   jump to exit
/* 18918 */	brn     | pcop3  << off_ ,
// pcop2:
/* 18919 */	stmt    | 6563   << off_ ,	//pcop2	mov wa -(xt)  load address of copy from list
/* 18920 */	dca     | xt     << dst_ ,
/* 18921 */	load    | wa     << dst_ | xt     << src_ ,
// pcop3:
/* 18922 */	stmt    | 6564   << off_ ,	//pcop3	mov xt wb  restore xt
/* 18923 */	move    | xt     << dst_ | wb     << src_ ,
/* 18924 */	stmt    | 6565   << off_ ,	//	exi    return to pcopy caller
/* 18925 */	exi     | 1500   << off_ ,
// prflr:
/* 18926 */	stmt    | 6566   << off_ ,	//prflr	prc e 0
/* 18927 */	stmt    | 6567   << off_ ,	//	bze pfdmp prfl4  no printing if no profiling done
/* 18928 */	load    | r1     << dst_ | pfdmp  << off_ ,
/* 18929 */	bze     | r1     << dst_ | prfl4  << off_ ,
/* 18930 */	stmt    | 6568   << off_ ,	//	mov -(xs) xr  preserve entry xr
/* 18931 */	dca     | xs     << dst_ ,
/* 18932 */	store   | xr     << dst_ | xs     << src_ ,
/* 18933 */	stmt    | 6569   << off_ ,	//	mov pfsvw wb  and also wb
/* 18934 */	store   | wb     << dst_ | pfsvw  << off_ ,
/* 18935 */	stmt    | 6570   << off_ ,	//	jsr prtpg   eject
/* 18936 */	call    | prtpg  << off_ ,
/* 18937 */	stmt    | 6571   << off_ ,	//	mov xr =pfms1  load msg /program profile/
/* 18938 */	loadi   | xr     << dst_ | pfms1  << off_ ,
/* 18939 */	stmt    | 6572   << off_ ,	//	jsr prtst   and print it
/* 18940 */	call    | prtst  << off_ ,
/* 18941 */	stmt    | 6573   << off_ ,	//	jsr prtnl   followed by newline
/* 18942 */	call    | prtnl  << off_ ,
/* 18943 */	stmt    | 6574   << off_ ,	//	jsr prtnl   and another
/* 18944 */	call    | prtnl  << off_ ,
/* 18945 */	stmt    | 6575   << off_ ,	//	mov xr =pfms2  point to first hdr
/* 18946 */	loadi   | xr     << dst_ | pfms2  << off_ ,
/* 18947 */	stmt    | 6576   << off_ ,	//	jsr prtst   print it
/* 18948 */	call    | prtst  << off_ ,
/* 18949 */	stmt    | 6577   << off_ ,	//	jsr prtnl   new line
/* 18950 */	call    | prtnl  << off_ ,
/* 18951 */	stmt    | 6578   << off_ ,	//	mov xr =pfms3  second hdr
/* 18952 */	loadi   | xr     << dst_ | pfms3  << off_ ,
/* 18953 */	stmt    | 6579   << off_ ,	//	jsr prtst   print it
/* 18954 */	call    | prtst  << off_ ,
/* 18955 */	stmt    | 6580   << off_ ,	//	jsr prtnl   new line
/* 18956 */	call    | prtnl  << off_ ,
/* 18957 */	stmt    | 6581   << off_ ,	//	jsr prtnl   and another blank line
/* 18958 */	call    | prtnl  << off_ ,
/* 18959 */	stmt    | 6582   << off_ ,	//	zer wb   initial stmt count
/* 18960 */	move    | wb     << dst_ ,
/* 18961 */	stmt    | 6583   << off_ ,	//	mov xr pftbl  point to table origin
/* 18962 */	load    | xr     << dst_ | pftbl  << off_ ,
/* 18963 */	stmt    | 6584   << off_ ,	//	add xr *xndta  bias past xnblk header (sgd07)
/* 18964 */	loadi   | r2     << dst_ | xndta  << off_ ,
/* 18965 */	add     | xr     << dst_ | r2     << src_ ,
// prfl1:
/* 18966 */	stmt    | 6585   << off_ ,	//prfl1	icv wb   bump stmt nr
/* 18967 */	icv     | wb     << dst_ ,
/* 18968 */	stmt    | 6586   << off_ ,	//	ldi (xr)   load nr of executions
/* 18969 */	load    | r1     << dst_ | xr     << src_ ,
/* 18970 */	ldi     | r1     << dst_ ,
/* 18971 */	stmt    | 6587   << off_ ,	//	ieq prfl3   no printing if zero
/* 18972 */	ieq     | prfl3  << off_ ,
/* 18973 */	stmt    | 6588   << off_ ,	//	mov profs =pfpd1  point where to print
/* 18974 */	loadi   | r1     << dst_ | pfpd1  << off_ ,
/* 18975 */	store   | r1     << dst_ | profs  << off_ ,
/* 18976 */	stmt    | 6589   << off_ ,	//	jsr prtin   and print it
/* 18977 */	call    | prtin  << off_ ,
/* 18978 */	stmt    | 6590   << off_ ,	//	zer profs   back to start of line
/* 18979 */	store   | r0     << dst_ | profs  << off_ ,
/* 18980 */	stmt    | 6591   << off_ ,	//	mti wb   load stmt nr
/* 18981 */	move    | ia     << dst_ | wb     << src_ ,
/* 18982 */	stmt    | 6592   << off_ ,	//	jsr prtin   print it there
/* 18983 */	call    | prtin  << off_ ,
/* 18984 */	stmt    | 6593   << off_ ,	//	mov profs =pfpd2  and pad past count
/* 18985 */	loadi   | r1     << dst_ | pfpd2  << off_ ,
/* 18986 */	store   | r1     << dst_ | profs  << off_ ,
/* 18987 */	stmt    | 6594   << off_ ,	//	ldi cfp_i(xr)   load total exec time
/* 18988 */	load    | r1     << dst_ | xr     << src_ | cfp_i  << off_ ,
/* 18989 */	ldi     | r1     << dst_ ,
/* 18990 */	stmt    | 6595   << off_ ,	//	jsr prtin   print that too
/* 18991 */	call    | prtin  << off_ ,
/* 18992 */	stmt    | 6596   << off_ ,	//	ldi cfp_i(xr)   reload time
/* 18993 */	load    | r1     << dst_ | xr     << src_ | cfp_i  << off_ ,
/* 18994 */	ldi     | r1     << dst_ ,
/* 18995 */	stmt    | 6597   << off_ ,	//	mli 4,intth   convert to microsec
/* 18996 */	load    | r1     << dst_ | intth  << off_ ,
/* 18997 */	mli     | r1     << dst_ ,
/* 18998 */	stmt    | 6598   << off_ ,	//	iov prfl2   omit next bit if overflow
/* 18999 */	iov     | prfl2  << off_ ,
/* 19000 */	stmt    | 6599   << off_ ,	//	dvi (xr)   divide by executions
/* 19001 */	load    | r1     << dst_ | xr     << src_ ,
/* 19002 */	dvi     | r1     << dst_ ,
/* 19003 */	stmt    | 6600   << off_ ,	//	mov profs =pfpd3  pad last print
/* 19004 */	loadi   | r1     << dst_ | pfpd3  << off_ ,
/* 19005 */	store   | r1     << dst_ | profs  << off_ ,
/* 19006 */	stmt    | 6601   << off_ ,	//	jsr prtin   and print mcsec/execn
/* 19007 */	call    | prtin  << off_ ,
// prfl2:
/* 19008 */	stmt    | 6602   << off_ ,	//prfl2	jsr prtnl   thats another line
/* 19009 */	call    | prtnl  << off_ ,
// prfl3:
/* 19010 */	stmt    | 6603   << off_ ,	//prfl3	add xr *pf_i2  bump index ptr (sgd07)
/* 19011 */	loadi   | r2     << dst_ | pf_i2  << off_ ,
/* 19012 */	add     | xr     << dst_ | r2     << src_ ,
/* 19013 */	stmt    | 6604   << off_ ,	//	blt wb pfnte prfl1 loop if more stmts
/* 19014 */	load    | r2     << dst_ | pfnte  << off_ ,
/* 19015 */	blt     | wb     << dst_ | r2     << src_ | prfl1  << off_ ,
/* 19016 */	stmt    | 6605   << off_ ,	//	mov xr (xs)+  restore callers xr
/* 19017 */	load    | xr     << dst_ | xs     << src_ ,
/* 19018 */	ica     | xs     << dst_ ,
/* 19019 */	stmt    | 6606   << off_ ,	//	mov wb pfsvw  and wb too
/* 19020 */	load    | wb     << dst_ | pfsvw  << off_ ,
// prfl4:
/* 19021 */	stmt    | 6607   << off_ ,	//prfl4	exi    return
/* 19022 */	exi     | 0      << off_ ,
// prflu:
/* 19023 */	stmt    | 6608   << off_ ,	//prflu	prc e 0
/* 19024 */	stmt    | 6609   << off_ ,	//	bnz pffnc pflu4  skip if just entered function
/* 19025 */	load    | r1     << dst_ | pffnc  << off_ ,
/* 19026 */	bnz     | r1     << dst_ | pflu4  << off_ ,
/* 19027 */	stmt    | 6610   << off_ ,	//	mov -(xs) xr  preserve entry xr
/* 19028 */	dca     | xs     << dst_ ,
/* 19029 */	store   | xr     << dst_ | xs     << src_ ,
/* 19030 */	stmt    | 6611   << off_ ,	//	mov pfsvw wa  save wa (sgd07)
/* 19031 */	store   | wa     << dst_ | pfsvw  << off_ ,
/* 19032 */	stmt    | 6612   << off_ ,	//	bnz pftbl pflu2  branch if table allocated
/* 19033 */	load    | r1     << dst_ | pftbl  << off_ ,
/* 19034 */	bnz     | r1     << dst_ | pflu2  << off_ ,
/* 19035 */	stmt    | 6613   << off_ ,	//	sub pfnte =num01  adjust for extra count (sgd07)
/* 19036 */	load    | r1     << dst_ | pfnte  << off_ ,
/* 19037 */	loadi   | r2     << dst_ | num01  << off_ ,
/* 19038 */	sub     | r1     << dst_ | r2     << src_ ,
/* 19039 */	store   | r1     << dst_ | pfnte  << off_ ,
/* 19040 */	stmt    | 6614   << off_ ,	//	mti 4,pfi2a   convrt entry size to int
/* 19041 */	load    | ia     << dst_ | pfi2a  << off_ ,
/* 19042 */	stmt    | 6615   << off_ ,	//	sti pfste   and store safely for later
/* 19043 */	store   | ia     << dst_ | pfste  << off_ ,
/* 19044 */	stmt    | 6616   << off_ ,	//	mti pfnte   load table length as integer
/* 19045 */	load    | ia     << dst_ | pfnte  << off_ ,
/* 19046 */	stmt    | 6617   << off_ ,	//	mli pfste   multiply by entry size
/* 19047 */	load    | r1     << dst_ | pfste  << off_ ,
/* 19048 */	mli     | r1     << dst_ ,
/* 19049 */	stmt    | 6618   << off_ ,	//	mfi wa   get back address-style
/* 19050 */	move    | wa     << dst_ | ia     << src_ ,
/* 19051 */	stmt    | 6619   << off_ ,	//	add wa =num02  add on 2 word overhead
/* 19052 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 19053 */	add     | wa     << dst_ | r2     << src_ ,
/* 19054 */	stmt    | 6620   << off_ ,	//	wtb wa   convert the whole lot to bytes
/* 19055 */	stmt    | 6621   << off_ ,	//	jsr alost   gimme the space
/* 19056 */	call    | alost  << off_ ,
/* 19057 */	stmt    | 6622   << off_ ,	//	mov pftbl xr  save block pointer
/* 19058 */	store   | xr     << dst_ | pftbl  << off_ ,
/* 19059 */	stmt    | 6623   << off_ ,	//	mov (xr)+ =b_xnt  put block type and ...
/* 19060 */	loadi   | r1     << dst_ | b_xnt  << off_ ,
/* 19061 */	store   | r1     << dst_ | xr     << src_ ,
/* 19062 */	ica     | xr     << dst_ ,
/* 19063 */	stmt    | 6624   << off_ ,	//	mov (xr)+ wa  ... length into header
/* 19064 */	store   | wa     << dst_ | xr     << src_ ,
/* 19065 */	ica     | xr     << dst_ ,
/* 19066 */	stmt    | 6625   << off_ ,	//	mfi wa   get back nr of wds in data area
/* 19067 */	move    | wa     << dst_ | ia     << src_ ,
/* 19068 */	stmt    | 6626   << off_ ,	//	lct wa wa  load the counter
// pflu1:
/* 19069 */	stmt    | 6627   << off_ ,	//pflu1	zer (xr)+   blank a word
/* 19070 */	store   | r0     << dst_ | xr     << src_ ,
/* 19071 */	ica     | xr     << dst_ ,
/* 19072 */	stmt    | 6628   << off_ ,	//	bct wa pflu1  and alllllll the rest
/* 19073 */	bct     | wa     << dst_ | pflu1  << off_ ,
// pflu2:
/* 19074 */	stmt    | 6629   << off_ ,	//pflu2	mti kvstn   load nr of stmt just ended
/* 19075 */	load    | ia     << dst_ | kvstn  << off_ ,
/* 19076 */	stmt    | 6630   << off_ ,	//	sbi 4,intv1   make into index offset
/* 19077 */	load    | r1     << dst_ | intv1  << off_ ,
/* 19078 */	sbi     | r1     << dst_ ,
/* 19079 */	stmt    | 6631   << off_ ,	//	mli pfste   make offset of table entry
/* 19080 */	load    | r1     << dst_ | pfste  << off_ ,
/* 19081 */	mli     | r1     << dst_ ,
/* 19082 */	stmt    | 6632   << off_ ,	//	mfi wa   convert to address
/* 19083 */	move    | wa     << dst_ | ia     << src_ ,
/* 19084 */	stmt    | 6633   << off_ ,	//	wtb wa   get as baus
/* 19085 */	stmt    | 6634   << off_ ,	//	add wa *num02  offset includes table header
/* 19086 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 19087 */	add     | wa     << dst_ | r2     << src_ ,
/* 19088 */	stmt    | 6635   << off_ ,	//	mov xr pftbl  get table start
/* 19089 */	load    | xr     << dst_ | pftbl  << off_ ,
/* 19090 */	stmt    | 6636   << off_ ,	//	bge wa num01(xr) pflu3 if out of table, skip it
/* 19091 */	load    | r2     << dst_ | xr     << src_ | num01  << off_ ,
/* 19092 */	bge     | wa     << dst_ | r2     << src_ | pflu3  << off_ ,
/* 19093 */	stmt    | 6637   << off_ ,	//	add xr wa  else point to entry
/* 19094 */	add     | xr     << dst_ | wa     << src_ ,
/* 19095 */	stmt    | 6638   << off_ ,	//	ldi (xr)   get nr of executions so far
/* 19096 */	load    | r1     << dst_ | xr     << src_ ,
/* 19097 */	ldi     | r1     << dst_ ,
/* 19098 */	stmt    | 6639   << off_ ,	//	adi 4,intv1   nudge up one
/* 19099 */	load    | r1     << dst_ | intv1  << off_ ,
/* 19100 */	adi     | r1     << dst_ ,
/* 19101 */	stmt    | 6640   << off_ ,	//	sti (xr)   and put back
/* 19102 */	store   | ia     << dst_ | xr     << src_ ,
/* 19103 */	stmt    | 6641   << off_ ,	//	jsr systm   get time now
/* 19104 */	sys     | systm_ << off_ ,
/* 19105 */	stmt    | 6642   << off_ ,	//	sti pfetm   stash ending time
/* 19106 */	store   | ia     << dst_ | pfetm  << off_ ,
/* 19107 */	stmt    | 6643   << off_ ,	//	sbi pfstm   subtract start time
/* 19108 */	load    | r1     << dst_ | pfstm  << off_ ,
/* 19109 */	sbi     | r1     << dst_ ,
/* 19110 */	stmt    | 6644   << off_ ,	//	adi cfp_i(xr)   add cumulative time so far
/* 19111 */	load    | r1     << dst_ | xr     << src_ | cfp_i  << off_ ,
/* 19112 */	adi     | r1     << dst_ ,
/* 19113 */	stmt    | 6645   << off_ ,	//	sti cfp_i(xr)   and put back new total
/* 19114 */	store   | ia     << dst_ | xr     << src_ | cfp_i  << off_ ,
/* 19115 */	stmt    | 6646   << off_ ,	//	ldi pfetm   load end time of this stmt ...
/* 19116 */	load    | r1     << dst_ | pfetm  << off_ ,
/* 19117 */	ldi     | r1     << dst_ ,
/* 19118 */	stmt    | 6647   << off_ ,	//	sti pfstm   ... which is start time of next
/* 19119 */	store   | ia     << dst_ | pfstm  << off_ ,
// pflu3:
/* 19120 */	stmt    | 6648   << off_ ,	//pflu3	mov xr (xs)+  restore callers xr
/* 19121 */	load    | xr     << dst_ | xs     << src_ ,
/* 19122 */	ica     | xs     << dst_ ,
/* 19123 */	stmt    | 6649   << off_ ,	//	mov wa pfsvw  restore saved reg
/* 19124 */	load    | wa     << dst_ | pfsvw  << off_ ,
/* 19125 */	stmt    | 6650   << off_ ,	//	exi    and return
/* 19126 */	exi     | 0      << off_ ,
// pflu4:
/* 19127 */	stmt    | 6651   << off_ ,	//pflu4	zer pffnc   reset the condition flag
/* 19128 */	store   | r0     << dst_ | pffnc  << off_ ,
/* 19129 */	stmt    | 6652   << off_ ,	//	exi    and immediate return
/* 19130 */	exi     | 0      << off_ ,
// prpar:
/* 19131 */	stmt    | 6653   << off_ ,	//prpar	prc e 0  entry point
/* 19132 */	stmt    | 6654   << off_ ,	//	bnz wc prpa8  jump to associate terminal
/* 19133 */	bnz     | wc     << dst_ | prpa8  << off_ ,
/* 19134 */	stmt    | 6655   << off_ ,	//	jsr syspp   get print parameters
/* 19135 */	sys     | syspp_ << off_ ,
/* 19136 */	stmt    | 6656   << off_ ,	//	bnz wb prpa1  jump if lines/page specified
/* 19137 */	bnz     | wb     << dst_ | prpa1  << off_ ,
/* 19138 */	stmt    | 6657   << off_ ,	//	mov wb mxint  else use a large value
/* 19139 */	load    | wb     << dst_ | mxint  << off_ ,
/* 19140 */	stmt    | 6658   << off_ ,	//	rsh wb 1  but not too large
/* 19141 */	rsh     | wb     << dst_ | 1      << off_ ,
// prpa1:
/* 19142 */	stmt    | 6659   << off_ ,	//prpa1	mov lstnp wb  store number of lines/page
/* 19143 */	store   | wb     << dst_ | lstnp  << off_ ,
/* 19144 */	stmt    | 6660   << off_ ,	//	mov lstlc wb  pretend page is full initially
/* 19145 */	store   | wb     << dst_ | lstlc  << off_ ,
/* 19146 */	stmt    | 6661   << off_ ,	//	zer lstpg   clear page number
/* 19147 */	store   | r0     << dst_ | lstpg  << off_ ,
/* 19148 */	stmt    | 6662   << off_ ,	//	mov wb prlen  get prior length if any
/* 19149 */	load    | wb     << dst_ | prlen  << off_ ,
/* 19150 */	stmt    | 6663   << off_ ,	//	bze wb prpa2  skip if no length
/* 19151 */	bze     | wb     << dst_ | prpa2  << off_ ,
/* 19152 */	stmt    | 6664   << off_ ,	//	bgt wa wb prpa3 skip storing if too big
/* 19153 */	bgt     | wa     << dst_ | wb     << src_ | prpa3  << off_ ,
// prpa2:
/* 19154 */	stmt    | 6665   << off_ ,	//prpa2	mov prlen wa  store value
/* 19155 */	store   | wa     << dst_ | prlen  << off_ ,
// prpa3:
/* 19156 */	stmt    | 6666   << off_ ,	//prpa3	mov wb 4,bits3  bit 3 mask
/* 19157 */	load    | wb     << dst_ | bits3  << off_ ,
/* 19158 */	stmt    | 6667   << off_ ,	//	anb wb wc  get -nolist bit
/* 19159 */	anb     | wb     << dst_ | wc     << src_ ,
/* 19160 */	stmt    | 6668   << off_ ,	//	zrb wb prpa4  skip if clear
/* 19161 */	zrb     | wb     << dst_ | prpa4  << off_ ,
/* 19162 */	stmt    | 6669   << off_ ,	//	zer cswls   set -nolist
/* 19163 */	store   | r0     << dst_ | cswls  << off_ ,
// prpa4:
/* 19164 */	stmt    | 6670   << off_ ,	//prpa4	mov wb 4,bits1  bit 1 mask
/* 19165 */	load    | wb     << dst_ | bits1  << off_ ,
/* 19166 */	stmt    | 6671   << off_ ,	//	anb wb wc  get bit
/* 19167 */	anb     | wb     << dst_ | wc     << src_ ,
/* 19168 */	stmt    | 6672   << off_ ,	//	mov erich wb  store int. chan. error flag
/* 19169 */	store   | wb     << dst_ | erich  << off_ ,
/* 19170 */	stmt    | 6673   << off_ ,	//	mov wb 4,bits2  bit 2 mask
/* 19171 */	load    | wb     << dst_ | bits2  << off_ ,
/* 19172 */	stmt    | 6674   << off_ ,	//	anb wb wc  get bit
/* 19173 */	anb     | wb     << dst_ | wc     << src_ ,
/* 19174 */	stmt    | 6675   << off_ ,	//	mov prich wb  flag for std printer on int. chan.
/* 19175 */	store   | wb     << dst_ | prich  << off_ ,
/* 19176 */	stmt    | 6676   << off_ ,	//	mov wb 4,bits4  bit 4 mask
/* 19177 */	load    | wb     << dst_ | bits4  << off_ ,
/* 19178 */	stmt    | 6677   << off_ ,	//	anb wb wc  get bit
/* 19179 */	anb     | wb     << dst_ | wc     << src_ ,
/* 19180 */	stmt    | 6678   << off_ ,	//	mov cpsts wb  flag for compile stats suppressn.
/* 19181 */	store   | wb     << dst_ | cpsts  << off_ ,
/* 19182 */	stmt    | 6679   << off_ ,	//	mov wb 4,bits5  bit 5 mask
/* 19183 */	load    | wb     << dst_ | bits5  << off_ ,
/* 19184 */	stmt    | 6680   << off_ ,	//	anb wb wc  get bit
/* 19185 */	anb     | wb     << dst_ | wc     << src_ ,
/* 19186 */	stmt    | 6681   << off_ ,	//	mov exsts wb  flag for exec stats suppression
/* 19187 */	store   | wb     << dst_ | exsts  << off_ ,
/* 19188 */	stmt    | 6682   << off_ ,	//	mov wb 4,bits6  bit 6 mask
/* 19189 */	load    | wb     << dst_ | bits6  << off_ ,
/* 19190 */	stmt    | 6683   << off_ ,	//	anb wb wc  get bit
/* 19191 */	anb     | wb     << dst_ | wc     << src_ ,
/* 19192 */	stmt    | 6684   << off_ ,	//	mov precl wb  extended/compact listing flag
/* 19193 */	store   | wb     << dst_ | precl  << off_ ,
/* 19194 */	stmt    | 6685   << off_ ,	//	sub wa =num08  point 8 chars from line end
/* 19195 */	loadi   | r2     << dst_ | num08  << off_ ,
/* 19196 */	sub     | wa     << dst_ | r2     << src_ ,
/* 19197 */	stmt    | 6686   << off_ ,	//	zrb wb prpa5  jump if not extended
/* 19198 */	zrb     | wb     << dst_ | prpa5  << off_ ,
/* 19199 */	stmt    | 6687   << off_ ,	//	mov lstpo wa  store for listing page headings
/* 19200 */	store   | wa     << dst_ | lstpo  << off_ ,
// prpa5:
/* 19201 */	stmt    | 6688   << off_ ,	//prpa5	mov wb 4,bits7  bit 7 mask
/* 19202 */	load    | wb     << dst_ | bits7  << off_ ,
/* 19203 */	stmt    | 6689   << off_ ,	//	anb wb wc  get bit 7
/* 19204 */	anb     | wb     << dst_ | wc     << src_ ,
/* 19205 */	stmt    | 6690   << off_ ,	//	mov cswex wb  set -noexecute if non-zero
/* 19206 */	store   | wb     << dst_ | cswex  << off_ ,
/* 19207 */	stmt    | 6691   << off_ ,	//	mov wb 4,bit10  bit 10 mask
/* 19208 */	load    | wb     << dst_ | bit10  << off_ ,
/* 19209 */	stmt    | 6692   << off_ ,	//	anb wb wc  get bit 10
/* 19210 */	anb     | wb     << dst_ | wc     << src_ ,
/* 19211 */	stmt    | 6693   << off_ ,	//	mov headp wb  pretend printed to omit headers
/* 19212 */	store   | wb     << dst_ | headp  << off_ ,
/* 19213 */	stmt    | 6694   << off_ ,	//	mov wb 4,bits9  bit 9 mask
/* 19214 */	load    | wb     << dst_ | bits9  << off_ ,
/* 19215 */	stmt    | 6695   << off_ ,	//	anb wb wc  get bit 9
/* 19216 */	anb     | wb     << dst_ | wc     << src_ ,
/* 19217 */	stmt    | 6696   << off_ ,	//	mov prsto wb  keep it as std listing option
/* 19218 */	store   | wb     << dst_ | prsto  << off_ ,
/* 19219 */	stmt    | 6697   << off_ ,	//	mov wb 4,bit12  bit 12 mask
/* 19220 */	load    | wb     << dst_ | bit12  << off_ ,
/* 19221 */	stmt    | 6698   << off_ ,	//	anb wb wc  get bit 12
/* 19222 */	anb     | wb     << dst_ | wc     << src_ ,
/* 19223 */	stmt    | 6699   << off_ ,	//	mov cswer wb  keep it as errors/noerrors option
/* 19224 */	store   | wb     << dst_ | cswer  << off_ ,
/* 19225 */	stmt    | 6700   << off_ ,	//	zrb wb prpa6  skip if clear
/* 19226 */	zrb     | wb     << dst_ | prpa6  << off_ ,
/* 19227 */	stmt    | 6701   << off_ ,	//	mov wa prlen  get print buffer length
/* 19228 */	load    | wa     << dst_ | prlen  << off_ ,
/* 19229 */	stmt    | 6702   << off_ ,	//	sub wa =num08  point 8 chars from line end
/* 19230 */	loadi   | r2     << dst_ | num08  << off_ ,
/* 19231 */	sub     | wa     << dst_ | r2     << src_ ,
/* 19232 */	stmt    | 6703   << off_ ,	//	mov lstpo wa  store page offset
/* 19233 */	store   | wa     << dst_ | lstpo  << off_ ,
// prpa6:
/* 19234 */	stmt    | 6704   << off_ ,	//prpa6	mov wb 4,bit11  bit 11 mask
/* 19235 */	load    | wb     << dst_ | bit11  << off_ ,
/* 19236 */	stmt    | 6705   << off_ ,	//	anb wb wc  get bit 11
/* 19237 */	anb     | wb     << dst_ | wc     << src_ ,
/* 19238 */	stmt    | 6706   << off_ ,	//	mov cswpr wb  set -print if non-zero
/* 19239 */	store   | wb     << dst_ | cswpr  << off_ ,
/* 19240 */	stmt    | 6707   << off_ ,	//	anb wc 4,bits8  see if terminal to be activated
/* 19241 */	load    | r2     << dst_ | bits8  << off_ ,
/* 19242 */	anb     | wc     << dst_ | r2     << src_ ,
/* 19243 */	stmt    | 6708   << off_ ,	//	bnz wc prpa8  jump if terminal required
/* 19244 */	bnz     | wc     << dst_ | prpa8  << off_ ,
/* 19245 */	stmt    | 6709   << off_ ,	//	bze initr prpa9  jump if no terminal to detach
/* 19246 */	load    | r1     << dst_ | initr  << off_ ,
/* 19247 */	bze     | r1     << dst_ | prpa9  << off_ ,
/* 19248 */	stmt    | 6710   << off_ ,	//	mov xl =v_ter  ptr to /terminal/
/* 19249 */	loadi   | xl     << dst_ | v_ter  << off_ ,
/* 19250 */	stmt    | 6711   << off_ ,	//	jsr gtnvr   get vrblk pointer
/* 19251 */	call    | gtnvr  << off_ ,
/* 19252 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 19253 */	ppm     ,
/* 19254 */	stmt    | 6712   << off_ ,	//	mov vrval(xr) =nulls  clear value of terminal
/* 19255 */	loadi   | r1     << dst_ | nulls  << off_ ,
/* 19256 */	store   | r1     << dst_ | xr     << src_ | vrval  << off_ ,
/* 19257 */	stmt    | 6713   << off_ ,	//	jsr setvr   remove association
/* 19258 */	call    | setvr  << off_ ,
/* 19259 */	stmt    | 6714   << off_ ,	//	brn prpa9   return
/* 19260 */	brn     | prpa9  << off_ ,
// prpa8:
/* 19261 */	stmt    | 6715   << off_ ,	//prpa8	mnz initr   note terminal associated
/* 19262 */	store   | xs     << dst_ | initr  << off_ ,
/* 19263 */	stmt    | 6716   << off_ ,	//	bze dnamb prpa9  cant if memory not organised
/* 19264 */	load    | r1     << dst_ | dnamb  << off_ ,
/* 19265 */	bze     | r1     << dst_ | prpa9  << off_ ,
/* 19266 */	stmt    | 6717   << off_ ,	//	mov xl =v_ter  point to terminal string
/* 19267 */	loadi   | xl     << dst_ | v_ter  << off_ ,
/* 19268 */	stmt    | 6718   << off_ ,	//	mov wb =trtou  output trace type
/* 19269 */	loadi   | wb     << dst_ | trtou  << off_ ,
/* 19270 */	stmt    | 6719   << off_ ,	//	jsr inout   attach output trblk to vrblk
/* 19271 */	call    | inout  << off_ ,
/* 19272 */	stmt    | 6720   << off_ ,	//	mov -(xs) xr  stack trblk ptr
/* 19273 */	dca     | xs     << dst_ ,
/* 19274 */	store   | xr     << dst_ | xs     << src_ ,
/* 19275 */	stmt    | 6721   << off_ ,	//	mov xl =v_ter  point to terminal string
/* 19276 */	loadi   | xl     << dst_ | v_ter  << off_ ,
/* 19277 */	stmt    | 6722   << off_ ,	//	mov wb =trtin  input trace type
/* 19278 */	loadi   | wb     << dst_ | trtin  << off_ ,
/* 19279 */	stmt    | 6723   << off_ ,	//	jsr inout   attach input trace blk
/* 19280 */	call    | inout  << off_ ,
/* 19281 */	stmt    | 6724   << off_ ,	//	mov vrval(xr) (xs)+  add output trblk to chain
/* 19282 */	load    | r1     << dst_ | xs     << src_ ,
/* 19283 */	ica     | xs     << dst_ ,
/* 19284 */	store   | r1     << dst_ | xr     << src_ | vrval  << off_ ,
// prpa9:
/* 19285 */	stmt    | 6725   << off_ ,	//prpa9	exi    return
/* 19286 */	exi     | 0      << off_ ,
// prtch:
/* 19287 */	stmt    | 6726   << off_ ,	//prtch	prc e 0  entry point
/* 19288 */	stmt    | 6727   << off_ ,	//	mov -(xs) xr  save xr
/* 19289 */	dca     | xs     << dst_ ,
/* 19290 */	store   | xr     << dst_ | xs     << src_ ,
/* 19291 */	stmt    | 6728   << off_ ,	//	bne profs prlen prch1 jump if room in buffer
/* 19292 */	load    | r1     << dst_ | profs  << off_ ,
/* 19293 */	load    | r2     << dst_ | prlen  << off_ ,
/* 19294 */	bne     | r1     << dst_ | r2     << src_ | prch1  << off_ ,
/* 19295 */	stmt    | 6729   << off_ ,	//	jsr prtnl   else print this line
/* 19296 */	call    | prtnl  << off_ ,
// prch1:
/* 19297 */	stmt    | 6730   << off_ ,	//prch1	mov xr prbuf  point to print buffer
/* 19298 */	load    | xr     << dst_ | prbuf  << off_ ,
/* 19299 */	stmt    | 6731   << off_ ,	//	psc xr profs  point to next character location
/* 19300 */	load    | r2     << dst_ | profs  << off_ ,
/* 19301 */	psc     | xr     << dst_ | r2     << src_ ,
/* 19302 */	stmt    | 6732   << off_ ,	//	sch wa (xr)  store new character
/* 19303 */	store   | wa     << dst_ | xr     << src_ ,
/* 19304 */	stmt    | 6733   << off_ ,	//	csc xr   complete store characters
/* 19305 */	stmt    | 6734   << off_ ,	//	icv profs   bump pointer
/* 19306 */	load    | r1     << dst_ | profs  << off_ ,
/* 19307 */	icv     | r1     << dst_ ,
/* 19308 */	store   | r1     << dst_ | profs  << off_ ,
/* 19309 */	stmt    | 6735   << off_ ,	//	mov xr (xs)+  restore entry xr
/* 19310 */	load    | xr     << dst_ | xs     << src_ ,
/* 19311 */	ica     | xs     << dst_ ,
/* 19312 */	stmt    | 6736   << off_ ,	//	exi    return to prtch caller
/* 19313 */	exi     | 0      << off_ ,
// prtic:
/* 19314 */	stmt    | 6737   << off_ ,	//prtic	prc e 0  entry point
/* 19315 */	stmt    | 6738   << off_ ,	//	mov -(xs) xr  save xr
/* 19316 */	dca     | xs     << dst_ ,
/* 19317 */	store   | xr     << dst_ | xs     << src_ ,
/* 19318 */	stmt    | 6739   << off_ ,	//	mov xr prbuf  point to buffer
/* 19319 */	load    | xr     << dst_ | prbuf  << off_ ,
/* 19320 */	stmt    | 6740   << off_ ,	//	mov wa profs  no of chars
/* 19321 */	load    | wa     << dst_ | profs  << off_ ,
/* 19322 */	stmt    | 6741   << off_ ,	//	jsr syspi   print
/* 19323 */	sys     | syspi_ << off_ ,
/* 19324 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 19325 */	ppm     | prtc2  << off_ ,
// prtc1:
/* 19326 */	stmt    | 6742   << off_ ,	//prtc1	mov xr (xs)+  restore xr
/* 19327 */	load    | xr     << dst_ | xs     << src_ ,
/* 19328 */	ica     | xs     << dst_ ,
/* 19329 */	stmt    | 6743   << off_ ,	//	exi    return
/* 19330 */	exi     | 0      << off_ ,
// prtc2:
/* 19331 */	stmt    | 6744   << off_ ,	//prtc2	zer erich   prevent looping
/* 19332 */	store   | r0     << dst_ | erich  << off_ ,
/* 19333 */	stmt    | 6745   << off_ ,	//	erb 252 error on printing to interactive channel
/* 19334 */	erb     | 252    << off_ ,
/* 19335 */	stmt    | 6746   << off_ ,	//	brn prtc1   return
/* 19336 */	brn     | prtc1  << off_ ,
// prtis:
/* 19337 */	stmt    | 6747   << off_ ,	//prtis	prc e 0  entry point
/* 19338 */	stmt    | 6748   << off_ ,	//	bnz prich prts1  jump if standard printer is int.ch.
/* 19339 */	load    | r1     << dst_ | prich  << off_ ,
/* 19340 */	bnz     | r1     << dst_ | prts1  << off_ ,
/* 19341 */	stmt    | 6749   << off_ ,	//	bze erich prts1  skip if not doing int. error reps.
/* 19342 */	load    | r1     << dst_ | erich  << off_ ,
/* 19343 */	bze     | r1     << dst_ | prts1  << off_ ,
/* 19344 */	stmt    | 6750   << off_ ,	//	jsr prtic   print to interactive channel
/* 19345 */	call    | prtic  << off_ ,
// prts1:
/* 19346 */	stmt    | 6751   << off_ ,	//prts1	jsr prtnl   print to standard printer
/* 19347 */	call    | prtnl  << off_ ,
/* 19348 */	stmt    | 6752   << off_ ,	//	exi    return
/* 19349 */	exi     | 0      << off_ ,
// prtin:
/* 19350 */	stmt    | 6753   << off_ ,	//prtin	prc e 0  entry point
/* 19351 */	stmt    | 6754   << off_ ,	//	mov -(xs) xr  save xr
/* 19352 */	dca     | xs     << dst_ ,
/* 19353 */	store   | xr     << dst_ | xs     << src_ ,
/* 19354 */	stmt    | 6755   << off_ ,	//	jsr icbld   build integer block
/* 19355 */	call    | icbld  << off_ ,
/* 19356 */	stmt    | 6756   << off_ ,	//	blo xr dnamb prti1 jump if icblk below dynamic
/* 19357 */	load    | r2     << dst_ | dnamb  << off_ ,
/* 19358 */	blo     | xr     << dst_ | r2     << src_ | prti1  << off_ ,
/* 19359 */	stmt    | 6757   << off_ ,	//	bhi xr dnamp prti1 jump if above dynamic
/* 19360 */	load    | r2     << dst_ | dnamp  << off_ ,
/* 19361 */	bhi     | xr     << dst_ | r2     << src_ | prti1  << off_ ,
/* 19362 */	stmt    | 6758   << off_ ,	//	mov dnamp xr  immediately delete it
/* 19363 */	store   | xr     << dst_ | dnamp  << off_ ,
// prti1:
/* 19364 */	stmt    | 6759   << off_ ,	//prti1	mov -(xs) xr  stack ptr for gtstg
/* 19365 */	dca     | xs     << dst_ ,
/* 19366 */	store   | xr     << dst_ | xs     << src_ ,
/* 19367 */	stmt    | 6760   << off_ ,	//	jsr gtstg   convert to string
/* 19368 */	call    | gtstg  << off_ ,
/* 19369 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 19370 */	ppm     ,
/* 19371 */	stmt    | 6761   << off_ ,	//	mov dnamp xr  reset pointer to delete scblk
/* 19372 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 19373 */	stmt    | 6762   << off_ ,	//	jsr prtst   print integer string
/* 19374 */	call    | prtst  << off_ ,
/* 19375 */	stmt    | 6763   << off_ ,	//	mov xr (xs)+  restore entry xr
/* 19376 */	load    | xr     << dst_ | xs     << src_ ,
/* 19377 */	ica     | xs     << dst_ ,
/* 19378 */	stmt    | 6764   << off_ ,	//	exi    return to prtin caller
/* 19379 */	exi     | 0      << off_ ,
// prtmi:
/* 19380 */	stmt    | 6765   << off_ ,	//prtmi	prc e 0  entry point
/* 19381 */	stmt    | 6766   << off_ ,	//	jsr prtst   print string message
/* 19382 */	call    | prtst  << off_ ,
/* 19383 */	stmt    | 6767   << off_ ,	//	mov profs =prtmf  set column offset
/* 19384 */	loadi   | r1     << dst_ | prtmf  << off_ ,
/* 19385 */	store   | r1     << dst_ | profs  << off_ ,
/* 19386 */	stmt    | 6768   << off_ ,	//	jsr prtin   print integer
/* 19387 */	call    | prtin  << off_ ,
/* 19388 */	stmt    | 6769   << off_ ,	//	jsr prtnl   print line
/* 19389 */	call    | prtnl  << off_ ,
/* 19390 */	stmt    | 6770   << off_ ,	//	exi    return to prtmi caller
/* 19391 */	exi     | 0      << off_ ,
// prtmm:
/* 19392 */	stmt    | 6771   << off_ ,	//prtmm	prc e 0
/* 19393 */	stmt    | 6772   << off_ ,	//	mov wa dnamp  next available loc
/* 19394 */	load    | wa     << dst_ | dnamp  << off_ ,
/* 19395 */	stmt    | 6773   << off_ ,	//	sub wa statb  minus start
/* 19396 */	load    | r2     << dst_ | statb  << off_ ,
/* 19397 */	sub     | wa     << dst_ | r2     << src_ ,
/* 19398 */	stmt    | 6774   << off_ ,	//	mti wa   convert to integer
/* 19399 */	move    | ia     << dst_ | wa     << src_ ,
/* 19400 */	stmt    | 6775   << off_ ,	//	mov xr =encm1  point to /memory used (words)/
/* 19401 */	loadi   | xr     << dst_ | encm1  << off_ ,
/* 19402 */	stmt    | 6776   << off_ ,	//	jsr prtmi   print message
/* 19403 */	call    | prtmi  << off_ ,
/* 19404 */	stmt    | 6777   << off_ ,	//	mov wa dname  end of memory
/* 19405 */	load    | wa     << dst_ | dname  << off_ ,
/* 19406 */	stmt    | 6778   << off_ ,	//	sub wa dnamp  minus next available loc
/* 19407 */	load    | r2     << dst_ | dnamp  << off_ ,
/* 19408 */	sub     | wa     << dst_ | r2     << src_ ,
/* 19409 */	stmt    | 6779   << off_ ,	//	mti wa   convert to integer
/* 19410 */	move    | ia     << dst_ | wa     << src_ ,
/* 19411 */	stmt    | 6780   << off_ ,	//	mov xr =encm2  point to /memory available (words)/
/* 19412 */	loadi   | xr     << dst_ | encm2  << off_ ,
/* 19413 */	stmt    | 6781   << off_ ,	//	jsr prtmi   print line
/* 19414 */	call    | prtmi  << off_ ,
/* 19415 */	stmt    | 6782   << off_ ,	//	exi    return to prtmm caller
/* 19416 */	exi     | 0      << off_ ,
// prtmx:
/* 19417 */	stmt    | 6783   << off_ ,	//prtmx	prc e 0  entry point
/* 19418 */	stmt    | 6784   << off_ ,	//	jsr prtst   print string message
/* 19419 */	call    | prtst  << off_ ,
/* 19420 */	stmt    | 6785   << off_ ,	//	mov profs =prtmf  set column offset
/* 19421 */	loadi   | r1     << dst_ | prtmf  << off_ ,
/* 19422 */	store   | r1     << dst_ | profs  << off_ ,
/* 19423 */	stmt    | 6786   << off_ ,	//	jsr prtin   print integer
/* 19424 */	call    | prtin  << off_ ,
/* 19425 */	stmt    | 6787   << off_ ,	//	jsr prtis   print line
/* 19426 */	call    | prtis  << off_ ,
/* 19427 */	stmt    | 6788   << off_ ,	//	exi    return
/* 19428 */	exi     | 0      << off_ ,
// prtnl:
/* 19429 */	stmt    | 6789   << off_ ,	//prtnl	prc r 0  entry point
/* 19430 */	stmt    | 6790   << off_ ,	//	bnz headp prnl0  were headers printed
/* 19431 */	load    | r1     << dst_ | headp  << off_ ,
/* 19432 */	bnz     | r1     << dst_ | prnl0  << off_ ,
/* 19433 */	stmt    | 6791   << off_ ,	//	jsr prtps   no - print them
/* 19434 */	call    | prtps  << off_ ,
// prnl0:
/* 19435 */	stmt    | 6792   << off_ ,	//prnl0	mov -(xs) xr  save entry xr
/* 19436 */	dca     | xs     << dst_ ,
/* 19437 */	store   | xr     << dst_ | xs     << src_ ,
/* 19438 */	stmt    | 6793   << off_ ,	//	mov prtsa wa  save wa
/* 19439 */	store   | wa     << dst_ | prtsa  << off_ ,
/* 19440 */	stmt    | 6794   << off_ ,	//	mov prtsb wb  save wb
/* 19441 */	store   | wb     << dst_ | prtsb  << off_ ,
/* 19442 */	stmt    | 6795   << off_ ,	//	mov xr prbuf  load pointer to buffer
/* 19443 */	load    | xr     << dst_ | prbuf  << off_ ,
/* 19444 */	stmt    | 6796   << off_ ,	//	mov wa profs  load number of chars in buffer
/* 19445 */	load    | wa     << dst_ | profs  << off_ ,
/* 19446 */	stmt    | 6797   << off_ ,	//	jsr syspr   call system print routine
/* 19447 */	sys     | syspr_ << off_ ,
/* 19448 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 19449 */	ppm     | prnl2  << off_ ,
/* 19450 */	stmt    | 6798   << off_ ,	//	lct wa prlnw  load length of buffer in words
/* 19451 */	load    | wa     << dst_ | prlnw  << off_ ,
/* 19452 */	stmt    | 6799   << off_ ,	//	add xr *schar  point to chars of buffer
/* 19453 */	loadi   | r2     << dst_ | schar  << off_ ,
/* 19454 */	add     | xr     << dst_ | r2     << src_ ,
/* 19455 */	stmt    | 6800   << off_ ,	//	mov wb 4,nullw  get word of blanks
/* 19456 */	load    | wb     << dst_ | nullw  << off_ ,
// prnl1:
/* 19457 */	stmt    | 6801   << off_ ,	//prnl1	mov (xr)+ wb  store word of blanks, bump ptr
/* 19458 */	store   | wb     << dst_ | xr     << src_ ,
/* 19459 */	ica     | xr     << dst_ ,
/* 19460 */	stmt    | 6802   << off_ ,	//	bct wa prnl1  loop till all blanked
/* 19461 */	bct     | wa     << dst_ | prnl1  << off_ ,
/* 19462 */	stmt    | 6803   << off_ ,	//	mov wb prtsb  restore wb
/* 19463 */	load    | wb     << dst_ | prtsb  << off_ ,
/* 19464 */	stmt    | 6804   << off_ ,	//	mov wa prtsa  restore wa
/* 19465 */	load    | wa     << dst_ | prtsa  << off_ ,
/* 19466 */	stmt    | 6805   << off_ ,	//	mov xr (xs)+  restore entry xr
/* 19467 */	load    | xr     << dst_ | xs     << src_ ,
/* 19468 */	ica     | xs     << dst_ ,
/* 19469 */	stmt    | 6806   << off_ ,	//	zer profs   reset print buffer pointer
/* 19470 */	store   | r0     << dst_ | profs  << off_ ,
/* 19471 */	stmt    | 6807   << off_ ,	//	exi    return to prtnl caller
/* 19472 */	exi     | 0      << off_ ,
// prnl2:
/* 19473 */	stmt    | 6808   << off_ ,	//prnl2	bnz prtef prnl3  jump if not first time
/* 19474 */	load    | r1     << dst_ | prtef  << off_ ,
/* 19475 */	bnz     | r1     << dst_ | prnl3  << off_ ,
/* 19476 */	stmt    | 6809   << off_ ,	//	mnz prtef   mark first occurrence
/* 19477 */	store   | xs     << dst_ | prtef  << off_ ,
/* 19478 */	stmt    | 6810   << off_ ,	//	erb 253 print limit exceeded on standard output channel
/* 19479 */	erb     | 253    << off_ ,
// prnl3:
/* 19480 */	stmt    | 6811   << off_ ,	//prnl3	mov wb =nini8  ending code
/* 19481 */	loadi   | wb     << dst_ | nini8  << off_ ,
/* 19482 */	stmt    | 6812   << off_ ,	//	mov wa kvstn  statement number
/* 19483 */	load    | wa     << dst_ | kvstn  << off_ ,
/* 19484 */	stmt    | 6813   << off_ ,	//	mov xl r_fcb  get fcblk chain head
/* 19485 */	load    | xl     << dst_ | r_fcb  << off_ ,
/* 19486 */	stmt    | 6814   << off_ ,	//	jsr sysej   stop
/* 19487 */	sys     | sysej_ << off_ ,
// prtnm:
/* 19488 */	stmt    | 6815   << off_ ,	//prtnm	prc r 0  entry point (recursive, see prtvl)
/* 19489 */	stmt    | 6816   << off_ ,	//	mov -(xs) wa  save wa (offset is collectable)
/* 19490 */	dca     | xs     << dst_ ,
/* 19491 */	store   | wa     << dst_ | xs     << src_ ,
/* 19492 */	stmt    | 6817   << off_ ,	//	mov -(xs) xr  save entry xr
/* 19493 */	dca     | xs     << dst_ ,
/* 19494 */	store   | xr     << dst_ | xs     << src_ ,
/* 19495 */	stmt    | 6818   << off_ ,	//	mov -(xs) xl  save name base
/* 19496 */	dca     | xs     << dst_ ,
/* 19497 */	store   | xl     << dst_ | xs     << src_ ,
/* 19498 */	stmt    | 6819   << off_ ,	//	bhi xl state prn02 jump if not natural variable
/* 19499 */	load    | r2     << dst_ | state  << off_ ,
/* 19500 */	bhi     | xl     << dst_ | r2     << src_ | prn02  << off_ ,
/* 19501 */	stmt    | 6820   << off_ ,	//	mov xr xl  point to vrblk
/* 19502 */	move    | xr     << dst_ | xl     << src_ ,
/* 19503 */	stmt    | 6821   << off_ ,	//	jsr prtvn   print name of variable
/* 19504 */	call    | prtvn  << off_ ,
// prn01:
/* 19505 */	stmt    | 6822   << off_ ,	//prn01	mov xl (xs)+  restore name base
/* 19506 */	load    | xl     << dst_ | xs     << src_ ,
/* 19507 */	ica     | xs     << dst_ ,
/* 19508 */	stmt    | 6823   << off_ ,	//	mov xr (xs)+  restore entry value of xr
/* 19509 */	load    | xr     << dst_ | xs     << src_ ,
/* 19510 */	ica     | xs     << dst_ ,
/* 19511 */	stmt    | 6824   << off_ ,	//	mov wa (xs)+  restore wa
/* 19512 */	load    | wa     << dst_ | xs     << src_ ,
/* 19513 */	ica     | xs     << dst_ ,
/* 19514 */	stmt    | 6825   << off_ ,	//	exi    return to prtnm caller
/* 19515 */	exi     | 0      << off_ ,
// prn02:
/* 19516 */	stmt    | 6826   << off_ ,	//prn02	mov wb wa  copy name offset
/* 19517 */	move    | wb     << dst_ | wa     << src_ ,
/* 19518 */	stmt    | 6827   << off_ ,	//	bne (xl) =b_pdt prn03 jump if array or table
/* 19519 */	load    | r1     << dst_ | xl     << src_ ,
/* 19520 */	loadi   | r2     << dst_ | b_pdt  << off_ ,
/* 19521 */	bne     | r1     << dst_ | r2     << src_ | prn03  << off_ ,
/* 19522 */	stmt    | 6828   << off_ ,	//	mov xr pddfp(xl)  load pointer to dfblk
/* 19523 */	load    | xr     << dst_ | xl     << src_ | pddfp  << off_ ,
/* 19524 */	stmt    | 6829   << off_ ,	//	add xr wa  add name offset
/* 19525 */	add     | xr     << dst_ | wa     << src_ ,
/* 19526 */	stmt    | 6830   << off_ ,	//	mov xr pdfof(xr)  load vrblk pointer for field
/* 19527 */	load    | xr     << dst_ | xr     << src_ | pdfof  << off_ ,
/* 19528 */	stmt    | 6831   << off_ ,	//	jsr prtvn   print field name
/* 19529 */	call    | prtvn  << off_ ,
/* 19530 */	stmt    | 6832   << off_ ,	//	mov wa =ch_pp  load left paren
/* 19531 */	loadi   | wa     << dst_ | ch_pp  << off_ ,
/* 19532 */	stmt    | 6833   << off_ ,	//	jsr prtch   print character
/* 19533 */	call    | prtch  << off_ ,
// prn03:
/* 19534 */	stmt    | 6834   << off_ ,	//prn03	bne (xl) =b_tet prn04 jump if we got there (or not te)
/* 19535 */	load    | r1     << dst_ | xl     << src_ ,
/* 19536 */	loadi   | r2     << dst_ | b_tet  << off_ ,
/* 19537 */	bne     | r1     << dst_ | r2     << src_ | prn04  << off_ ,
/* 19538 */	stmt    | 6835   << off_ ,	//	mov xl tenxt(xl)  else move out on chain
/* 19539 */	load    | xl     << dst_ | xl     << src_ | tenxt  << off_ ,
/* 19540 */	stmt    | 6836   << off_ ,	//	brn prn03   and loop back
/* 19541 */	brn     | prn03  << off_ ,
// prn04:
/* 19542 */	stmt    | 6837   << off_ ,	//prn04	mov xr prnmv  point to vrblk we found last time
/* 19543 */	load    | xr     << dst_ | prnmv  << off_ ,
/* 19544 */	stmt    | 6838   << off_ ,	//	mov wa hshtb  point to hash table in case not
/* 19545 */	load    | wa     << dst_ | hshtb  << off_ ,
/* 19546 */	stmt    | 6839   << off_ ,	//	brn prn07   jump into search for special check
/* 19547 */	brn     | prn07  << off_ ,
// prn05:
/* 19548 */	stmt    | 6840   << off_ ,	//prn05	mov xr wa  copy slot pointer
/* 19549 */	move    | xr     << dst_ | wa     << src_ ,
/* 19550 */	stmt    | 6841   << off_ ,	//	ica wa   bump slot pointer
/* 19551 */	ica     | wa     << dst_ ,
/* 19552 */	stmt    | 6842   << off_ ,	//	sub xr *vrnxt  introduce standard vrblk offset
/* 19553 */	loadi   | r2     << dst_ | vrnxt  << off_ ,
/* 19554 */	sub     | xr     << dst_ | r2     << src_ ,
// prn06:
/* 19555 */	stmt    | 6843   << off_ ,	//prn06	mov xr vrnxt(xr)  point to next vrblk on hash chain
/* 19556 */	load    | xr     << dst_ | xr     << src_ | vrnxt  << off_ ,
// prn07:
/* 19557 */	stmt    | 6844   << off_ ,	//prn07	mov wc xr  copy vrblk pointer
/* 19558 */	move    | wc     << dst_ | xr     << src_ ,
/* 19559 */	stmt    | 6845   << off_ ,	//	bze wc prn09  jump if chain end (or prnmv zero)
/* 19560 */	bze     | wc     << dst_ | prn09  << off_ ,
// prn08:
/* 19561 */	stmt    | 6846   << off_ ,	//prn08	mov xr vrval(xr)  load value
/* 19562 */	load    | xr     << dst_ | xr     << src_ | vrval  << off_ ,
/* 19563 */	stmt    | 6847   << off_ ,	//	beq (xr) =b_trt prn08 loop if that was a trblk
/* 19564 */	load    | r1     << dst_ | xr     << src_ ,
/* 19565 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 19566 */	beq     | r1     << dst_ | r2     << src_ | prn08  << off_ ,
/* 19567 */	stmt    | 6848   << off_ ,	//	beq xr xl prn10 jump if this matches the name base
/* 19568 */	beq     | xr     << dst_ | xl     << src_ | prn10  << off_ ,
/* 19569 */	stmt    | 6849   << off_ ,	//	mov xr wc  else point back to that vrblk
/* 19570 */	move    | xr     << dst_ | wc     << src_ ,
/* 19571 */	stmt    | 6850   << off_ ,	//	brn prn06   and loop back
/* 19572 */	brn     | prn06  << off_ ,
// prn09:
/* 19573 */	stmt    | 6851   << off_ ,	//prn09	blt wa hshte prn05 loop back if more to go
/* 19574 */	load    | r2     << dst_ | hshte  << off_ ,
/* 19575 */	blt     | wa     << dst_ | r2     << src_ | prn05  << off_ ,
/* 19576 */	stmt    | 6852   << off_ ,	//	mov xr xl  else not found, copy value pointer
/* 19577 */	move    | xr     << dst_ | xl     << src_ ,
/* 19578 */	stmt    | 6853   << off_ ,	//	jsr prtvl   print value
/* 19579 */	call    | prtvl  << off_ ,
/* 19580 */	stmt    | 6854   << off_ ,	//	brn prn11   and merge ahead
/* 19581 */	brn     | prn11  << off_ ,
// prn10:
/* 19582 */	stmt    | 6855   << off_ ,	//prn10	mov xr wc  copy vrblk pointer
/* 19583 */	move    | xr     << dst_ | wc     << src_ ,
/* 19584 */	stmt    | 6856   << off_ ,	//	mov prnmv xr  save for next time in
/* 19585 */	store   | xr     << dst_ | prnmv  << off_ ,
/* 19586 */	stmt    | 6857   << off_ ,	//	jsr prtvn   print variable name
/* 19587 */	call    | prtvn  << off_ ,
// prn11:
/* 19588 */	stmt    | 6858   << off_ ,	//prn11	mov wc (xl)  load first word of name base
/* 19589 */	load    | wc     << dst_ | xl     << src_ ,
/* 19590 */	stmt    | 6859   << off_ ,	//	bne wc =b_pdt prn13 jump if not program defined
/* 19591 */	loadi   | r2     << dst_ | b_pdt  << off_ ,
/* 19592 */	bne     | wc     << dst_ | r2     << src_ | prn13  << off_ ,
/* 19593 */	stmt    | 6860   << off_ ,	//	mov wa =ch_rp  load right paren, merge
/* 19594 */	loadi   | wa     << dst_ | ch_rp  << off_ ,
// prn12:
/* 19595 */	stmt    | 6861   << off_ ,	//prn12	jsr prtch   print final character
/* 19596 */	call    | prtch  << off_ ,
/* 19597 */	stmt    | 6862   << off_ ,	//	mov wa wb  restore name offset
/* 19598 */	move    | wa     << dst_ | wb     << src_ ,
/* 19599 */	stmt    | 6863   << off_ ,	//	brn prn01   merge back to exit
/* 19600 */	brn     | prn01  << off_ ,
// prn13:
/* 19601 */	stmt    | 6864   << off_ ,	//prn13	mov wa =ch_bb  load left bracket
/* 19602 */	loadi   | wa     << dst_ | ch_bb  << off_ ,
/* 19603 */	stmt    | 6865   << off_ ,	//	jsr prtch   and print it
/* 19604 */	call    | prtch  << off_ ,
/* 19605 */	stmt    | 6866   << off_ ,	//	mov xl (xs)  restore block pointer
/* 19606 */	load    | xl     << dst_ | xs     << src_ ,
/* 19607 */	stmt    | 6867   << off_ ,	//	mov wc (xl)  load type word again
/* 19608 */	load    | wc     << dst_ | xl     << src_ ,
/* 19609 */	stmt    | 6868   << off_ ,	//	bne wc =b_tet prn15 jump if not table
/* 19610 */	loadi   | r2     << dst_ | b_tet  << off_ ,
/* 19611 */	bne     | wc     << dst_ | r2     << src_ | prn15  << off_ ,
/* 19612 */	stmt    | 6869   << off_ ,	//	mov xr tesub(xl)  load subscript value
/* 19613 */	load    | xr     << dst_ | xl     << src_ | tesub  << off_ ,
/* 19614 */	stmt    | 6870   << off_ ,	//	mov xl wb  save name offset
/* 19615 */	move    | xl     << dst_ | wb     << src_ ,
/* 19616 */	stmt    | 6871   << off_ ,	//	jsr prtvl   print subscript value
/* 19617 */	call    | prtvl  << off_ ,
/* 19618 */	stmt    | 6872   << off_ ,	//	mov wb xl  restore name offset
/* 19619 */	move    | wb     << dst_ | xl     << src_ ,
// prn14:
/* 19620 */	stmt    | 6873   << off_ ,	//prn14	mov wa =ch_rb  load right bracket
/* 19621 */	loadi   | wa     << dst_ | ch_rb  << off_ ,
/* 19622 */	stmt    | 6874   << off_ ,	//	brn prn12   merge back to print it
/* 19623 */	brn     | prn12  << off_ ,
// prn15:
/* 19624 */	stmt    | 6875   << off_ ,	//prn15	mov wa wb  copy name offset
/* 19625 */	move    | wa     << dst_ | wb     << src_ ,
/* 19626 */	stmt    | 6876   << off_ ,	//	btw wa   convert to words
/* 19627 */	stmt    | 6877   << off_ ,	//	beq wc =b_art prn16 jump if arblk
/* 19628 */	loadi   | r2     << dst_ | b_art  << off_ ,
/* 19629 */	beq     | wc     << dst_ | r2     << src_ | prn16  << off_ ,
/* 19630 */	stmt    | 6878   << off_ ,	//	sub wa =vcvlb  adjust for standard fields
/* 19631 */	loadi   | r2     << dst_ | vcvlb  << off_ ,
/* 19632 */	sub     | wa     << dst_ | r2     << src_ ,
/* 19633 */	stmt    | 6879   << off_ ,	//	mti wa   move to integer accum
/* 19634 */	move    | ia     << dst_ | wa     << src_ ,
/* 19635 */	stmt    | 6880   << off_ ,	//	jsr prtin   print linear subscript
/* 19636 */	call    | prtin  << off_ ,
/* 19637 */	stmt    | 6881   << off_ ,	//	brn prn14   merge back for right bracket
/* 19638 */	brn     | prn14  << off_ ,
// prn16:
/* 19639 */	stmt    | 6882   << off_ ,	//prn16	mov wc arofs(xl)  load length of bounds info
/* 19640 */	load    | wc     << dst_ | xl     << src_ | arofs  << off_ ,
/* 19641 */	stmt    | 6883   << off_ ,	//	ica wc   adjust for arpro field
/* 19642 */	ica     | wc     << dst_ ,
/* 19643 */	stmt    | 6884   << off_ ,	//	btw wc   convert to words
/* 19644 */	stmt    | 6885   << off_ ,	//	sub wa wc  get linear zero-origin subscript
/* 19645 */	sub     | wa     << dst_ | wc     << src_ ,
/* 19646 */	stmt    | 6886   << off_ ,	//	mti wa   get integer value
/* 19647 */	move    | ia     << dst_ | wa     << src_ ,
/* 19648 */	stmt    | 6887   << off_ ,	//	lct wa arndm(xl)  set num of dimensions as loop count
/* 19649 */	load    | wa     << dst_ | xl     << src_ | arndm  << off_ ,
/* 19650 */	stmt    | 6888   << off_ ,	//	add xl arofs(xl)  point past bounds information
/* 19651 */	load    | r2     << dst_ | xl     << src_ | arofs  << off_ ,
/* 19652 */	add     | xl     << dst_ | r2     << src_ ,
/* 19653 */	stmt    | 6889   << off_ ,	//	sub xl *arlbd  set ok offset for proper ptr later
/* 19654 */	loadi   | r2     << dst_ | arlbd  << off_ ,
/* 19655 */	sub     | xl     << dst_ | r2     << src_ ,
// prn17:
/* 19656 */	stmt    | 6890   << off_ ,	//prn17	sub xl *ardms  point to next set of bounds
/* 19657 */	loadi   | r2     << dst_ | ardms  << off_ ,
/* 19658 */	sub     | xl     << dst_ | r2     << src_ ,
/* 19659 */	stmt    | 6891   << off_ ,	//	sti prnsi   save current offset
/* 19660 */	store   | ia     << dst_ | prnsi  << off_ ,
/* 19661 */	stmt    | 6892   << off_ ,	//	rmi ardim(xl)   get remainder on dividing by dimens
/* 19662 */	load    | r1     << dst_ | xl     << src_ | ardim  << off_ ,
/* 19663 */	rmi     | r1     << dst_ ,
/* 19664 */	stmt    | 6893   << off_ ,	//	mfi -(xs)   store on stack (one word)
/* 19665 */	dca     | xs     << dst_ ,
/* 19666 */	store   | ia     << dst_ | xs     << src_ ,
/* 19667 */	stmt    | 6894   << off_ ,	//	ldi prnsi   reload argument
/* 19668 */	load    | r1     << dst_ | prnsi  << off_ ,
/* 19669 */	ldi     | r1     << dst_ ,
/* 19670 */	stmt    | 6895   << off_ ,	//	dvi ardim(xl)   divide to get quotient
/* 19671 */	load    | r1     << dst_ | xl     << src_ | ardim  << off_ ,
/* 19672 */	dvi     | r1     << dst_ ,
/* 19673 */	stmt    | 6896   << off_ ,	//	bct wa prn17  loop till all stacked
/* 19674 */	bct     | wa     << dst_ | prn17  << off_ ,
/* 19675 */	stmt    | 6897   << off_ ,	//	zer xr   set offset to first set of bounds
/* 19676 */	move    | xr     << dst_ ,
/* 19677 */	stmt    | 6898   << off_ ,	//	lct wb arndm(xl)  load count of dims to control loop
/* 19678 */	load    | wb     << dst_ | xl     << src_ | arndm  << off_ ,
/* 19679 */	stmt    | 6899   << off_ ,	//	brn prn19   jump into print loop
/* 19680 */	brn     | prn19  << off_ ,
// prn18:
/* 19681 */	stmt    | 6900   << off_ ,	//prn18	mov wa =ch_cm  load a comma
/* 19682 */	loadi   | wa     << dst_ | ch_cm  << off_ ,
/* 19683 */	stmt    | 6901   << off_ ,	//	jsr prtch   print it
/* 19684 */	call    | prtch  << off_ ,
// prn19:
/* 19685 */	stmt    | 6902   << off_ ,	//prn19	mti (xs)+   load subscript offset as integer
/* 19686 */	load    | ia     << dst_ | xs     << src_ ,
/* 19687 */	ica     | xs     << dst_ ,
/* 19688 */	stmt    | 6903   << off_ ,	//	add xl xr  point to current lbd
/* 19689 */	add     | xl     << dst_ | xr     << src_ ,
/* 19690 */	stmt    | 6904   << off_ ,	//	adi arlbd(xl)   add lbd to get signed subscript
/* 19691 */	load    | r1     << dst_ | xl     << src_ | arlbd  << off_ ,
/* 19692 */	adi     | r1     << dst_ ,
/* 19693 */	stmt    | 6905   << off_ ,	//	sub xl xr  point back to start of arblk
/* 19694 */	sub     | xl     << dst_ | xr     << src_ ,
/* 19695 */	stmt    | 6906   << off_ ,	//	jsr prtin   print subscript
/* 19696 */	call    | prtin  << off_ ,
/* 19697 */	stmt    | 6907   << off_ ,	//	add xr *ardms  bump offset to next bounds
/* 19698 */	loadi   | r2     << dst_ | ardms  << off_ ,
/* 19699 */	add     | xr     << dst_ | r2     << src_ ,
/* 19700 */	stmt    | 6908   << off_ ,	//	bct wb prn18  loop back till all printed
/* 19701 */	bct     | wb     << dst_ | prn18  << off_ ,
/* 19702 */	stmt    | 6909   << off_ ,	//	brn prn14   merge back to print right bracket
/* 19703 */	brn     | prn14  << off_ ,
// prtnv:
/* 19704 */	stmt    | 6910   << off_ ,	//prtnv	prc e 0  entry point
/* 19705 */	stmt    | 6911   << off_ ,	//	jsr prtnm   print argument name
/* 19706 */	call    | prtnm  << off_ ,
/* 19707 */	stmt    | 6912   << off_ ,	//	mov -(xs) xr  save entry xr
/* 19708 */	dca     | xs     << dst_ ,
/* 19709 */	store   | xr     << dst_ | xs     << src_ ,
/* 19710 */	stmt    | 6913   << off_ ,	//	mov -(xs) wa  save name offset (collectable)
/* 19711 */	dca     | xs     << dst_ ,
/* 19712 */	store   | wa     << dst_ | xs     << src_ ,
/* 19713 */	stmt    | 6914   << off_ ,	//	mov xr =tmbeb  point to blank equal blank
/* 19714 */	loadi   | xr     << dst_ | tmbeb  << off_ ,
/* 19715 */	stmt    | 6915   << off_ ,	//	jsr prtst   print it
/* 19716 */	call    | prtst  << off_ ,
/* 19717 */	stmt    | 6916   << off_ ,	//	mov xr xl  copy name base
/* 19718 */	move    | xr     << dst_ | xl     << src_ ,
/* 19719 */	stmt    | 6917   << off_ ,	//	add xr wa  point to value
/* 19720 */	add     | xr     << dst_ | wa     << src_ ,
/* 19721 */	stmt    | 6918   << off_ ,	//	mov xr (xr)  load value pointer
/* 19722 */	load    | xr     << dst_ | xr     << src_ ,
/* 19723 */	stmt    | 6919   << off_ ,	//	jsr prtvl   print value
/* 19724 */	call    | prtvl  << off_ ,
/* 19725 */	stmt    | 6920   << off_ ,	//	jsr prtnl   terminate line
/* 19726 */	call    | prtnl  << off_ ,
/* 19727 */	stmt    | 6921   << off_ ,	//	mov wa (xs)+  restore name offset
/* 19728 */	load    | wa     << dst_ | xs     << src_ ,
/* 19729 */	ica     | xs     << dst_ ,
/* 19730 */	stmt    | 6922   << off_ ,	//	mov xr (xs)+  restore entry xr
/* 19731 */	load    | xr     << dst_ | xs     << src_ ,
/* 19732 */	ica     | xs     << dst_ ,
/* 19733 */	stmt    | 6923   << off_ ,	//	exi    return to caller
/* 19734 */	exi     | 0      << off_ ,
// prtpg:
/* 19735 */	stmt    | 6924   << off_ ,	//prtpg	prc e 0  entry point
/* 19736 */	stmt    | 6925   << off_ ,	//	beq stage =stgxt prp01 jump if execution time
/* 19737 */	load    | r1     << dst_ | stage  << off_ ,
/* 19738 */	loadi   | r2     << dst_ | stgxt  << off_ ,
/* 19739 */	beq     | r1     << dst_ | r2     << src_ | prp01  << off_ ,
/* 19740 */	stmt    | 6926   << off_ ,	//	bze lstlc prp06  return if top of page already
/* 19741 */	load    | r1     << dst_ | lstlc  << off_ ,
/* 19742 */	bze     | r1     << dst_ | prp06  << off_ ,
/* 19743 */	stmt    | 6927   << off_ ,	//	zer lstlc   clear line count
/* 19744 */	store   | r0     << dst_ | lstlc  << off_ ,
// prp01:
/* 19745 */	stmt    | 6928   << off_ ,	//prp01	mov -(xs) xr  preserve xr
/* 19746 */	dca     | xs     << dst_ ,
/* 19747 */	store   | xr     << dst_ | xs     << src_ ,
/* 19748 */	stmt    | 6929   << off_ ,	//	bnz prstd prp02  eject if flag set
/* 19749 */	load    | r1     << dst_ | prstd  << off_ ,
/* 19750 */	bnz     | r1     << dst_ | prp02  << off_ ,
/* 19751 */	stmt    | 6930   << off_ ,	//	bnz prich prp03  jump if interactive listing channel
/* 19752 */	load    | r1     << dst_ | prich  << off_ ,
/* 19753 */	bnz     | r1     << dst_ | prp03  << off_ ,
/* 19754 */	stmt    | 6931   << off_ ,	//	bze precl prp03  jump if compact listing
/* 19755 */	load    | r1     << dst_ | precl  << off_ ,
/* 19756 */	bze     | r1     << dst_ | prp03  << off_ ,
// prp02:
/* 19757 */	stmt    | 6932   << off_ ,	//prp02	jsr sysep   eject
/* 19758 */	sys     | sysep_ << off_ ,
/* 19759 */	stmt    | 6933   << off_ ,	//	brn prp04   merge
/* 19760 */	brn     | prp04  << off_ ,
// prp03:
/* 19761 */	stmt    | 6934   << off_ ,	//prp03	mov xr headp  remember headp
/* 19762 */	load    | xr     << dst_ | headp  << off_ ,
/* 19763 */	stmt    | 6935   << off_ ,	//	mnz headp   set to avoid repeated prtpg calls
/* 19764 */	store   | xs     << dst_ | headp  << off_ ,
/* 19765 */	stmt    | 6936   << off_ ,	//	jsr prtnl   print blank line
/* 19766 */	call    | prtnl  << off_ ,
/* 19767 */	stmt    | 6937   << off_ ,	//	jsr prtnl   print blank line
/* 19768 */	call    | prtnl  << off_ ,
/* 19769 */	stmt    | 6938   << off_ ,	//	jsr prtnl   print blank line
/* 19770 */	call    | prtnl  << off_ ,
/* 19771 */	stmt    | 6939   << off_ ,	//	mov lstlc =num03  count blank lines
/* 19772 */	loadi   | r1     << dst_ | num03  << off_ ,
/* 19773 */	store   | r1     << dst_ | lstlc  << off_ ,
/* 19774 */	stmt    | 6940   << off_ ,	//	mov headp xr  restore header flag
/* 19775 */	store   | xr     << dst_ | headp  << off_ ,
// prp04:
/* 19776 */	stmt    | 6941   << off_ ,	//prp04	bnz headp prp05  jump if header listed
/* 19777 */	load    | r1     << dst_ | headp  << off_ ,
/* 19778 */	bnz     | r1     << dst_ | prp05  << off_ ,
/* 19779 */	stmt    | 6942   << off_ ,	//	mnz headp   mark headers printed
/* 19780 */	store   | xs     << dst_ | headp  << off_ ,
/* 19781 */	stmt    | 6943   << off_ ,	//	mov -(xs) xl  keep xl
/* 19782 */	dca     | xs     << dst_ ,
/* 19783 */	store   | xl     << dst_ | xs     << src_ ,
/* 19784 */	stmt    | 6944   << off_ ,	//	mov xr =headr  point to listing header
/* 19785 */	loadi   | xr     << dst_ | headr  << off_ ,
/* 19786 */	stmt    | 6945   << off_ ,	//	jsr prtst   place it
/* 19787 */	call    | prtst  << off_ ,
/* 19788 */	stmt    | 6946   << off_ ,	//	jsr sysid   get system identification
/* 19789 */	sys     | sysid_ << off_ ,
/* 19790 */	stmt    | 6947   << off_ ,	//	jsr prtst   append extra chars
/* 19791 */	call    | prtst  << off_ ,
/* 19792 */	stmt    | 6948   << off_ ,	//	jsr prtnl   print it
/* 19793 */	call    | prtnl  << off_ ,
/* 19794 */	stmt    | 6949   << off_ ,	//	mov xr xl  extra header line
/* 19795 */	move    | xr     << dst_ | xl     << src_ ,
/* 19796 */	stmt    | 6950   << off_ ,	//	jsr prtst   place it
/* 19797 */	call    | prtst  << off_ ,
/* 19798 */	stmt    | 6951   << off_ ,	//	jsr prtnl   print it
/* 19799 */	call    | prtnl  << off_ ,
/* 19800 */	stmt    | 6952   << off_ ,	//	jsr prtnl   print a blank
/* 19801 */	call    | prtnl  << off_ ,
/* 19802 */	stmt    | 6953   << off_ ,	//	jsr prtnl   and another
/* 19803 */	call    | prtnl  << off_ ,
/* 19804 */	stmt    | 6954   << off_ ,	//	add lstlc =num04  four header lines printed
/* 19805 */	load    | r1     << dst_ | lstlc  << off_ ,
/* 19806 */	loadi   | r2     << dst_ | num04  << off_ ,
/* 19807 */	add     | r1     << dst_ | r2     << src_ ,
/* 19808 */	store   | r1     << dst_ | lstlc  << off_ ,
/* 19809 */	stmt    | 6955   << off_ ,	//	mov xl (xs)+  restore xl
/* 19810 */	load    | xl     << dst_ | xs     << src_ ,
/* 19811 */	ica     | xs     << dst_ ,
// prp05:
/* 19812 */	stmt    | 6956   << off_ ,	//prp05	mov xr (xs)+  restore xr
/* 19813 */	load    | xr     << dst_ | xs     << src_ ,
/* 19814 */	ica     | xs     << dst_ ,
// prp06:
/* 19815 */	stmt    | 6957   << off_ ,	//prp06	exi    return
/* 19816 */	exi     | 0      << off_ ,
// prtps:
/* 19817 */	stmt    | 6958   << off_ ,	//prtps	prc e 0  entry point
/* 19818 */	stmt    | 6959   << off_ ,	//	mov prstd prsto  copy option flag
/* 19819 */	load    | r1     << dst_ | prsto  << off_ ,
/* 19820 */	store   | r1     << dst_ | prstd  << off_ ,
/* 19821 */	stmt    | 6960   << off_ ,	//	jsr prtpg   print page
/* 19822 */	call    | prtpg  << off_ ,
/* 19823 */	stmt    | 6961   << off_ ,	//	zer prstd   clear flag
/* 19824 */	store   | r0     << dst_ | prstd  << off_ ,
/* 19825 */	stmt    | 6962   << off_ ,	//	exi    return
/* 19826 */	exi     | 0      << off_ ,
// prtsn:
/* 19827 */	stmt    | 6963   << off_ ,	//prtsn	prc e 0  entry point
/* 19828 */	stmt    | 6964   << off_ ,	//	mov -(xs) xr  save entry xr
/* 19829 */	dca     | xs     << dst_ ,
/* 19830 */	store   | xr     << dst_ | xs     << src_ ,
/* 19831 */	stmt    | 6965   << off_ ,	//	mov prsna wa  save entry wa
/* 19832 */	store   | wa     << dst_ | prsna  << off_ ,
/* 19833 */	stmt    | 6966   << off_ ,	//	mov xr =tmasb  point to asterisks
/* 19834 */	loadi   | xr     << dst_ | tmasb  << off_ ,
/* 19835 */	stmt    | 6967   << off_ ,	//	jsr prtst   print asterisks
/* 19836 */	call    | prtst  << off_ ,
/* 19837 */	stmt    | 6968   << off_ ,	//	mov profs =num04  point into middle of asterisks
/* 19838 */	loadi   | r1     << dst_ | num04  << off_ ,
/* 19839 */	store   | r1     << dst_ | profs  << off_ ,
/* 19840 */	stmt    | 6969   << off_ ,	//	mti kvstn   load statement number as integer
/* 19841 */	load    | ia     << dst_ | kvstn  << off_ ,
/* 19842 */	stmt    | 6970   << off_ ,	//	jsr prtin   print integer statement number
/* 19843 */	call    | prtin  << off_ ,
/* 19844 */	stmt    | 6971   << off_ ,	//	mov profs =prsnf  point past asterisks plus blank
/* 19845 */	loadi   | r1     << dst_ | prsnf  << off_ ,
/* 19846 */	store   | r1     << dst_ | profs  << off_ ,
/* 19847 */	stmt    | 6972   << off_ ,	//	mov xr kvfnc  get fnclevel
/* 19848 */	load    | xr     << dst_ | kvfnc  << off_ ,
/* 19849 */	stmt    | 6973   << off_ ,	//	mov wa =ch_li  set letter i
/* 19850 */	loadi   | wa     << dst_ | ch_li  << off_ ,
// prsn1:
/* 19851 */	stmt    | 6974   << off_ ,	//prsn1	bze xr prsn2  jump if all set
/* 19852 */	bze     | xr     << dst_ | prsn2  << off_ ,
/* 19853 */	stmt    | 6975   << off_ ,	//	jsr prtch   else print an i
/* 19854 */	call    | prtch  << off_ ,
/* 19855 */	stmt    | 6976   << off_ ,	//	dcv xr   decrement counter
/* 19856 */	dcv     | xr     << dst_ ,
/* 19857 */	stmt    | 6977   << off_ ,	//	brn prsn1   loop back
/* 19858 */	brn     | prsn1  << off_ ,
// prsn2:
/* 19859 */	stmt    | 6978   << off_ ,	//prsn2	mov wa =ch_bl  get blank
/* 19860 */	loadi   | wa     << dst_ | ch_bl  << off_ ,
/* 19861 */	stmt    | 6979   << off_ ,	//	jsr prtch   print blank
/* 19862 */	call    | prtch  << off_ ,
/* 19863 */	stmt    | 6980   << off_ ,	//	mov wa prsna  restore entry wa
/* 19864 */	load    | wa     << dst_ | prsna  << off_ ,
/* 19865 */	stmt    | 6981   << off_ ,	//	mov xr (xs)+  restore entry xr
/* 19866 */	load    | xr     << dst_ | xs     << src_ ,
/* 19867 */	ica     | xs     << dst_ ,
/* 19868 */	stmt    | 6982   << off_ ,	//	exi    return to prtsn caller
/* 19869 */	exi     | 0      << off_ ,
// prtst:
/* 19870 */	stmt    | 6983   << off_ ,	//prtst	prc r 0  entry point
/* 19871 */	stmt    | 6984   << off_ ,	//	bnz headp prst0  were headers printed
/* 19872 */	load    | r1     << dst_ | headp  << off_ ,
/* 19873 */	bnz     | r1     << dst_ | prst0  << off_ ,
/* 19874 */	stmt    | 6985   << off_ ,	//	jsr prtps   no - print them
/* 19875 */	call    | prtps  << off_ ,
// prst0:
/* 19876 */	stmt    | 6986   << off_ ,	//prst0	mov prsva wa  save wa
/* 19877 */	store   | wa     << dst_ | prsva  << off_ ,
/* 19878 */	stmt    | 6987   << off_ ,	//	mov prsvb wb  save wb
/* 19879 */	store   | wb     << dst_ | prsvb  << off_ ,
/* 19880 */	stmt    | 6988   << off_ ,	//	zer wb   set chars printed count to zero
/* 19881 */	move    | wb     << dst_ ,
// prst1:
/* 19882 */	stmt    | 6989   << off_ ,	//prst1	mov wa sclen(xr)  load string length
/* 19883 */	load    | wa     << dst_ | xr     << src_ | sclen  << off_ ,
/* 19884 */	stmt    | 6990   << off_ ,	//	sub wa wb  subtract count of chars already out
/* 19885 */	sub     | wa     << dst_ | wb     << src_ ,
/* 19886 */	stmt    | 6991   << off_ ,	//	bze wa prst4  jump to exit if none left
/* 19887 */	bze     | wa     << dst_ | prst4  << off_ ,
/* 19888 */	stmt    | 6992   << off_ ,	//	mov -(xs) xl  else stack entry xl
/* 19889 */	dca     | xs     << dst_ ,
/* 19890 */	store   | xl     << dst_ | xs     << src_ ,
/* 19891 */	stmt    | 6993   << off_ ,	//	mov -(xs) xr  save argument
/* 19892 */	dca     | xs     << dst_ ,
/* 19893 */	store   | xr     << dst_ | xs     << src_ ,
/* 19894 */	stmt    | 6994   << off_ ,	//	mov xl xr  copy for eventual move
/* 19895 */	move    | xl     << dst_ | xr     << src_ ,
/* 19896 */	stmt    | 6995   << off_ ,	//	mov xr prlen  load print buffer length
/* 19897 */	load    | xr     << dst_ | prlen  << off_ ,
/* 19898 */	stmt    | 6996   << off_ ,	//	sub xr profs  get chars left in print buffer
/* 19899 */	load    | r2     << dst_ | profs  << off_ ,
/* 19900 */	sub     | xr     << dst_ | r2     << src_ ,
/* 19901 */	stmt    | 6997   << off_ ,	//	bnz xr prst2  skip if room left on this line
/* 19902 */	bnz     | xr     << dst_ | prst2  << off_ ,
/* 19903 */	stmt    | 6998   << off_ ,	//	jsr prtnl   else print this line
/* 19904 */	call    | prtnl  << off_ ,
/* 19905 */	stmt    | 6999   << off_ ,	//	mov xr prlen  and set full width available
/* 19906 */	load    | xr     << dst_ | prlen  << off_ ,
// prst2:
/* 19907 */	stmt    | 7000   << off_ ,	//prst2	blo wa xr prst3 jump if room for rest of string
/* 19908 */	blo     | wa     << dst_ | xr     << src_ | prst3  << off_ ,
/* 19909 */	stmt    | 7001   << off_ ,	//	mov wa xr  else set to fill line
/* 19910 */	move    | wa     << dst_ | xr     << src_ ,
// prst3:
/* 19911 */	stmt    | 7002   << off_ ,	//prst3	mov xr prbuf  point to print buffer
/* 19912 */	load    | xr     << dst_ | prbuf  << off_ ,
/* 19913 */	stmt    | 7003   << off_ ,	//	plc xl wb  point to location in string
/* 19914 */	plc     | xl     << dst_ | wb     << src_ ,
/* 19915 */	stmt    | 7004   << off_ ,	//	psc xr profs  point to location in buffer
/* 19916 */	load    | r2     << dst_ | profs  << off_ ,
/* 19917 */	psc     | xr     << dst_ | r2     << src_ ,
/* 19918 */	stmt    | 7005   << off_ ,	//	add wb wa  bump string chars count
/* 19919 */	add     | wb     << dst_ | wa     << src_ ,
/* 19920 */	stmt    | 7006   << off_ ,	//	add profs wa  bump buffer pointer
/* 19921 */	load    | r1     << dst_ | profs  << off_ ,
/* 19922 */	add     | r1     << dst_ | wa     << src_ ,
/* 19923 */	store   | r1     << dst_ | profs  << off_ ,
/* 19924 */	stmt    | 7007   << off_ ,	//	mov prsvc wb  preserve char counter
/* 19925 */	store   | wb     << dst_ | prsvc  << off_ ,
/* 19926 */	stmt    | 7008   << off_ ,	//	mvc    move characters to buffer
/* 19927 */	mvc     ,
/* 19928 */	stmt    | 7009   << off_ ,	//	mov wb prsvc  recover char counter
/* 19929 */	load    | wb     << dst_ | prsvc  << off_ ,
/* 19930 */	stmt    | 7010   << off_ ,	//	mov xr (xs)+  restore argument pointer
/* 19931 */	load    | xr     << dst_ | xs     << src_ ,
/* 19932 */	ica     | xs     << dst_ ,
/* 19933 */	stmt    | 7011   << off_ ,	//	mov xl (xs)+  restore entry xl
/* 19934 */	load    | xl     << dst_ | xs     << src_ ,
/* 19935 */	ica     | xs     << dst_ ,
/* 19936 */	stmt    | 7012   << off_ ,	//	brn prst1   loop back to test for more
/* 19937 */	brn     | prst1  << off_ ,
// prst4:
/* 19938 */	stmt    | 7013   << off_ ,	//prst4	mov wb prsvb  restore entry wb
/* 19939 */	load    | wb     << dst_ | prsvb  << off_ ,
/* 19940 */	stmt    | 7014   << off_ ,	//	mov wa prsva  restore entry wa
/* 19941 */	load    | wa     << dst_ | prsva  << off_ ,
/* 19942 */	stmt    | 7015   << off_ ,	//	exi    return to prtst caller
/* 19943 */	exi     | 0      << off_ ,
// prttr:
/* 19944 */	stmt    | 7016   << off_ ,	//prttr	prc e 0  entry point
/* 19945 */	stmt    | 7017   << off_ ,	//	mov -(xs) xr  save xr
/* 19946 */	dca     | xs     << dst_ ,
/* 19947 */	store   | xr     << dst_ | xs     << src_ ,
/* 19948 */	stmt    | 7018   << off_ ,	//	jsr prtic   print buffer contents
/* 19949 */	call    | prtic  << off_ ,
/* 19950 */	stmt    | 7019   << off_ ,	//	mov xr prbuf  point to print bfr to clear it
/* 19951 */	load    | xr     << dst_ | prbuf  << off_ ,
/* 19952 */	stmt    | 7020   << off_ ,	//	lct wa prlnw  get buffer length
/* 19953 */	load    | wa     << dst_ | prlnw  << off_ ,
/* 19954 */	stmt    | 7021   << off_ ,	//	add xr *schar  point past scblk header
/* 19955 */	loadi   | r2     << dst_ | schar  << off_ ,
/* 19956 */	add     | xr     << dst_ | r2     << src_ ,
/* 19957 */	stmt    | 7022   << off_ ,	//	mov wb 4,nullw  get blanks
/* 19958 */	load    | wb     << dst_ | nullw  << off_ ,
// prtt1:
/* 19959 */	stmt    | 7023   << off_ ,	//prtt1	mov (xr)+ wb  clear a word
/* 19960 */	store   | wb     << dst_ | xr     << src_ ,
/* 19961 */	ica     | xr     << dst_ ,
/* 19962 */	stmt    | 7024   << off_ ,	//	bct wa prtt1  loop
/* 19963 */	bct     | wa     << dst_ | prtt1  << off_ ,
/* 19964 */	stmt    | 7025   << off_ ,	//	zer profs   reset profs
/* 19965 */	store   | r0     << dst_ | profs  << off_ ,
/* 19966 */	stmt    | 7026   << off_ ,	//	mov xr (xs)+  restore xr
/* 19967 */	load    | xr     << dst_ | xs     << src_ ,
/* 19968 */	ica     | xs     << dst_ ,
/* 19969 */	stmt    | 7027   << off_ ,	//	exi    return
/* 19970 */	exi     | 0      << off_ ,
// prtvl:
/* 19971 */	stmt    | 7028   << off_ ,	//prtvl	prc r 0  entry point, recursive
/* 19972 */	stmt    | 7029   << off_ ,	//	mov -(xs) xl  save entry xl
/* 19973 */	dca     | xs     << dst_ ,
/* 19974 */	store   | xl     << dst_ | xs     << src_ ,
/* 19975 */	stmt    | 7030   << off_ ,	//	mov -(xs) xr  save argument
/* 19976 */	dca     | xs     << dst_ ,
/* 19977 */	store   | xr     << dst_ | xs     << src_ ,
/* 19978 */	stmt    | 7031   << off_ ,	//	chk    check for stack overflow
/* 19979 */	chk     ,
// prv01:
/* 19980 */	stmt    | 7032   << off_ ,	//prv01	mov prvsi idval(xr)  copy idval (if any)
/* 19981 */	load    | r1     << dst_ | xr     << src_ | idval  << off_ ,
/* 19982 */	store   | r1     << dst_ | prvsi  << off_ ,
/* 19983 */	stmt    | 7033   << off_ ,	//	mov xl (xr)  load first word of block
/* 19984 */	load    | xl     << dst_ | xr     << src_ ,
/* 19985 */	stmt    | 7034   << off_ ,	//	lei xl   load entry point id
/* 19986 */	lei     | xl     << dst_ ,
/* 19987 */	stmt    | 7035   << off_ ,	//	bsw xl bl__t prv02 switch on block type
/* 19988 */	loadi   | r1     << dst_ | bl__t  << off_ ,
/* 19989 */	bsw     | xl     << dst_ | r1     << src_ | prv02  << off_ ,
/* 19990 */	prv05   ,
/* 19991 */	prv02   ,
/* 19992 */	prv02   ,
/* 19993 */	prv08   ,
/* 19994 */	prv09   ,
/* 19995 */	prv02   ,
/* 19996 */	prv02   ,
/* 19997 */	prv02   ,
/* 19998 */	prv08   ,
/* 19999 */	prv11   ,
/* 20000 */	prv12   ,
/* 20001 */	prv13   ,
/* 20002 */	prv13   ,
/* 20003 */	prv02   ,
/* 20004 */	prv02   ,
/* 20005 */	prv02   ,
/* 20006 */	prv10   ,
/* 20007 */	prv04   ,
// prv02:
/* 20008 */	stmt    | 7036   << off_ ,	//prv02	jsr dtype   get datatype name
/* 20009 */	call    | dtype  << off_ ,
/* 20010 */	stmt    | 7037   << off_ ,	//	jsr prtst   print datatype name
/* 20011 */	call    | prtst  << off_ ,
// prv03:
/* 20012 */	stmt    | 7038   << off_ ,	//prv03	mov xr (xs)+  reload argument
/* 20013 */	load    | xr     << dst_ | xs     << src_ ,
/* 20014 */	ica     | xs     << dst_ ,
/* 20015 */	stmt    | 7039   << off_ ,	//	mov xl (xs)+  restore xl
/* 20016 */	load    | xl     << dst_ | xs     << src_ ,
/* 20017 */	ica     | xs     << dst_ ,
/* 20018 */	stmt    | 7040   << off_ ,	//	exi    return to prtvl caller
/* 20019 */	exi     | 0      << off_ ,
// prv04:
/* 20020 */	stmt    | 7041   << off_ ,	//prv04	mov xr trval(xr)  load real value
/* 20021 */	load    | xr     << dst_ | xr     << src_ | trval  << off_ ,
/* 20022 */	stmt    | 7042   << off_ ,	//	brn prv01   and loop back
/* 20023 */	brn     | prv01  << off_ ,
// prv05:
/* 20024 */	stmt    | 7043   << off_ ,	//prv05	mov xl xr  preserve argument
/* 20025 */	move    | xl     << dst_ | xr     << src_ ,
/* 20026 */	stmt    | 7044   << off_ ,	//	mov xr =scarr  point to datatype name (array)
/* 20027 */	loadi   | xr     << dst_ | scarr  << off_ ,
/* 20028 */	stmt    | 7045   << off_ ,	//	jsr prtst   print it
/* 20029 */	call    | prtst  << off_ ,
/* 20030 */	stmt    | 7046   << off_ ,	//	mov wa =ch_pp  load left paren
/* 20031 */	loadi   | wa     << dst_ | ch_pp  << off_ ,
/* 20032 */	stmt    | 7047   << off_ ,	//	jsr prtch   print left paren
/* 20033 */	call    | prtch  << off_ ,
/* 20034 */	stmt    | 7048   << off_ ,	//	add xl arofs(xl)  point to prototype
/* 20035 */	load    | r2     << dst_ | xl     << src_ | arofs  << off_ ,
/* 20036 */	add     | xl     << dst_ | r2     << src_ ,
/* 20037 */	stmt    | 7049   << off_ ,	//	mov xr (xl)  load prototype
/* 20038 */	load    | xr     << dst_ | xl     << src_ ,
/* 20039 */	stmt    | 7050   << off_ ,	//	jsr prtst   print prototype
/* 20040 */	call    | prtst  << off_ ,
// prv06:
/* 20041 */	stmt    | 7051   << off_ ,	//prv06	mov wa =ch_rp  load right paren
/* 20042 */	loadi   | wa     << dst_ | ch_rp  << off_ ,
/* 20043 */	stmt    | 7052   << off_ ,	//	jsr prtch   print right paren
/* 20044 */	call    | prtch  << off_ ,
// prv07:
/* 20045 */	stmt    | 7053   << off_ ,	//prv07	mov wa =ch_bl  load blank
/* 20046 */	loadi   | wa     << dst_ | ch_bl  << off_ ,
/* 20047 */	stmt    | 7054   << off_ ,	//	jsr prtch   print it
/* 20048 */	call    | prtch  << off_ ,
/* 20049 */	stmt    | 7055   << off_ ,	//	mov wa =ch_nm  load number sign
/* 20050 */	loadi   | wa     << dst_ | ch_nm  << off_ ,
/* 20051 */	stmt    | 7056   << off_ ,	//	jsr prtch   print it
/* 20052 */	call    | prtch  << off_ ,
/* 20053 */	stmt    | 7057   << off_ ,	//	mti prvsi   get idval
/* 20054 */	load    | ia     << dst_ | prvsi  << off_ ,
/* 20055 */	stmt    | 7058   << off_ ,	//	jsr prtin   print id number
/* 20056 */	call    | prtin  << off_ ,
/* 20057 */	stmt    | 7059   << off_ ,	//	brn prv03   back to exit
/* 20058 */	brn     | prv03  << off_ ,
// prv08:
/* 20059 */	stmt    | 7060   << off_ ,	//prv08	mov -(xs) xr  stack argument for gtstg
/* 20060 */	dca     | xs     << dst_ ,
/* 20061 */	store   | xr     << dst_ | xs     << src_ ,
/* 20062 */	stmt    | 7061   << off_ ,	//	jsr gtstg   convert to string
/* 20063 */	call    | gtstg  << off_ ,
/* 20064 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 20065 */	ppm     ,
/* 20066 */	stmt    | 7062   << off_ ,	//	jsr prtst   print the string
/* 20067 */	call    | prtst  << off_ ,
/* 20068 */	stmt    | 7063   << off_ ,	//	mov dnamp xr  delete garbage string from storage
/* 20069 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 20070 */	stmt    | 7064   << off_ ,	//	brn prv03   back to exit
/* 20071 */	brn     | prv03  << off_ ,
// prv09:
/* 20072 */	stmt    | 7065   << off_ ,	//prv09	mov xl nmbas(xr)  load name base
/* 20073 */	load    | xl     << dst_ | xr     << src_ | nmbas  << off_ ,
/* 20074 */	stmt    | 7066   << off_ ,	//	mov wa (xl)  load first word of block
/* 20075 */	load    | wa     << dst_ | xl     << src_ ,
/* 20076 */	stmt    | 7067   << off_ ,	//	beq wa =b_kvt prv02 just print name if keyword
/* 20077 */	loadi   | r2     << dst_ | b_kvt  << off_ ,
/* 20078 */	beq     | wa     << dst_ | r2     << src_ | prv02  << off_ ,
/* 20079 */	stmt    | 7068   << off_ ,	//	beq wa =b_evt prv02 just print name if expression var
/* 20080 */	loadi   | r2     << dst_ | b_evt  << off_ ,
/* 20081 */	beq     | wa     << dst_ | r2     << src_ | prv02  << off_ ,
/* 20082 */	stmt    | 7069   << off_ ,	//	mov wa =ch_dt  else get dot
/* 20083 */	loadi   | wa     << dst_ | ch_dt  << off_ ,
/* 20084 */	stmt    | 7070   << off_ ,	//	jsr prtch   and print it
/* 20085 */	call    | prtch  << off_ ,
/* 20086 */	stmt    | 7071   << off_ ,	//	mov wa nmofs(xr)  load name offset
/* 20087 */	load    | wa     << dst_ | xr     << src_ | nmofs  << off_ ,
/* 20088 */	stmt    | 7072   << off_ ,	//	jsr prtnm   print name
/* 20089 */	call    | prtnm  << off_ ,
/* 20090 */	stmt    | 7073   << off_ ,	//	brn prv03   back to exit
/* 20091 */	brn     | prv03  << off_ ,
// prv10:
/* 20092 */	stmt    | 7074   << off_ ,	//prv10	jsr dtype   get datatype name
/* 20093 */	call    | dtype  << off_ ,
/* 20094 */	stmt    | 7075   << off_ ,	//	jsr prtst   print datatype name
/* 20095 */	call    | prtst  << off_ ,
/* 20096 */	stmt    | 7076   << off_ ,	//	brn prv07   merge back to print id
/* 20097 */	brn     | prv07  << off_ ,
// prv11:
/* 20098 */	stmt    | 7077   << off_ ,	//prv11	mov wa =ch_sq  load single quote
/* 20099 */	loadi   | wa     << dst_ | ch_sq  << off_ ,
/* 20100 */	stmt    | 7078   << off_ ,	//	jsr prtch   print quote
/* 20101 */	call    | prtch  << off_ ,
/* 20102 */	stmt    | 7079   << off_ ,	//	jsr prtst   print string value
/* 20103 */	call    | prtst  << off_ ,
/* 20104 */	stmt    | 7080   << off_ ,	//	jsr prtch   print another quote
/* 20105 */	call    | prtch  << off_ ,
/* 20106 */	stmt    | 7081   << off_ ,	//	brn prv03   back to exit
/* 20107 */	brn     | prv03  << off_ ,
// prv12:
/* 20108 */	stmt    | 7082   << off_ ,	//prv12	mov wa =ch_as  load asterisk
/* 20109 */	loadi   | wa     << dst_ | ch_as  << off_ ,
/* 20110 */	stmt    | 7083   << off_ ,	//	jsr prtch   print asterisk
/* 20111 */	call    | prtch  << off_ ,
/* 20112 */	stmt    | 7084   << off_ ,	//	mov xr sevar(xr)  load variable pointer
/* 20113 */	load    | xr     << dst_ | xr     << src_ | sevar  << off_ ,
/* 20114 */	stmt    | 7085   << off_ ,	//	jsr prtvn   print variable name
/* 20115 */	call    | prtvn  << off_ ,
/* 20116 */	stmt    | 7086   << off_ ,	//	brn prv03   jump back to exit
/* 20117 */	brn     | prv03  << off_ ,
// prv13:
/* 20118 */	stmt    | 7087   << off_ ,	//prv13	mov xl xr  preserve argument
/* 20119 */	move    | xl     << dst_ | xr     << src_ ,
/* 20120 */	stmt    | 7088   << off_ ,	//	jsr dtype   get datatype name
/* 20121 */	call    | dtype  << off_ ,
/* 20122 */	stmt    | 7089   << off_ ,	//	jsr prtst   print datatype name
/* 20123 */	call    | prtst  << off_ ,
/* 20124 */	stmt    | 7090   << off_ ,	//	mov wa =ch_pp  load left paren
/* 20125 */	loadi   | wa     << dst_ | ch_pp  << off_ ,
/* 20126 */	stmt    | 7091   << off_ ,	//	jsr prtch   print left paren
/* 20127 */	call    | prtch  << off_ ,
/* 20128 */	stmt    | 7092   << off_ ,	//	mov wa tblen(xl)  load length of block (=vclen)
/* 20129 */	load    | wa     << dst_ | xl     << src_ | tblen  << off_ ,
/* 20130 */	stmt    | 7093   << off_ ,	//	btw wa   convert to word count
/* 20131 */	stmt    | 7094   << off_ ,	//	sub wa =tbsi_  allow for standard fields
/* 20132 */	loadi   | r2     << dst_ | tbsi_  << off_ ,
/* 20133 */	sub     | wa     << dst_ | r2     << src_ ,
/* 20134 */	stmt    | 7095   << off_ ,	//	beq (xl) =b_tbt prv14 jump if table
/* 20135 */	load    | r1     << dst_ | xl     << src_ ,
/* 20136 */	loadi   | r2     << dst_ | b_tbt  << off_ ,
/* 20137 */	beq     | r1     << dst_ | r2     << src_ | prv14  << off_ ,
/* 20138 */	stmt    | 7096   << off_ ,	//	add wa =vctbd  for vcblk, adjust size
/* 20139 */	loadi   | r2     << dst_ | vctbd  << off_ ,
/* 20140 */	add     | wa     << dst_ | r2     << src_ ,
// prv14:
/* 20141 */	stmt    | 7097   << off_ ,	//prv14	mti wa   move as integer
/* 20142 */	move    | ia     << dst_ | wa     << src_ ,
/* 20143 */	stmt    | 7098   << off_ ,	//	jsr prtin   print integer prototype
/* 20144 */	call    | prtin  << off_ ,
/* 20145 */	stmt    | 7099   << off_ ,	//	brn prv06   merge back for rest
/* 20146 */	brn     | prv06  << off_ ,
// prtvn:
/* 20147 */	stmt    | 7100   << off_ ,	//prtvn	prc e 0  entry point
/* 20148 */	stmt    | 7101   << off_ ,	//	mov -(xs) xr  stack vrblk pointer
/* 20149 */	dca     | xs     << dst_ ,
/* 20150 */	store   | xr     << dst_ | xs     << src_ ,
/* 20151 */	stmt    | 7102   << off_ ,	//	add xr *vrsof  point to possible string name
/* 20152 */	loadi   | r2     << dst_ | vrsof  << off_ ,
/* 20153 */	add     | xr     << dst_ | r2     << src_ ,
/* 20154 */	stmt    | 7103   << off_ ,	//	bnz sclen(xr) prvn1  jump if not system variable
/* 20155 */	load    | r1     << dst_ | xr     << src_ | sclen  << off_ ,
/* 20156 */	bnz     | r1     << dst_ | prvn1  << off_ ,
/* 20157 */	stmt    | 7104   << off_ ,	//	mov xr vrsvo(xr)  point to svblk with name
/* 20158 */	load    | xr     << dst_ | xr     << src_ | vrsvo  << off_ ,
// prvn1:
/* 20159 */	stmt    | 7105   << off_ ,	//prvn1	jsr prtst   print string name of variable
/* 20160 */	call    | prtst  << off_ ,
/* 20161 */	stmt    | 7106   << off_ ,	//	mov xr (xs)+  restore vrblk pointer
/* 20162 */	load    | xr     << dst_ | xs     << src_ ,
/* 20163 */	ica     | xs     << dst_ ,
/* 20164 */	stmt    | 7107   << off_ ,	//	exi    return to prtvn caller
/* 20165 */	exi     | 0      << off_ ,
// rcbld:
/* 20166 */	stmt    | 7108   << off_ ,	//rcbld	prc e 0  entry point
/* 20167 */	stmt    | 7109   << off_ ,	//	mov xr dnamp  load pointer to next available loc
/* 20168 */	load    | xr     << dst_ | dnamp  << off_ ,
/* 20169 */	stmt    | 7110   << off_ ,	//	add xr *rcsi_  point past new rcblk
/* 20170 */	loadi   | r2     << dst_ | rcsi_  << off_ ,
/* 20171 */	add     | xr     << dst_ | r2     << src_ ,
/* 20172 */	stmt    | 7111   << off_ ,	//	blo xr dname rcbl1 jump if there is room
/* 20173 */	load    | r2     << dst_ | dname  << off_ ,
/* 20174 */	blo     | xr     << dst_ | r2     << src_ | rcbl1  << off_ ,
/* 20175 */	stmt    | 7112   << off_ ,	//	mov wa *rcsi_  else load rcblk length
/* 20176 */	loadi   | wa     << dst_ | rcsi_  << off_ ,
/* 20177 */	stmt    | 7113   << off_ ,	//	jsr alloc   use standard allocator to get block
/* 20178 */	call    | alloc  << off_ ,
/* 20179 */	stmt    | 7114   << off_ ,	//	add xr wa  point past block to merge
/* 20180 */	add     | xr     << dst_ | wa     << src_ ,
// rcbl1:
/* 20181 */	stmt    | 7115   << off_ ,	//rcbl1	mov dnamp xr  set new pointer
/* 20182 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 20183 */	stmt    | 7116   << off_ ,	//	sub xr *rcsi_  point back to start of block
/* 20184 */	loadi   | r2     << dst_ | rcsi_  << off_ ,
/* 20185 */	sub     | xr     << dst_ | r2     << src_ ,
/* 20186 */	stmt    | 7117   << off_ ,	//	mov (xr) =b_rcl  store type word
/* 20187 */	loadi   | r1     << dst_ | b_rcl  << off_ ,
/* 20188 */	store   | r1     << dst_ | xr     << src_ ,
/* 20189 */	stmt    | 7118   << off_ ,	//	str rcval(xr)   store real value in rcblk
/* 20190 */	store   | ra     << dst_ | xr     << src_ | rcval  << off_ ,
/* 20191 */	stmt    | 7119   << off_ ,	//	exi    return to rcbld caller
/* 20192 */	exi     | 0      << off_ ,
// readr:
/* 20193 */	stmt    | 7120   << off_ ,	//readr	prc e 0  entry point
/* 20194 */	stmt    | 7121   << off_ ,	//	mov xr r_cni  get ptr to next image
/* 20195 */	load    | xr     << dst_ | r_cni  << off_ ,
/* 20196 */	stmt    | 7122   << off_ ,	//	bnz xr read3  exit if already read
/* 20197 */	bnz     | xr     << dst_ | read3  << off_ ,
/* 20198 */	stmt    | 7123   << off_ ,	//	bnz cnind reada  if within include file
/* 20199 */	load    | r1     << dst_ | cnind  << off_ ,
/* 20200 */	bnz     | r1     << dst_ | reada  << off_ ,
/* 20201 */	stmt    | 7124   << off_ ,	//	bne stage =stgic read3 exit if not initial compile
/* 20202 */	load    | r1     << dst_ | stage  << off_ ,
/* 20203 */	loadi   | r2     << dst_ | stgic  << off_ ,
/* 20204 */	bne     | r1     << dst_ | r2     << src_ | read3  << off_ ,
// reada:
/* 20205 */	stmt    | 7125   << off_ ,	//reada	mov wa cswin  max read length
/* 20206 */	load    | wa     << dst_ | cswin  << off_ ,
/* 20207 */	stmt    | 7126   << off_ ,	//	zer xl   clear any dud value in xl
/* 20208 */	move    | xl     << dst_ ,
/* 20209 */	stmt    | 7127   << off_ ,	//	jsr alocs   allocate buffer
/* 20210 */	call    | alocs  << off_ ,
/* 20211 */	stmt    | 7128   << off_ ,	//	jsr sysrd   read input image
/* 20212 */	sys     | sysrd_ << off_ ,
/* 20213 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 20214 */	ppm     | read4  << off_ ,
/* 20215 */	stmt    | 7129   << off_ ,	//	icv rdnln   increment next line number
/* 20216 */	load    | r1     << dst_ | rdnln  << off_ ,
/* 20217 */	icv     | r1     << dst_ ,
/* 20218 */	store   | r1     << dst_ | rdnln  << off_ ,
/* 20219 */	stmt    | 7130   << off_ ,	//	dcv polct   test if time to poll interface
/* 20220 */	load    | r1     << dst_ | polct  << off_ ,
/* 20221 */	dcv     | r1     << dst_ ,
/* 20222 */	store   | r1     << dst_ | polct  << off_ ,
/* 20223 */	stmt    | 7131   << off_ ,	//	bnz polct read0  not yet
/* 20224 */	load    | r1     << dst_ | polct  << off_ ,
/* 20225 */	bnz     | r1     << dst_ | read0  << off_ ,
/* 20226 */	stmt    | 7132   << off_ ,	//	zer wa   =0 for poll
/* 20227 */	move    | wa     << dst_ ,
/* 20228 */	stmt    | 7133   << off_ ,	//	mov wb rdnln  line number
/* 20229 */	load    | wb     << dst_ | rdnln  << off_ ,
/* 20230 */	stmt    | 7134   << off_ ,	//	jsr syspl   allow interactive access
/* 20231 */	sys     | syspl_ << off_ ,
/* 20232 */	jsrerr  | r1     << dst_ | 3      << off_ ,
/* 20233 */	err     | 320    << off_ ,
/* 20234 */	ppm     ,
/* 20235 */	ppm     ,
/* 20236 */	stmt    | 7135   << off_ ,	//	mov polcs wa  new countdown start value
/* 20237 */	store   | wa     << dst_ | polcs  << off_ ,
/* 20238 */	stmt    | 7136   << off_ ,	//	mov polct wa  new counter value
/* 20239 */	store   | wa     << dst_ | polct  << off_ ,
// read0:
/* 20240 */	stmt    | 7137   << off_ ,	//read0	ble sclen(xr) cswin read1 use smaller of string lnth ...
/* 20241 */	load    | r1     << dst_ | xr     << src_ | sclen  << off_ ,
/* 20242 */	load    | r2     << dst_ | cswin  << off_ ,
/* 20243 */	ble     | r1     << dst_ | r2     << src_ | read1  << off_ ,
/* 20244 */	stmt    | 7138   << off_ ,	//	mov sclen(xr) cswin  ... and xxx of -inxxx
/* 20245 */	load    | r1     << dst_ | cswin  << off_ ,
/* 20246 */	store   | r1     << dst_ | xr     << src_ | sclen  << off_ ,
// read1:
/* 20247 */	stmt    | 7139   << off_ ,	//read1	mnz wb   set trimr to perform trim
/* 20248 */	move    | wb     << dst_ | xs     << src_ ,
/* 20249 */	stmt    | 7140   << off_ ,	//	jsr trimr   trim trailing blanks
/* 20250 */	call    | trimr  << off_ ,
// read2:
/* 20251 */	stmt    | 7141   << off_ ,	//read2	mov r_cni xr  store copy of pointer
/* 20252 */	store   | xr     << dst_ | r_cni  << off_ ,
// read3:
/* 20253 */	stmt    | 7142   << off_ ,	//read3	exi    return to readr caller
/* 20254 */	exi     | 0      << off_ ,
// read4:
/* 20255 */	stmt    | 7143   << off_ ,	//read4	bze sclen(xr) read5  jump if true end of file
/* 20256 */	load    | r1     << dst_ | xr     << src_ | sclen  << off_ ,
/* 20257 */	bze     | r1     << dst_ | read5  << off_ ,
/* 20258 */	stmt    | 7144   << off_ ,	//	zer wb   new source file name
/* 20259 */	move    | wb     << dst_ ,
/* 20260 */	stmt    | 7145   << off_ ,	//	mov rdnln wb  restart line counter for new file
/* 20261 */	store   | wb     << dst_ | rdnln  << off_ ,
/* 20262 */	stmt    | 7146   << off_ ,	//	jsr trimr   remove unused space in block
/* 20263 */	call    | trimr  << off_ ,
/* 20264 */	stmt    | 7147   << off_ ,	//	jsr newfn   record new file name
/* 20265 */	call    | newfn  << off_ ,
/* 20266 */	stmt    | 7148   << off_ ,	//	brn reada   now reissue read for record data
/* 20267 */	brn     | reada  << off_ ,
// read5:
/* 20268 */	stmt    | 7149   << off_ ,	//read5	mov dnamp xr  pop unused scblk
/* 20269 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 20270 */	stmt    | 7150   << off_ ,	//	bze cnind read6  jump if not within an include file
/* 20271 */	load    | r1     << dst_ | cnind  << off_ ,
/* 20272 */	bze     | r1     << dst_ | read6  << off_ ,
/* 20273 */	stmt    | 7151   << off_ ,	//	zer xl   eof within include file
/* 20274 */	move    | xl     << dst_ ,
/* 20275 */	stmt    | 7152   << off_ ,	//	jsr sysif   switch stream back to previous file
/* 20276 */	sys     | sysif_ << off_ ,
/* 20277 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 20278 */	ppm     ,
/* 20279 */	stmt    | 7153   << off_ ,	//	mov wa cnind  restore prev line number, file name
/* 20280 */	load    | wa     << dst_ | cnind  << off_ ,
/* 20281 */	stmt    | 7154   << off_ ,	//	add wa =vcvlb  vector offset in words
/* 20282 */	loadi   | r2     << dst_ | vcvlb  << off_ ,
/* 20283 */	add     | wa     << dst_ | r2     << src_ ,
/* 20284 */	stmt    | 7155   << off_ ,	//	wtb wa   convert to bytes
/* 20285 */	stmt    | 7156   << off_ ,	//	mov xr r_ifa  file name array
/* 20286 */	load    | xr     << dst_ | r_ifa  << off_ ,
/* 20287 */	stmt    | 7157   << off_ ,	//	add xr wa  ptr to element
/* 20288 */	add     | xr     << dst_ | wa     << src_ ,
/* 20289 */	stmt    | 7158   << off_ ,	//	mov r_sfc (xr)  change source file name
/* 20290 */	load    | r1     << dst_ | xr     << src_ ,
/* 20291 */	store   | r1     << dst_ | r_sfc  << off_ ,
/* 20292 */	stmt    | 7159   << off_ ,	//	mov (xr) =nulls  release scblk
/* 20293 */	loadi   | r1     << dst_ | nulls  << off_ ,
/* 20294 */	store   | r1     << dst_ | xr     << src_ ,
/* 20295 */	stmt    | 7160   << off_ ,	//	mov xr r_ifl  line number array
/* 20296 */	load    | xr     << dst_ | r_ifl  << off_ ,
/* 20297 */	stmt    | 7161   << off_ ,	//	add xr wa  ptr to element
/* 20298 */	add     | xr     << dst_ | wa     << src_ ,
/* 20299 */	stmt    | 7162   << off_ ,	//	mov xl (xr)  icblk containing saved line number
/* 20300 */	load    | xl     << dst_ | xr     << src_ ,
/* 20301 */	stmt    | 7163   << off_ ,	//	ldi icval(xl)   line number integer
/* 20302 */	load    | r1     << dst_ | xl     << src_ | icval  << off_ ,
/* 20303 */	ldi     | r1     << dst_ ,
/* 20304 */	stmt    | 7164   << off_ ,	//	mfi rdnln   change source line number
/* 20305 */	store   | ia     << dst_ | rdnln  << off_ ,
/* 20306 */	stmt    | 7165   << off_ ,	//	mov (xr) =inton  release icblk
/* 20307 */	loadi   | r1     << dst_ | inton  << off_ ,
/* 20308 */	store   | r1     << dst_ | xr     << src_ ,
/* 20309 */	stmt    | 7166   << off_ ,	//	dcv cnind   decrement nesting level
/* 20310 */	load    | r1     << dst_ | cnind  << off_ ,
/* 20311 */	dcv     | r1     << dst_ ,
/* 20312 */	store   | r1     << dst_ | cnind  << off_ ,
/* 20313 */	stmt    | 7167   << off_ ,	//	mov wb cmpsn  current statement number
/* 20314 */	load    | wb     << dst_ | cmpsn  << off_ ,
/* 20315 */	stmt    | 7168   << off_ ,	//	icv wb   anticipate end of previous stmt
/* 20316 */	icv     | wb     << dst_ ,
/* 20317 */	stmt    | 7169   << off_ ,	//	mti wb   convert to integer
/* 20318 */	move    | ia     << dst_ | wb     << src_ ,
/* 20319 */	stmt    | 7170   << off_ ,	//	jsr icbld   build icblk for stmt number
/* 20320 */	call    | icbld  << off_ ,
/* 20321 */	stmt    | 7171   << off_ ,	//	mov xl r_sfn  file name table
/* 20322 */	load    | xl     << dst_ | r_sfn  << off_ ,
/* 20323 */	stmt    | 7172   << off_ ,	//	mnz wb   lookup statement number by name
/* 20324 */	move    | wb     << dst_ | xs     << src_ ,
/* 20325 */	stmt    | 7173   << off_ ,	//	jsr tfind   allocate new teblk
/* 20326 */	call    | tfind  << off_ ,
/* 20327 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 20328 */	ppm     ,
/* 20329 */	stmt    | 7174   << off_ ,	//	mov teval(xl) r_sfc  record file name as entry value
/* 20330 */	load    | r1     << dst_ | r_sfc  << off_ ,
/* 20331 */	store   | r1     << dst_ | xl     << src_ | teval  << off_ ,
/* 20332 */	stmt    | 7175   << off_ ,	//	beq stage =stgic reada if initial compile, reissue read
/* 20333 */	load    | r1     << dst_ | stage  << off_ ,
/* 20334 */	loadi   | r2     << dst_ | stgic  << off_ ,
/* 20335 */	beq     | r1     << dst_ | r2     << src_ | reada  << off_ ,
/* 20336 */	stmt    | 7176   << off_ ,	//	bnz cnind reada  still reading from include file
/* 20337 */	load    | r1     << dst_ | cnind  << off_ ,
/* 20338 */	bnz     | r1     << dst_ | reada  << off_ ,
/* 20339 */	stmt    | 7177   << off_ ,	//	mov xl r_ici  restore code argument string
/* 20340 */	load    | xl     << dst_ | r_ici  << off_ ,
/* 20341 */	stmt    | 7178   << off_ ,	//	zer r_ici   release original string
/* 20342 */	store   | r0     << dst_ | r_ici  << off_ ,
/* 20343 */	stmt    | 7179   << off_ ,	//	mov wa cnsil  get length of string
/* 20344 */	load    | wa     << dst_ | cnsil  << off_ ,
/* 20345 */	stmt    | 7180   << off_ ,	//	mov wb cnspt  offset of characters left
/* 20346 */	load    | wb     << dst_ | cnspt  << off_ ,
/* 20347 */	stmt    | 7181   << off_ ,	//	sub wa wb  number of characters left
/* 20348 */	sub     | wa     << dst_ | wb     << src_ ,
/* 20349 */	stmt    | 7182   << off_ ,	//	mov scnil wa  set new scan length
/* 20350 */	store   | wa     << dst_ | scnil  << off_ ,
/* 20351 */	stmt    | 7183   << off_ ,	//	zer scnpt   scan from start of substring
/* 20352 */	store   | r0     << dst_ | scnpt  << off_ ,
/* 20353 */	stmt    | 7184   << off_ ,	//	jsr sbstr   create substring of remainder
/* 20354 */	call    | sbstr  << off_ ,
/* 20355 */	stmt    | 7185   << off_ ,	//	mov r_cim xr  set scan image
/* 20356 */	store   | xr     << dst_ | r_cim  << off_ ,
/* 20357 */	stmt    | 7186   << off_ ,	//	brn read2   return
/* 20358 */	brn     | read2  << off_ ,
// read6:
/* 20359 */	stmt    | 7187   << off_ ,	//read6	zer xr   zero ptr as result
/* 20360 */	move    | xr     << dst_ ,
/* 20361 */	stmt    | 7188   << off_ ,	//	brn read2   merge
/* 20362 */	brn     | read2  << off_ ,
// sbstr:
/* 20363 */	stmt    | 7189   << off_ ,	//sbstr	prc e 0  entry point
/* 20364 */	stmt    | 7190   << off_ ,	//	bze wa sbst2  jump if null substring
/* 20365 */	bze     | wa     << dst_ | sbst2  << off_ ,
/* 20366 */	stmt    | 7191   << off_ ,	//	jsr alocs   else allocate scblk
/* 20367 */	call    | alocs  << off_ ,
/* 20368 */	stmt    | 7192   << off_ ,	//	mov wa wc  move number of characters
/* 20369 */	move    | wa     << dst_ | wc     << src_ ,
/* 20370 */	stmt    | 7193   << off_ ,	//	mov wc xr  save ptr to new scblk
/* 20371 */	move    | wc     << dst_ | xr     << src_ ,
/* 20372 */	stmt    | 7194   << off_ ,	//	plc xl wb  prepare to load chars from old blk
/* 20373 */	plc     | xl     << dst_ | wb     << src_ ,
/* 20374 */	stmt    | 7195   << off_ ,	//	psc xr   prepare to store chars in new blk
/* 20375 */	psc     | xr     << dst_ ,
/* 20376 */	stmt    | 7196   << off_ ,	//	mvc    move characters to new string
/* 20377 */	mvc     ,
/* 20378 */	stmt    | 7197   << off_ ,	//	mov xr wc  then restore scblk pointer
/* 20379 */	move    | xr     << dst_ | wc     << src_ ,
// sbst1:
/* 20380 */	stmt    | 7198   << off_ ,	//sbst1	zer xl   clear garbage pointer in xl
/* 20381 */	move    | xl     << dst_ ,
/* 20382 */	stmt    | 7199   << off_ ,	//	exi    return to sbstr caller
/* 20383 */	exi     | 0      << off_ ,
// sbst2:
/* 20384 */	stmt    | 7200   << off_ ,	//sbst2	mov xr =nulls  set null string as result
/* 20385 */	loadi   | xr     << dst_ | nulls  << off_ ,
/* 20386 */	stmt    | 7201   << off_ ,	//	brn sbst1   return
/* 20387 */	brn     | sbst1  << off_ ,
// stgcc:
/* 20388 */	stmt    | 7202   << off_ ,	//stgcc	prc e 0
/* 20389 */	stmt    | 7203   << off_ ,	//	mov wa polcs  assume no profiling or stcount tracing
/* 20390 */	load    | wa     << dst_ | polcs  << off_ ,
/* 20391 */	stmt    | 7204   << off_ ,	//	mov wb =num01  poll each time polcs expires
/* 20392 */	loadi   | wb     << dst_ | num01  << off_ ,
/* 20393 */	stmt    | 7205   << off_ ,	//	ldi kvstl   get stmt limit
/* 20394 */	load    | r1     << dst_ | kvstl  << off_ ,
/* 20395 */	ldi     | r1     << dst_ ,
/* 20396 */	stmt    | 7206   << off_ ,	//	bnz kvpfl stgc1  jump if profiling enabled
/* 20397 */	load    | r1     << dst_ | kvpfl  << off_ ,
/* 20398 */	bnz     | r1     << dst_ | stgc1  << off_ ,
/* 20399 */	stmt    | 7207   << off_ ,	//	ilt stgc3   no stcount tracing if negative
/* 20400 */	ilt     | stgc3  << off_ ,
/* 20401 */	stmt    | 7208   << off_ ,	//	bze r_stc stgc2  jump if not stcount tracing
/* 20402 */	load    | r1     << dst_ | r_stc  << off_ ,
/* 20403 */	bze     | r1     << dst_ | stgc2  << off_ ,
// stgc1:
/* 20404 */	stmt    | 7209   << off_ ,	//stgc1	mov wb wa  count polcs times within stmg
/* 20405 */	move    | wb     << dst_ | wa     << src_ ,
/* 20406 */	stmt    | 7210   << off_ ,	//	mov wa =num01  break out of stmgo on each stmt
/* 20407 */	loadi   | wa     << dst_ | num01  << off_ ,
/* 20408 */	stmt    | 7211   << off_ ,	//	brn stgc3
/* 20409 */	brn     | stgc3  << off_ ,
// stgc2:
/* 20410 */	stmt    | 7212   << off_ ,	//stgc2	mti wa   breakout count start value
/* 20411 */	move    | ia     << dst_ | wa     << src_ ,
/* 20412 */	stmt    | 7213   << off_ ,	//	sbi kvstl   proposed stmcs minus stmt limit
/* 20413 */	load    | r1     << dst_ | kvstl  << off_ ,
/* 20414 */	sbi     | r1     << dst_ ,
/* 20415 */	stmt    | 7214   << off_ ,	//	ile stgc3   jump if stmt count does not limit
/* 20416 */	ile     | stgc3  << off_ ,
/* 20417 */	stmt    | 7215   << off_ ,	//	ldi kvstl   stlimit limits breakcount count
/* 20418 */	load    | r1     << dst_ | kvstl  << off_ ,
/* 20419 */	ldi     | r1     << dst_ ,
/* 20420 */	stmt    | 7216   << off_ ,	//	mfi wa   use it instead
/* 20421 */	move    | wa     << dst_ | ia     << src_ ,
// stgc3:
/* 20422 */	stmt    | 7217   << off_ ,	//stgc3	mov stmcs wa  update breakout count start value
/* 20423 */	store   | wa     << dst_ | stmcs  << off_ ,
/* 20424 */	stmt    | 7218   << off_ ,	//	mov stmct wa  reset breakout counter
/* 20425 */	store   | wa     << dst_ | stmct  << off_ ,
/* 20426 */	stmt    | 7219   << off_ ,	//	mov polct wb
/* 20427 */	store   | wb     << dst_ | polct  << off_ ,
/* 20428 */	stmt    | 7220   << off_ ,	//	exi
/* 20429 */	exi     | 0      << off_ ,
// tfind:
/* 20430 */	stmt    | 7221   << off_ ,	//tfind	prc e 1  entry point
/* 20431 */	stmt    | 7222   << off_ ,	//	mov -(xs) wb  save name/value indicator
/* 20432 */	dca     | xs     << dst_ ,
/* 20433 */	store   | wb     << dst_ | xs     << src_ ,
/* 20434 */	stmt    | 7223   << off_ ,	//	mov -(xs) xr  save subscript value
/* 20435 */	dca     | xs     << dst_ ,
/* 20436 */	store   | xr     << dst_ | xs     << src_ ,
/* 20437 */	stmt    | 7224   << off_ ,	//	mov -(xs) xl  save table pointer
/* 20438 */	dca     | xs     << dst_ ,
/* 20439 */	store   | xl     << dst_ | xs     << src_ ,
/* 20440 */	stmt    | 7225   << off_ ,	//	mov wa tblen(xl)  load length of tbblk
/* 20441 */	load    | wa     << dst_ | xl     << src_ | tblen  << off_ ,
/* 20442 */	stmt    | 7226   << off_ ,	//	btw wa   convert to word count
/* 20443 */	stmt    | 7227   << off_ ,	//	sub wa =tbbuk  get number of buckets
/* 20444 */	loadi   | r2     << dst_ | tbbuk  << off_ ,
/* 20445 */	sub     | wa     << dst_ | r2     << src_ ,
/* 20446 */	stmt    | 7228   << off_ ,	//	mti wa   convert to integer value
/* 20447 */	move    | ia     << dst_ | wa     << src_ ,
/* 20448 */	stmt    | 7229   << off_ ,	//	sti tfnsi   save for later
/* 20449 */	store   | ia     << dst_ | tfnsi  << off_ ,
/* 20450 */	stmt    | 7230   << off_ ,	//	mov xl (xr)  load first word of subscript
/* 20451 */	load    | xl     << dst_ | xr     << src_ ,
/* 20452 */	stmt    | 7231   << off_ ,	//	lei xl   load block entry id (bl_xx)
/* 20453 */	lei     | xl     << dst_ ,
/* 20454 */	stmt    | 7232   << off_ ,	//	bsw xl bl__d tfn00 switch on block type
/* 20455 */	loadi   | r1     << dst_ | bl__d  << off_ ,
/* 20456 */	bsw     | xl     << dst_ | r1     << src_ | tfn00  << off_ ,
/* 20457 */	tfn00   ,
/* 20458 */	tfn00   ,
/* 20459 */	tfn00   ,
/* 20460 */	tfn02   ,
/* 20461 */	tfn04   ,
/* 20462 */	tfn03   ,
/* 20463 */	tfn03   ,
/* 20464 */	tfn03   ,
/* 20465 */	tfn02   ,
/* 20466 */	tfn05   ,
/* 20467 */	tfn00   ,
/* 20468 */	tfn00   ,
/* 20469 */	tfn00   ,
/* 20470 */	tfn00   ,
/* 20471 */	tfn00   ,
/* 20472 */	tfn00   ,
/* 20473 */	tfn00   ,
// tfn00:
/* 20474 */	stmt    | 7233   << off_ ,	//tfn00	mov wa 1(xr)  load second word
/* 20475 */	load    | wa     << dst_ | xr     << src_ | 1      << off_ ,
// tfn01:
/* 20476 */	stmt    | 7234   << off_ ,	//tfn01	mti wa   convert to integer
/* 20477 */	move    | ia     << dst_ | wa     << src_ ,
/* 20478 */	stmt    | 7235   << off_ ,	//	brn tfn06   jump to merge
/* 20479 */	brn     | tfn06  << off_ ,
// tfn02:
/* 20480 */	stmt    | 7236   << off_ ,	//tfn02	ldi 1(xr)   load value as hash source
/* 20481 */	load    | r1     << dst_ | xr     << src_ | 1      << off_ ,
/* 20482 */	ldi     | r1     << dst_ ,
/* 20483 */	stmt    | 7237   << off_ ,	//	ige tfn06   ok if positive or zero
/* 20484 */	ige     | tfn06  << off_ ,
/* 20485 */	stmt    | 7238   << off_ ,	//	ngi    make positive
/* 20486 */	ngi     ,
/* 20487 */	stmt    | 7239   << off_ ,	//	iov tfn06   clear possible overflow
/* 20488 */	iov     | tfn06  << off_ ,
/* 20489 */	stmt    | 7240   << off_ ,	//	brn tfn06   merge
/* 20490 */	brn     | tfn06  << off_ ,
// tfn03:
/* 20491 */	stmt    | 7241   << off_ ,	//tfn03	mov wa (xr)  load first word as hash source
/* 20492 */	load    | wa     << dst_ | xr     << src_ ,
/* 20493 */	stmt    | 7242   << off_ ,	//	brn tfn01   merge back
/* 20494 */	brn     | tfn01  << off_ ,
// tfn04:
/* 20495 */	stmt    | 7243   << off_ ,	//tfn04	mov wa nmofs(xr)  load offset as hash source
/* 20496 */	load    | wa     << dst_ | xr     << src_ | nmofs  << off_ ,
/* 20497 */	stmt    | 7244   << off_ ,	//	brn tfn01   merge back
/* 20498 */	brn     | tfn01  << off_ ,
// tfn05:
/* 20499 */	stmt    | 7245   << off_ ,	//tfn05	jsr hashs   call routine to compute hash
/* 20500 */	call    | hashs  << off_ ,
// tfn06:
/* 20501 */	stmt    | 7246   << off_ ,	//tfn06	rmi tfnsi   compute hash index by remaindering
/* 20502 */	load    | r1     << dst_ | tfnsi  << off_ ,
/* 20503 */	rmi     | r1     << dst_ ,
/* 20504 */	stmt    | 7247   << off_ ,	//	mfi wc   get as one word integer
/* 20505 */	move    | wc     << dst_ | ia     << src_ ,
/* 20506 */	stmt    | 7248   << off_ ,	//	wtb wc   convert to byte offset
/* 20507 */	stmt    | 7249   << off_ ,	//	mov xl (xs)  get table ptr again
/* 20508 */	load    | xl     << dst_ | xs     << src_ ,
/* 20509 */	stmt    | 7250   << off_ ,	//	add xl wc  point to proper bucket
/* 20510 */	add     | xl     << dst_ | wc     << src_ ,
/* 20511 */	stmt    | 7251   << off_ ,	//	mov xr tbbuk(xl)  load first teblk pointer
/* 20512 */	load    | xr     << dst_ | xl     << src_ | tbbuk  << off_ ,
/* 20513 */	stmt    | 7252   << off_ ,	//	beq xr (xs) tfn10 jump if no teblks on chain
/* 20514 */	load    | r2     << dst_ | xs     << src_ ,
/* 20515 */	beq     | xr     << dst_ | r2     << src_ | tfn10  << off_ ,
// tfn07:
/* 20516 */	stmt    | 7253   << off_ ,	//tfn07	mov wb xr  save teblk pointer
/* 20517 */	move    | wb     << dst_ | xr     << src_ ,
/* 20518 */	stmt    | 7254   << off_ ,	//	mov xr tesub(xr)  load subscript value
/* 20519 */	load    | xr     << dst_ | xr     << src_ | tesub  << off_ ,
/* 20520 */	stmt    | 7255   << off_ ,	//	mov xl 1(xs)  load input argument subscript val
/* 20521 */	load    | xl     << dst_ | xs     << src_ | 1      << off_ ,
/* 20522 */	stmt    | 7256   << off_ ,	//	jsr ident   compare them
/* 20523 */	call    | ident  << off_ ,
/* 20524 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 20525 */	ppm     | tfn08  << off_ ,
/* 20526 */	stmt    | 7257   << off_ ,	//	mov xl wb  restore teblk pointer
/* 20527 */	move    | xl     << dst_ | wb     << src_ ,
/* 20528 */	stmt    | 7258   << off_ ,	//	mov xr tenxt(xl)  point to next teblk on chain
/* 20529 */	load    | xr     << dst_ | xl     << src_ | tenxt  << off_ ,
/* 20530 */	stmt    | 7259   << off_ ,	//	bne xr (xs) tfn07 jump if there is one
/* 20531 */	load    | r2     << dst_ | xs     << src_ ,
/* 20532 */	bne     | xr     << dst_ | r2     << src_ | tfn07  << off_ ,
/* 20533 */	stmt    | 7260   << off_ ,	//	mov wc *tenxt  set offset to link field (xl base)
/* 20534 */	loadi   | wc     << dst_ | tenxt  << off_ ,
/* 20535 */	stmt    | 7261   << off_ ,	//	brn tfn11   jump to merge
/* 20536 */	brn     | tfn11  << off_ ,
// tfn08:
/* 20537 */	stmt    | 7262   << off_ ,	//tfn08	mov xl wb  restore teblk pointer
/* 20538 */	move    | xl     << dst_ | wb     << src_ ,
/* 20539 */	stmt    | 7263   << off_ ,	//	mov wa *teval  set teblk name offset
/* 20540 */	loadi   | wa     << dst_ | teval  << off_ ,
/* 20541 */	stmt    | 7264   << off_ ,	//	mov wb 2(xs)  restore name/value indicator
/* 20542 */	load    | wb     << dst_ | xs     << src_ | 2      << off_ ,
/* 20543 */	stmt    | 7265   << off_ ,	//	bnz wb tfn09  jump if called by name
/* 20544 */	bnz     | wb     << dst_ | tfn09  << off_ ,
/* 20545 */	stmt    | 7266   << off_ ,	//	jsr acess   else get value
/* 20546 */	call    | acess  << off_ ,
/* 20547 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 20548 */	ppm     | tfn12  << off_ ,
/* 20549 */	stmt    | 7267   << off_ ,	//	zer wb   restore name/value indicator
/* 20550 */	move    | wb     << dst_ ,
// tfn09:
/* 20551 */	stmt    | 7268   << off_ ,	//tfn09	add xs *num03  pop stack entries
/* 20552 */	loadi   | r2     << dst_ | num03  << off_ ,
/* 20553 */	add     | xs     << dst_ | r2     << src_ ,
/* 20554 */	stmt    | 7269   << off_ ,	//	exi    return to tfind caller
/* 20555 */	exi     | 0      << off_ ,
// tfn10:
/* 20556 */	stmt    | 7270   << off_ ,	//tfn10	add wc *tbbuk  get offset to bucket ptr
/* 20557 */	loadi   | r2     << dst_ | tbbuk  << off_ ,
/* 20558 */	add     | wc     << dst_ | r2     << src_ ,
/* 20559 */	stmt    | 7271   << off_ ,	//	mov xl (xs)  set tbblk ptr as base
/* 20560 */	load    | xl     << dst_ | xs     << src_ ,
// tfn11:
/* 20561 */	stmt    | 7272   << off_ ,	//tfn11	mov xr (xs)  tbblk pointer
/* 20562 */	load    | xr     << dst_ | xs     << src_ ,
/* 20563 */	stmt    | 7273   << off_ ,	//	mov xr tbinv(xr)  load default value in case
/* 20564 */	load    | xr     << dst_ | xr     << src_ | tbinv  << off_ ,
/* 20565 */	stmt    | 7274   << off_ ,	//	mov wb 2(xs)  load name/value indicator
/* 20566 */	load    | wb     << dst_ | xs     << src_ | 2      << off_ ,
/* 20567 */	stmt    | 7275   << off_ ,	//	bze wb tfn09  exit with default if value call
/* 20568 */	bze     | wb     << dst_ | tfn09  << off_ ,
/* 20569 */	stmt    | 7276   << off_ ,	//	mov wb xr  copy default value
/* 20570 */	move    | wb     << dst_ | xr     << src_ ,
/* 20571 */	stmt    | 7277   << off_ ,	//	mov wa *tesi_  set size of teblk
/* 20572 */	loadi   | wa     << dst_ | tesi_  << off_ ,
/* 20573 */	stmt    | 7278   << off_ ,	//	jsr alloc   allocate teblk
/* 20574 */	call    | alloc  << off_ ,
/* 20575 */	stmt    | 7279   << off_ ,	//	add xl wc  point to hash link
/* 20576 */	add     | xl     << dst_ | wc     << src_ ,
/* 20577 */	stmt    | 7280   << off_ ,	//	mov (xl) xr  link new teblk at end of chain
/* 20578 */	store   | xr     << dst_ | xl     << src_ ,
/* 20579 */	stmt    | 7281   << off_ ,	//	mov (xr) =b_tet  store type word
/* 20580 */	loadi   | r1     << dst_ | b_tet  << off_ ,
/* 20581 */	store   | r1     << dst_ | xr     << src_ ,
/* 20582 */	stmt    | 7282   << off_ ,	//	mov teval(xr) wb  set default as initial value
/* 20583 */	store   | wb     << dst_ | xr     << src_ | teval  << off_ ,
/* 20584 */	stmt    | 7283   << off_ ,	//	mov tenxt(xr) (xs)+  set tbblk ptr to mark end of chain
/* 20585 */	load    | r1     << dst_ | xs     << src_ ,
/* 20586 */	ica     | xs     << dst_ ,
/* 20587 */	store   | r1     << dst_ | xr     << src_ | tenxt  << off_ ,
/* 20588 */	stmt    | 7284   << off_ ,	//	mov tesub(xr) (xs)+  store subscript value
/* 20589 */	load    | r1     << dst_ | xs     << src_ ,
/* 20590 */	ica     | xs     << dst_ ,
/* 20591 */	store   | r1     << dst_ | xr     << src_ | tesub  << off_ ,
/* 20592 */	stmt    | 7285   << off_ ,	//	mov wb (xs)+  restore name/value indicator
/* 20593 */	load    | wb     << dst_ | xs     << src_ ,
/* 20594 */	ica     | xs     << dst_ ,
/* 20595 */	stmt    | 7286   << off_ ,	//	mov xl xr  copy teblk pointer (name base)
/* 20596 */	move    | xl     << dst_ | xr     << src_ ,
/* 20597 */	stmt    | 7287   << off_ ,	//	mov wa *teval  set offset
/* 20598 */	loadi   | wa     << dst_ | teval  << off_ ,
/* 20599 */	stmt    | 7288   << off_ ,	//	exi    return to caller with new teblk
/* 20600 */	exi     | 0      << off_ ,
// tfn12:
/* 20601 */	stmt    | 7289   << off_ ,	//tfn12	exi 1   alternative return
/* 20602 */	exi     | 1      << off_ ,
// tmake:
/* 20603 */	stmt    | 7290   << off_ ,	//tmake	prc e 0
/* 20604 */	stmt    | 7291   << off_ ,	//	mov wa wc  copy number of headers
/* 20605 */	move    | wa     << dst_ | wc     << src_ ,
/* 20606 */	stmt    | 7292   << off_ ,	//	add wa =tbsi_  adjust for standard fields
/* 20607 */	loadi   | r2     << dst_ | tbsi_  << off_ ,
/* 20608 */	add     | wa     << dst_ | r2     << src_ ,
/* 20609 */	stmt    | 7293   << off_ ,	//	wtb wa   convert length to bytes
/* 20610 */	stmt    | 7294   << off_ ,	//	jsr alloc   allocate space for tbblk
/* 20611 */	call    | alloc  << off_ ,
/* 20612 */	stmt    | 7295   << off_ ,	//	mov wb xr  copy pointer to tbblk
/* 20613 */	move    | wb     << dst_ | xr     << src_ ,
/* 20614 */	stmt    | 7296   << off_ ,	//	mov (xr)+ =b_tbt  store type word
/* 20615 */	loadi   | r1     << dst_ | b_tbt  << off_ ,
/* 20616 */	store   | r1     << dst_ | xr     << src_ ,
/* 20617 */	ica     | xr     << dst_ ,
/* 20618 */	stmt    | 7297   << off_ ,	//	zer (xr)+   zero id for the moment
/* 20619 */	store   | r0     << dst_ | xr     << src_ ,
/* 20620 */	ica     | xr     << dst_ ,
/* 20621 */	stmt    | 7298   << off_ ,	//	mov (xr)+ wa  store length (tblen)
/* 20622 */	store   | wa     << dst_ | xr     << src_ ,
/* 20623 */	ica     | xr     << dst_ ,
/* 20624 */	stmt    | 7299   << off_ ,	//	mov (xr)+ xl  store initial lookup value
/* 20625 */	store   | xl     << dst_ | xr     << src_ ,
/* 20626 */	ica     | xr     << dst_ ,
/* 20627 */	stmt    | 7300   << off_ ,	//	lct wc wc  set loop counter (num headers)
// tma01:
/* 20628 */	stmt    | 7301   << off_ ,	//tma01	mov (xr)+ wb  store tbblk ptr in bucket header
/* 20629 */	store   | wb     << dst_ | xr     << src_ ,
/* 20630 */	ica     | xr     << dst_ ,
/* 20631 */	stmt    | 7302   << off_ ,	//	bct wc tma01  loop till all stored
/* 20632 */	bct     | wc     << dst_ | tma01  << off_ ,
/* 20633 */	stmt    | 7303   << off_ ,	//	mov xr wb  recall pointer to tbblk
/* 20634 */	move    | xr     << dst_ | wb     << src_ ,
/* 20635 */	stmt    | 7304   << off_ ,	//	exi
/* 20636 */	exi     | 0      << off_ ,
// vmake:
/* 20637 */	stmt    | 7305   << off_ ,	//vmake	prc e 1  entry point
/* 20638 */	stmt    | 7306   << off_ ,	//	lct wb wa  copy elements for loop later on
/* 20639 */	move    | wb     << dst_ | wa     << src_ ,
/* 20640 */	stmt    | 7307   << off_ ,	//	add wa =vcsi_  add space for standard fields
/* 20641 */	loadi   | r2     << dst_ | vcsi_  << off_ ,
/* 20642 */	add     | wa     << dst_ | r2     << src_ ,
/* 20643 */	stmt    | 7308   << off_ ,	//	wtb wa   convert length to bytes
/* 20644 */	stmt    | 7309   << off_ ,	//	bgt wa mxlen vmak2 fail if too large
/* 20645 */	load    | r2     << dst_ | mxlen  << off_ ,
/* 20646 */	bgt     | wa     << dst_ | r2     << src_ | vmak2  << off_ ,
/* 20647 */	stmt    | 7310   << off_ ,	//	jsr alloc   allocate space for vcblk
/* 20648 */	call    | alloc  << off_ ,
/* 20649 */	stmt    | 7311   << off_ ,	//	mov (xr) =b_vct  store type word
/* 20650 */	loadi   | r1     << dst_ | b_vct  << off_ ,
/* 20651 */	store   | r1     << dst_ | xr     << src_ ,
/* 20652 */	stmt    | 7312   << off_ ,	//	zer idval(xr)   initialize idval
/* 20653 */	store   | r0     << dst_ | xr     << src_ | idval  << off_ ,
/* 20654 */	stmt    | 7313   << off_ ,	//	mov vclen(xr) wa  set length
/* 20655 */	store   | wa     << dst_ | xr     << src_ | vclen  << off_ ,
/* 20656 */	stmt    | 7314   << off_ ,	//	mov wc xl  copy default value
/* 20657 */	move    | wc     << dst_ | xl     << src_ ,
/* 20658 */	stmt    | 7315   << off_ ,	//	mov xl xr  copy vcblk pointer
/* 20659 */	move    | xl     << dst_ | xr     << src_ ,
/* 20660 */	stmt    | 7316   << off_ ,	//	add xl *vcvls  point to first element value
/* 20661 */	loadi   | r2     << dst_ | vcvls  << off_ ,
/* 20662 */	add     | xl     << dst_ | r2     << src_ ,
// vmak1:
/* 20663 */	stmt    | 7317   << off_ ,	//vmak1	mov (xl)+ wc  store one value
/* 20664 */	store   | wc     << dst_ | xl     << src_ ,
/* 20665 */	ica     | xl     << dst_ ,
/* 20666 */	stmt    | 7318   << off_ ,	//	bct wb vmak1  loop till all stored
/* 20667 */	bct     | wb     << dst_ | vmak1  << off_ ,
/* 20668 */	stmt    | 7319   << off_ ,	//	exi    success return
/* 20669 */	exi     | 0      << off_ ,
// vmak2:
/* 20670 */	stmt    | 7320   << off_ ,	//vmak2	exi 1   fail return
/* 20671 */	exi     | 1      << off_ ,
// scane:
/* 20672 */	stmt    | 7321   << off_ ,	//scane	prc e 0  entry point
/* 20673 */	stmt    | 7322   << off_ ,	//	zer scnbl   reset blanks flag
/* 20674 */	store   | r0     << dst_ | scnbl  << off_ ,
/* 20675 */	stmt    | 7323   << off_ ,	//	mov scnsa wa  save wa
/* 20676 */	store   | wa     << dst_ | scnsa  << off_ ,
/* 20677 */	stmt    | 7324   << off_ ,	//	mov scnsb wb  save wb
/* 20678 */	store   | wb     << dst_ | scnsb  << off_ ,
/* 20679 */	stmt    | 7325   << off_ ,	//	mov scnsc wc  save wc
/* 20680 */	store   | wc     << dst_ | scnsc  << off_ ,
/* 20681 */	stmt    | 7326   << off_ ,	//	bze scnrs scn03  jump if no rescan
/* 20682 */	load    | r1     << dst_ | scnrs  << off_ ,
/* 20683 */	bze     | r1     << dst_ | scn03  << off_ ,
/* 20684 */	stmt    | 7327   << off_ ,	//	mov xl scntp  set previous returned scan type
/* 20685 */	load    | xl     << dst_ | scntp  << off_ ,
/* 20686 */	stmt    | 7328   << off_ ,	//	mov xr r_scp  set previous returned pointer
/* 20687 */	load    | xr     << dst_ | r_scp  << off_ ,
/* 20688 */	stmt    | 7329   << off_ ,	//	zer scnrs   reset rescan switch
/* 20689 */	store   | r0     << dst_ | scnrs  << off_ ,
/* 20690 */	stmt    | 7330   << off_ ,	//	brn scn13   jump to exit
/* 20691 */	brn     | scn13  << off_ ,
// scn01:
/* 20692 */	stmt    | 7331   << off_ ,	//scn01	jsr readr   read next image
/* 20693 */	call    | readr  << off_ ,
/* 20694 */	stmt    | 7332   << off_ ,	//	mov wb *dvubs  set wb for not reading name
/* 20695 */	loadi   | wb     << dst_ | dvubs  << off_ ,
/* 20696 */	stmt    | 7333   << off_ ,	//	bze xr scn30  treat as semi-colon if none
/* 20697 */	bze     | xr     << dst_ | scn30  << off_ ,
/* 20698 */	stmt    | 7334   << off_ ,	//	plc xr   else point to first character
/* 20699 */	plc     | xr     << dst_ ,
/* 20700 */	stmt    | 7335   << off_ ,	//	lch wc (xr)  load first character
/* 20701 */	load    | wc     << dst_ | xr     << src_ ,
/* 20702 */	stmt    | 7336   << off_ ,	//	beq wc =ch_dt scn02 jump if dot for continuation
/* 20703 */	loadi   | r2     << dst_ | ch_dt  << off_ ,
/* 20704 */	beq     | wc     << dst_ | r2     << src_ | scn02  << off_ ,
/* 20705 */	stmt    | 7337   << off_ ,	//	bne wc =ch_pl scn30 else treat as semicolon unless plus
/* 20706 */	loadi   | r2     << dst_ | ch_pl  << off_ ,
/* 20707 */	bne     | wc     << dst_ | r2     << src_ | scn30  << off_ ,
// scn02:
/* 20708 */	stmt    | 7338   << off_ ,	//scn02	jsr nexts   acquire next source image
/* 20709 */	call    | nexts  << off_ ,
/* 20710 */	stmt    | 7339   << off_ ,	//	mov scnpt =num01  set scan pointer past continuation
/* 20711 */	loadi   | r1     << dst_ | num01  << off_ ,
/* 20712 */	store   | r1     << dst_ | scnpt  << off_ ,
/* 20713 */	stmt    | 7340   << off_ ,	//	mnz scnbl   set blanks flag
/* 20714 */	store   | xs     << dst_ | scnbl  << off_ ,
// scn03:
/* 20715 */	stmt    | 7341   << off_ ,	//scn03	mov wa scnpt  load current offset
/* 20716 */	load    | wa     << dst_ | scnpt  << off_ ,
/* 20717 */	stmt    | 7342   << off_ ,	//	beq wa scnil scn01 check continuation if end
/* 20718 */	load    | r2     << dst_ | scnil  << off_ ,
/* 20719 */	beq     | wa     << dst_ | r2     << src_ | scn01  << off_ ,
/* 20720 */	stmt    | 7343   << off_ ,	//	mov xl r_cim  point to current line
/* 20721 */	load    | xl     << dst_ | r_cim  << off_ ,
/* 20722 */	stmt    | 7344   << off_ ,	//	plc xl wa  point to current character
/* 20723 */	plc     | xl     << dst_ | wa     << src_ ,
/* 20724 */	stmt    | 7345   << off_ ,	//	mov scnse wa  set start of element location
/* 20725 */	store   | wa     << dst_ | scnse  << off_ ,
/* 20726 */	stmt    | 7346   << off_ ,	//	mov wc =opdvs  point to operator dv list
/* 20727 */	loadi   | wc     << dst_ | opdvs  << off_ ,
/* 20728 */	stmt    | 7347   << off_ ,	//	mov wb *dvubs  set constant for operator circuit
/* 20729 */	loadi   | wb     << dst_ | dvubs  << off_ ,
/* 20730 */	stmt    | 7348   << off_ ,	//	brn scn06   start scanning
/* 20731 */	brn     | scn06  << off_ ,
// scn05:
/* 20732 */	stmt    | 7349   << off_ ,	//scn05	bze wb scn10  jump if trailing
/* 20733 */	bze     | wb     << dst_ | scn10  << off_ ,
/* 20734 */	stmt    | 7350   << off_ ,	//	icv scnse   increment start of element
/* 20735 */	load    | r1     << dst_ | scnse  << off_ ,
/* 20736 */	icv     | r1     << dst_ ,
/* 20737 */	store   | r1     << dst_ | scnse  << off_ ,
/* 20738 */	stmt    | 7351   << off_ ,	//	beq wa scnil scn01 jump if end of image
/* 20739 */	load    | r2     << dst_ | scnil  << off_ ,
/* 20740 */	beq     | wa     << dst_ | r2     << src_ | scn01  << off_ ,
/* 20741 */	stmt    | 7352   << off_ ,	//	mnz scnbl   note blanks seen
/* 20742 */	store   | xs     << dst_ | scnbl  << off_ ,
// scn06:
/* 20743 */	stmt    | 7353   << off_ ,	//scn06	lch xr (xl)+  get next character
/* 20744 */	load    | xr     << dst_ | xl     << src_ ,
/* 20745 */	ica     | xl     << dst_ ,
/* 20746 */	stmt    | 7354   << off_ ,	//	icv wa   bump scan offset
/* 20747 */	icv     | wa     << dst_ ,
/* 20748 */	stmt    | 7355   << off_ ,	//	mov scnpt wa  store offset past char scanned
/* 20749 */	store   | wa     << dst_ | scnpt  << off_ ,
/* 20750 */	stmt    | 7356   << off_ ,	//	bsw xr cfp_u scn07 switch on scanned character
/* 20751 */	loadi   | r1     << dst_ | cfp_u  << off_ ,
/* 20752 */	bsw     | xr     << dst_ | r1     << src_ | scn07  << off_ ,
/* 20753 */	scn07   ,
/* 20754 */	scn07   ,
/* 20755 */	scn07   ,
/* 20756 */	scn07   ,
/* 20757 */	scn07   ,
/* 20758 */	scn07   ,
/* 20759 */	scn07   ,
/* 20760 */	scn07   ,
/* 20761 */	scn07   ,
/* 20762 */	scn05   ,
/* 20763 */	scn07   ,
/* 20764 */	scn07   ,
/* 20765 */	scn07   ,
/* 20766 */	scn07   ,
/* 20767 */	scn07   ,
/* 20768 */	scn07   ,
/* 20769 */	scn07   ,
/* 20770 */	scn07   ,
/* 20771 */	scn07   ,
/* 20772 */	scn07   ,
/* 20773 */	scn07   ,
/* 20774 */	scn07   ,
/* 20775 */	scn07   ,
/* 20776 */	scn07   ,
/* 20777 */	scn07   ,
/* 20778 */	scn07   ,
/* 20779 */	scn07   ,
/* 20780 */	scn07   ,
/* 20781 */	scn07   ,
/* 20782 */	scn07   ,
/* 20783 */	scn07   ,
/* 20784 */	scn07   ,
/* 20785 */	scn05   ,
/* 20786 */	scn37   ,
/* 20787 */	scn17   ,
/* 20788 */	scn41   ,
/* 20789 */	scn36   ,
/* 20790 */	scn07   ,
/* 20791 */	scn44   ,
/* 20792 */	scn16   ,
/* 20793 */	scn25   ,
/* 20794 */	scn26   ,
/* 20795 */	scn49   ,
/* 20796 */	scn33   ,
/* 20797 */	scn31   ,
/* 20798 */	scn34   ,
/* 20799 */	scn32   ,
/* 20800 */	scn40   ,
/* 20801 */	scn08   ,
/* 20802 */	scn08   ,
/* 20803 */	scn08   ,
/* 20804 */	scn08   ,
/* 20805 */	scn08   ,
/* 20806 */	scn08   ,
/* 20807 */	scn08   ,
/* 20808 */	scn08   ,
/* 20809 */	scn08   ,
/* 20810 */	scn08   ,
/* 20811 */	scn29   ,
/* 20812 */	scn30   ,
/* 20813 */	scn28   ,
/* 20814 */	scn46   ,
/* 20815 */	scn27   ,
/* 20816 */	scn45   ,
/* 20817 */	scn42   ,
/* 20818 */	scn09   ,
/* 20819 */	scn09   ,
/* 20820 */	scn09   ,
/* 20821 */	scn09   ,
/* 20822 */	scn09   ,
/* 20823 */	scn20   ,
/* 20824 */	scn09   ,
/* 20825 */	scn09   ,
/* 20826 */	scn09   ,
/* 20827 */	scn09   ,
/* 20828 */	scn09   ,
/* 20829 */	scn09   ,
/* 20830 */	scn09   ,
/* 20831 */	scn09   ,
/* 20832 */	scn09   ,
/* 20833 */	scn09   ,
/* 20834 */	scn09   ,
/* 20835 */	scn09   ,
/* 20836 */	scn21   ,
/* 20837 */	scn09   ,
/* 20838 */	scn09   ,
/* 20839 */	scn09   ,
/* 20840 */	scn09   ,
/* 20841 */	scn09   ,
/* 20842 */	scn09   ,
/* 20843 */	scn09   ,
/* 20844 */	scn28   ,
/* 20845 */	scn07   ,
/* 20846 */	scn27   ,
/* 20847 */	scn38   ,
/* 20848 */	scn24   ,
/* 20849 */	scn07   ,
/* 20850 */	scn09   ,
/* 20851 */	scn09   ,
/* 20852 */	scn09   ,
/* 20853 */	scn09   ,
/* 20854 */	scn09   ,
/* 20855 */	scn20   ,
/* 20856 */	scn09   ,
/* 20857 */	scn09   ,
/* 20858 */	scn09   ,
/* 20859 */	scn09   ,
/* 20860 */	scn09   ,
/* 20861 */	scn09   ,
/* 20862 */	scn09   ,
/* 20863 */	scn09   ,
/* 20864 */	scn09   ,
/* 20865 */	scn09   ,
/* 20866 */	scn09   ,
/* 20867 */	scn09   ,
/* 20868 */	scn21   ,
/* 20869 */	scn09   ,
/* 20870 */	scn09   ,
/* 20871 */	scn09   ,
/* 20872 */	scn09   ,
/* 20873 */	scn09   ,
/* 20874 */	scn09   ,
/* 20875 */	scn09   ,
/* 20876 */	scn07   ,
/* 20877 */	scn43   ,
/* 20878 */	scn07   ,
/* 20879 */	scn35   ,
/* 20880 */	scn07   ,
// scn07:
/* 20881 */	stmt    | 7357   << off_ ,	//scn07	bze wb scn10  jump if scanning name or constant
/* 20882 */	bze     | wb     << dst_ | scn10  << off_ ,
/* 20883 */	stmt    | 7358   << off_ ,	//	erb 230 syntax error: illegal character
/* 20884 */	erb     | 230    << off_ ,
// scn08:
/* 20885 */	stmt    | 7359   << off_ ,	//scn08	bze wb scn09  keep scanning if name/constant
/* 20886 */	bze     | wb     << dst_ | scn09  << off_ ,
/* 20887 */	stmt    | 7360   << off_ ,	//	zer wc   else set flag for scanning constant
/* 20888 */	move    | wc     << dst_ ,
// scn09:
/* 20889 */	stmt    | 7361   << off_ ,	//scn09	beq wa scnil scn11 jump if end of image
/* 20890 */	load    | r2     << dst_ | scnil  << off_ ,
/* 20891 */	beq     | wa     << dst_ | r2     << src_ | scn11  << off_ ,
/* 20892 */	stmt    | 7362   << off_ ,	//	zer wb   set flag for scanning name/const
/* 20893 */	move    | wb     << dst_ ,
/* 20894 */	stmt    | 7363   << off_ ,	//	brn scn06   merge back to continue scan
/* 20895 */	brn     | scn06  << off_ ,
// scn10:
/* 20896 */	stmt    | 7364   << off_ ,	//scn10	dcv wa   reset offset to point to delimiter
/* 20897 */	dcv     | wa     << dst_ ,
// scn11:
/* 20898 */	stmt    | 7365   << off_ ,	//scn11	mov scnpt wa  store updated scan offset
/* 20899 */	store   | wa     << dst_ | scnpt  << off_ ,
/* 20900 */	stmt    | 7366   << off_ ,	//	mov wb scnse  point to start of element
/* 20901 */	load    | wb     << dst_ | scnse  << off_ ,
/* 20902 */	stmt    | 7367   << off_ ,	//	sub wa wb  get number of characters
/* 20903 */	sub     | wa     << dst_ | wb     << src_ ,
/* 20904 */	stmt    | 7368   << off_ ,	//	mov xl r_cim  point to line image
/* 20905 */	load    | xl     << dst_ | r_cim  << off_ ,
/* 20906 */	stmt    | 7369   << off_ ,	//	bnz wc scn15  jump if name
/* 20907 */	bnz     | wc     << dst_ | scn15  << off_ ,
/* 20908 */	stmt    | 7370   << off_ ,	//	jsr sbstr   get string for constant
/* 20909 */	call    | sbstr  << off_ ,
/* 20910 */	stmt    | 7371   << off_ ,	//	mov dnamp xr  delete from storage (not needed)
/* 20911 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 20912 */	stmt    | 7372   << off_ ,	//	jsr gtnum   convert to numeric
/* 20913 */	call    | gtnum  << off_ ,
/* 20914 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 20915 */	ppm     | scn14  << off_ ,
// scn12:
/* 20916 */	stmt    | 7373   << off_ ,	//scn12	mov xl =t_con  set result type of constant
/* 20917 */	loadi   | xl     << dst_ | t_con  << off_ ,
// scn13:
/* 20918 */	stmt    | 7374   << off_ ,	//scn13	mov wa scnsa  restore wa
/* 20919 */	load    | wa     << dst_ | scnsa  << off_ ,
/* 20920 */	stmt    | 7375   << off_ ,	//	mov wb scnsb  restore wb
/* 20921 */	load    | wb     << dst_ | scnsb  << off_ ,
/* 20922 */	stmt    | 7376   << off_ ,	//	mov wc scnsc  restore wc
/* 20923 */	load    | wc     << dst_ | scnsc  << off_ ,
/* 20924 */	stmt    | 7377   << off_ ,	//	mov r_scp xr  save xr in case rescan
/* 20925 */	store   | xr     << dst_ | r_scp  << off_ ,
/* 20926 */	stmt    | 7378   << off_ ,	//	mov scntp xl  save xl in case rescan
/* 20927 */	store   | xl     << dst_ | scntp  << off_ ,
/* 20928 */	stmt    | 7379   << off_ ,	//	zer scngo   reset possible goto flag
/* 20929 */	store   | r0     << dst_ | scngo  << off_ ,
/* 20930 */	stmt    | 7380   << off_ ,	//	exi    return to scane caller
/* 20931 */	exi     | 0      << off_ ,
// scn14:
/* 20932 */	stmt    | 7381   << off_ ,	//scn14	erb 231 syntax error: invalid numeric item
/* 20933 */	erb     | 231    << off_ ,
// scn15:
/* 20934 */	stmt    | 7382   << off_ ,	//scn15	jsr sbstr   build string name of variable
/* 20935 */	call    | sbstr  << off_ ,
/* 20936 */	stmt    | 7383   << off_ ,	//	bnz scncc scn13  return if cncrd call
/* 20937 */	load    | r1     << dst_ | scncc  << off_ ,
/* 20938 */	bnz     | r1     << dst_ | scn13  << off_ ,
/* 20939 */	stmt    | 7384   << off_ ,	//	jsr gtnvr   locate/build vrblk
/* 20940 */	call    | gtnvr  << off_ ,
/* 20941 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 20942 */	ppm     ,
/* 20943 */	stmt    | 7385   << off_ ,	//	mov xl =t_var  set type as variable
/* 20944 */	loadi   | xl     << dst_ | t_var  << off_ ,
/* 20945 */	stmt    | 7386   << off_ ,	//	brn scn13   back to exit
/* 20946 */	brn     | scn13  << off_ ,
// scn16:
/* 20947 */	stmt    | 7387   << off_ ,	//scn16	bze wb scn10  terminator if scanning name or cnst
/* 20948 */	bze     | wb     << dst_ | scn10  << off_ ,
/* 20949 */	stmt    | 7388   << off_ ,	//	mov wb =ch_sq  set terminator as single quote
/* 20950 */	loadi   | wb     << dst_ | ch_sq  << off_ ,
/* 20951 */	stmt    | 7389   << off_ ,	//	brn scn18   merge
/* 20952 */	brn     | scn18  << off_ ,
// scn17:
/* 20953 */	stmt    | 7390   << off_ ,	//scn17	bze wb scn10  terminator if scanning name or cnst
/* 20954 */	bze     | wb     << dst_ | scn10  << off_ ,
/* 20955 */	stmt    | 7391   << off_ ,	//	mov wb =ch_dq  set double quote terminator, merge
/* 20956 */	loadi   | wb     << dst_ | ch_dq  << off_ ,
// scn18:
/* 20957 */	stmt    | 7392   << off_ ,	//scn18	beq wa scnil scn19 error if end of image
/* 20958 */	load    | r2     << dst_ | scnil  << off_ ,
/* 20959 */	beq     | wa     << dst_ | r2     << src_ | scn19  << off_ ,
/* 20960 */	stmt    | 7393   << off_ ,	//	lch wc (xl)+  else load next character
/* 20961 */	load    | wc     << dst_ | xl     << src_ ,
/* 20962 */	ica     | xl     << dst_ ,
/* 20963 */	stmt    | 7394   << off_ ,	//	icv wa   bump offset
/* 20964 */	icv     | wa     << dst_ ,
/* 20965 */	stmt    | 7395   << off_ ,	//	bne wc wb scn18 loop back if not terminator
/* 20966 */	bne     | wc     << dst_ | wb     << src_ | scn18  << off_ ,
/* 20967 */	stmt    | 7396   << off_ ,	//	mov wb scnpt  point to first character
/* 20968 */	load    | wb     << dst_ | scnpt  << off_ ,
/* 20969 */	stmt    | 7397   << off_ ,	//	mov scnpt wa  save offset past final quote
/* 20970 */	store   | wa     << dst_ | scnpt  << off_ ,
/* 20971 */	stmt    | 7398   << off_ ,	//	dcv wa   point back past last character
/* 20972 */	dcv     | wa     << dst_ ,
/* 20973 */	stmt    | 7399   << off_ ,	//	sub wa wb  get number of characters
/* 20974 */	sub     | wa     << dst_ | wb     << src_ ,
/* 20975 */	stmt    | 7400   << off_ ,	//	mov xl r_cim  point to input image
/* 20976 */	load    | xl     << dst_ | r_cim  << off_ ,
/* 20977 */	stmt    | 7401   << off_ ,	//	jsr sbstr   build substring value
/* 20978 */	call    | sbstr  << off_ ,
/* 20979 */	stmt    | 7402   << off_ ,	//	brn scn12   back to exit with constant result
/* 20980 */	brn     | scn12  << off_ ,
// scn19:
/* 20981 */	stmt    | 7403   << off_ ,	//scn19	mov scnpt wa  set updated scan pointer
/* 20982 */	store   | wa     << dst_ | scnpt  << off_ ,
/* 20983 */	stmt    | 7404   << off_ ,	//	erb 232 syntax error: unmatched string quote
/* 20984 */	erb     | 232    << off_ ,
// scn20:
/* 20985 */	stmt    | 7405   << off_ ,	//scn20	mov xr =t_fgo  set return code for fail goto
/* 20986 */	loadi   | xr     << dst_ | t_fgo  << off_ ,
/* 20987 */	stmt    | 7406   << off_ ,	//	brn scn22   jump to merge
/* 20988 */	brn     | scn22  << off_ ,
// scn21:
/* 20989 */	stmt    | 7407   << off_ ,	//scn21	mov xr =t_sgo  set success goto as return code
/* 20990 */	loadi   | xr     << dst_ | t_sgo  << off_ ,
// scn22:
/* 20991 */	stmt    | 7408   << off_ ,	//scn22	bze scngo scn09  treat as normal letter if not goto
/* 20992 */	load    | r1     << dst_ | scngo  << off_ ,
/* 20993 */	bze     | r1     << dst_ | scn09  << off_ ,
// scn23:
/* 20994 */	stmt    | 7409   << off_ ,	//scn23	bze wb scn10  jump if end of name/constant
/* 20995 */	bze     | wb     << dst_ | scn10  << off_ ,
/* 20996 */	stmt    | 7410   << off_ ,	//	mov xl xr  else copy code
/* 20997 */	move    | xl     << dst_ | xr     << src_ ,
/* 20998 */	stmt    | 7411   << off_ ,	//	brn scn13   and jump to exit
/* 20999 */	brn     | scn13  << off_ ,
// scn24:
/* 21000 */	stmt    | 7412   << off_ ,	//scn24	bze wb scn09  part of name if scanning name
/* 21001 */	bze     | wb     << dst_ | scn09  << off_ ,
/* 21002 */	stmt    | 7413   << off_ ,	//	brn scn07   else illegal
/* 21003 */	brn     | scn07  << off_ ,
// scn25:
/* 21004 */	stmt    | 7414   << off_ ,	//scn25	mov xr =t_lpr  set left paren return code
/* 21005 */	loadi   | xr     << dst_ | t_lpr  << off_ ,
/* 21006 */	stmt    | 7415   << off_ ,	//	bnz wb scn23  return left paren unless name
/* 21007 */	bnz     | wb     << dst_ | scn23  << off_ ,
/* 21008 */	stmt    | 7416   << off_ ,	//	bze wc scn10  delimiter if scanning constant
/* 21009 */	bze     | wc     << dst_ | scn10  << off_ ,
/* 21010 */	stmt    | 7417   << off_ ,	//	mov wb scnse  point to start of name
/* 21011 */	load    | wb     << dst_ | scnse  << off_ ,
/* 21012 */	stmt    | 7418   << off_ ,	//	mov scnpt wa  set pointer past left paren
/* 21013 */	store   | wa     << dst_ | scnpt  << off_ ,
/* 21014 */	stmt    | 7419   << off_ ,	//	dcv wa   point back past last char of name
/* 21015 */	dcv     | wa     << dst_ ,
/* 21016 */	stmt    | 7420   << off_ ,	//	sub wa wb  get name length
/* 21017 */	sub     | wa     << dst_ | wb     << src_ ,
/* 21018 */	stmt    | 7421   << off_ ,	//	mov xl r_cim  point to input image
/* 21019 */	load    | xl     << dst_ | r_cim  << off_ ,
/* 21020 */	stmt    | 7422   << off_ ,	//	jsr sbstr   get string name for function
/* 21021 */	call    | sbstr  << off_ ,
/* 21022 */	stmt    | 7423   << off_ ,	//	jsr gtnvr   locate/build vrblk
/* 21023 */	call    | gtnvr  << off_ ,
/* 21024 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 21025 */	ppm     ,
/* 21026 */	stmt    | 7424   << off_ ,	//	mov xl =t_fnc  set code for function call
/* 21027 */	loadi   | xl     << dst_ | t_fnc  << off_ ,
/* 21028 */	stmt    | 7425   << off_ ,	//	brn scn13   back to exit
/* 21029 */	brn     | scn13  << off_ ,
// scn26:
/* 21030 */	stmt    | 7426   << off_ ,	//scn26	mov xr =t_rpr  right paren, set code
/* 21031 */	loadi   | xr     << dst_ | t_rpr  << off_ ,
/* 21032 */	stmt    | 7427   << off_ ,	//	brn scn23   take special character exit
/* 21033 */	brn     | scn23  << off_ ,
// scn27:
/* 21034 */	stmt    | 7428   << off_ ,	//scn27	mov xr =t_rbr  right bracket, set code
/* 21035 */	loadi   | xr     << dst_ | t_rbr  << off_ ,
/* 21036 */	stmt    | 7429   << off_ ,	//	brn scn23   take special character exit
/* 21037 */	brn     | scn23  << off_ ,
// scn28:
/* 21038 */	stmt    | 7430   << off_ ,	//scn28	mov xr =t_lbr  left bracket, set code
/* 21039 */	loadi   | xr     << dst_ | t_lbr  << off_ ,
/* 21040 */	stmt    | 7431   << off_ ,	//	brn scn23   take special character exit
/* 21041 */	brn     | scn23  << off_ ,
// scn29:
/* 21042 */	stmt    | 7432   << off_ ,	//scn29	mov xr =t_col  colon, set code
/* 21043 */	loadi   | xr     << dst_ | t_col  << off_ ,
/* 21044 */	stmt    | 7433   << off_ ,	//	brn scn23   take special character exit
/* 21045 */	brn     | scn23  << off_ ,
// scn30:
/* 21046 */	stmt    | 7434   << off_ ,	//scn30	mov xr =t_smc  semi-colon, set code
/* 21047 */	loadi   | xr     << dst_ | t_smc  << off_ ,
/* 21048 */	stmt    | 7435   << off_ ,	//	brn scn23   take special character exit
/* 21049 */	brn     | scn23  << off_ ,
// scn31:
/* 21050 */	stmt    | 7436   << off_ ,	//scn31	mov xr =t_cma  comma, set code
/* 21051 */	loadi   | xr     << dst_ | t_cma  << off_ ,
/* 21052 */	stmt    | 7437   << off_ ,	//	brn scn23   take special character exit
/* 21053 */	brn     | scn23  << off_ ,
// scn32:
/* 21054 */	stmt    | 7438   << off_ ,	//scn32	bze wb scn09  dot can be part of name or constant
/* 21055 */	bze     | wb     << dst_ | scn09  << off_ ,
/* 21056 */	stmt    | 7439   << off_ ,	//	add wc wb  else bump pointer
/* 21057 */	add     | wc     << dst_ | wb     << src_ ,
// scn33:
/* 21058 */	stmt    | 7440   << off_ ,	//scn33	bze wc scn09  plus can be part of constant
/* 21059 */	bze     | wc     << dst_ | scn09  << off_ ,
/* 21060 */	stmt    | 7441   << off_ ,	//	bze wb scn48  plus cannot be part of name
/* 21061 */	bze     | wb     << dst_ | scn48  << off_ ,
/* 21062 */	stmt    | 7442   << off_ ,	//	add wc wb  else bump pointer
/* 21063 */	add     | wc     << dst_ | wb     << src_ ,
// scn34:
/* 21064 */	stmt    | 7443   << off_ ,	//scn34	bze wc scn09  minus can be part of constant
/* 21065 */	bze     | wc     << dst_ | scn09  << off_ ,
/* 21066 */	stmt    | 7444   << off_ ,	//	bze wb scn48  minus cannot be part of name
/* 21067 */	bze     | wb     << dst_ | scn48  << off_ ,
/* 21068 */	stmt    | 7445   << off_ ,	//	add wc wb  else bump pointer
/* 21069 */	add     | wc     << dst_ | wb     << src_ ,
// scn35:
/* 21070 */	stmt    | 7446   << off_ ,	//scn35	add wc wb  not
/* 21071 */	add     | wc     << dst_ | wb     << src_ ,
// scn36:
/* 21072 */	stmt    | 7447   << off_ ,	//scn36	add wc wb  dollar
/* 21073 */	add     | wc     << dst_ | wb     << src_ ,
// scn37:
/* 21074 */	stmt    | 7448   << off_ ,	//scn37	add wc wb  exclamation
/* 21075 */	add     | wc     << dst_ | wb     << src_ ,
// scn38:
/* 21076 */	stmt    | 7449   << off_ ,	//scn38	add wc wb  percent
/* 21077 */	add     | wc     << dst_ | wb     << src_ ,
// scn39:
/* 21078 */	stmt    | 7450   << off_ ,	//scn39	add wc wb  asterisk
/* 21079 */	add     | wc     << dst_ | wb     << src_ ,
// scn40:
/* 21080 */	stmt    | 7451   << off_ ,	//scn40	add wc wb  slash
/* 21081 */	add     | wc     << dst_ | wb     << src_ ,
// scn41:
/* 21082 */	stmt    | 7452   << off_ ,	//scn41	add wc wb  number sign
/* 21083 */	add     | wc     << dst_ | wb     << src_ ,
// scn42:
/* 21084 */	stmt    | 7453   << off_ ,	//scn42	add wc wb  at sign
/* 21085 */	add     | wc     << dst_ | wb     << src_ ,
// scn43:
/* 21086 */	stmt    | 7454   << off_ ,	//scn43	add wc wb  vertical bar
/* 21087 */	add     | wc     << dst_ | wb     << src_ ,
// scn44:
/* 21088 */	stmt    | 7455   << off_ ,	//scn44	add wc wb  ampersand
/* 21089 */	add     | wc     << dst_ | wb     << src_ ,
// scn45:
/* 21090 */	stmt    | 7456   << off_ ,	//scn45	add wc wb  question mark
/* 21091 */	add     | wc     << dst_ | wb     << src_ ,
// scn46:
/* 21092 */	stmt    | 7457   << off_ ,	//scn46	bze wb scn10  operator terminates name/constant
/* 21093 */	bze     | wb     << dst_ | scn10  << off_ ,
/* 21094 */	stmt    | 7458   << off_ ,	//	mov xr wc  else copy dv pointer
/* 21095 */	move    | xr     << dst_ | wc     << src_ ,
/* 21096 */	stmt    | 7459   << off_ ,	//	lch wc (xl)  load next character
/* 21097 */	load    | wc     << dst_ | xl     << src_ ,
/* 21098 */	stmt    | 7460   << off_ ,	//	mov xl =t_bop  set binary op in case
/* 21099 */	loadi   | xl     << dst_ | t_bop  << off_ ,
/* 21100 */	stmt    | 7461   << off_ ,	//	beq wa scnil scn47 should be binary if image end
/* 21101 */	load    | r2     << dst_ | scnil  << off_ ,
/* 21102 */	beq     | wa     << dst_ | r2     << src_ | scn47  << off_ ,
/* 21103 */	stmt    | 7462   << off_ ,	//	beq wc =ch_bl scn47 should be binary if followed by blk
/* 21104 */	loadi   | r2     << dst_ | ch_bl  << off_ ,
/* 21105 */	beq     | wc     << dst_ | r2     << src_ | scn47  << off_ ,
/* 21106 */	stmt    | 7463   << off_ ,	//	beq wc =ch_ht scn47 jump if horizontal tab
/* 21107 */	loadi   | r2     << dst_ | ch_ht  << off_ ,
/* 21108 */	beq     | wc     << dst_ | r2     << src_ | scn47  << off_ ,
/* 21109 */	stmt    | 7464   << off_ ,	//	beq wc =ch_sm scn47 semicolon can immediately follow =
/* 21110 */	loadi   | r2     << dst_ | ch_sm  << off_ ,
/* 21111 */	beq     | wc     << dst_ | r2     << src_ | scn47  << off_ ,
/* 21112 */	stmt    | 7465   << off_ ,	//	beq wc =ch_cl scn47 colon can immediately follow =
/* 21113 */	loadi   | r2     << dst_ | ch_cl  << off_ ,
/* 21114 */	beq     | wc     << dst_ | r2     << src_ | scn47  << off_ ,
/* 21115 */	stmt    | 7466   << off_ ,	//	beq wc =ch_rp scn47 right paren can immediately follow =
/* 21116 */	loadi   | r2     << dst_ | ch_rp  << off_ ,
/* 21117 */	beq     | wc     << dst_ | r2     << src_ | scn47  << off_ ,
/* 21118 */	stmt    | 7467   << off_ ,	//	beq wc =ch_rb scn47 right bracket can immediately follow =
/* 21119 */	loadi   | r2     << dst_ | ch_rb  << off_ ,
/* 21120 */	beq     | wc     << dst_ | r2     << src_ | scn47  << off_ ,
/* 21121 */	stmt    | 7468   << off_ ,	//	beq wc =ch_cb scn47 right bracket can immediately follow =
/* 21122 */	loadi   | r2     << dst_ | ch_cb  << off_ ,
/* 21123 */	beq     | wc     << dst_ | r2     << src_ | scn47  << off_ ,
/* 21124 */	stmt    | 7469   << off_ ,	//	add xr *dvbs_  point to dv for unary op
/* 21125 */	loadi   | r2     << dst_ | dvbs_  << off_ ,
/* 21126 */	add     | xr     << dst_ | r2     << src_ ,
/* 21127 */	stmt    | 7470   << off_ ,	//	mov xl =t_uop  set type for unary operator
/* 21128 */	loadi   | xl     << dst_ | t_uop  << off_ ,
/* 21129 */	stmt    | 7471   << off_ ,	//	ble scntp =t_uok scn13 ok unary if ok preceding element
/* 21130 */	load    | r1     << dst_ | scntp  << off_ ,
/* 21131 */	loadi   | r2     << dst_ | t_uok  << off_ ,
/* 21132 */	ble     | r1     << dst_ | r2     << src_ | scn13  << off_ ,
// scn47:
/* 21133 */	stmt    | 7472   << off_ ,	//scn47	bnz scnbl scn13  all ok if preceding blanks, exit
/* 21134 */	load    | r1     << dst_ | scnbl  << off_ ,
/* 21135 */	bnz     | r1     << dst_ | scn13  << off_ ,
// scn48:
/* 21136 */	stmt    | 7473   << off_ ,	//scn48	erb 233 syntax error: invalid use of operator
/* 21137 */	erb     | 233    << off_ ,
// scn49:
/* 21138 */	stmt    | 7474   << off_ ,	//scn49	bze wb scn10  end of name if scanning name
/* 21139 */	bze     | wb     << dst_ | scn10  << off_ ,
/* 21140 */	stmt    | 7475   << off_ ,	//	beq wa scnil scn39 not ** if * at image end
/* 21141 */	load    | r2     << dst_ | scnil  << off_ ,
/* 21142 */	beq     | wa     << dst_ | r2     << src_ | scn39  << off_ ,
/* 21143 */	stmt    | 7476   << off_ ,	//	mov xr wa  else save offset past first *
/* 21144 */	move    | xr     << dst_ | wa     << src_ ,
/* 21145 */	stmt    | 7477   << off_ ,	//	mov scnof wa  save another copy
/* 21146 */	store   | wa     << dst_ | scnof  << off_ ,
/* 21147 */	stmt    | 7478   << off_ ,	//	lch wa (xl)+  load next character
/* 21148 */	load    | wa     << dst_ | xl     << src_ ,
/* 21149 */	ica     | xl     << dst_ ,
/* 21150 */	stmt    | 7479   << off_ ,	//	bne wa =ch_as scn50 not ** if next char not *
/* 21151 */	loadi   | r2     << dst_ | ch_as  << off_ ,
/* 21152 */	bne     | wa     << dst_ | r2     << src_ | scn50  << off_ ,
/* 21153 */	stmt    | 7480   << off_ ,	//	icv xr   else step offset past second *
/* 21154 */	icv     | xr     << dst_ ,
/* 21155 */	stmt    | 7481   << off_ ,	//	beq xr scnil scn51 ok exclam if end of image
/* 21156 */	load    | r2     << dst_ | scnil  << off_ ,
/* 21157 */	beq     | xr     << dst_ | r2     << src_ | scn51  << off_ ,
/* 21158 */	stmt    | 7482   << off_ ,	//	lch wa (xl)  else load next character
/* 21159 */	load    | wa     << dst_ | xl     << src_ ,
/* 21160 */	stmt    | 7483   << off_ ,	//	beq wa =ch_bl scn51 exclamation if blank
/* 21161 */	loadi   | r2     << dst_ | ch_bl  << off_ ,
/* 21162 */	beq     | wa     << dst_ | r2     << src_ | scn51  << off_ ,
/* 21163 */	stmt    | 7484   << off_ ,	//	beq wa =ch_ht scn51 exclamation if horizontal tab
/* 21164 */	loadi   | r2     << dst_ | ch_ht  << off_ ,
/* 21165 */	beq     | wa     << dst_ | r2     << src_ | scn51  << off_ ,
// scn50:
/* 21166 */	stmt    | 7485   << off_ ,	//scn50	mov wa scnof  recover stored offset
/* 21167 */	load    | wa     << dst_ | scnof  << off_ ,
/* 21168 */	stmt    | 7486   << off_ ,	//	mov xl r_cim  point to line again
/* 21169 */	load    | xl     << dst_ | r_cim  << off_ ,
/* 21170 */	stmt    | 7487   << off_ ,	//	plc xl wa  point to current char
/* 21171 */	plc     | xl     << dst_ | wa     << src_ ,
/* 21172 */	stmt    | 7488   << off_ ,	//	brn scn39   merge with unary *
/* 21173 */	brn     | scn39  << off_ ,
// scn51:
/* 21174 */	stmt    | 7489   << off_ ,	//scn51	mov scnpt xr  save scan pointer past 2nd *
/* 21175 */	store   | xr     << dst_ | scnpt  << off_ ,
/* 21176 */	stmt    | 7490   << off_ ,	//	mov wa xr  copy scan pointer
/* 21177 */	move    | wa     << dst_ | xr     << src_ ,
/* 21178 */	stmt    | 7491   << off_ ,	//	brn scn37   merge with exclamation
/* 21179 */	brn     | scn37  << off_ ,
// scngf:
/* 21180 */	stmt    | 7492   << off_ ,	//scngf	prc e 0  entry point
/* 21181 */	stmt    | 7493   << off_ ,	//	jsr scane   scan initial element
/* 21182 */	call    | scane  << off_ ,
/* 21183 */	stmt    | 7494   << off_ ,	//	beq xl =t_lpr scng1 skip if left paren (normal goto)
/* 21184 */	loadi   | r2     << dst_ | t_lpr  << off_ ,
/* 21185 */	beq     | xl     << dst_ | r2     << src_ | scng1  << off_ ,
/* 21186 */	stmt    | 7495   << off_ ,	//	beq xl =t_lbr scng2 skip if left bracket (direct goto)
/* 21187 */	loadi   | r2     << dst_ | t_lbr  << off_ ,
/* 21188 */	beq     | xl     << dst_ | r2     << src_ | scng2  << off_ ,
/* 21189 */	stmt    | 7496   << off_ ,	//	erb 234 syntax error: goto field incorrect
/* 21190 */	erb     | 234    << off_ ,
// scng1:
/* 21191 */	stmt    | 7497   << off_ ,	//scng1	mov wb =num01  set expan flag for normal goto
/* 21192 */	loadi   | wb     << dst_ | num01  << off_ ,
/* 21193 */	stmt    | 7498   << off_ ,	//	jsr expan   analyze goto field
/* 21194 */	call    | expan  << off_ ,
/* 21195 */	stmt    | 7499   << off_ ,	//	mov wa =opdvn  point to opdv for complex goto
/* 21196 */	loadi   | wa     << dst_ | opdvn  << off_ ,
/* 21197 */	stmt    | 7500   << off_ ,	//	ble xr statb scng3 jump if not in static (sgd15)
/* 21198 */	load    | r2     << dst_ | statb  << off_ ,
/* 21199 */	ble     | xr     << dst_ | r2     << src_ | scng3  << off_ ,
/* 21200 */	stmt    | 7501   << off_ ,	//	blo xr state scng4 jump to exit if simple label name
/* 21201 */	load    | r2     << dst_ | state  << off_ ,
/* 21202 */	blo     | xr     << dst_ | r2     << src_ | scng4  << off_ ,
/* 21203 */	stmt    | 7502   << off_ ,	//	brn scng3   complex goto - merge
/* 21204 */	brn     | scng3  << off_ ,
// scng2:
/* 21205 */	stmt    | 7503   << off_ ,	//scng2	mov wb =num02  set expan flag for direct goto
/* 21206 */	loadi   | wb     << dst_ | num02  << off_ ,
/* 21207 */	stmt    | 7504   << off_ ,	//	jsr expan   scan goto field
/* 21208 */	call    | expan  << off_ ,
/* 21209 */	stmt    | 7505   << off_ ,	//	mov wa =opdvd  set opdv pointer for direct goto
/* 21210 */	loadi   | wa     << dst_ | opdvd  << off_ ,
// scng3:
/* 21211 */	stmt    | 7506   << off_ ,	//scng3	mov -(xs) wa  stack operator dv pointer
/* 21212 */	dca     | xs     << dst_ ,
/* 21213 */	store   | wa     << dst_ | xs     << src_ ,
/* 21214 */	stmt    | 7507   << off_ ,	//	mov -(xs) xr  stack pointer to expression tree
/* 21215 */	dca     | xs     << dst_ ,
/* 21216 */	store   | xr     << dst_ | xs     << src_ ,
/* 21217 */	stmt    | 7508   << off_ ,	//	jsr expop   pop operator off
/* 21218 */	call    | expop  << off_ ,
/* 21219 */	stmt    | 7509   << off_ ,	//	mov xr (xs)+  reload new expression tree pointer
/* 21220 */	load    | xr     << dst_ | xs     << src_ ,
/* 21221 */	ica     | xs     << dst_ ,
// scng4:
/* 21222 */	stmt    | 7510   << off_ ,	//scng4	exi    return to caller
/* 21223 */	exi     | 0      << off_ ,
// setvr:
/* 21224 */	stmt    | 7511   << off_ ,	//setvr	prc e 0  entry point
/* 21225 */	stmt    | 7512   << off_ ,	//	bhi xr state setv1 exit if not natural variable
/* 21226 */	load    | r2     << dst_ | state  << off_ ,
/* 21227 */	bhi     | xr     << dst_ | r2     << src_ | setv1  << off_ ,
/* 21228 */	stmt    | 7513   << off_ ,	//	mov xl xr  copy vrblk pointer
/* 21229 */	move    | xl     << dst_ | xr     << src_ ,
/* 21230 */	stmt    | 7514   << off_ ,	//	mov vrget(xr) =b_vrl  store normal get value
/* 21231 */	loadi   | r1     << dst_ | b_vrl  << off_ ,
/* 21232 */	store   | r1     << dst_ | xr     << src_ | vrget  << off_ ,
/* 21233 */	stmt    | 7515   << off_ ,	//	beq vrsto(xr) =b_vre setv1 skip if protected variable
/* 21234 */	load    | r1     << dst_ | xr     << src_ | vrsto  << off_ ,
/* 21235 */	loadi   | r2     << dst_ | b_vre  << off_ ,
/* 21236 */	beq     | r1     << dst_ | r2     << src_ | setv1  << off_ ,
/* 21237 */	stmt    | 7516   << off_ ,	//	mov vrsto(xr) =b_vrs  store normal store value
/* 21238 */	loadi   | r1     << dst_ | b_vrs  << off_ ,
/* 21239 */	store   | r1     << dst_ | xr     << src_ | vrsto  << off_ ,
/* 21240 */	stmt    | 7517   << off_ ,	//	mov xl vrval(xl)  point to next entry on chain
/* 21241 */	load    | xl     << dst_ | xl     << src_ | vrval  << off_ ,
/* 21242 */	stmt    | 7518   << off_ ,	//	bne (xl) =b_trt setv1 jump if end of trblk chain
/* 21243 */	load    | r1     << dst_ | xl     << src_ ,
/* 21244 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 21245 */	bne     | r1     << dst_ | r2     << src_ | setv1  << off_ ,
/* 21246 */	stmt    | 7519   << off_ ,	//	mov vrget(xr) =b_vra  store trapped routine address
/* 21247 */	loadi   | r1     << dst_ | b_vra  << off_ ,
/* 21248 */	store   | r1     << dst_ | xr     << src_ | vrget  << off_ ,
/* 21249 */	stmt    | 7520   << off_ ,	//	mov vrsto(xr) =b_vrv  set trapped routine address
/* 21250 */	loadi   | r1     << dst_ | b_vrv  << off_ ,
/* 21251 */	store   | r1     << dst_ | xr     << src_ | vrsto  << off_ ,
// setv1:
/* 21252 */	stmt    | 7521   << off_ ,	//setv1	exi    return to setvr caller
/* 21253 */	exi     | 0      << off_ ,
// sorta:
/* 21254 */	stmt    | 7522   << off_ ,	//sorta	prc n 1  entry point
/* 21255 */	prc     | 16     << off_ ,
/* 21256 */	stmt    | 7523   << off_ ,	//	mov srtsr wa  sort/rsort indicator
/* 21257 */	store   | wa     << dst_ | srtsr  << off_ ,
/* 21258 */	stmt    | 7524   << off_ ,	//	mov srtst *num01  default stride of 1
/* 21259 */	loadi   | r1     << dst_ | num01  << off_ ,
/* 21260 */	store   | r1     << dst_ | srtst  << off_ ,
/* 21261 */	stmt    | 7525   << off_ ,	//	zer srtof   default zero offset to sort key
/* 21262 */	store   | r0     << dst_ | srtof  << off_ ,
/* 21263 */	stmt    | 7526   << off_ ,	//	mov srtdf =nulls  clear datatype field name
/* 21264 */	loadi   | r1     << dst_ | nulls  << off_ ,
/* 21265 */	store   | r1     << dst_ | srtdf  << off_ ,
/* 21266 */	stmt    | 7527   << off_ ,	//	mov r_sxr (xs)+  unstack argument 2
/* 21267 */	load    | r1     << dst_ | xs     << src_ ,
/* 21268 */	ica     | xs     << dst_ ,
/* 21269 */	store   | r1     << dst_ | r_sxr  << off_ ,
/* 21270 */	stmt    | 7528   << off_ ,	//	mov xr (xs)+  get first argument
/* 21271 */	load    | xr     << dst_ | xs     << src_ ,
/* 21272 */	ica     | xs     << dst_ ,
/* 21273 */	stmt    | 7529   << off_ ,	//	mnz wa   use key/values of table entries
/* 21274 */	move    | wa     << dst_ | xs     << src_ ,
/* 21275 */	stmt    | 7530   << off_ ,	//	jsr gtarr   convert to array
/* 21276 */	call    | gtarr  << off_ ,
/* 21277 */	jsrerr  | r1     << dst_ | 2      << off_ ,
/* 21278 */	ppm     | srt18  << off_ ,
/* 21279 */	ppm     | srt16  << off_ ,
/* 21280 */	stmt    | 7531   << off_ ,	//	mov -(xs) xr  stack ptr to resulting key array
/* 21281 */	dca     | xs     << dst_ ,
/* 21282 */	store   | xr     << dst_ | xs     << src_ ,
/* 21283 */	stmt    | 7532   << off_ ,	//	mov -(xs) xr  another copy for copyb
/* 21284 */	dca     | xs     << dst_ ,
/* 21285 */	store   | xr     << dst_ | xs     << src_ ,
/* 21286 */	stmt    | 7533   << off_ ,	//	jsr copyb   get copy array for sorting into
/* 21287 */	call    | copyb  << off_ ,
/* 21288 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 21289 */	ppm     ,
/* 21290 */	stmt    | 7534   << off_ ,	//	mov -(xs) xr  stack pointer to sort array
/* 21291 */	dca     | xs     << dst_ ,
/* 21292 */	store   | xr     << dst_ | xs     << src_ ,
/* 21293 */	stmt    | 7535   << off_ ,	//	mov xr r_sxr  get second arg
/* 21294 */	load    | xr     << dst_ | r_sxr  << off_ ,
/* 21295 */	stmt    | 7536   << off_ ,	//	mov xl num01(xs)  get ptr to key array
/* 21296 */	load    | xl     << dst_ | xs     << src_ | num01  << off_ ,
/* 21297 */	stmt    | 7537   << off_ ,	//	bne (xl) =b_vct srt02 jump if arblk
/* 21298 */	load    | r1     << dst_ | xl     << src_ ,
/* 21299 */	loadi   | r2     << dst_ | b_vct  << off_ ,
/* 21300 */	bne     | r1     << dst_ | r2     << src_ | srt02  << off_ ,
/* 21301 */	stmt    | 7538   << off_ ,	//	beq xr =nulls srt01 jump if null second arg
/* 21302 */	loadi   | r2     << dst_ | nulls  << off_ ,
/* 21303 */	beq     | xr     << dst_ | r2     << src_ | srt01  << off_ ,
/* 21304 */	stmt    | 7539   << off_ ,	//	jsr gtnvr   get vrblk ptr for it
/* 21305 */	call    | gtnvr  << off_ ,
/* 21306 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 21307 */	err     | 257    << off_ ,
/* 21308 */	stmt    | 7540   << off_ ,	//	mov srtdf xr  store datatype field name vrblk
/* 21309 */	store   | xr     << dst_ | srtdf  << off_ ,
// srt01:
/* 21310 */	stmt    | 7541   << off_ ,	//srt01	mov wc *vclen  offset to a(0)
/* 21311 */	loadi   | wc     << dst_ | vclen  << off_ ,
/* 21312 */	stmt    | 7542   << off_ ,	//	mov wb *vcvls  offset to first item
/* 21313 */	loadi   | wb     << dst_ | vcvls  << off_ ,
/* 21314 */	stmt    | 7543   << off_ ,	//	mov wa vclen(xl)  get block length
/* 21315 */	load    | wa     << dst_ | xl     << src_ | vclen  << off_ ,
/* 21316 */	stmt    | 7544   << off_ ,	//	sub wa *vcsi_  get no. of entries, n (in bytes)
/* 21317 */	loadi   | r2     << dst_ | vcsi_  << off_ ,
/* 21318 */	sub     | wa     << dst_ | r2     << src_ ,
/* 21319 */	stmt    | 7545   << off_ ,	//	brn srt04   merge
/* 21320 */	brn     | srt04  << off_ ,
// srt02:
/* 21321 */	stmt    | 7546   << off_ ,	//srt02	ldi ardim(xl)   get possible dimension
/* 21322 */	load    | r1     << dst_ | xl     << src_ | ardim  << off_ ,
/* 21323 */	ldi     | r1     << dst_ ,
/* 21324 */	stmt    | 7547   << off_ ,	//	mfi wa   convert to short integer
/* 21325 */	move    | wa     << dst_ | ia     << src_ ,
/* 21326 */	stmt    | 7548   << off_ ,	//	wtb wa   further convert to baus
/* 21327 */	stmt    | 7549   << off_ ,	//	mov wb *arvls  offset to first value if one
/* 21328 */	loadi   | wb     << dst_ | arvls  << off_ ,
/* 21329 */	stmt    | 7550   << off_ ,	//	mov wc *arpro  offset before values if one dim.
/* 21330 */	loadi   | wc     << dst_ | arpro  << off_ ,
/* 21331 */	stmt    | 7551   << off_ ,	//	beq arndm(xl) =num01 srt04 jump in fact if one dim.
/* 21332 */	load    | r1     << dst_ | xl     << src_ | arndm  << off_ ,
/* 21333 */	loadi   | r2     << dst_ | num01  << off_ ,
/* 21334 */	beq     | r1     << dst_ | r2     << src_ | srt04  << off_ ,
/* 21335 */	stmt    | 7552   << off_ ,	//	bne arndm(xl) =num02 srt16 fail unless two dimens
/* 21336 */	load    | r1     << dst_ | xl     << src_ | arndm  << off_ ,
/* 21337 */	loadi   | r2     << dst_ | num02  << off_ ,
/* 21338 */	bne     | r1     << dst_ | r2     << src_ | srt16  << off_ ,
/* 21339 */	stmt    | 7553   << off_ ,	//	ldi arlb2(xl)   get lower bound 2 as default
/* 21340 */	load    | r1     << dst_ | xl     << src_ | arlb2  << off_ ,
/* 21341 */	ldi     | r1     << dst_ ,
/* 21342 */	stmt    | 7554   << off_ ,	//	beq xr =nulls srt03 jump if default second arg
/* 21343 */	loadi   | r2     << dst_ | nulls  << off_ ,
/* 21344 */	beq     | xr     << dst_ | r2     << src_ | srt03  << off_ ,
/* 21345 */	stmt    | 7555   << off_ ,	//	jsr gtint   convert to integer
/* 21346 */	call    | gtint  << off_ ,
/* 21347 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 21348 */	ppm     | srt17  << off_ ,
/* 21349 */	stmt    | 7556   << off_ ,	//	ldi icval(xr)   get actual integer value
/* 21350 */	load    | r1     << dst_ | xr     << src_ | icval  << off_ ,
/* 21351 */	ldi     | r1     << dst_ ,
// srt03:
/* 21352 */	stmt    | 7557   << off_ ,	//srt03	sbi arlb2(xl)   subtract low bound
/* 21353 */	load    | r1     << dst_ | xl     << src_ | arlb2  << off_ ,
/* 21354 */	sbi     | r1     << dst_ ,
/* 21355 */	stmt    | 7558   << off_ ,	//	iov srt17   fail if overflow
/* 21356 */	iov     | srt17  << off_ ,
/* 21357 */	stmt    | 7559   << off_ ,	//	ilt srt17   fail if below low bound
/* 21358 */	ilt     | srt17  << off_ ,
/* 21359 */	stmt    | 7560   << off_ ,	//	sbi ardm2(xl)   check against dimension
/* 21360 */	load    | r1     << dst_ | xl     << src_ | ardm2  << off_ ,
/* 21361 */	sbi     | r1     << dst_ ,
/* 21362 */	stmt    | 7561   << off_ ,	//	ige srt17   fail if too large
/* 21363 */	ige     | srt17  << off_ ,
/* 21364 */	stmt    | 7562   << off_ ,	//	adi ardm2(xl)   restore value
/* 21365 */	load    | r1     << dst_ | xl     << src_ | ardm2  << off_ ,
/* 21366 */	adi     | r1     << dst_ ,
/* 21367 */	stmt    | 7563   << off_ ,	//	mfi wa   get as small integer
/* 21368 */	move    | wa     << dst_ | ia     << src_ ,
/* 21369 */	stmt    | 7564   << off_ ,	//	wtb wa   offset within row to key
/* 21370 */	stmt    | 7565   << off_ ,	//	mov srtof wa  keep offset
/* 21371 */	store   | wa     << dst_ | srtof  << off_ ,
/* 21372 */	stmt    | 7566   << off_ ,	//	ldi ardm2(xl)   second dimension is row length
/* 21373 */	load    | r1     << dst_ | xl     << src_ | ardm2  << off_ ,
/* 21374 */	ldi     | r1     << dst_ ,
/* 21375 */	stmt    | 7567   << off_ ,	//	mfi wa   convert to short integer
/* 21376 */	move    | wa     << dst_ | ia     << src_ ,
/* 21377 */	stmt    | 7568   << off_ ,	//	mov xr wa  copy row length
/* 21378 */	move    | xr     << dst_ | wa     << src_ ,
/* 21379 */	stmt    | 7569   << off_ ,	//	wtb wa   convert to bytes
/* 21380 */	stmt    | 7570   << off_ ,	//	mov srtst wa  store as stride
/* 21381 */	store   | wa     << dst_ | srtst  << off_ ,
/* 21382 */	stmt    | 7571   << off_ ,	//	ldi ardim(xl)   get number of rows
/* 21383 */	load    | r1     << dst_ | xl     << src_ | ardim  << off_ ,
/* 21384 */	ldi     | r1     << dst_ ,
/* 21385 */	stmt    | 7572   << off_ ,	//	mfi wa   as a short integer
/* 21386 */	move    | wa     << dst_ | ia     << src_ ,
/* 21387 */	stmt    | 7573   << off_ ,	//	wtb wa   convert n to baus
/* 21388 */	stmt    | 7574   << off_ ,	//	mov wc arlen(xl)  offset past array end
/* 21389 */	load    | wc     << dst_ | xl     << src_ | arlen  << off_ ,
/* 21390 */	stmt    | 7575   << off_ ,	//	sub wc wa  adjust, giving space for n offsets
/* 21391 */	sub     | wc     << dst_ | wa     << src_ ,
/* 21392 */	stmt    | 7576   << off_ ,	//	dca wc   point to a(0)
/* 21393 */	dca     | wc     << dst_ ,
/* 21394 */	stmt    | 7577   << off_ ,	//	mov wb arofs(xl)  offset to word before first item
/* 21395 */	load    | wb     << dst_ | xl     << src_ | arofs  << off_ ,
/* 21396 */	stmt    | 7578   << off_ ,	//	ica wb   offset to first item
/* 21397 */	ica     | wb     << dst_ ,
// srt04:
/* 21398 */	stmt    | 7579   << off_ ,	//srt04	ble wa *num01 srt15 return if only a single item
/* 21399 */	loadi   | r2     << dst_ | num01  << off_ ,
/* 21400 */	ble     | wa     << dst_ | r2     << src_ | srt15  << off_ ,
/* 21401 */	stmt    | 7580   << off_ ,	//	mov srtsn wa  store number of items (in baus)
/* 21402 */	store   | wa     << dst_ | srtsn  << off_ ,
/* 21403 */	stmt    | 7581   << off_ ,	//	mov srtso wc  store offset to a(0)
/* 21404 */	store   | wc     << dst_ | srtso  << off_ ,
/* 21405 */	stmt    | 7582   << off_ ,	//	mov wc arlen(xl)  length of array or vec (=vclen)
/* 21406 */	load    | wc     << dst_ | xl     << src_ | arlen  << off_ ,
/* 21407 */	stmt    | 7583   << off_ ,	//	add wc xl  point past end of array or vector
/* 21408 */	add     | wc     << dst_ | xl     << src_ ,
/* 21409 */	stmt    | 7584   << off_ ,	//	mov srtsf wb  store offset to first row
/* 21410 */	store   | wb     << dst_ | srtsf  << off_ ,
/* 21411 */	stmt    | 7585   << off_ ,	//	add xl wb  point to first item in key array
/* 21412 */	add     | xl     << dst_ | wb     << src_ ,
// srt05:
/* 21413 */	stmt    | 7586   << off_ ,	//srt05	mov xr (xl)  get an entry
/* 21414 */	load    | xr     << dst_ | xl     << src_ ,
// srt06:
/* 21415 */	stmt    | 7587   << off_ ,	//srt06	bne (xr) =b_trt srt07 jump out if not trblk
/* 21416 */	load    | r1     << dst_ | xr     << src_ ,
/* 21417 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 21418 */	bne     | r1     << dst_ | r2     << src_ | srt07  << off_ ,
/* 21419 */	stmt    | 7588   << off_ ,	//	mov xr trval(xr)  get value field
/* 21420 */	load    | xr     << dst_ | xr     << src_ | trval  << off_ ,
/* 21421 */	stmt    | 7589   << off_ ,	//	brn srt06   loop
/* 21422 */	brn     | srt06  << off_ ,
// srt07:
/* 21423 */	stmt    | 7590   << off_ ,	//srt07	mov (xl)+ xr  store as array entry
/* 21424 */	store   | xr     << dst_ | xl     << src_ ,
/* 21425 */	ica     | xl     << dst_ ,
/* 21426 */	stmt    | 7591   << off_ ,	//	blt xl wc srt05 loop if not done
/* 21427 */	blt     | xl     << dst_ | wc     << src_ | srt05  << off_ ,
/* 21428 */	stmt    | 7592   << off_ ,	//	mov xl (xs)  get adrs of sort array
/* 21429 */	load    | xl     << dst_ | xs     << src_ ,
/* 21430 */	stmt    | 7593   << off_ ,	//	mov xr srtsf  initial offset to first key
/* 21431 */	load    | xr     << dst_ | srtsf  << off_ ,
/* 21432 */	stmt    | 7594   << off_ ,	//	mov wb srtst  get stride
/* 21433 */	load    | wb     << dst_ | srtst  << off_ ,
/* 21434 */	stmt    | 7595   << off_ ,	//	add xl srtso  offset to a(0)
/* 21435 */	load    | r2     << dst_ | srtso  << off_ ,
/* 21436 */	add     | xl     << dst_ | r2     << src_ ,
/* 21437 */	stmt    | 7596   << off_ ,	//	ica xl   point to a(1)
/* 21438 */	ica     | xl     << dst_ ,
/* 21439 */	stmt    | 7597   << off_ ,	//	mov wc srtsn  get n
/* 21440 */	load    | wc     << dst_ | srtsn  << off_ ,
/* 21441 */	stmt    | 7598   << off_ ,	//	btw wc   convert from bytes
/* 21442 */	stmt    | 7599   << off_ ,	//	mov srtnr wc  store as row count
/* 21443 */	store   | wc     << dst_ | srtnr  << off_ ,
/* 21444 */	stmt    | 7600   << off_ ,	//	lct wc wc  loop counter
// srt08:
/* 21445 */	stmt    | 7601   << off_ ,	//srt08	mov (xl)+ xr  store an offset
/* 21446 */	store   | xr     << dst_ | xl     << src_ ,
/* 21447 */	ica     | xl     << dst_ ,
/* 21448 */	stmt    | 7602   << off_ ,	//	add xr wb  bump offset by stride
/* 21449 */	add     | xr     << dst_ | wb     << src_ ,
/* 21450 */	stmt    | 7603   << off_ ,	//	bct wc srt08  loop through rows
/* 21451 */	bct     | wc     << dst_ | srt08  << off_ ,
// srt09:
/* 21452 */	stmt    | 7604   << off_ ,	//srt09	mov wa srtsn  get n
/* 21453 */	load    | wa     << dst_ | srtsn  << off_ ,
/* 21454 */	stmt    | 7605   << off_ ,	//	mov wc srtnr  get number of rows
/* 21455 */	load    | wc     << dst_ | srtnr  << off_ ,
/* 21456 */	stmt    | 7606   << off_ ,	//	rsh wc 1  i = n / 2 (wc=i, index into array)
/* 21457 */	rsh     | wc     << dst_ | 1      << off_ ,
/* 21458 */	stmt    | 7607   << off_ ,	//	wtb wc   convert back to bytes
// srt10:
/* 21459 */	stmt    | 7608   << off_ ,	//srt10	jsr sorth   sorth(i,n)
/* 21460 */	call    | sorth  << off_ ,
/* 21461 */	stmt    | 7609   << off_ ,	//	dca wc   i = i - 1
/* 21462 */	dca     | wc     << dst_ ,
/* 21463 */	stmt    | 7610   << off_ ,	//	bnz wc srt10  loop if i gt 0
/* 21464 */	bnz     | wc     << dst_ | srt10  << off_ ,
/* 21465 */	stmt    | 7611   << off_ ,	//	mov wc wa  i = n
/* 21466 */	move    | wc     << dst_ | wa     << src_ ,
// srt11:
/* 21467 */	stmt    | 7612   << off_ ,	//srt11	dca wc   i = i - 1 (n - 1 initially)
/* 21468 */	dca     | wc     << dst_ ,
/* 21469 */	stmt    | 7613   << off_ ,	//	bze wc srt12  jump if done
/* 21470 */	bze     | wc     << dst_ | srt12  << off_ ,
/* 21471 */	stmt    | 7614   << off_ ,	//	mov xr (xs)  get sort array address
/* 21472 */	load    | xr     << dst_ | xs     << src_ ,
/* 21473 */	stmt    | 7615   << off_ ,	//	add xr srtso  point to a(0)
/* 21474 */	load    | r2     << dst_ | srtso  << off_ ,
/* 21475 */	add     | xr     << dst_ | r2     << src_ ,
/* 21476 */	stmt    | 7616   << off_ ,	//	mov xl xr  a(0) address
/* 21477 */	move    | xl     << dst_ | xr     << src_ ,
/* 21478 */	stmt    | 7617   << off_ ,	//	add xl wc  a(i) address
/* 21479 */	add     | xl     << dst_ | wc     << src_ ,
/* 21480 */	stmt    | 7618   << off_ ,	//	mov wb num01(xl)  copy a(i+1)
/* 21481 */	load    | wb     << dst_ | xl     << src_ | num01  << off_ ,
/* 21482 */	stmt    | 7619   << off_ ,	//	mov num01(xl) num01(xr)  move a(1) to a(i+1)
/* 21483 */	load    | r1     << dst_ | xr     << src_ | num01  << off_ ,
/* 21484 */	store   | r1     << dst_ | xl     << src_ | num01  << off_ ,
/* 21485 */	stmt    | 7620   << off_ ,	//	mov num01(xr) wb  complete exchange of a(1), a(i+1)
/* 21486 */	store   | wb     << dst_ | xr     << src_ | num01  << off_ ,
/* 21487 */	stmt    | 7621   << off_ ,	//	mov wa wc  n = i for sorth
/* 21488 */	move    | wa     << dst_ | wc     << src_ ,
/* 21489 */	stmt    | 7622   << off_ ,	//	mov wc *num01  i = 1 for sorth
/* 21490 */	loadi   | wc     << dst_ | num01  << off_ ,
/* 21491 */	stmt    | 7623   << off_ ,	//	jsr sorth   sorth(1,n)
/* 21492 */	call    | sorth  << off_ ,
/* 21493 */	stmt    | 7624   << off_ ,	//	mov wc wa  restore wc
/* 21494 */	move    | wc     << dst_ | wa     << src_ ,
/* 21495 */	stmt    | 7625   << off_ ,	//	brn srt11   loop
/* 21496 */	brn     | srt11  << off_ ,
// srt12:
/* 21497 */	stmt    | 7626   << off_ ,	//srt12	mov xr (xs)  base adrs of key array
/* 21498 */	load    | xr     << dst_ | xs     << src_ ,
/* 21499 */	stmt    | 7627   << off_ ,	//	mov wc xr  copy it
/* 21500 */	move    | wc     << dst_ | xr     << src_ ,
/* 21501 */	stmt    | 7628   << off_ ,	//	add wc srtso  offset of a(0)
/* 21502 */	load    | r2     << dst_ | srtso  << off_ ,
/* 21503 */	add     | wc     << dst_ | r2     << src_ ,
/* 21504 */	stmt    | 7629   << off_ ,	//	add xr srtsf  adrs of first row of sort array
/* 21505 */	load    | r2     << dst_ | srtsf  << off_ ,
/* 21506 */	add     | xr     << dst_ | r2     << src_ ,
/* 21507 */	stmt    | 7630   << off_ ,	//	mov wb srtst  get stride
/* 21508 */	load    | wb     << dst_ | srtst  << off_ ,
// srt13:
/* 21509 */	stmt    | 7631   << off_ ,	//srt13	ica wc   adrs of next of sorted offsets
/* 21510 */	ica     | wc     << dst_ ,
/* 21511 */	stmt    | 7632   << off_ ,	//	mov xl wc  copy it for access
/* 21512 */	move    | xl     << dst_ | wc     << src_ ,
/* 21513 */	stmt    | 7633   << off_ ,	//	mov xl (xl)  get offset
/* 21514 */	load    | xl     << dst_ | xl     << src_ ,
/* 21515 */	stmt    | 7634   << off_ ,	//	add xl num01(xs)  add key array base adrs
/* 21516 */	load    | r2     << dst_ | xs     << src_ | num01  << off_ ,
/* 21517 */	add     | xl     << dst_ | r2     << src_ ,
/* 21518 */	stmt    | 7635   << off_ ,	//	mov wa wb  get count of characters in row
/* 21519 */	move    | wa     << dst_ | wb     << src_ ,
/* 21520 */	stmt    | 7636   << off_ ,	//	mvw    copy a complete row
/* 21521 */	mvw     ,
/* 21522 */	stmt    | 7637   << off_ ,	//	dcv srtnr   decrement row count
/* 21523 */	load    | r1     << dst_ | srtnr  << off_ ,
/* 21524 */	dcv     | r1     << dst_ ,
/* 21525 */	store   | r1     << dst_ | srtnr  << off_ ,
/* 21526 */	stmt    | 7638   << off_ ,	//	bnz srtnr srt13  repeat till all rows done
/* 21527 */	load    | r1     << dst_ | srtnr  << off_ ,
/* 21528 */	bnz     | r1     << dst_ | srt13  << off_ ,
// srt15:
/* 21529 */	stmt    | 7639   << off_ ,	//srt15	mov xr (xs)+  pop result array ptr
/* 21530 */	load    | xr     << dst_ | xs     << src_ ,
/* 21531 */	ica     | xs     << dst_ ,
/* 21532 */	stmt    | 7640   << off_ ,	//	ica xs   pop key array ptr
/* 21533 */	ica     | xs     << dst_ ,
/* 21534 */	stmt    | 7641   << off_ ,	//	zer r_sxl   clear junk
/* 21535 */	store   | r0     << dst_ | r_sxl  << off_ ,
/* 21536 */	stmt    | 7642   << off_ ,	//	zer r_sxr   clear junk
/* 21537 */	store   | r0     << dst_ | r_sxr  << off_ ,
/* 21538 */	stmt    | 7643   << off_ ,	//	exi    return
/* 21539 */	exi     | 1600   << off_ ,
// srt16:
/* 21540 */	stmt    | 7644   << off_ ,	//srt16	erb 256 sort/rsort 1st arg not suitable array or table
/* 21541 */	erb     | 256    << off_ ,
// srt17:
/* 21542 */	stmt    | 7645   << off_ ,	//srt17	erb 258 sort/rsort 2nd arg out of range or non-integer
/* 21543 */	erb     | 258    << off_ ,
// srt18:
/* 21544 */	stmt    | 7646   << off_ ,	//srt18	exi 1   return indication of null table
/* 21545 */	exi     | 1601   << off_ ,
// sortc:
/* 21546 */	stmt    | 7647   << off_ ,	//sortc	prc e 1  entry point
/* 21547 */	stmt    | 7648   << off_ ,	//	mov srts1 wa  save offset 1
/* 21548 */	store   | wa     << dst_ | srts1  << off_ ,
/* 21549 */	stmt    | 7649   << off_ ,	//	mov srts2 wb  save offset 2
/* 21550 */	store   | wb     << dst_ | srts2  << off_ ,
/* 21551 */	stmt    | 7650   << off_ ,	//	mov srtsc wc  save wc
/* 21552 */	store   | wc     << dst_ | srtsc  << off_ ,
/* 21553 */	stmt    | 7651   << off_ ,	//	add xl srtof  add offset to comparand field
/* 21554 */	load    | r2     << dst_ | srtof  << off_ ,
/* 21555 */	add     | xl     << dst_ | r2     << src_ ,
/* 21556 */	stmt    | 7652   << off_ ,	//	mov xr xl  copy base + offset
/* 21557 */	move    | xr     << dst_ | xl     << src_ ,
/* 21558 */	stmt    | 7653   << off_ ,	//	add xl wa  add key1 offset
/* 21559 */	add     | xl     << dst_ | wa     << src_ ,
/* 21560 */	stmt    | 7654   << off_ ,	//	add xr wb  add key2 offset
/* 21561 */	add     | xr     << dst_ | wb     << src_ ,
/* 21562 */	stmt    | 7655   << off_ ,	//	mov xl (xl)  get key1
/* 21563 */	load    | xl     << dst_ | xl     << src_ ,
/* 21564 */	stmt    | 7656   << off_ ,	//	mov xr (xr)  get key2
/* 21565 */	load    | xr     << dst_ | xr     << src_ ,
/* 21566 */	stmt    | 7657   << off_ ,	//	bne srtdf =nulls src12 jump if datatype field name used
/* 21567 */	load    | r1     << dst_ | srtdf  << off_ ,
/* 21568 */	loadi   | r2     << dst_ | nulls  << off_ ,
/* 21569 */	bne     | r1     << dst_ | r2     << src_ | src12  << off_ ,
// src01:
/* 21570 */	stmt    | 7658   << off_ ,	//src01	mov wc (xl)  get type code
/* 21571 */	load    | wc     << dst_ | xl     << src_ ,
/* 21572 */	stmt    | 7659   << off_ ,	//	bne wc (xr) src02 skip if not same datatype
/* 21573 */	load    | r2     << dst_ | xr     << src_ ,
/* 21574 */	bne     | wc     << dst_ | r2     << src_ | src02  << off_ ,
/* 21575 */	stmt    | 7660   << off_ ,	//	beq wc =b_scl src09 jump if both strings
/* 21576 */	loadi   | r2     << dst_ | b_scl  << off_ ,
/* 21577 */	beq     | wc     << dst_ | r2     << src_ | src09  << off_ ,
/* 21578 */	stmt    | 7661   << off_ ,	//	beq wc =b_icl src14 jump if both integers
/* 21579 */	loadi   | r2     << dst_ | b_icl  << off_ ,
/* 21580 */	beq     | wc     << dst_ | r2     << src_ | src14  << off_ ,
// src02:
/* 21581 */	stmt    | 7662   << off_ ,	//src02	mov r_sxl xl  keep arg1
/* 21582 */	store   | xl     << dst_ | r_sxl  << off_ ,
/* 21583 */	stmt    | 7663   << off_ ,	//	mov r_sxr xr  keep arg2
/* 21584 */	store   | xr     << dst_ | r_sxr  << off_ ,
/* 21585 */	stmt    | 7664   << off_ ,	//	beq wc =b_scl src11 do not allow conversion to number
/* 21586 */	loadi   | r2     << dst_ | b_scl  << off_ ,
/* 21587 */	beq     | wc     << dst_ | r2     << src_ | src11  << off_ ,
/* 21588 */	stmt    | 7665   << off_ ,	//	beq (xr) =b_scl src11 if either arg is a string
/* 21589 */	load    | r1     << dst_ | xr     << src_ ,
/* 21590 */	loadi   | r2     << dst_ | b_scl  << off_ ,
/* 21591 */	beq     | r1     << dst_ | r2     << src_ | src11  << off_ ,
// src14:
/* 21592 */	stmt    | 7666   << off_ ,	//src14	mov -(xs) xl  stack
/* 21593 */	dca     | xs     << dst_ ,
/* 21594 */	store   | xl     << dst_ | xs     << src_ ,
/* 21595 */	stmt    | 7667   << off_ ,	//	mov -(xs) xr  args
/* 21596 */	dca     | xs     << dst_ ,
/* 21597 */	store   | xr     << dst_ | xs     << src_ ,
/* 21598 */	stmt    | 7668   << off_ ,	//	jsr acomp   compare objects
/* 21599 */	call    | acomp  << off_ ,
/* 21600 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/* 21601 */	ppm     | src10  << off_ ,
/* 21602 */	ppm     | src10  << off_ ,
/* 21603 */	ppm     | src03  << off_ ,
/* 21604 */	ppm     | src08  << off_ ,
/* 21605 */	ppm     | src05  << off_ ,
// src03:
/* 21606 */	stmt    | 7669   << off_ ,	//src03	bnz srtsr src06  jump if rsort
/* 21607 */	load    | r1     << dst_ | srtsr  << off_ ,
/* 21608 */	bnz     | r1     << dst_ | src06  << off_ ,
// src04:
/* 21609 */	stmt    | 7670   << off_ ,	//src04	mov wc srtsc  restore wc
/* 21610 */	load    | wc     << dst_ | srtsc  << off_ ,
/* 21611 */	stmt    | 7671   << off_ ,	//	exi 1   return
/* 21612 */	exi     | 1      << off_ ,
// src05:
/* 21613 */	stmt    | 7672   << off_ ,	//src05	bnz srtsr src04  jump if rsort
/* 21614 */	load    | r1     << dst_ | srtsr  << off_ ,
/* 21615 */	bnz     | r1     << dst_ | src04  << off_ ,
// src06:
/* 21616 */	stmt    | 7673   << off_ ,	//src06	mov wc srtsc  restore wc
/* 21617 */	load    | wc     << dst_ | srtsc  << off_ ,
/* 21618 */	stmt    | 7674   << off_ ,	//	exi    return
/* 21619 */	exi     | 0      << off_ ,
// src07:
/* 21620 */	stmt    | 7675   << off_ ,	//src07	blt xl xr src03 item first created is less
/* 21621 */	blt     | xl     << dst_ | xr     << src_ | src03  << off_ ,
/* 21622 */	stmt    | 7676   << off_ ,	//	bgt xl xr src05 addresses rise in order of creation
/* 21623 */	bgt     | xl     << dst_ | xr     << src_ | src05  << off_ ,
// src08:
/* 21624 */	stmt    | 7677   << off_ ,	//src08	blt srts1 srts2 src04 test offsets or key addrss instead
/* 21625 */	load    | r1     << dst_ | srts1  << off_ ,
/* 21626 */	load    | r2     << dst_ | srts2  << off_ ,
/* 21627 */	blt     | r1     << dst_ | r2     << src_ | src04  << off_ ,
/* 21628 */	stmt    | 7678   << off_ ,	//	brn src06   offset 1 greater
/* 21629 */	brn     | src06  << off_ ,
// src09:
/* 21630 */	stmt    | 7679   << off_ ,	//src09	mov -(xs) xl  stack
/* 21631 */	dca     | xs     << dst_ ,
/* 21632 */	store   | xl     << dst_ | xs     << src_ ,
/* 21633 */	stmt    | 7680   << off_ ,	//	mov -(xs) xr  args
/* 21634 */	dca     | xs     << dst_ ,
/* 21635 */	store   | xr     << dst_ | xs     << src_ ,
/* 21636 */	stmt    | 7681   << off_ ,	//	jsr lcomp   compare objects
/* 21637 */	call    | lcomp  << off_ ,
/* 21638 */	jsrerr  | r1     << dst_ | 5      << off_ ,
/* 21639 */	ppm     ,
/* 21640 */	ppm     ,
/* 21641 */	ppm     | src03  << off_ ,
/* 21642 */	ppm     | src08  << off_ ,
/* 21643 */	ppm     | src05  << off_ ,
// src10:
/* 21644 */	stmt    | 7682   << off_ ,	//src10	mov xl r_sxl  get arg1
/* 21645 */	load    | xl     << dst_ | r_sxl  << off_ ,
/* 21646 */	stmt    | 7683   << off_ ,	//	mov xr r_sxr  get arg2
/* 21647 */	load    | xr     << dst_ | r_sxr  << off_ ,
/* 21648 */	stmt    | 7684   << off_ ,	//	mov wc (xl)  get type of key1
/* 21649 */	load    | wc     << dst_ | xl     << src_ ,
/* 21650 */	stmt    | 7685   << off_ ,	//	beq wc (xr) src07 jump if keys of same type
/* 21651 */	load    | r2     << dst_ | xr     << src_ ,
/* 21652 */	beq     | wc     << dst_ | r2     << src_ | src07  << off_ ,
// src11:
/* 21653 */	stmt    | 7686   << off_ ,	//src11	mov xl wc  get block type word
/* 21654 */	move    | xl     << dst_ | wc     << src_ ,
/* 21655 */	stmt    | 7687   << off_ ,	//	mov xr (xr)  get block type word
/* 21656 */	load    | xr     << dst_ | xr     << src_ ,
/* 21657 */	stmt    | 7688   << off_ ,	//	lei xl   entry point id for key1
/* 21658 */	lei     | xl     << dst_ ,
/* 21659 */	stmt    | 7689   << off_ ,	//	lei xr   entry point id for key2
/* 21660 */	lei     | xr     << dst_ ,
/* 21661 */	stmt    | 7690   << off_ ,	//	bgt xl xr src05 jump if key1 gt key2
/* 21662 */	bgt     | xl     << dst_ | xr     << src_ | src05  << off_ ,
/* 21663 */	stmt    | 7691   << off_ ,	//	brn src03   key1 lt key2
/* 21664 */	brn     | src03  << off_ ,
// src12:
/* 21665 */	stmt    | 7692   << off_ ,	//src12	jsr sortf   call routine to find field 1
/* 21666 */	call    | sortf  << off_ ,
/* 21667 */	stmt    | 7693   << off_ ,	//	mov -(xs) xl  stack item pointer
/* 21668 */	dca     | xs     << dst_ ,
/* 21669 */	store   | xl     << dst_ | xs     << src_ ,
/* 21670 */	stmt    | 7694   << off_ ,	//	mov xl xr  get key2
/* 21671 */	move    | xl     << dst_ | xr     << src_ ,
/* 21672 */	stmt    | 7695   << off_ ,	//	jsr sortf   find field 2
/* 21673 */	call    | sortf  << off_ ,
/* 21674 */	stmt    | 7696   << off_ ,	//	mov xr xl  place as key2
/* 21675 */	move    | xr     << dst_ | xl     << src_ ,
/* 21676 */	stmt    | 7697   << off_ ,	//	mov xl (xs)+  recover key1
/* 21677 */	load    | xl     << dst_ | xs     << src_ ,
/* 21678 */	ica     | xs     << dst_ ,
/* 21679 */	stmt    | 7698   << off_ ,	//	brn src01   merge
/* 21680 */	brn     | src01  << off_ ,
// sortf:
/* 21681 */	stmt    | 7699   << off_ ,	//sortf	prc e 0  entry point
/* 21682 */	stmt    | 7700   << off_ ,	//	bne (xl) =b_pdt srtf3 return if not pdblk
/* 21683 */	load    | r1     << dst_ | xl     << src_ ,
/* 21684 */	loadi   | r2     << dst_ | b_pdt  << off_ ,
/* 21685 */	bne     | r1     << dst_ | r2     << src_ | srtf3  << off_ ,
/* 21686 */	stmt    | 7701   << off_ ,	//	mov -(xs) xr  keep xr
/* 21687 */	dca     | xs     << dst_ ,
/* 21688 */	store   | xr     << dst_ | xs     << src_ ,
/* 21689 */	stmt    | 7702   << off_ ,	//	mov xr srtfd  get possible former dfblk ptr
/* 21690 */	load    | xr     << dst_ | srtfd  << off_ ,
/* 21691 */	stmt    | 7703   << off_ ,	//	bze xr srtf4  jump if not
/* 21692 */	bze     | xr     << dst_ | srtf4  << off_ ,
/* 21693 */	stmt    | 7704   << off_ ,	//	bne xr pddfp(xl) srtf4 jump if not right datatype
/* 21694 */	load    | r2     << dst_ | xl     << src_ | pddfp  << off_ ,
/* 21695 */	bne     | xr     << dst_ | r2     << src_ | srtf4  << off_ ,
/* 21696 */	stmt    | 7705   << off_ ,	//	bne srtdf srtff srtf4 jump if not right field name
/* 21697 */	load    | r1     << dst_ | srtdf  << off_ ,
/* 21698 */	load    | r2     << dst_ | srtff  << off_ ,
/* 21699 */	bne     | r1     << dst_ | r2     << src_ | srtf4  << off_ ,
/* 21700 */	stmt    | 7706   << off_ ,	//	add xl srtfo  add offset to required field
/* 21701 */	load    | r2     << dst_ | srtfo  << off_ ,
/* 21702 */	add     | xl     << dst_ | r2     << src_ ,
// srtf1:
/* 21703 */	stmt    | 7707   << off_ ,	//srtf1	mov xl (xl)  get item from field
/* 21704 */	load    | xl     << dst_ | xl     << src_ ,
// srtf2:
/* 21705 */	stmt    | 7708   << off_ ,	//srtf2	mov xr (xs)+  restore xr
/* 21706 */	load    | xr     << dst_ | xs     << src_ ,
/* 21707 */	ica     | xs     << dst_ ,
// srtf3:
/* 21708 */	stmt    | 7709   << off_ ,	//srtf3	exi    return
/* 21709 */	exi     | 0      << off_ ,
// srtf4:
/* 21710 */	stmt    | 7710   << off_ ,	//srtf4	mov xr xl  copy original pointer
/* 21711 */	move    | xr     << dst_ | xl     << src_ ,
/* 21712 */	stmt    | 7711   << off_ ,	//	mov xr pddfp(xr)  point to dfblk
/* 21713 */	load    | xr     << dst_ | xr     << src_ | pddfp  << off_ ,
/* 21714 */	stmt    | 7712   << off_ ,	//	mov srtfd xr  keep a copy
/* 21715 */	store   | xr     << dst_ | srtfd  << off_ ,
/* 21716 */	stmt    | 7713   << off_ ,	//	mov wc fargs(xr)  get number of fields
/* 21717 */	load    | wc     << dst_ | xr     << src_ | fargs  << off_ ,
/* 21718 */	stmt    | 7714   << off_ ,	//	wtb wc   convert to bytes
/* 21719 */	stmt    | 7715   << off_ ,	//	add xr dflen(xr)  point past last field
/* 21720 */	load    | r2     << dst_ | xr     << src_ | dflen  << off_ ,
/* 21721 */	add     | xr     << dst_ | r2     << src_ ,
// srtf5:
/* 21722 */	stmt    | 7716   << off_ ,	//srtf5	dca wc   count down
/* 21723 */	dca     | wc     << dst_ ,
/* 21724 */	stmt    | 7717   << off_ ,	//	dca xr   point in front
/* 21725 */	dca     | xr     << dst_ ,
/* 21726 */	stmt    | 7718   << off_ ,	//	beq (xr) srtdf srtf6 skip out if found
/* 21727 */	load    | r1     << dst_ | xr     << src_ ,
/* 21728 */	load    | r2     << dst_ | srtdf  << off_ ,
/* 21729 */	beq     | r1     << dst_ | r2     << src_ | srtf6  << off_ ,
/* 21730 */	stmt    | 7719   << off_ ,	//	bnz wc srtf5  loop
/* 21731 */	bnz     | wc     << dst_ | srtf5  << off_ ,
/* 21732 */	stmt    | 7720   << off_ ,	//	brn srtf2   return - not found
/* 21733 */	brn     | srtf2  << off_ ,
// srtf6:
/* 21734 */	stmt    | 7721   << off_ ,	//srtf6	mov srtff (xr)  keep field name ptr
/* 21735 */	load    | r1     << dst_ | xr     << src_ ,
/* 21736 */	store   | r1     << dst_ | srtff  << off_ ,
/* 21737 */	stmt    | 7722   << off_ ,	//	add wc *pdfld  add offset to first field
/* 21738 */	loadi   | r2     << dst_ | pdfld  << off_ ,
/* 21739 */	add     | wc     << dst_ | r2     << src_ ,
/* 21740 */	stmt    | 7723   << off_ ,	//	mov srtfo wc  store as field offset
/* 21741 */	store   | wc     << dst_ | srtfo  << off_ ,
/* 21742 */	stmt    | 7724   << off_ ,	//	add xl wc  point to field
/* 21743 */	add     | xl     << dst_ | wc     << src_ ,
/* 21744 */	stmt    | 7725   << off_ ,	//	brn srtf1   return
/* 21745 */	brn     | srtf1  << off_ ,
// sorth:
/* 21746 */	stmt    | 7726   << off_ ,	//sorth	prc n 0  entry point
/* 21747 */	prc     | 17     << off_ ,
/* 21748 */	stmt    | 7727   << off_ ,	//	mov srtsn wa  save n
/* 21749 */	store   | wa     << dst_ | srtsn  << off_ ,
/* 21750 */	stmt    | 7728   << off_ ,	//	mov srtwc wc  keep wc
/* 21751 */	store   | wc     << dst_ | srtwc  << off_ ,
/* 21752 */	stmt    | 7729   << off_ ,	//	mov xl (xs)  sort array base adrs
/* 21753 */	load    | xl     << dst_ | xs     << src_ ,
/* 21754 */	stmt    | 7730   << off_ ,	//	add xl srtso  add offset to a(0)
/* 21755 */	load    | r2     << dst_ | srtso  << off_ ,
/* 21756 */	add     | xl     << dst_ | r2     << src_ ,
/* 21757 */	stmt    | 7731   << off_ ,	//	add xl wc  point to a(j)
/* 21758 */	add     | xl     << dst_ | wc     << src_ ,
/* 21759 */	stmt    | 7732   << off_ ,	//	mov srtrt (xl)  get offset to root
/* 21760 */	load    | r1     << dst_ | xl     << src_ ,
/* 21761 */	store   | r1     << dst_ | srtrt  << off_ ,
/* 21762 */	stmt    | 7733   << off_ ,	//	add wc wc  double j - cant exceed n
/* 21763 */	add     | wc     << dst_ | wc     << src_ ,
// srh01:
/* 21764 */	stmt    | 7734   << off_ ,	//srh01	bgt wc srtsn srh03 done if j gt n
/* 21765 */	load    | r2     << dst_ | srtsn  << off_ ,
/* 21766 */	bgt     | wc     << dst_ | r2     << src_ | srh03  << off_ ,
/* 21767 */	stmt    | 7735   << off_ ,	//	beq wc srtsn srh02 skip if j equals n
/* 21768 */	load    | r2     << dst_ | srtsn  << off_ ,
/* 21769 */	beq     | wc     << dst_ | r2     << src_ | srh02  << off_ ,
/* 21770 */	stmt    | 7736   << off_ ,	//	mov xr (xs)  sort array base adrs
/* 21771 */	load    | xr     << dst_ | xs     << src_ ,
/* 21772 */	stmt    | 7737   << off_ ,	//	mov xl num01(xs)  key array base adrs
/* 21773 */	load    | xl     << dst_ | xs     << src_ | num01  << off_ ,
/* 21774 */	stmt    | 7738   << off_ ,	//	add xr srtso  point to a(0)
/* 21775 */	load    | r2     << dst_ | srtso  << off_ ,
/* 21776 */	add     | xr     << dst_ | r2     << src_ ,
/* 21777 */	stmt    | 7739   << off_ ,	//	add xr wc  adrs of a(j)
/* 21778 */	add     | xr     << dst_ | wc     << src_ ,
/* 21779 */	stmt    | 7740   << off_ ,	//	mov wa num01(xr)  get a(j+1)
/* 21780 */	load    | wa     << dst_ | xr     << src_ | num01  << off_ ,
/* 21781 */	stmt    | 7741   << off_ ,	//	mov wb (xr)  get a(j)
/* 21782 */	load    | wb     << dst_ | xr     << src_ ,
/* 21783 */	stmt    | 7742   << off_ ,	//	jsr sortc   compare keys - lt(a(j+1),a(j))
/* 21784 */	call    | sortc  << off_ ,
/* 21785 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 21786 */	ppm     | srh02  << off_ ,
/* 21787 */	stmt    | 7743   << off_ ,	//	ica wc   point to greater son, a(j+1)
/* 21788 */	ica     | wc     << dst_ ,
// srh02:
/* 21789 */	stmt    | 7744   << off_ ,	//srh02	mov xl num01(xs)  key array base adrs
/* 21790 */	load    | xl     << dst_ | xs     << src_ | num01  << off_ ,
/* 21791 */	stmt    | 7745   << off_ ,	//	mov xr (xs)  get sort array address
/* 21792 */	load    | xr     << dst_ | xs     << src_ ,
/* 21793 */	stmt    | 7746   << off_ ,	//	add xr srtso  adrs of a(0)
/* 21794 */	load    | r2     << dst_ | srtso  << off_ ,
/* 21795 */	add     | xr     << dst_ | r2     << src_ ,
/* 21796 */	stmt    | 7747   << off_ ,	//	mov wb xr  copy this adrs
/* 21797 */	move    | wb     << dst_ | xr     << src_ ,
/* 21798 */	stmt    | 7748   << off_ ,	//	add xr wc  adrs of greater son, a(j)
/* 21799 */	add     | xr     << dst_ | wc     << src_ ,
/* 21800 */	stmt    | 7749   << off_ ,	//	mov wa (xr)  get a(j)
/* 21801 */	load    | wa     << dst_ | xr     << src_ ,
/* 21802 */	stmt    | 7750   << off_ ,	//	mov xr wb  point back to a(0)
/* 21803 */	move    | xr     << dst_ | wb     << src_ ,
/* 21804 */	stmt    | 7751   << off_ ,	//	mov wb srtrt  get root
/* 21805 */	load    | wb     << dst_ | srtrt  << off_ ,
/* 21806 */	stmt    | 7752   << off_ ,	//	jsr sortc   compare them - lt(a(j),root)
/* 21807 */	call    | sortc  << off_ ,
/* 21808 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 21809 */	ppm     | srh03  << off_ ,
/* 21810 */	stmt    | 7753   << off_ ,	//	mov xr (xs)  get sort array adrs
/* 21811 */	load    | xr     << dst_ | xs     << src_ ,
/* 21812 */	stmt    | 7754   << off_ ,	//	add xr srtso  point to a(0)
/* 21813 */	load    | r2     << dst_ | srtso  << off_ ,
/* 21814 */	add     | xr     << dst_ | r2     << src_ ,
/* 21815 */	stmt    | 7755   << off_ ,	//	mov xl xr  copy it
/* 21816 */	move    | xl     << dst_ | xr     << src_ ,
/* 21817 */	stmt    | 7756   << off_ ,	//	mov wa wc  copy j
/* 21818 */	move    | wa     << dst_ | wc     << src_ ,
/* 21819 */	stmt    | 7757   << off_ ,	//	btw wc   convert to words
/* 21820 */	stmt    | 7758   << off_ ,	//	rsh wc 1  get j/2
/* 21821 */	rsh     | wc     << dst_ | 1      << off_ ,
/* 21822 */	stmt    | 7759   << off_ ,	//	wtb wc   convert back to bytes
/* 21823 */	stmt    | 7760   << off_ ,	//	add xl wa  point to a(j)
/* 21824 */	add     | xl     << dst_ | wa     << src_ ,
/* 21825 */	stmt    | 7761   << off_ ,	//	add xr wc  adrs of a(j/2)
/* 21826 */	add     | xr     << dst_ | wc     << src_ ,
/* 21827 */	stmt    | 7762   << off_ ,	//	mov (xr) (xl)  a(j/2) = a(j)
/* 21828 */	load    | r1     << dst_ | xl     << src_ ,
/* 21829 */	store   | r1     << dst_ | xr     << src_ ,
/* 21830 */	stmt    | 7763   << off_ ,	//	mov wc wa  recover j
/* 21831 */	move    | wc     << dst_ | wa     << src_ ,
/* 21832 */	stmt    | 7764   << off_ ,	//	aov wc wc srh03 j = j*2. done if too big
/* 21833 */	aov     | wc     << dst_ | wc     << src_ | srh03  << off_ ,
/* 21834 */	stmt    | 7765   << off_ ,	//	brn srh01   loop
/* 21835 */	brn     | srh01  << off_ ,
// srh03:
/* 21836 */	stmt    | 7766   << off_ ,	//srh03	btw wc   convert to words
/* 21837 */	stmt    | 7767   << off_ ,	//	rsh wc 1  j = j/2
/* 21838 */	rsh     | wc     << dst_ | 1      << off_ ,
/* 21839 */	stmt    | 7768   << off_ ,	//	wtb wc   convert back to bytes
/* 21840 */	stmt    | 7769   << off_ ,	//	mov xr (xs)  sort array adrs
/* 21841 */	load    | xr     << dst_ | xs     << src_ ,
/* 21842 */	stmt    | 7770   << off_ ,	//	add xr srtso  adrs of a(0)
/* 21843 */	load    | r2     << dst_ | srtso  << off_ ,
/* 21844 */	add     | xr     << dst_ | r2     << src_ ,
/* 21845 */	stmt    | 7771   << off_ ,	//	add xr wc  adrs of a(j/2)
/* 21846 */	add     | xr     << dst_ | wc     << src_ ,
/* 21847 */	stmt    | 7772   << off_ ,	//	mov (xr) srtrt  a(j/2) = root
/* 21848 */	load    | r1     << dst_ | srtrt  << off_ ,
/* 21849 */	store   | r1     << dst_ | xr     << src_ ,
/* 21850 */	stmt    | 7773   << off_ ,	//	mov wa srtsn  restore wa
/* 21851 */	load    | wa     << dst_ | srtsn  << off_ ,
/* 21852 */	stmt    | 7774   << off_ ,	//	mov wc srtwc  restore wc
/* 21853 */	load    | wc     << dst_ | srtwc  << off_ ,
/* 21854 */	stmt    | 7775   << off_ ,	//	exi    return
/* 21855 */	exi     | 1700   << off_ ,
// trace:
/* 21856 */	stmt    | 7776   << off_ ,	//trace	prc n 2  entry point
/* 21857 */	prc     | 18     << off_ ,
/* 21858 */	stmt    | 7777   << off_ ,	//	jsr gtstg   get trace type string
/* 21859 */	call    | gtstg  << off_ ,
/* 21860 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 21861 */	ppm     | trc15  << off_ ,
/* 21862 */	stmt    | 7778   << off_ ,	//	plc xr   else point to string
/* 21863 */	plc     | xr     << dst_ ,
/* 21864 */	stmt    | 7779   << off_ ,	//	lch wa (xr)  load first character
/* 21865 */	load    | wa     << dst_ | xr     << src_ ,
/* 21866 */	stmt    | 7780   << off_ ,	//	mov xr (xs)  load name argument
/* 21867 */	load    | xr     << dst_ | xs     << src_ ,
/* 21868 */	stmt    | 7781   << off_ ,	//	mov (xs) xl  stack trblk ptr or zero
/* 21869 */	store   | xl     << dst_ | xs     << src_ ,
/* 21870 */	stmt    | 7782   << off_ ,	//	mov wc =trtac  set trtyp for access trace
/* 21871 */	loadi   | wc     << dst_ | trtac  << off_ ,
/* 21872 */	stmt    | 7783   << off_ ,	//	beq wa =ch_la trc10 jump if a (access)
/* 21873 */	loadi   | r2     << dst_ | ch_la  << off_ ,
/* 21874 */	beq     | wa     << dst_ | r2     << src_ | trc10  << off_ ,
/* 21875 */	stmt    | 7784   << off_ ,	//	mov wc =trtvl  set trtyp for value trace
/* 21876 */	loadi   | wc     << dst_ | trtvl  << off_ ,
/* 21877 */	stmt    | 7785   << off_ ,	//	beq wa =ch_lv trc10 jump if v (value)
/* 21878 */	loadi   | r2     << dst_ | ch_lv  << off_ ,
/* 21879 */	beq     | wa     << dst_ | r2     << src_ | trc10  << off_ ,
/* 21880 */	stmt    | 7786   << off_ ,	//	beq wa =ch_bl trc10 jump if blank (value)
/* 21881 */	loadi   | r2     << dst_ | ch_bl  << off_ ,
/* 21882 */	beq     | wa     << dst_ | r2     << src_ | trc10  << off_ ,
/* 21883 */	stmt    | 7787   << off_ ,	//	beq wa =ch_lf trc01 jump if f (function)
/* 21884 */	loadi   | r2     << dst_ | ch_lf  << off_ ,
/* 21885 */	beq     | wa     << dst_ | r2     << src_ | trc01  << off_ ,
/* 21886 */	stmt    | 7788   << off_ ,	//	beq wa =ch_lr trc01 jump if r (return)
/* 21887 */	loadi   | r2     << dst_ | ch_lr  << off_ ,
/* 21888 */	beq     | wa     << dst_ | r2     << src_ | trc01  << off_ ,
/* 21889 */	stmt    | 7789   << off_ ,	//	beq wa =ch_ll trc03 jump if l (label)
/* 21890 */	loadi   | r2     << dst_ | ch_ll  << off_ ,
/* 21891 */	beq     | wa     << dst_ | r2     << src_ | trc03  << off_ ,
/* 21892 */	stmt    | 7790   << off_ ,	//	beq wa =ch_lk trc06 jump if k (keyword)
/* 21893 */	loadi   | r2     << dst_ | ch_lk  << off_ ,
/* 21894 */	beq     | wa     << dst_ | r2     << src_ | trc06  << off_ ,
/* 21895 */	stmt    | 7791   << off_ ,	//	bne wa =ch_lc trc15 else error if not c (call)
/* 21896 */	loadi   | r2     << dst_ | ch_lc  << off_ ,
/* 21897 */	bne     | wa     << dst_ | r2     << src_ | trc15  << off_ ,
// trc01:
/* 21898 */	stmt    | 7792   << off_ ,	//trc01	jsr gtnvr   point to vrblk for name
/* 21899 */	call    | gtnvr  << off_ ,
/* 21900 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 21901 */	ppm     | trc16  << off_ ,
/* 21902 */	stmt    | 7793   << off_ ,	//	ica xs   pop stack
/* 21903 */	ica     | xs     << dst_ ,
/* 21904 */	stmt    | 7794   << off_ ,	//	mov xr vrfnc(xr)  point to function block
/* 21905 */	load    | xr     << dst_ | xr     << src_ | vrfnc  << off_ ,
/* 21906 */	stmt    | 7795   << off_ ,	//	bne (xr) =b_pfc trc17 error if not program function
/* 21907 */	load    | r1     << dst_ | xr     << src_ ,
/* 21908 */	loadi   | r2     << dst_ | b_pfc  << off_ ,
/* 21909 */	bne     | r1     << dst_ | r2     << src_ | trc17  << off_ ,
/* 21910 */	stmt    | 7796   << off_ ,	//	beq wa =ch_lr trc02 jump if r (return)
/* 21911 */	loadi   | r2     << dst_ | ch_lr  << off_ ,
/* 21912 */	beq     | wa     << dst_ | r2     << src_ | trc02  << off_ ,
/* 21913 */	stmt    | 7797   << off_ ,	//	mov pfctr(xr) xl  set/reset call trace
/* 21914 */	store   | xl     << dst_ | xr     << src_ | pfctr  << off_ ,
/* 21915 */	stmt    | 7798   << off_ ,	//	beq wa =ch_lc exnul exit with null if c (call)
/* 21916 */	loadi   | r2     << dst_ | ch_lc  << off_ ,
/* 21917 */	beq     | wa     << dst_ | r2     << src_ | exnul  << off_ ,
// trc02:
/* 21918 */	stmt    | 7799   << off_ ,	//trc02	mov pfrtr(xr) xl  set/reset return trace
/* 21919 */	store   | xl     << dst_ | xr     << src_ | pfrtr  << off_ ,
/* 21920 */	stmt    | 7800   << off_ ,	//	exi    return
/* 21921 */	exi     | 1800   << off_ ,
// trc03:
/* 21922 */	stmt    | 7801   << off_ ,	//trc03	jsr gtnvr   point to vrblk
/* 21923 */	call    | gtnvr  << off_ ,
/* 21924 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 21925 */	ppm     | trc16  << off_ ,
/* 21926 */	stmt    | 7802   << off_ ,	//	mov xl vrlbl(xr)  load label pointer
/* 21927 */	load    | xl     << dst_ | xr     << src_ | vrlbl  << off_ ,
/* 21928 */	stmt    | 7803   << off_ ,	//	bne (xl) =b_trt trc04 jump if no old trace
/* 21929 */	load    | r1     << dst_ | xl     << src_ ,
/* 21930 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 21931 */	bne     | r1     << dst_ | r2     << src_ | trc04  << off_ ,
/* 21932 */	stmt    | 7804   << off_ ,	//	mov xl trlbl(xl)  else delete old trace association
/* 21933 */	load    | xl     << dst_ | xl     << src_ | trlbl  << off_ ,
// trc04:
/* 21934 */	stmt    | 7805   << off_ ,	//trc04	beq xl =stndl trc16 error if undefined label
/* 21935 */	loadi   | r2     << dst_ | stndl  << off_ ,
/* 21936 */	beq     | xl     << dst_ | r2     << src_ | trc16  << off_ ,
/* 21937 */	stmt    | 7806   << off_ ,	//	mov wb (xs)+  get trblk ptr again
/* 21938 */	load    | wb     << dst_ | xs     << src_ ,
/* 21939 */	ica     | xs     << dst_ ,
/* 21940 */	stmt    | 7807   << off_ ,	//	bze wb trc05  jump if stoptr case
/* 21941 */	bze     | wb     << dst_ | trc05  << off_ ,
/* 21942 */	stmt    | 7808   << off_ ,	//	mov vrlbl(xr) wb  else set new trblk pointer
/* 21943 */	store   | wb     << dst_ | xr     << src_ | vrlbl  << off_ ,
/* 21944 */	stmt    | 7809   << off_ ,	//	mov vrtra(xr) =b_vrt  set label trace routine address
/* 21945 */	loadi   | r1     << dst_ | b_vrt  << off_ ,
/* 21946 */	store   | r1     << dst_ | xr     << src_ | vrtra  << off_ ,
/* 21947 */	stmt    | 7810   << off_ ,	//	mov xr wb  copy trblk pointer
/* 21948 */	move    | xr     << dst_ | wb     << src_ ,
/* 21949 */	stmt    | 7811   << off_ ,	//	mov trlbl(xr) xl  store real label in trblk
/* 21950 */	store   | xl     << dst_ | xr     << src_ | trlbl  << off_ ,
/* 21951 */	stmt    | 7812   << off_ ,	//	exi    return
/* 21952 */	exi     | 1800   << off_ ,
// trc05:
/* 21953 */	stmt    | 7813   << off_ ,	//trc05	mov vrlbl(xr) xl  store label ptr back in vrblk
/* 21954 */	store   | xl     << dst_ | xr     << src_ | vrlbl  << off_ ,
/* 21955 */	stmt    | 7814   << off_ ,	//	mov vrtra(xr) =b_vrg  store normal transfer address
/* 21956 */	loadi   | r1     << dst_ | b_vrg  << off_ ,
/* 21957 */	store   | r1     << dst_ | xr     << src_ | vrtra  << off_ ,
/* 21958 */	stmt    | 7815   << off_ ,	//	exi    return
/* 21959 */	exi     | 1800   << off_ ,
// trc06:
/* 21960 */	stmt    | 7816   << off_ ,	//trc06	jsr gtnvr   point to vrblk
/* 21961 */	call    | gtnvr  << off_ ,
/* 21962 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 21963 */	ppm     | trc16  << off_ ,
/* 21964 */	stmt    | 7817   << off_ ,	//	bnz vrlen(xr) trc16  error if not system var
/* 21965 */	load    | r1     << dst_ | xr     << src_ | vrlen  << off_ ,
/* 21966 */	bnz     | r1     << dst_ | trc16  << off_ ,
/* 21967 */	stmt    | 7818   << off_ ,	//	ica xs   pop stack
/* 21968 */	ica     | xs     << dst_ ,
/* 21969 */	stmt    | 7819   << off_ ,	//	bze xl trc07  jump if stoptr case
/* 21970 */	bze     | xl     << dst_ | trc07  << off_ ,
/* 21971 */	stmt    | 7820   << off_ ,	//	mov trkvr(xl) xr  store vrblk ptr in trblk for ktrex
/* 21972 */	store   | xr     << dst_ | xl     << src_ | trkvr  << off_ ,
// trc07:
/* 21973 */	stmt    | 7821   << off_ ,	//trc07	mov xr vrsvp(xr)  point to svblk
/* 21974 */	load    | xr     << dst_ | xr     << src_ | vrsvp  << off_ ,
/* 21975 */	stmt    | 7822   << off_ ,	//	beq xr =v_ert trc08 jump if errtype
/* 21976 */	loadi   | r2     << dst_ | v_ert  << off_ ,
/* 21977 */	beq     | xr     << dst_ | r2     << src_ | trc08  << off_ ,
/* 21978 */	stmt    | 7823   << off_ ,	//	beq xr =v_stc trc09 jump if stcount
/* 21979 */	loadi   | r2     << dst_ | v_stc  << off_ ,
/* 21980 */	beq     | xr     << dst_ | r2     << src_ | trc09  << off_ ,
/* 21981 */	stmt    | 7824   << off_ ,	//	bne xr =v_fnc trc17 else error if not fnclevel
/* 21982 */	loadi   | r2     << dst_ | v_fnc  << off_ ,
/* 21983 */	bne     | xr     << dst_ | r2     << src_ | trc17  << off_ ,
/* 21984 */	stmt    | 7825   << off_ ,	//	mov r_fnc xl  set/reset fnclevel trace
/* 21985 */	store   | xl     << dst_ | r_fnc  << off_ ,
/* 21986 */	stmt    | 7826   << off_ ,	//	exi    return
/* 21987 */	exi     | 1800   << off_ ,
// trc08:
/* 21988 */	stmt    | 7827   << off_ ,	//trc08	mov r_ert xl  set/reset errtype trace
/* 21989 */	store   | xl     << dst_ | r_ert  << off_ ,
/* 21990 */	stmt    | 7828   << off_ ,	//	exi    return
/* 21991 */	exi     | 1800   << off_ ,
// trc09:
/* 21992 */	stmt    | 7829   << off_ ,	//trc09	mov r_stc xl  set/reset stcount trace
/* 21993 */	store   | xl     << dst_ | r_stc  << off_ ,
/* 21994 */	stmt    | 7830   << off_ ,	//	jsr stgcc   update countdown counters
/* 21995 */	call    | stgcc  << off_ ,
/* 21996 */	stmt    | 7831   << off_ ,	//	exi    return
/* 21997 */	exi     | 1800   << off_ ,
// trc10:
/* 21998 */	stmt    | 7832   << off_ ,	//trc10	jsr gtvar   locate variable
/* 21999 */	call    | gtvar  << off_ ,
/* 22000 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 22001 */	ppm     | trc16  << off_ ,
/* 22002 */	stmt    | 7833   << off_ ,	//	mov wb (xs)+  get new trblk ptr again
/* 22003 */	load    | wb     << dst_ | xs     << src_ ,
/* 22004 */	ica     | xs     << dst_ ,
/* 22005 */	stmt    | 7834   << off_ ,	//	add wa xl  point to variable location
/* 22006 */	add     | wa     << dst_ | xl     << src_ ,
/* 22007 */	stmt    | 7835   << off_ ,	//	mov xr wa  copy variable pointer
/* 22008 */	move    | xr     << dst_ | wa     << src_ ,
// trc11:
/* 22009 */	stmt    | 7836   << off_ ,	//trc11	mov xl (xr)  point to next entry
/* 22010 */	load    | xl     << dst_ | xr     << src_ ,
/* 22011 */	stmt    | 7837   << off_ ,	//	bne (xl) =b_trt trc13 jump if not trblk
/* 22012 */	load    | r1     << dst_ | xl     << src_ ,
/* 22013 */	loadi   | r2     << dst_ | b_trt  << off_ ,
/* 22014 */	bne     | r1     << dst_ | r2     << src_ | trc13  << off_ ,
/* 22015 */	stmt    | 7838   << off_ ,	//	blt wc trtyp(xl) trc13 jump if too far out on chain
/* 22016 */	load    | r2     << dst_ | xl     << src_ | trtyp  << off_ ,
/* 22017 */	blt     | wc     << dst_ | r2     << src_ | trc13  << off_ ,
/* 22018 */	stmt    | 7839   << off_ ,	//	beq wc trtyp(xl) trc12 jump if this matches our type
/* 22019 */	load    | r2     << dst_ | xl     << src_ | trtyp  << off_ ,
/* 22020 */	beq     | wc     << dst_ | r2     << src_ | trc12  << off_ ,
/* 22021 */	stmt    | 7840   << off_ ,	//	add xl *trnxt  else point to link field
/* 22022 */	loadi   | r2     << dst_ | trnxt  << off_ ,
/* 22023 */	add     | xl     << dst_ | r2     << src_ ,
/* 22024 */	stmt    | 7841   << off_ ,	//	mov xr xl  copy pointer
/* 22025 */	move    | xr     << dst_ | xl     << src_ ,
/* 22026 */	stmt    | 7842   << off_ ,	//	brn trc11   and loop back
/* 22027 */	brn     | trc11  << off_ ,
// trc12:
/* 22028 */	stmt    | 7843   << off_ ,	//trc12	mov xl trnxt(xl)  get ptr to next block or value
/* 22029 */	load    | xl     << dst_ | xl     << src_ | trnxt  << off_ ,
/* 22030 */	stmt    | 7844   << off_ ,	//	mov (xr) xl  store to delete this trblk
/* 22031 */	store   | xl     << dst_ | xr     << src_ ,
// trc13:
/* 22032 */	stmt    | 7845   << off_ ,	//trc13	bze wb trc14  jump if stoptr case
/* 22033 */	bze     | wb     << dst_ | trc14  << off_ ,
/* 22034 */	stmt    | 7846   << off_ ,	//	mov (xr) wb  else link new trblk in
/* 22035 */	store   | wb     << dst_ | xr     << src_ ,
/* 22036 */	stmt    | 7847   << off_ ,	//	mov xr wb  copy trblk pointer
/* 22037 */	move    | xr     << dst_ | wb     << src_ ,
/* 22038 */	stmt    | 7848   << off_ ,	//	mov trnxt(xr) xl  store forward pointer
/* 22039 */	store   | xl     << dst_ | xr     << src_ | trnxt  << off_ ,
/* 22040 */	stmt    | 7849   << off_ ,	//	mov trtyp(xr) wc  store appropriate trap type code
/* 22041 */	store   | wc     << dst_ | xr     << src_ | trtyp  << off_ ,
// trc14:
/* 22042 */	stmt    | 7850   << off_ ,	//trc14	mov xr wa  recall possible vrblk pointer
/* 22043 */	move    | xr     << dst_ | wa     << src_ ,
/* 22044 */	stmt    | 7851   << off_ ,	//	sub xr *vrval  point back to vrblk
/* 22045 */	loadi   | r2     << dst_ | vrval  << off_ ,
/* 22046 */	sub     | xr     << dst_ | r2     << src_ ,
/* 22047 */	stmt    | 7852   << off_ ,	//	jsr setvr   set fields if vrblk
/* 22048 */	call    | setvr  << off_ ,
/* 22049 */	stmt    | 7853   << off_ ,	//	exi    return
/* 22050 */	exi     | 1800   << off_ ,
// trc15:
/* 22051 */	stmt    | 7854   << off_ ,	//trc15	exi 2   take bad trace type error exit
/* 22052 */	exi     | 1802   << off_ ,
// trc16:
/* 22053 */	stmt    | 7855   << off_ ,	//trc16	ica xs   pop stack
/* 22054 */	ica     | xs     << dst_ ,
// trc17:
/* 22055 */	stmt    | 7856   << off_ ,	//trc17	exi 1   take bad name error exit
/* 22056 */	exi     | 1801   << off_ ,
// trbld:
/* 22057 */	stmt    | 7857   << off_ ,	//trbld	prc e 0  entry point
/* 22058 */	stmt    | 7858   << off_ ,	//	mov -(xs) xr  stack trtag (or trfnm)
/* 22059 */	dca     | xs     << dst_ ,
/* 22060 */	store   | xr     << dst_ | xs     << src_ ,
/* 22061 */	stmt    | 7859   << off_ ,	//	mov wa *trsi_  set size of trblk
/* 22062 */	loadi   | wa     << dst_ | trsi_  << off_ ,
/* 22063 */	stmt    | 7860   << off_ ,	//	jsr alloc   allocate trblk
/* 22064 */	call    | alloc  << off_ ,
/* 22065 */	stmt    | 7861   << off_ ,	//	mov (xr) =b_trt  store first word
/* 22066 */	loadi   | r1     << dst_ | b_trt  << off_ ,
/* 22067 */	store   | r1     << dst_ | xr     << src_ ,
/* 22068 */	stmt    | 7862   << off_ ,	//	mov trfnc(xr) xl  store trfnc (or trfpt)
/* 22069 */	store   | xl     << dst_ | xr     << src_ | trfnc  << off_ ,
/* 22070 */	stmt    | 7863   << off_ ,	//	mov trtag(xr) (xs)+  store trtag (or trfnm)
/* 22071 */	load    | r1     << dst_ | xs     << src_ ,
/* 22072 */	ica     | xs     << dst_ ,
/* 22073 */	store   | r1     << dst_ | xr     << src_ | trtag  << off_ ,
/* 22074 */	stmt    | 7864   << off_ ,	//	mov trtyp(xr) wb  store type
/* 22075 */	store   | wb     << dst_ | xr     << src_ | trtyp  << off_ ,
/* 22076 */	stmt    | 7865   << off_ ,	//	mov trval(xr) =nulls  for now, a null value
/* 22077 */	loadi   | r1     << dst_ | nulls  << off_ ,
/* 22078 */	store   | r1     << dst_ | xr     << src_ | trval  << off_ ,
/* 22079 */	stmt    | 7866   << off_ ,	//	exi    return to caller
/* 22080 */	exi     | 0      << off_ ,
// trimr:
/* 22081 */	stmt    | 7867   << off_ ,	//trimr	prc e 0  entry point
/* 22082 */	stmt    | 7868   << off_ ,	//	mov xl xr  copy string pointer
/* 22083 */	move    | xl     << dst_ | xr     << src_ ,
/* 22084 */	stmt    | 7869   << off_ ,	//	mov wa sclen(xr)  load string length
/* 22085 */	load    | wa     << dst_ | xr     << src_ | sclen  << off_ ,
/* 22086 */	stmt    | 7870   << off_ ,	//	bze wa trim2  jump if null input
/* 22087 */	bze     | wa     << dst_ | trim2  << off_ ,
/* 22088 */	stmt    | 7871   << off_ ,	//	plc xl wa  else point past last character
/* 22089 */	plc     | xl     << dst_ | wa     << src_ ,
/* 22090 */	stmt    | 7872   << off_ ,	//	bze wb trim3  jump if no trim
/* 22091 */	bze     | wb     << dst_ | trim3  << off_ ,
/* 22092 */	stmt    | 7873   << off_ ,	//	mov wc =ch_bl  load blank character
/* 22093 */	loadi   | wc     << dst_ | ch_bl  << off_ ,
// trim0:
/* 22094 */	stmt    | 7874   << off_ ,	//trim0	lch wb -(xl)  load next character
/* 22095 */	dca     | xl     << dst_ ,
/* 22096 */	load    | wb     << dst_ | xl     << src_ ,
/* 22097 */	stmt    | 7875   << off_ ,	//	beq wb =ch_ht trim1 jump if horizontal tab
/* 22098 */	loadi   | r2     << dst_ | ch_ht  << off_ ,
/* 22099 */	beq     | wb     << dst_ | r2     << src_ | trim1  << off_ ,
/* 22100 */	stmt    | 7876   << off_ ,	//	bne wb wc trim3 jump if non-blank found
/* 22101 */	bne     | wb     << dst_ | wc     << src_ | trim3  << off_ ,
// trim1:
/* 22102 */	stmt    | 7877   << off_ ,	//trim1	dcv wa   else decrement character count
/* 22103 */	dcv     | wa     << dst_ ,
/* 22104 */	stmt    | 7878   << off_ ,	//	bnz wa trim0  loop back if more to check
/* 22105 */	bnz     | wa     << dst_ | trim0  << off_ ,
// trim2:
/* 22106 */	stmt    | 7879   << off_ ,	//trim2	mov dnamp xr  wipe out input string block
/* 22107 */	store   | xr     << dst_ | dnamp  << off_ ,
/* 22108 */	stmt    | 7880   << off_ ,	//	mov xr =nulls  load null result
/* 22109 */	loadi   | xr     << dst_ | nulls  << off_ ,
/* 22110 */	stmt    | 7881   << off_ ,	//	brn trim5   merge to exit
/* 22111 */	brn     | trim5  << off_ ,
// trim3:
/* 22112 */	stmt    | 7882   << off_ ,	//trim3	mov sclen(xr) wa  set new length
/* 22113 */	store   | wa     << dst_ | xr     << src_ | sclen  << off_ ,
/* 22114 */	stmt    | 7883   << off_ ,	//	mov xl xr  copy string pointer
/* 22115 */	move    | xl     << dst_ | xr     << src_ ,
/* 22116 */	stmt    | 7884   << off_ ,	//	psc xl wa  ready for storing blanks
/* 22117 */	psc     | xl     << dst_ | wa     << src_ ,
/* 22118 */	stmt    | 7885   << off_ ,	//	ctb wa schar  get length of block in bytes
/* 22119 */	ctb     | wa     << dst_ | schar  << off_ ,
/* 22120 */	stmt    | 7886   << off_ ,	//	add wa xr  point past new block
/* 22121 */	add     | wa     << dst_ | xr     << src_ ,
/* 22122 */	stmt    | 7887   << off_ ,	//	mov dnamp wa  set new top of storage pointer
/* 22123 */	store   | wa     << dst_ | dnamp  << off_ ,
/* 22124 */	stmt    | 7888   << off_ ,	//	lct wa =cfp_c  get count of chars in word
/* 22125 */	loadi   | wa     << dst_ | cfp_c  << off_ ,
/* 22126 */	stmt    | 7889   << off_ ,	//	zer wc   set zero char
/* 22127 */	move    | wc     << dst_ ,
// trim4:
/* 22128 */	stmt    | 7890   << off_ ,	//trim4	sch wc (xl)+  store zero character
/* 22129 */	store   | wc     << dst_ | xl     << src_ ,
/* 22130 */	ica     | xl     << dst_ ,
/* 22131 */	stmt    | 7891   << off_ ,	//	bct wa trim4  loop back till all stored
/* 22132 */	bct     | wa     << dst_ | trim4  << off_ ,
/* 22133 */	stmt    | 7892   << off_ ,	//	csc xl   complete store characters
// trim5:
/* 22134 */	stmt    | 7893   << off_ ,	//trim5	zer xl   clear garbage xl pointer
/* 22135 */	move    | xl     << dst_ ,
/* 22136 */	stmt    | 7894   << off_ ,	//	exi    return to caller
/* 22137 */	exi     | 0      << off_ ,
// trxeq:
/* 22138 */	stmt    | 7895   << off_ ,	//trxeq	prc r 0  entry point (recursive)
/* 22139 */	stmt    | 7896   << off_ ,	//	mov wc r_cod  load code block pointer
/* 22140 */	load    | wc     << dst_ | r_cod  << off_ ,
/* 22141 */	stmt    | 7897   << off_ ,	//	scp wb   get current code pointer
/* 22142 */	scp     | wb     << dst_ ,
/* 22143 */	stmt    | 7898   << off_ ,	//	sub wb wc  make code pointer into offset
/* 22144 */	sub     | wb     << dst_ | wc     << src_ ,
/* 22145 */	stmt    | 7899   << off_ ,	//	mov -(xs) kvtra  stack trace keyword value
/* 22146 */	load    | r1     << dst_ | kvtra  << off_ ,
/* 22147 */	dca     | xs     << dst_ ,
/* 22148 */	store   | r1     << dst_ | xs     << src_ ,
/* 22149 */	stmt    | 7900   << off_ ,	//	mov -(xs) xr  stack trblk pointer
/* 22150 */	dca     | xs     << dst_ ,
/* 22151 */	store   | xr     << dst_ | xs     << src_ ,
/* 22152 */	stmt    | 7901   << off_ ,	//	mov -(xs) xl  stack name base
/* 22153 */	dca     | xs     << dst_ ,
/* 22154 */	store   | xl     << dst_ | xs     << src_ ,
/* 22155 */	stmt    | 7902   << off_ ,	//	mov -(xs) wa  stack name offset
/* 22156 */	dca     | xs     << dst_ ,
/* 22157 */	store   | wa     << dst_ | xs     << src_ ,
/* 22158 */	stmt    | 7903   << off_ ,	//	mov -(xs) wc  stack code block pointer
/* 22159 */	dca     | xs     << dst_ ,
/* 22160 */	store   | wc     << dst_ | xs     << src_ ,
/* 22161 */	stmt    | 7904   << off_ ,	//	mov -(xs) wb  stack code pointer offset
/* 22162 */	dca     | xs     << dst_ ,
/* 22163 */	store   | wb     << dst_ | xs     << src_ ,
/* 22164 */	stmt    | 7905   << off_ ,	//	mov -(xs) flptr  stack old failure pointer
/* 22165 */	load    | r1     << dst_ | flptr  << off_ ,
/* 22166 */	dca     | xs     << dst_ ,
/* 22167 */	store   | r1     << dst_ | xs     << src_ ,
/* 22168 */	stmt    | 7906   << off_ ,	//	zer -(xs)   set dummy fail offset
/* 22169 */	dca     | xs     << dst_ ,
/* 22170 */	store   | r0     << dst_ | xs     << src_ ,
/* 22171 */	stmt    | 7907   << off_ ,	//	mov flptr xs  set new failure pointer
/* 22172 */	store   | xs     << dst_ | flptr  << off_ ,
/* 22173 */	stmt    | 7908   << off_ ,	//	zer kvtra   reset trace keyword to zero
/* 22174 */	store   | r0     << dst_ | kvtra  << off_ ,
/* 22175 */	stmt    | 7909   << off_ ,	//	mov wc =trxdc  load new (dummy) code blk pointer
/* 22176 */	loadi   | wc     << dst_ | trxdc  << off_ ,
/* 22177 */	stmt    | 7910   << off_ ,	//	mov r_cod wc  set as code block pointer
/* 22178 */	store   | wc     << dst_ | r_cod  << off_ ,
/* 22179 */	stmt    | 7911   << off_ ,	//	lcp wc   and new code pointer
/* 22180 */	lcp     | wc     << dst_ ,
/* 22181 */	stmt    | 7912   << off_ ,	//	mov wb wa  save name offset
/* 22182 */	move    | wb     << dst_ | wa     << src_ ,
/* 22183 */	stmt    | 7913   << off_ ,	//	mov wa *nmsi_  load nmblk size
/* 22184 */	loadi   | wa     << dst_ | nmsi_  << off_ ,
/* 22185 */	stmt    | 7914   << off_ ,	//	jsr alloc   allocate space for nmblk
/* 22186 */	call    | alloc  << off_ ,
/* 22187 */	stmt    | 7915   << off_ ,	//	mov (xr) =b_nml  set type word
/* 22188 */	loadi   | r1     << dst_ | b_nml  << off_ ,
/* 22189 */	store   | r1     << dst_ | xr     << src_ ,
/* 22190 */	stmt    | 7916   << off_ ,	//	mov nmbas(xr) xl  store name base
/* 22191 */	store   | xl     << dst_ | xr     << src_ | nmbas  << off_ ,
/* 22192 */	stmt    | 7917   << off_ ,	//	mov nmofs(xr) wb  store name offset
/* 22193 */	store   | wb     << dst_ | xr     << src_ | nmofs  << off_ ,
/* 22194 */	stmt    | 7918   << off_ ,	//	mov xl 6(xs)  reload pointer to trblk
/* 22195 */	load    | xl     << dst_ | xs     << src_ | 6      << off_ ,
/* 22196 */	stmt    | 7919   << off_ ,	//	mov -(xs) xr  stack nmblk pointer (1st argument)
/* 22197 */	dca     | xs     << dst_ ,
/* 22198 */	store   | xr     << dst_ | xs     << src_ ,
/* 22199 */	stmt    | 7920   << off_ ,	//	mov -(xs) trtag(xl)  stack trace tag (2nd argument)
/* 22200 */	load    | r1     << dst_ | xl     << src_ | trtag  << off_ ,
/* 22201 */	dca     | xs     << dst_ ,
/* 22202 */	store   | r1     << dst_ | xs     << src_ ,
/* 22203 */	stmt    | 7921   << off_ ,	//	mov xl trfnc(xl)  load trace vrblk pointer
/* 22204 */	load    | xl     << dst_ | xl     << src_ | trfnc  << off_ ,
/* 22205 */	stmt    | 7922   << off_ ,	//	mov xl vrfnc(xl)  load trace function pointer
/* 22206 */	load    | xl     << dst_ | xl     << src_ | vrfnc  << off_ ,
/* 22207 */	stmt    | 7923   << off_ ,	//	beq xl =stndf trxq2 jump if not a defined function
/* 22208 */	loadi   | r2     << dst_ | stndf  << off_ ,
/* 22209 */	beq     | xl     << dst_ | r2     << src_ | trxq2  << off_ ,
/* 22210 */	stmt    | 7924   << off_ ,	//	mov wa =num02  set number of arguments to two
/* 22211 */	loadi   | wa     << dst_ | num02  << off_ ,
/* 22212 */	stmt    | 7925   << off_ ,	//	brn cfunc   jump to call function
/* 22213 */	brn     | cfunc  << off_ ,
// trxq1:
/* 22214 */	stmt    | 7926   << off_ ,	//trxq1	mov xs flptr  point back to our stack entries
/* 22215 */	load    | xs     << dst_ | flptr  << off_ ,
/* 22216 */	stmt    | 7927   << off_ ,	//	ica xs   pop off garbage fail offset
/* 22217 */	ica     | xs     << dst_ ,
/* 22218 */	stmt    | 7928   << off_ ,	//	mov flptr (xs)+  restore old failure pointer
/* 22219 */	load    | r1     << dst_ | xs     << src_ ,
/* 22220 */	ica     | xs     << dst_ ,
/* 22221 */	store   | r1     << dst_ | flptr  << off_ ,
/* 22222 */	stmt    | 7929   << off_ ,	//	mov wb (xs)+  reload code offset
/* 22223 */	load    | wb     << dst_ | xs     << src_ ,
/* 22224 */	ica     | xs     << dst_ ,
/* 22225 */	stmt    | 7930   << off_ ,	//	mov wc (xs)+  load old code base pointer
/* 22226 */	load    | wc     << dst_ | xs     << src_ ,
/* 22227 */	ica     | xs     << dst_ ,
/* 22228 */	stmt    | 7931   << off_ ,	//	mov xr wc  copy cdblk pointer
/* 22229 */	move    | xr     << dst_ | wc     << src_ ,
/* 22230 */	stmt    | 7932   << off_ ,	//	mov kvstn cdstm(xr)  restore stmnt no
/* 22231 */	load    | r1     << dst_ | xr     << src_ | cdstm  << off_ ,
/* 22232 */	store   | r1     << dst_ | kvstn  << off_ ,
/* 22233 */	stmt    | 7933   << off_ ,	//	mov wa (xs)+  reload name offset
/* 22234 */	load    | wa     << dst_ | xs     << src_ ,
/* 22235 */	ica     | xs     << dst_ ,
/* 22236 */	stmt    | 7934   << off_ ,	//	mov xl (xs)+  reload name base
/* 22237 */	load    | xl     << dst_ | xs     << src_ ,
/* 22238 */	ica     | xs     << dst_ ,
/* 22239 */	stmt    | 7935   << off_ ,	//	mov xr (xs)+  reload trblk pointer
/* 22240 */	load    | xr     << dst_ | xs     << src_ ,
/* 22241 */	ica     | xs     << dst_ ,
/* 22242 */	stmt    | 7936   << off_ ,	//	mov kvtra (xs)+  restore trace keyword value
/* 22243 */	load    | r1     << dst_ | xs     << src_ ,
/* 22244 */	ica     | xs     << dst_ ,
/* 22245 */	store   | r1     << dst_ | kvtra  << off_ ,
/* 22246 */	stmt    | 7937   << off_ ,	//	add wb wc  recompute absolute code pointer
/* 22247 */	add     | wb     << dst_ | wc     << src_ ,
/* 22248 */	stmt    | 7938   << off_ ,	//	lcp wb   restore code pointer
/* 22249 */	lcp     | wb     << dst_ ,
/* 22250 */	stmt    | 7939   << off_ ,	//	mov r_cod wc  and code block pointer
/* 22251 */	store   | wc     << dst_ | r_cod  << off_ ,
/* 22252 */	stmt    | 7940   << off_ ,	//	exi    return to trxeq caller
/* 22253 */	exi     | 0      << off_ ,
// trxq2:
/* 22254 */	stmt    | 7941   << off_ ,	//trxq2	erb 197 trace fourth arg is not function name or null
/* 22255 */	erb     | 197    << off_ ,
// xscan:
/* 22256 */	stmt    | 7942   << off_ ,	//xscan	prc e 0  entry point
/* 22257 */	stmt    | 7943   << off_ ,	//	mov xscwb wb  preserve wb
/* 22258 */	store   | wb     << dst_ | xscwb  << off_ ,
/* 22259 */	stmt    | 7944   << off_ ,	//	mov -(xs) wa  record blank skip flag
/* 22260 */	dca     | xs     << dst_ ,
/* 22261 */	store   | wa     << dst_ | xs     << src_ ,
/* 22262 */	stmt    | 7945   << off_ ,	//	mov -(xs) wa  and second copy
/* 22263 */	dca     | xs     << dst_ ,
/* 22264 */	store   | wa     << dst_ | xs     << src_ ,
/* 22265 */	stmt    | 7946   << off_ ,	//	mov xr r_xsc  point to argument string
/* 22266 */	load    | xr     << dst_ | r_xsc  << off_ ,
/* 22267 */	stmt    | 7947   << off_ ,	//	mov wa sclen(xr)  load string length
/* 22268 */	load    | wa     << dst_ | xr     << src_ | sclen  << off_ ,
/* 22269 */	stmt    | 7948   << off_ ,	//	mov wb xsofs  load current offset
/* 22270 */	load    | wb     << dst_ | xsofs  << off_ ,
/* 22271 */	stmt    | 7949   << off_ ,	//	sub wa wb  get number of remaining characters
/* 22272 */	sub     | wa     << dst_ | wb     << src_ ,
/* 22273 */	stmt    | 7950   << off_ ,	//	bze wa xscn3  jump if no characters left
/* 22274 */	bze     | wa     << dst_ | xscn3  << off_ ,
/* 22275 */	stmt    | 7951   << off_ ,	//	plc xr wb  point to current character
/* 22276 */	plc     | xr     << dst_ | wb     << src_ ,
// xscn1:
/* 22277 */	stmt    | 7952   << off_ ,	//xscn1	lch wb (xr)+  load next character
/* 22278 */	load    | wb     << dst_ | xr     << src_ ,
/* 22279 */	ica     | xr     << dst_ ,
/* 22280 */	stmt    | 7953   << off_ ,	//	beq wb wc xscn4 jump if delimiter one found
/* 22281 */	beq     | wb     << dst_ | wc     << src_ | xscn4  << off_ ,
/* 22282 */	stmt    | 7954   << off_ ,	//	beq wb xl xscn5 jump if delimiter two found
/* 22283 */	beq     | wb     << dst_ | xl     << src_ | xscn5  << off_ ,
/* 22284 */	stmt    | 7955   << off_ ,	//	bze (xs) xscn2  jump if not skipping blanks
/* 22285 */	load    | r1     << dst_ | xs     << src_ ,
/* 22286 */	bze     | r1     << dst_ | xscn2  << off_ ,
/* 22287 */	stmt    | 7956   << off_ ,	//	icv xsofs   assume blank and delete it
/* 22288 */	load    | r1     << dst_ | xsofs  << off_ ,
/* 22289 */	icv     | r1     << dst_ ,
/* 22290 */	store   | r1     << dst_ | xsofs  << off_ ,
/* 22291 */	stmt    | 7957   << off_ ,	//	beq wb =ch_ht xscn2 jump if horizontal tab
/* 22292 */	loadi   | r2     << dst_ | ch_ht  << off_ ,
/* 22293 */	beq     | wb     << dst_ | r2     << src_ | xscn2  << off_ ,
/* 22294 */	stmt    | 7958   << off_ ,	//	beq wb =ch_bl xscn2 jump if blank
/* 22295 */	loadi   | r2     << dst_ | ch_bl  << off_ ,
/* 22296 */	beq     | wb     << dst_ | r2     << src_ | xscn2  << off_ ,
/* 22297 */	stmt    | 7959   << off_ ,	//	dcv xsofs   undelete non-blank character
/* 22298 */	load    | r1     << dst_ | xsofs  << off_ ,
/* 22299 */	dcv     | r1     << dst_ ,
/* 22300 */	store   | r1     << dst_ | xsofs  << off_ ,
/* 22301 */	stmt    | 7960   << off_ ,	//	zer (xs)   and discontinue blank checking
/* 22302 */	store   | r0     << dst_ | xs     << src_ ,
// xscn2:
/* 22303 */	stmt    | 7961   << off_ ,	//xscn2	dcv wa   decrement count of chars left
/* 22304 */	dcv     | wa     << dst_ ,
/* 22305 */	stmt    | 7962   << off_ ,	//	bnz wa xscn1  loop back if more chars to go
/* 22306 */	bnz     | wa     << dst_ | xscn1  << off_ ,
// xscn3:
/* 22307 */	stmt    | 7963   << off_ ,	//xscn3	mov xl r_xsc  point to string block
/* 22308 */	load    | xl     << dst_ | r_xsc  << off_ ,
/* 22309 */	stmt    | 7964   << off_ ,	//	mov wa sclen(xl)  get string length
/* 22310 */	load    | wa     << dst_ | xl     << src_ | sclen  << off_ ,
/* 22311 */	stmt    | 7965   << off_ ,	//	mov wb xsofs  load offset
/* 22312 */	load    | wb     << dst_ | xsofs  << off_ ,
/* 22313 */	stmt    | 7966   << off_ ,	//	sub wa wb  get substring length
/* 22314 */	sub     | wa     << dst_ | wb     << src_ ,
/* 22315 */	stmt    | 7967   << off_ ,	//	zer r_xsc   clear string ptr for collector
/* 22316 */	store   | r0     << dst_ | r_xsc  << off_ ,
/* 22317 */	stmt    | 7968   << off_ ,	//	zer xscrt   set zero (runout) return code
/* 22318 */	store   | r0     << dst_ | xscrt  << off_ ,
/* 22319 */	stmt    | 7969   << off_ ,	//	brn xscn7   jump to exit
/* 22320 */	brn     | xscn7  << off_ ,
// xscn4:
/* 22321 */	stmt    | 7970   << off_ ,	//xscn4	mov xscrt =num01  set return code
/* 22322 */	loadi   | r1     << dst_ | num01  << off_ ,
/* 22323 */	store   | r1     << dst_ | xscrt  << off_ ,
/* 22324 */	stmt    | 7971   << off_ ,	//	brn xscn6   jump to merge
/* 22325 */	brn     | xscn6  << off_ ,
// xscn5:
/* 22326 */	stmt    | 7972   << off_ ,	//xscn5	mov xscrt =num02  set return code
/* 22327 */	loadi   | r1     << dst_ | num02  << off_ ,
/* 22328 */	store   | r1     << dst_ | xscrt  << off_ ,
// xscn6:
/* 22329 */	stmt    | 7973   << off_ ,	//xscn6	mov xl r_xsc  reload pointer to string
/* 22330 */	load    | xl     << dst_ | r_xsc  << off_ ,
/* 22331 */	stmt    | 7974   << off_ ,	//	mov wc sclen(xl)  get original length of string
/* 22332 */	load    | wc     << dst_ | xl     << src_ | sclen  << off_ ,
/* 22333 */	stmt    | 7975   << off_ ,	//	sub wc wa  minus chars left = chars scanned
/* 22334 */	sub     | wc     << dst_ | wa     << src_ ,
/* 22335 */	stmt    | 7976   << off_ ,	//	mov wa wc  move to reg for sbstr
/* 22336 */	move    | wa     << dst_ | wc     << src_ ,
/* 22337 */	stmt    | 7977   << off_ ,	//	mov wb xsofs  set offset
/* 22338 */	load    | wb     << dst_ | xsofs  << off_ ,
/* 22339 */	stmt    | 7978   << off_ ,	//	sub wa wb  compute length for sbstr
/* 22340 */	sub     | wa     << dst_ | wb     << src_ ,
/* 22341 */	stmt    | 7979   << off_ ,	//	icv wc   adjust new cursor past delimiter
/* 22342 */	icv     | wc     << dst_ ,
/* 22343 */	stmt    | 7980   << off_ ,	//	mov xsofs wc  store new offset
/* 22344 */	store   | wc     << dst_ | xsofs  << off_ ,
// xscn7:
/* 22345 */	stmt    | 7981   << off_ ,	//xscn7	zer xr   clear garbage character ptr in xr
/* 22346 */	move    | xr     << dst_ ,
/* 22347 */	stmt    | 7982   << off_ ,	//	jsr sbstr   build sub-string
/* 22348 */	call    | sbstr  << off_ ,
/* 22349 */	stmt    | 7983   << off_ ,	//	ica xs   remove copy of blank flag
/* 22350 */	ica     | xs     << dst_ ,
/* 22351 */	stmt    | 7984   << off_ ,	//	mov wb (xs)+  original blank skip/trim flag
/* 22352 */	load    | wb     << dst_ | xs     << src_ ,
/* 22353 */	ica     | xs     << dst_ ,
/* 22354 */	stmt    | 7985   << off_ ,	//	bze sclen(xr) xscn8  cannot trim the null string
/* 22355 */	load    | r1     << dst_ | xr     << src_ | sclen  << off_ ,
/* 22356 */	bze     | r1     << dst_ | xscn8  << off_ ,
/* 22357 */	stmt    | 7986   << off_ ,	//	jsr trimr   trim trailing blanks if requested
/* 22358 */	call    | trimr  << off_ ,
// xscn8:
/* 22359 */	stmt    | 7987   << off_ ,	//xscn8	mov wa xscrt  load return code
/* 22360 */	load    | wa     << dst_ | xscrt  << off_ ,
/* 22361 */	stmt    | 7988   << off_ ,	//	mov wb xscwb  restore wb
/* 22362 */	load    | wb     << dst_ | xscwb  << off_ ,
/* 22363 */	stmt    | 7989   << off_ ,	//	exi    return to xscan caller
/* 22364 */	exi     | 0      << off_ ,
// xscni:
/* 22365 */	stmt    | 7990   << off_ ,	//xscni	prc n 2  entry point
/* 22366 */	prc     | 19     << off_ ,
/* 22367 */	stmt    | 7991   << off_ ,	//	jsr gtstg   fetch argument as string
/* 22368 */	call    | gtstg  << off_ ,
/* 22369 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 22370 */	ppm     | xsci1  << off_ ,
/* 22371 */	stmt    | 7992   << off_ ,	//	mov r_xsc xr  else store scblk ptr for xscan
/* 22372 */	store   | xr     << dst_ | r_xsc  << off_ ,
/* 22373 */	stmt    | 7993   << off_ ,	//	zer xsofs   set offset to zero
/* 22374 */	store   | r0     << dst_ | xsofs  << off_ ,
/* 22375 */	stmt    | 7994   << off_ ,	//	bze wa xsci2  jump if null string
/* 22376 */	bze     | wa     << dst_ | xsci2  << off_ ,
/* 22377 */	stmt    | 7995   << off_ ,	//	exi    return to xscni caller
/* 22378 */	exi     | 1900   << off_ ,
// xsci1:
/* 22379 */	stmt    | 7996   << off_ ,	//xsci1	exi 1   take not-string error exit
/* 22380 */	exi     | 1901   << off_ ,
// xsci2:
/* 22381 */	stmt    | 7997   << off_ ,	//xsci2	exi 2   take null-string error exit
/* 22382 */	exi     | 1902   << off_ ,
/* 22383 */	stmt    | 7998   << off_ ,	//	sec    start of stack overflow section
// sec06:
/* 22384 */	stmt    | 7999   << off_ ,	//	add errft =num04  force conclusive fatal error
/* 22385 */	load    | r1     << dst_ | errft  << off_ ,
/* 22386 */	loadi   | r2     << dst_ | num04  << off_ ,
/* 22387 */	add     | r1     << dst_ | r2     << src_ ,
/* 22388 */	store   | r1     << dst_ | errft  << off_ ,
/* 22389 */	stmt    | 8000   << off_ ,	//	mov xs flptr  pop stack to avoid more fails
/* 22390 */	load    | xs     << dst_ | flptr  << off_ ,
/* 22391 */	stmt    | 8001   << off_ ,	//	bnz gbcfl stak1  jump if garbage collecting
/* 22392 */	load    | r1     << dst_ | gbcfl  << off_ ,
/* 22393 */	bnz     | r1     << dst_ | stak1  << off_ ,
/* 22394 */	stmt    | 8002   << off_ ,	//	erb 246 stack overflow
/* 22395 */	erb     | 246    << off_ ,
// stak1:
/* 22396 */	stmt    | 8003   << off_ ,	//stak1	mov xr =endso  point to message
/* 22397 */	loadi   | xr     << dst_ | endso  << off_ ,
/* 22398 */	stmt    | 8004   << off_ ,	//	zer kvdmp   memory is undumpable
/* 22399 */	store   | r0     << dst_ | kvdmp  << off_ ,
/* 22400 */	stmt    | 8005   << off_ ,	//	brn stopr   give up
/* 22401 */	brn     | stopr  << off_ ,
/* 22402 */	stmt    | 8006   << off_ ,	//	sec    start of error section
//sec07
// error_:
// error_:
/* 22403 */	stmt    | 8007   << off_ ,	//error	beq r_cim =cmlab cmple jump if error in scanning label
/* 22404 */	load    | r1     << dst_ | r_cim  << off_ ,
/* 22405 */	loadi   | r2     << dst_ | cmlab  << off_ ,
/* 22406 */	beq     | r1     << dst_ | r2     << src_ | cmple  << off_ ,
/* 22407 */	stmt    | 8008   << off_ ,	//	mov kvert wa  save error code
/* 22408 */	store   | wa     << dst_ | kvert  << off_ ,
/* 22409 */	stmt    | 8009   << off_ ,	//	zer scnrs   reset rescan switch for scane
/* 22410 */	store   | r0     << dst_ | scnrs  << off_ ,
/* 22411 */	stmt    | 8010   << off_ ,	//	zer scngo   reset goto switch for scane
/* 22412 */	store   | r0     << dst_ | scngo  << off_ ,
/* 22413 */	stmt    | 8011   << off_ ,	//	mov polcs =num01  reset poll count
/* 22414 */	loadi   | r1     << dst_ | num01  << off_ ,
/* 22415 */	store   | r1     << dst_ | polcs  << off_ ,
/* 22416 */	stmt    | 8012   << off_ ,	//	mov polct =num01  reset poll count
/* 22417 */	loadi   | r1     << dst_ | num01  << off_ ,
/* 22418 */	store   | r1     << dst_ | polct  << off_ ,
/* 22419 */	stmt    | 8013   << off_ ,	//	mov xr stage  load current stage
/* 22420 */	load    | xr     << dst_ | stage  << off_ ,
/* 22421 */	stmt    | 8014   << off_ ,	//	bsw xr stgno  jump to appropriate error circuit
/* 22422 */	loadi   | r1     << dst_ | stgno  << off_ ,
/* 22423 */	bsw     | xr     << dst_ | r1     << src_ ,
/* 22424 */	err01   ,
/* 22425 */	err04   ,
/* 22426 */	err04   ,
/* 22427 */	err05   ,
/* 22428 */	err01   ,
/* 22429 */	err04   ,
/* 22430 */	err04   ,
// err01:
/* 22431 */	stmt    | 8015   << off_ ,	//err01	mov xs cmpxs  reset stack pointer
/* 22432 */	load    | xs     << dst_ | cmpxs  << off_ ,
/* 22433 */	stmt    | 8016   << off_ ,	//	ssl cmpss   restore s-r stack ptr for cmpil
/* 22434 */	stmt    | 8017   << off_ ,	//	bnz errsp err03  jump if error suppress flag set
/* 22435 */	load    | r1     << dst_ | errsp  << off_ ,
/* 22436 */	bnz     | r1     << dst_ | err03  << off_ ,
/* 22437 */	stmt    | 8018   << off_ ,	//	mov wc cmpsn  current statement
/* 22438 */	load    | wc     << dst_ | cmpsn  << off_ ,
/* 22439 */	stmt    | 8019   << off_ ,	//	jsr filnm   obtain file name for this statement
/* 22440 */	call    | filnm  << off_ ,
/* 22441 */	stmt    | 8020   << off_ ,	//	mov wb scnse  column number
/* 22442 */	load    | wb     << dst_ | scnse  << off_ ,
/* 22443 */	stmt    | 8021   << off_ ,	//	mov wc rdcln  line number
/* 22444 */	load    | wc     << dst_ | rdcln  << off_ ,
/* 22445 */	stmt    | 8022   << off_ ,	//	mov xr stage
/* 22446 */	load    | xr     << dst_ | stage  << off_ ,
/* 22447 */	stmt    | 8023   << off_ ,	//	jsr sysea   advise system of error
/* 22448 */	sys     | sysea_ << off_ ,
/* 22449 */	jsrerr  | r1     << dst_ | 1      << off_ ,
/* 22450 */	ppm     | erra3  << off_ ,
/* 22451 */	stmt    | 8024   << off_ ,	//	mov -(xs) xr  save any provided print message
/* 22452 */	dca     | xs     << dst_ ,
/* 22453 */	store   | xr     << dst_ | xs     << src_ ,
/* 22454 */	stmt    | 8025   << off_ ,	//	mov erlst erich  set flag for listr
/* 22455 */	load    | r1     << dst_ | erich  << off_ ,
/* 22456 */	store   | r1     << dst_ | erlst  << off_ ,
/* 22457 */	stmt    | 8026   << off_ ,	//	jsr listr   list line
/* 22458 */	call    | listr  << off_ ,
/* 22459 */	stmt    | 8027   << off_ ,	//	jsr prtis   terminate listing
/* 22460 */	call    | prtis  << off_ ,
/* 22461 */	stmt    | 8028   << off_ ,	//	zer erlst   clear listr flag
/* 22462 */	store   | r0     << dst_ | erlst  << off_ ,
/* 22463 */	stmt    | 8029   << off_ ,	//	mov wa scnse  load scan element offset
/* 22464 */	load    | wa     << dst_ | scnse  << off_ ,
/* 22465 */	stmt    | 8030   << off_ ,	//	bze wa err02  skip if not set
/* 22466 */	bze     | wa     << dst_ | err02  << off_ ,
/* 22467 */	stmt    | 8031   << off_ ,	//	lct wb wa  loop counter
/* 22468 */	move    | wb     << dst_ | wa     << src_ ,
/* 22469 */	stmt    | 8032   << off_ ,	//	icv wa   increase for ch_ex
/* 22470 */	icv     | wa     << dst_ ,
/* 22471 */	stmt    | 8033   << off_ ,	//	mov xl r_cim  point to bad statement
/* 22472 */	load    | xl     << dst_ | r_cim  << off_ ,
/* 22473 */	stmt    | 8034   << off_ ,	//	jsr alocs   string block for error flag
/* 22474 */	call    | alocs  << off_ ,
/* 22475 */	stmt    | 8035   << off_ ,	//	mov wa xr  remember string ptr
/* 22476 */	move    | wa     << dst_ | xr     << src_ ,
/* 22477 */	stmt    | 8036   << off_ ,	//	psc xr   ready for character storing
/* 22478 */	psc     | xr     << dst_ ,
/* 22479 */	stmt    | 8037   << off_ ,	//	plc xl   ready to get chars
/* 22480 */	plc     | xl     << dst_ ,
// erra1:
/* 22481 */	stmt    | 8038   << off_ ,	//erra1	lch wc (xl)+  get next char
/* 22482 */	load    | wc     << dst_ | xl     << src_ ,
/* 22483 */	ica     | xl     << dst_ ,
/* 22484 */	stmt    | 8039   << off_ ,	//	beq wc =ch_ht erra2 skip if tab
/* 22485 */	loadi   | r2     << dst_ | ch_ht  << off_ ,
/* 22486 */	beq     | wc     << dst_ | r2     << src_ | erra2  << off_ ,
/* 22487 */	stmt    | 8040   << off_ ,	//	mov wc =ch_bl  get a blank
/* 22488 */	loadi   | wc     << dst_ | ch_bl  << off_ ,
// erra2:
/* 22489 */	stmt    | 8041   << off_ ,	//erra2	sch wc (xr)+  store char
/* 22490 */	store   | wc     << dst_ | xr     << src_ ,
/* 22491 */	ica     | xr     << dst_ ,
/* 22492 */	stmt    | 8042   << off_ ,	//	bct wb erra1  loop
/* 22493 */	bct     | wb     << dst_ | erra1  << off_ ,
/* 22494 */	stmt    | 8043   << off_ ,	//	mov xl =ch_ex  exclamation mark
/* 22495 */	loadi   | xl     << dst_ | ch_ex  << off_ ,
/* 22496 */	stmt    | 8044   << off_ ,	//	sch xl (xr)  store at end of error line
/* 22497 */	store   | xl     << dst_ | xr     << src_ ,
/* 22498 */	stmt    | 8045   << off_ ,	//	csc xr   end of sch loop
/* 22499 */	stmt    | 8046   << off_ ,	//	mov profs =stnpd  allow for statement number
/* 22500 */	loadi   | r1     << dst_ | stnpd  << off_ ,
/* 22501 */	store   | r1     << dst_ | profs  << off_ ,
/* 22502 */	stmt    | 8047   << off_ ,	//	mov xr wa  point to error line
/* 22503 */	move    | xr     << dst_ | wa     << src_ ,
/* 22504 */	stmt    | 8048   << off_ ,	//	jsr prtst   print error line
/* 22505 */	call    | prtst  << off_ ,
// err02:
/* 22506 */	stmt    | 8049   << off_ ,	//err02	jsr prtis   print blank line
/* 22507 */	call    | prtis  << off_ ,
/* 22508 */	stmt    | 8050   << off_ ,	//	mov xr (xs)+  restore any sysea message
/* 22509 */	load    | xr     << dst_ | xs     << src_ ,
/* 22510 */	ica     | xs     << dst_ ,
/* 22511 */	stmt    | 8051   << off_ ,	//	bze xr erra0  did sysea provide message to print
/* 22512 */	bze     | xr     << dst_ | erra0  << off_ ,
/* 22513 */	stmt    | 8052   << off_ ,	//	jsr prtst   print sysea message
/* 22514 */	call    | prtst  << off_ ,
// erra0:
/* 22515 */	stmt    | 8053   << off_ ,	//erra0	jsr ermsg   generate flag and error message
/* 22516 */	call    | ermsg  << off_ ,
/* 22517 */	stmt    | 8054   << off_ ,	//	add lstlc =num03  bump page ctr for blank, error, blk
/* 22518 */	load    | r1     << dst_ | lstlc  << off_ ,
/* 22519 */	loadi   | r2     << dst_ | num03  << off_ ,
/* 22520 */	add     | r1     << dst_ | r2     << src_ ,
/* 22521 */	store   | r1     << dst_ | lstlc  << off_ ,
// erra3:
/* 22522 */	stmt    | 8055   << off_ ,	//erra3	zer xr   in case of fatal error
/* 22523 */	move    | xr     << dst_ ,
/* 22524 */	stmt    | 8056   << off_ ,	//	bhi errft =num03 stopr pack up if several fatals
/* 22525 */	load    | r1     << dst_ | errft  << off_ ,
/* 22526 */	loadi   | r2     << dst_ | num03  << off_ ,
/* 22527 */	bhi     | r1     << dst_ | r2     << src_ | stopr  << off_ ,
/* 22528 */	stmt    | 8057   << off_ ,	//	icv cmerc   bump error count
/* 22529 */	load    | r1     << dst_ | cmerc  << off_ ,
/* 22530 */	icv     | r1     << dst_ ,
/* 22531 */	store   | r1     << dst_ | cmerc  << off_ ,
/* 22532 */	stmt    | 8058   << off_ ,	//	add noxeq cswer  inhibit xeq if -noerrors
/* 22533 */	load    | r1     << dst_ | noxeq  << off_ ,
/* 22534 */	load    | r2     << dst_ | cswer  << off_ ,
/* 22535 */	add     | r1     << dst_ | r2     << src_ ,
/* 22536 */	store   | r1     << dst_ | noxeq  << off_ ,
/* 22537 */	stmt    | 8059   << off_ ,	//	bne stage =stgic cmp10 special return if after end line
/* 22538 */	load    | r1     << dst_ | stage  << off_ ,
/* 22539 */	loadi   | r2     << dst_ | stgic  << off_ ,
/* 22540 */	bne     | r1     << dst_ | r2     << src_ | cmp10  << off_ ,
// err03:
/* 22541 */	stmt    | 8060   << off_ ,	//err03	mov xr r_cim  point to start of image
/* 22542 */	load    | xr     << dst_ | r_cim  << off_ ,
/* 22543 */	stmt    | 8061   << off_ ,	//	plc xr   point to first char
/* 22544 */	plc     | xr     << dst_ ,
/* 22545 */	stmt    | 8062   << off_ ,	//	lch xr (xr)  get first char
/* 22546 */	load    | xr     << dst_ | xr     << src_ ,
/* 22547 */	stmt    | 8063   << off_ ,	//	beq xr =ch_mn cmpce jump if error in control card
/* 22548 */	loadi   | r2     << dst_ | ch_mn  << off_ ,
/* 22549 */	beq     | xr     << dst_ | r2     << src_ | cmpce  << off_ ,
/* 22550 */	stmt    | 8064   << off_ ,	//	zer scnrs   clear rescan flag
/* 22551 */	store   | r0     << dst_ | scnrs  << off_ ,
/* 22552 */	stmt    | 8065   << off_ ,	//	mnz errsp   set error suppress flag
/* 22553 */	store   | xs     << dst_ | errsp  << off_ ,
/* 22554 */	stmt    | 8066   << off_ ,	//	jsr scane   scan next element
/* 22555 */	call    | scane  << off_ ,
/* 22556 */	stmt    | 8067   << off_ ,	//	bne xl =t_smc err03 loop back if not statement end
/* 22557 */	loadi   | r2     << dst_ | t_smc  << off_ ,
/* 22558 */	bne     | xl     << dst_ | r2     << src_ | err03  << off_ ,
/* 22559 */	stmt    | 8068   << off_ ,	//	zer errsp   clear error suppress flag
/* 22560 */	store   | r0     << dst_ | errsp  << off_ ,
/* 22561 */	stmt    | 8069   << off_ ,	//	mov cwcof *cdcod  reset offset in ccblk
/* 22562 */	loadi   | r1     << dst_ | cdcod  << off_ ,
/* 22563 */	store   | r1     << dst_ | cwcof  << off_ ,
/* 22564 */	stmt    | 8070   << off_ ,	//	mov wa =ocer_  load compile error call
/* 22565 */	loadi   | wa     << dst_ | ocer_  << off_ ,
/* 22566 */	stmt    | 8071   << off_ ,	//	jsr cdwrd   generate it
/* 22567 */	call    | cdwrd  << off_ ,
/* 22568 */	stmt    | 8072   << off_ ,	//	mov cmsoc(xs) cwcof  set success fill in offset
/* 22569 */	load    | r1     << dst_ | cwcof  << off_ ,
/* 22570 */	store   | r1     << dst_ | xs     << src_ | cmsoc  << off_ ,
/* 22571 */	stmt    | 8073   << off_ ,	//	mnz cmffc(xs)   set failure fill in flag
/* 22572 */	store   | xs     << dst_ | xs     << src_ | cmffc  << off_ ,
/* 22573 */	stmt    | 8074   << off_ ,	//	jsr cdwrd   generate succ. fill in word
/* 22574 */	call    | cdwrd  << off_ ,
/* 22575 */	stmt    | 8075   << off_ ,	//	brn cmpse   merge to generate error as cdfal
/* 22576 */	brn     | cmpse  << off_ ,
// err04:
/* 22577 */	stmt    | 8076   << off_ ,	//err04	bge errft =num03 labo1 abort if too many fatal errors
/* 22578 */	load    | r1     << dst_ | errft  << off_ ,
/* 22579 */	loadi   | r2     << dst_ | num03  << off_ ,
/* 22580 */	bge     | r1     << dst_ | r2     << src_ | labo1  << off_ ,
/* 22581 */	stmt    | 8077   << off_ ,	//	beq kvert =nm320 err06 treat user interrupt specially
/* 22582 */	load    | r1     << dst_ | kvert  << off_ ,
/* 22583 */	loadi   | r2     << dst_ | nm320  << off_ ,
/* 22584 */	beq     | r1     << dst_ | r2     << src_ | err06  << off_ ,
/* 22585 */	stmt    | 8078   << off_ ,	//	zer r_ccb   forget garbage code block
/* 22586 */	store   | r0     << dst_ | r_ccb  << off_ ,
/* 22587 */	stmt    | 8079   << off_ ,	//	mov cwcof *cccod  set initial offset (mbe catspaw)
/* 22588 */	loadi   | r1     << dst_ | cccod  << off_ ,
/* 22589 */	store   | r1     << dst_ | cwcof  << off_ ,
/* 22590 */	stmt    | 8080   << off_ ,	//	ssl iniss   restore main prog s-r stack ptr
/* 22591 */	stmt    | 8081   << off_ ,	//	jsr ertex   get fail message text
/* 22592 */	call    | ertex  << off_ ,
/* 22593 */	stmt    | 8082   << off_ ,	//	dca xs   ensure stack ok on loop start
/* 22594 */	dca     | xs     << dst_ ,
// erra4:
/* 22595 */	stmt    | 8083   << off_ ,	//erra4	ica xs   pop stack
/* 22596 */	ica     | xs     << dst_ ,
/* 22597 */	stmt    | 8084   << off_ ,	//	beq xs flprt errc4 jump if prog defined fn call found
/* 22598 */	load    | r2     << dst_ | flprt  << off_ ,
/* 22599 */	beq     | xs     << dst_ | r2     << src_ | errc4  << off_ ,
/* 22600 */	stmt    | 8085   << off_ ,	//	bne xs gtcef erra4 loop if not eval or code call yet
/* 22601 */	load    | r2     << dst_ | gtcef  << off_ ,
/* 22602 */	bne     | xs     << dst_ | r2     << src_ | erra4  << off_ ,
/* 22603 */	stmt    | 8086   << off_ ,	//	mov stage =stgxt  re-set stage for execute
/* 22604 */	loadi   | r1     << dst_ | stgxt  << off_ ,
/* 22605 */	store   | r1     << dst_ | stage  << off_ ,
/* 22606 */	stmt    | 8087   << off_ ,	//	mov r_cod r_gtc  recover code ptr
/* 22607 */	load    | r1     << dst_ | r_gtc  << off_ ,
/* 22608 */	store   | r1     << dst_ | r_cod  << off_ ,
/* 22609 */	stmt    | 8088   << off_ ,	//	mov flptr xs  restore fail pointer
/* 22610 */	store   | xs     << dst_ | flptr  << off_ ,
/* 22611 */	stmt    | 8089   << off_ ,	//	zer r_cim   forget possible image
/* 22612 */	store   | r0     << dst_ | r_cim  << off_ ,
/* 22613 */	stmt    | 8090   << off_ ,	//	zer cnind   forget possible include
/* 22614 */	store   | r0     << dst_ | cnind  << off_ ,
// errb4:
/* 22615 */	stmt    | 8091   << off_ ,	//errb4	bnz kverl err07  jump if errlimit non-zero
/* 22616 */	load    | r1     << dst_ | kverl  << off_ ,
/* 22617 */	bnz     | r1     << dst_ | err07  << off_ ,
/* 22618 */	stmt    | 8092   << off_ ,	//	brn exfal   fail
/* 22619 */	brn     | exfal  << off_ ,
// errc4:
/* 22620 */	stmt    | 8093   << off_ ,	//errc4	mov xs flptr  restore stack from flptr
/* 22621 */	load    | xs     << dst_ | flptr  << off_ ,
/* 22622 */	stmt    | 8094   << off_ ,	//	brn errb4   merge
/* 22623 */	brn     | errb4  << off_ ,
// err05:
/* 22624 */	stmt    | 8095   << off_ ,	//err05	ssl iniss   restore main prog s-r stack ptr
/* 22625 */	stmt    | 8096   << off_ ,	//	bnz dmvch err08  jump if in mid-dump
/* 22626 */	load    | r1     << dst_ | dmvch  << off_ ,
/* 22627 */	bnz     | r1     << dst_ | err08  << off_ ,
// err06:
/* 22628 */	stmt    | 8097   << off_ ,	//err06	bze kverl labo1  abort if errlimit is zero
/* 22629 */	load    | r1     << dst_ | kverl  << off_ ,
/* 22630 */	bze     | r1     << dst_ | labo1  << off_ ,
/* 22631 */	stmt    | 8098   << off_ ,	//	jsr ertex   get fail message text
/* 22632 */	call    | ertex  << off_ ,
// err07:
/* 22633 */	stmt    | 8099   << off_ ,	//err07	bge errft =num03 labo1 abort if too many fatal errors
/* 22634 */	load    | r1     << dst_ | errft  << off_ ,
/* 22635 */	loadi   | r2     << dst_ | num03  << off_ ,
/* 22636 */	bge     | r1     << dst_ | r2     << src_ | labo1  << off_ ,
/* 22637 */	stmt    | 8100   << off_ ,	//	dcv kverl   decrement errlimit
/* 22638 */	load    | r1     << dst_ | kverl  << off_ ,
/* 22639 */	dcv     | r1     << dst_ ,
/* 22640 */	store   | r1     << dst_ | kverl  << off_ ,
/* 22641 */	stmt    | 8101   << off_ ,	//	mov xl r_ert  load errtype trace pointer
/* 22642 */	load    | xl     << dst_ | r_ert  << off_ ,
/* 22643 */	stmt    | 8102   << off_ ,	//	jsr ktrex   generate errtype trace if required
/* 22644 */	call    | ktrex  << off_ ,
/* 22645 */	stmt    | 8103   << off_ ,	//	mov wa r_cod  get current code block
/* 22646 */	load    | wa     << dst_ | r_cod  << off_ ,
/* 22647 */	stmt    | 8104   << off_ ,	//	mov r_cnt wa  set cdblk ptr for continuation
/* 22648 */	store   | wa     << dst_ | r_cnt  << off_ ,
/* 22649 */	stmt    | 8105   << off_ ,	//	scp wb   current code pointer
/* 22650 */	scp     | wb     << dst_ ,
/* 22651 */	stmt    | 8106   << off_ ,	//	sub wb wa  offset within code block
/* 22652 */	sub     | wb     << dst_ | wa     << src_ ,
/* 22653 */	stmt    | 8107   << off_ ,	//	mov stxoc wb  save code ptr offset for scontinue
/* 22654 */	store   | wb     << dst_ | stxoc  << off_ ,
/* 22655 */	stmt    | 8108   << off_ ,	//	mov xr flptr  set ptr to failure offset
/* 22656 */	load    | xr     << dst_ | flptr  << off_ ,
/* 22657 */	stmt    | 8109   << off_ ,	//	mov stxof (xr)  save failure offset for continue
/* 22658 */	load    | r1     << dst_ | xr     << src_ ,
/* 22659 */	store   | r1     << dst_ | stxof  << off_ ,
/* 22660 */	stmt    | 8110   << off_ ,	//	mov xr r_sxc  load setexit cdblk pointer
/* 22661 */	load    | xr     << dst_ | r_sxc  << off_ ,
/* 22662 */	stmt    | 8111   << off_ ,	//	bze xr lcnt1  continue if no setexit trap
/* 22663 */	bze     | xr     << dst_ | lcnt1  << off_ ,
/* 22664 */	stmt    | 8112   << off_ ,	//	zer r_sxc   else reset trap
/* 22665 */	store   | r0     << dst_ | r_sxc  << off_ ,
/* 22666 */	stmt    | 8113   << off_ ,	//	mov stxvr =nulls  reset setexit arg to null
/* 22667 */	loadi   | r1     << dst_ | nulls  << off_ ,
/* 22668 */	store   | r1     << dst_ | stxvr  << off_ ,
/* 22669 */	stmt    | 8114   << off_ ,	//	mov xl (xr)  load ptr to code block routine
/* 22670 */	load    | xl     << dst_ | xr     << src_ ,
/* 22671 */	stmt    | 8115   << off_ ,	//	bri xl   execute first trap statement
/* 22672 */	bri     | xl     << dst_ ,
// err08:
/* 22673 */	stmt    | 8116   << off_ ,	//err08	mov xr dmvch  chain head for affected vrblks
/* 22674 */	load    | xr     << dst_ | dmvch  << off_ ,
/* 22675 */	stmt    | 8117   << off_ ,	//	bze xr err06  done if zero
/* 22676 */	bze     | xr     << dst_ | err06  << off_ ,
/* 22677 */	stmt    | 8118   << off_ ,	//	mov dmvch (xr)  set next link as chain head
/* 22678 */	load    | r1     << dst_ | xr     << src_ ,
/* 22679 */	store   | r1     << dst_ | dmvch  << off_ ,
/* 22680 */	stmt    | 8119   << off_ ,	//	jsr setvr   restore vrget field
/* 22681 */	call    | setvr  << off_ ,
// s_yyy:
/* 22682 */	stmt    | 8120   << off_ ,	//s_yyy	brn err08   loop through chain
/* 22683 */	brn     | err08  << off_ ,
}
const (
	c_aaa	=	1
	alfsp	=	2
	bits0	=	3
	bits1	=	4
	bits2	=	5
	bits3	=	6
	bits4	=	7
	bits5	=	8
	bits6	=	9
	bits7	=	10
	bits8	=	11
	bits9	=	12
	bit10	=	13
	bit11	=	14
	bit12	=	15
	bitsm	=	16
	btfnc	=	17
	btknm	=	18
	btlbl	=	19
	btffc	=	20
	btckw	=	21
	btkwv	=	22
	btprd	=	23
	btpre	=	24
	btval	=	25
	ccnms	=	26
	dmhdk	=	122
	dmhdv	=	146
	encm1	=	173
	encm2	=	194
	encm3	=	215
	encm4	=	228
	encm5	=	250
	endab	=	272
	endmo	=	286
	endml	=	287
	endms	=	303
	endso	=	315
	endtu	=	353
	ermms	=	370
	ermns	=	377
	lstms	=	383
	headr	=	390
	headv	=	417
	gbsdp	=	424
	int_r	=	425
	intv0	=	426
	inton	=	427
	intv1	=	428
	inttw	=	429
	intv2	=	430
	intvt	=	431
	intvh	=	432
	intth	=	433
	intab	=	434
	ndabb	=	437
	ndabd	=	438
	ndarc	=	439
	ndexb	=	440
	ndfnb	=	441
	ndfnd	=	442
	ndexc	=	443
	ndimb	=	444
	ndimd	=	445
	ndnth	=	446
	ndpab	=	447
	ndpad	=	448
	nduna	=	449
	ndabo	=	450
	ndarb	=	452
	ndbal	=	454
	ndfal	=	456
	ndfen	=	458
	ndrem	=	460
	ndsuc	=	462
	nulls	=	464
	nullw	=	466
	lcase	=	476
	ucase	=	504
	opdvc	=	532
	opdvp	=	536
	opdvs	=	540
	opdvd	=	645
	opdvn	=	648
	oamn_	=	651
	oamv_	=	652
	oaon_	=	653
	oaov_	=	654
	ocer_	=	655
	ofex_	=	656
	ofif_	=	657
	ofnc_	=	658
	ofne_	=	659
	ofns_	=	660
	ogof_	=	661
	oinn_	=	662
	okwn_	=	663
	olex_	=	664
	olpt_	=	665
	olvn_	=	666
	onta_	=	667
	ontb_	=	668
	ontc_	=	669
	opmn_	=	670
	opms_	=	671
	opop_	=	672
	ornm_	=	673
	orpl_	=	674
	orvl_	=	675
	osla_	=	676
	oslb_	=	677
	oslc_	=	678
	osld_	=	679
	ostp_	=	680
	ounf_	=	681
	opsnb	=	682
	opnsu	=	687
	pfi2a	=	693
	pfms1	=	694
	pfms2	=	711
	pfms3	=	755
	reav0	=	804
	reap1	=	805
	reap5	=	806
	reav1	=	807
	reavt	=	808
	reatt	=	817
	scarr	=	818
	sccod	=	825
	scexp	=	831
	scext	=	843
	scint	=	853
	scnam	=	862
	scnum	=	868
	scpat	=	877
	screa	=	886
	scstr	=	892
	sctab	=	900
	scfil	=	907
	scfrt	=	913
	scnrt	=	922
	scrtn	=	931
	scnmt	=	939
	scre0	=	955
	stlim	=	959
	stndf	=	960
	stndl	=	962
	stndo	=	963
	stnvr	=	965
	stpm1	=	972
	stpm2	=	986
	stpm3	=	1002
	stpm4	=	1024
	stpm5	=	1033
	stpm6	=	1048
	stpm7	=	1057
	stpm8	=	1074
	stpm9	=	1091
	strtu	=	1106
	svctb	=	1108
	tmasb	=	1119
	tmbeb	=	1134
	trbev	=	1139
	trbkv	=	1140
	trxdr	=	1141
	trxdc	=	1142
	v_eqf	=	1143
	v_gef	=	1149
	v_gtf	=	1155
	v_lef	=	1161
	v_lnf	=	1167
	v_ltf	=	1173
	v_nef	=	1179
	v_any	=	1185
	v_arb	=	1192
	v_arg	=	1199
	v_bal	=	1206
	v_cos	=	1213
	v_end	=	1220
	v_exp	=	1226
	v_len	=	1233
	v_leq	=	1240
	v_lge	=	1247
	v_lgt	=	1254
	v_lle	=	1261
	v_llt	=	1268
	v_lne	=	1275
	v_pos	=	1282
	v_rem	=	1289
	v_set	=	1296
	v_sin	=	1303
	v_tab	=	1310
	v_tan	=	1317
	v_atn	=	1324
	v_chr	=	1332
	v_chp	=	1340
	v_cod	=	1348
	v_cop	=	1357
	v_dat	=	1365
	v_dte	=	1373
	v_dmp	=	1381
	v_dup	=	1390
	v_evl	=	1398
	v_ext	=	1406
	v_fal	=	1414
	v_fil	=	1422
	v_hst	=	1429
	v_itm	=	1437
	v_lin	=	1445
	v_lod	=	1452
	v_lpd	=	1460
	v_rpd	=	1468
	v_rps	=	1476
	v_rtb	=	1484
	v_si_	=	1492
	v_srt	=	1500
	v_spn	=	1508
	v_sqr	=	1516
	v_stn	=	1524
	v_tim	=	1531
	v_trm	=	1539
	v_abe	=	1548
	v_abo	=	1556
	v_app	=	1566
	v_abn	=	1575
	v_arr	=	1584
	v_brk	=	1593
	v_clr	=	1602
	v_ejc	=	1611
	v_fen	=	1620
	v_fld	=	1631
	v_idn	=	1640
	v_inp	=	1649
	v_lcs	=	1659
	v_loc	=	1667
	v_ops	=	1676
	v_rmd	=	1685
	v_rsr	=	1694
	v_tbl	=	1703
	v_tra	=	1712
	v_ucs	=	1722
	v_anc	=	1730
	v_bkx	=	1739
	v_def	=	1749
	v_det	=	1759
	v_dif	=	1769
	v_ftr	=	1779
	v_lst	=	1788
	v_nay	=	1797
	v_oup	=	1807
	v_ret	=	1818
	v_rew	=	1827
	v_stt	=	1837
	v_sub	=	1847
	v_unl	=	1857
	v_col	=	1867
	v_com	=	1878
	v_cnv	=	1888
	v_enf	=	1899
	v_etx	=	1910
	v_ert	=	1920
	v_frt	=	1930
	v_int	=	1940
	v_nrt	=	1951
	v_pfl	=	1961
	v_rpl	=	1971
	v_rvs	=	1982
	v_rtn	=	1993
	v_stx	=	2003
	v_stc	=	2014
	v_stl	=	2024
	v_suc	=	2034
	v_alp	=	2045
	v_cnt	=	2056
	v_dtp	=	2067
	v_erl	=	2079
	v_fnc	=	2090
	v_fls	=	2101
	v_lfl	=	2112
	v_lln	=	2123
	v_mxl	=	2134
	v_ter	=	2145
	v_bsp	=	2156
	v_pro	=	2169
	v_scn	=	2182
	vdmkw	=	2196
	vsrch	=	2222
	c_yyy	=	2232
	cmlab	=	2233
	w_aaa	=	2237
	actrm	=	2238
	aldyn	=	2239
	allia	=	2240
	allsv	=	2241
	alsta	=	2242
	arcdm	=	2243
	arnel	=	2244
	arptr	=	2245
	arsvl	=	2246
	arfsi	=	2247
	arfxs	=	2248
	befof	=	2249
	bpfpf	=	2250
	bpfsv	=	2251
	bpfxt	=	2252
	clsvi	=	2253
	cnscc	=	2254
	cnswc	=	2255
	cnr_t	=	2256
	cnvtp	=	2257
	datdv	=	2258
	datxs	=	2259
	deflb	=	2260
	defna	=	2261
	defvr	=	2262
	defxs	=	2263
	dmarg	=	2264
	dmpsa	=	2265
	dmpsb	=	2266
	dmpsv	=	2267
	dmvch	=	2268
	dmpch	=	2269
	dmpkb	=	2270
	dmpkt	=	2271
	dmpkn	=	2272
	dtcnb	=	2273
	dtcnm	=	2274
	dupsi	=	2275
	enfch	=	2276
	ertwa	=	2277
	ertwb	=	2278
	evlin	=	2279
	evlis	=	2280
	evliv	=	2281
	evlio	=	2282
	evlif	=	2283
	expsv	=	2284
	gbcfl	=	2285
	gbclm	=	2286
	gbcnm	=	2287
	gbcns	=	2288
	gbcmk	=	2289
	gbcia	=	2290
	gbcsd	=	2291
	gbcsf	=	2292
	gbsva	=	2293
	gbsvb	=	2294
	gbsvc	=	2295
	gnvhe	=	2296
	gnvnw	=	2297
	gnvsa	=	2298
	gnvsb	=	2299
	gnvsp	=	2300
	gnvst	=	2301
	gtawa	=	2302
	gtina	=	2303
	gtinb	=	2304
	gtnnf	=	2305
	gtnsi	=	2306
	gtndf	=	2307
	gtnes	=	2308
	gtnex	=	2309
	gtnsc	=	2310
	gtnsr	=	2311
	gtnrd	=	2312
	gtpsb	=	2313
	gtssf	=	2314
	gtsvc	=	2315
	gtsvb	=	2316
	gtses	=	2317
	gtsrs	=	2318
	gtvrc	=	2319
	ioptt	=	2320
	lodfn	=	2321
	lodna	=	2322
	mxint	=	2323
	pfsvw	=	2324
	prnsi	=	2325
	prsna	=	2326
	prsva	=	2327
	prsvb	=	2328
	prsvc	=	2329
	prtsa	=	2330
	prtsb	=	2331
	prvsi	=	2332
	psave	=	2333
	psavc	=	2334
	rlals	=	2335
	rldcd	=	2336
	rldst	=	2337
	rldls	=	2338
	rtnbp	=	2339
	rtnfv	=	2340
	rtnsv	=	2341
	sbssv	=	2342
	scnsa	=	2343
	scnsb	=	2344
	scnsc	=	2345
	scnof	=	2346
	srtdf	=	2347
	srtfd	=	2348
	srtff	=	2349
	srtfo	=	2350
	srtnr	=	2351
	srtof	=	2352
	srtrt	=	2353
	srts1	=	2354
	srts2	=	2355
	srtsc	=	2356
	srtsf	=	2357
	srtsn	=	2358
	srtso	=	2359
	srtsr	=	2360
	srtst	=	2361
	srtwc	=	2362
	stpsi	=	2363
	stpti	=	2364
	tfnsi	=	2365
	xscrt	=	2366
	xscwb	=	2367
	g_aaa	=	2368
	alfsf	=	2369
	cmerc	=	2370
	cmpln	=	2371
	cmpxs	=	2372
	cmpsn	=	2373
	cnsil	=	2374
	cnind	=	2375
	cnspt	=	2376
	cnttl	=	2377
	cpsts	=	2378
	cswdb	=	2379
	cswer	=	2380
	cswex	=	2381
	cswfl	=	2382
	cswin	=	2383
	cswls	=	2384
	cswno	=	2385
	cswpr	=	2386
	ctmsk	=	2387
	curid	=	2388
	cwcof	=	2389
	dnams	=	2390
	erich	=	2391
	erlst	=	2392
	errft	=	2393
	errsp	=	2394
	exsts	=	2395
	flprt	=	2396
	flptr	=	2397
	gbsed	=	2398
	gbcnt	=	2399
	gtcef	=	2400
	gtsrn	=	2401
	gtssc	=	2402
	gtswk	=	2403
	headp	=	2404
	hshnb	=	2405
	initr	=	2406
	kvabe	=	2407
	kvanc	=	2408
	kvcod	=	2409
	kvcom	=	2410
	kvdmp	=	2411
	kverl	=	2412
	kvert	=	2413
	kvftr	=	2414
	kvfls	=	2415
	kvinp	=	2416
	kvmxl	=	2417
	kvoup	=	2418
	kvpfl	=	2419
	kvtra	=	2420
	kvtrm	=	2421
	kvfnc	=	2422
	kvlst	=	2423
	kvlln	=	2424
	kvlin	=	2425
	kvstn	=	2426
	kvalp	=	2427
	kvrtn	=	2428
	kvstl	=	2429
	kvstc	=	2430
	lstid	=	2431
	lstlc	=	2432
	lstnp	=	2433
	lstpf	=	2434
	lstpg	=	2435
	lstpo	=	2436
	lstsn	=	2437
	mxlen	=	2438
	noxeq	=	2439
	pfdmp	=	2440
	pffnc	=	2441
	pfstm	=	2442
	pfetm	=	2443
	pfnte	=	2444
	pfste	=	2445
	pmdfl	=	2446
	pmhbs	=	2447
	pmssl	=	2448
	polcs	=	2449
	polct	=	2450
	prich	=	2451
	prstd	=	2452
	prsto	=	2453
	prbuf	=	2454
	precl	=	2455
	prlen	=	2456
	prlnw	=	2457
	profs	=	2458
	prtef	=	2459
	rdcln	=	2460
	rdnln	=	2461
	rsmem	=	2462
	stmcs	=	2463
	stmct	=	2464
	a_aaa	=	2465
	cmpss	=	2466
	dnamb	=	2467
	dnamp	=	2468
	dname	=	2469
	hshtb	=	2470
	hshte	=	2471
	iniss	=	2472
	pftbl	=	2473
	prnmv	=	2474
	statb	=	2475
	state	=	2476
	stxvr	=	2477
	r_aaa	=	2478
	r_arf	=	2479
	r_ccb	=	2480
	r_cim	=	2481
	r_cmp	=	2482
	r_cni	=	2483
	r_cnt	=	2484
	r_cod	=	2485
	r_ctp	=	2486
	r_cts	=	2487
	r_ert	=	2488
	r_etx	=	2489
	r_exs	=	2490
	r_fcb	=	2491
	r_fnc	=	2492
	r_gtc	=	2493
	r_ici	=	2494
	r_ifa	=	2495
	r_ifl	=	2496
	r_ifn	=	2497
	r_inc	=	2498
	r_io1	=	2499
	r_io2	=	2500
	r_iof	=	2501
	r_ion	=	2502
	r_iop	=	2503
	r_iot	=	2504
	r_pms	=	2505
	r_ra2	=	2506
	r_ra3	=	2507
	r_rpt	=	2508
	r_scp	=	2509
	r_sfc	=	2510
	r_sfn	=	2511
	r_sxl	=	2512
	r_sxr	=	2513
	r_stc	=	2514
	r_stl	=	2515
	r_sxc	=	2516
	r_ttl	=	2517
	r_xsc	=	2518
	r_uba	=	2519
	r_ubm	=	2520
	r_ubn	=	2521
	r_ubp	=	2522
	r_ubt	=	2523
	r_uub	=	2524
	r_uue	=	2525
	r_uun	=	2526
	r_uup	=	2527
	r_uus	=	2528
	r_uux	=	2529
	r_yyy	=	2530
	scnbl	=	2531
	scncc	=	2532
	scngo	=	2533
	scnil	=	2534
	scnpt	=	2535
	scnrs	=	2536
	scnse	=	2537
	scntp	=	2538
	stage	=	2539
	stbas	=	2540
	stxoc	=	2541
	stxof	=	2542
	timsx	=	2543
	timup	=	2544
	xsofs	=	2545
	w_yyy	=	2546
	relaj	=	2548
	s_aaa	=	2548
	rlaj0	=	2559
	rlaj1	=	2572
	rlaj2	=	2576
	rlaj3	=	2589
	rlaj4	=	2594
	relcr	=	2598
	reldn	=	2699
	rld01	=	2708
	rld03	=	2749
	rld04	=	2753
	rld05	=	2761
	rld07	=	2773
	rld08	=	2785
	rld09	=	2791
	rld10	=	2797
	rld11	=	2803
	rld12	=	2842
	rld13	=	2848
	rld14	=	2854
	rld15	=	2860
	rld16	=	2871
	rld17	=	2882
	rld18	=	2888
	rld19	=	2894
	rld20	=	2900
	reloc	=	2906
	relst	=	2925
	rls01	=	2935
	rls02	=	2943
	rls03	=	2953
	rls04	=	2966
	rls05	=	2974
	relws	=	2976
	start	=	2998
	ini03	=	3040
	ini06	=	3094
	ini07	=	3106
	ini08	=	3136
	ini09	=	3150
	ini11	=	3163
	ini13	=	3228
	inix0	=	3301
	inix1	=	3308
	iniy0	=	3324
	inix2	=	3357
	rstrt	=	3365
	o_add	=	3373
	oadd1	=	3386
	o_aff	=	3394
	o_alt	=	3410
	oalt1	=	3417
	oalt2	=	3443
	o_amn	=	3455
	o_amv	=	3462
	o_aon	=	3469
	oaon1	=	3481
	oaon2	=	3487
	oaon3	=	3510
	oaon4	=	3520
	o_aov	=	3526
	oaov1	=	3540
	oaov2	=	3552
	oaov3	=	3583
	o_ass	=	3598
	oass0	=	3598
	o_cer	=	3618
	o_cas	=	3621
	o_cnc	=	3640
	ocnc1	=	3658
	ocnc2	=	3691
	ocnc3	=	3713
	ocnc4	=	3720
	ocnc5	=	3729
	ocnc6	=	3734
	o_com	=	3763
	ocom1	=	3768
	ocom2	=	3780
	ocom3	=	3789
	o_dvd	=	3797
	odvd2	=	3810
	o_exp	=	3818
	oex13	=	3862
	oexp1	=	3867
	oexp2	=	3871
	oexp3	=	3873
	oexp4	=	3889
	oex14	=	3891
	oexp5	=	3896
	oexp6	=	3900
	oexp7	=	3902
	oexp8	=	3913
	oexp9	=	3930
	oex10	=	3956
	oex11	=	3975
	oex12	=	3977
	o_fex	=	3992
	o_fif	=	3995
	o_fnc	=	3998
	o_fne	=	4011
	ofne1	=	4019
	o_fns	=	4022
	o_fun	=	4035
	o_goc	=	4038
	ogoc1	=	4049
	o_god	=	4052
	o_gof	=	4065
	o_ima	=	4079
	o_inn	=	4118
	o_int	=	4123
	o_inv	=	4132
	o_kwn	=	4137
	o_kwv	=	4142
	o_lex	=	4159
	o_lpt	=	4180
	o_lvn	=	4191
	o_mlt	=	4206
	omlt1	=	4219
	o_nam	=	4227
	o_nta	=	4251
	o_ntb	=	4268
	o_ntc	=	4274
	o_oun	=	4283
	o_pas	=	4286
	o_pmn	=	4325
	o_pms	=	4330
	o_pmv	=	4335
	o_pop	=	4340
	o_stp	=	4348
	o_rnm	=	4351
	o_rpl	=	4354
	orpl1	=	4390
	orpl2	=	4401
	orpl3	=	4419
	o_rvl	=	4428
	o_sla	=	4431
	o_slb	=	4448
	o_slc	=	4471
	o_sld	=	4481
	o_sub	=	4493
	osub1	=	4506
	o_txr	=	4514
	o_unf	=	4517
	b_aaa	=	4520
	b_exl	=	4521
	b_sel	=	4530
	b_e__	=	4539
	b_trt	=	4540
	b_t__	=	4541
	b_art	=	4542
	b_bct	=	4543
	b_bft	=	4544
	b_cct	=	4545
	b_cdc	=	4546
	bcdc0	=	4546
	b_cds	=	4554
	bcds0	=	4554
	b_cmt	=	4562
	b_ctt	=	4563
	b_dfc	=	4564
	bdfc1	=	4579
	b_efc	=	4591
	befc1	=	4599
	beff1	=	4617
	befc2	=	4639
	befc3	=	4649
	befc4	=	4659
	befc5	=	4667
	befc6	=	4669
	befc7	=	4671
	befa8	=	4698
	befc8	=	4704
	befc9	=	4710
	bef10	=	4726
	bef11	=	4728
	bef12	=	4750
	b_evt	=	4777
	b_ffc	=	4778
	bffc1	=	4790
	bffc2	=	4797
	bffc3	=	4799
	bffc4	=	4822
	bffc5	=	4830
	b_icl	=	4839
	b_kvt	=	4848
	b_nml	=	4849
	b_pdt	=	4858
	b_pfc	=	4859
	bpf01	=	4865
	bpf02	=	4894
	bpf03	=	4897
	bpf04	=	4923
	bpf05	=	4932
	bpf06	=	4935
	bpf07	=	4952
	bpf7a	=	4975
	bpf7b	=	4982
	bpf7c	=	4986
	bpf08	=	5038
	bpf8a	=	5051
	bpf09	=	5054
	bpf10	=	5074
	bpf11	=	5081
	bpf12	=	5098
	bpf13	=	5102
	bpf15	=	5122
	bpf16	=	5128
	bpf17	=	5140
	b_rcl	=	5146
	b_scl	=	5155
	b_tbt	=	5164
	b_tet	=	5165
	b_vct	=	5166
	b_vr_	=	5167
	b_vra	=	5168
	b_vre	=	5185
	b_vrg	=	5188
	b_vrl	=	5195
	b_vrs	=	5205
	b_vrt	=	5214
	bvrt1	=	5237
	bvrt2	=	5259
	b_vrv	=	5265
	b_xnt	=	5284
	b_xrt	=	5285
	b_yyy	=	5286
	p_aaa	=	5287
	p_aba	=	5288
	p_abb	=	5307
	p_abc	=	5312
	pabc1	=	5330
	pabc2	=	5333
	p_abd	=	5340
	p_abo	=	5345
	p_alt	=	5348
	p_ans	=	5360
	pany1	=	5377
	p_any	=	5377
	p_ayd	=	5403
	p_arb	=	5410
	p_arc	=	5429
	p_bal	=	5446
	pbal1	=	5454
	pbal2	=	5467
	pbal3	=	5472
	pbal4	=	5476
	pbal5	=	5482
	p_bkd	=	5491
	p_bks	=	5498
	pbks1	=	5509
	pbrk1	=	5522
	p_brk	=	5522
	pbrk2	=	5535
	p_bkx	=	5559
	p_bxd	=	5564
	p_cas	=	5571
	p_exa	=	5602
	pexa1	=	5630
	pexa2	=	5648
	p_exb	=	5654
	p_exc	=	5659
	p_fal	=	5664
	p_fen	=	5667
	p_fna	=	5677
	p_fnb	=	5690
	p_fnc	=	5695
	pfnc1	=	5711
	p_fnd	=	5717
	p_ima	=	5722
	p_imb	=	5741
	p_imc	=	5746
	pimc1	=	5766
	pimc2	=	5769
	p_imd	=	5802
	p_len	=	5807
	plen1	=	5807
	p_lnd	=	5816
	p_nad	=	5824
	p_nas	=	5831
	pnay1	=	5848
	p_nay	=	5848
	p_nth	=	5874
	pnth1	=	5896
	pnth2	=	5901
	pnth3	=	5906
	pnth4	=	5925
	pnth5	=	5954
	pnth6	=	5956
	pnth7	=	5987
	pnth8	=	5993
	pnth9	=	5996
	p_pos	=	6002
	ppos2	=	6013
	p_psd	=	6028
	ppos1	=	6035
	p_paa	=	6054
	p_pab	=	6064
	p_pac	=	6067
	p_pad	=	6085
	p_rem	=	6088
	p_rpd	=	6093
	prps1	=	6100
	p_rps	=	6123
	prps2	=	6138
	prtb1	=	6156
	p_rtb	=	6156
	p_rtd	=	6171
	p_spd	=	6179
	pspn1	=	6186
	p_spn	=	6186
	pspn2	=	6201
	pspn3	=	6222
	p_sps	=	6228
	psps1	=	6241
	psps2	=	6251
	p_str	=	6257
	pstr1	=	6259
	p_suc	=	6288
	ptab1	=	6297
	p_tab	=	6297
	p_tbd	=	6308
	p_una	=	6316
	p_yyy	=	6338
	labo1	=	6339
	l_abo	=	6339
	labo2	=	6367
	labo3	=	6373
	lcnt1	=	6376
	l_cnt	=	6376
	lcnt2	=	6393
	lcnt3	=	6405
	lcnt4	=	6411
	l_end	=	6418
	lend0	=	6418
	l_frt	=	6423
	l_nrt	=	6428
	l_rtn	=	6433
	l_scn	=	6438
	lscn1	=	6464
	lscn2	=	6470
	l_und	=	6477
	s_any	=	6480
	s_app	=	6499
	sapp1	=	6516
	sapp2	=	6523
	sapp3	=	6533
	s_abn	=	6536
	s_arg	=	6586
	sarg1	=	6618
	s_arr	=	6621
	sar02	=	6645
	sar03	=	6669
	sar04	=	6702
	sar05	=	6742
	sar06	=	6753
	sar07	=	6769
	sar08	=	6793
	sar09	=	6832
	sar10	=	6837
	sar11	=	6839
	s_atn	=	6842
	s_bsp	=	6857
	s_brk	=	6872
	s_bkx	=	6891
	s_chr	=	6927
	schr1	=	6958
	s_chp	=	6961
	s_clr	=	6976
	sclr1	=	6981
	sclr2	=	6997
	sclr3	=	6999
	sclr4	=	7009
	sclr5	=	7020
	sclr6	=	7026
	s_cod	=	7042
	s_col	=	7060
	s_cnv	=	7103
	scv01	=	7125
	scv02	=	7134
	scv03	=	7156
	scv04	=	7176
	scv05	=	7178
	scv06	=	7182
	scv07	=	7197
	scv08	=	7209
	scv09	=	7221
	scv10	=	7231
	scv11	=	7243
	scv12	=	7284
	scv19	=	7300
	scv20	=	7355
	scv21	=	7362
	scv22	=	7376
	scv23	=	7382
	scv24	=	7397
	scv25	=	7404
	scv26	=	7420
	scv27	=	7434
	scv31	=	7438
	scv29	=	7446
	s_cop	=	7449
	s_cos	=	7456
	s_dat	=	7473
	sdat1	=	7490
	sdat2	=	7517
	sdat3	=	7529
	sdat4	=	7579
	sdat5	=	7596
	sdat6	=	7629
	s_dtp	=	7642
	s_dte	=	7656
	s_def	=	7682
	sdf01	=	7696
	sdf02	=	7713
	sdf03	=	7728
	sdf04	=	7740
	sdf05	=	7745
	sdf06	=	7757
	sdf07	=	7761
	sdf08	=	7774
	sdf09	=	7785
	sdf10	=	7834
	sdf11	=	7843
	sdf12	=	7854
	s_det	=	7857
	s_dif	=	7869
	s_dmp	=	7882
	s_dup	=	7892
	sdup1	=	7919
	sdup2	=	7931
	sdup3	=	7948
	sdup4	=	7952
	sdup5	=	7966
	sdup6	=	7981
	sdup7	=	7988
	s_ejc	=	7993
	sejc1	=	8007
	s_enf	=	8012
	senf1	=	8028
	senf2	=	8057
	senf3	=	8068
	senf4	=	8071
	s_eqf	=	8087
	s_evl	=	8096
	sevl1	=	8114
	sevl2	=	8140
	s_ext	=	8157
	sext1	=	8191
	sext2	=	8209
	sext3	=	8231
	sext4	=	8238
	sext5	=	8251
	s_exp	=	8256
	s_fld	=	8273
	sfld1	=	8305
	s_fnc	=	8308
	s_gef	=	8344
	s_gtf	=	8353
	s_hst	=	8362
	shst1	=	8388
	shst2	=	8394
	shst3	=	8404
	shst4	=	8411
	s_idn	=	8421
	s_inp	=	8434
	s_int	=	8449
	s_itm	=	8462
	sitm1	=	8470
	sitm2	=	8485
	s_lef	=	8492
	s_len	=	8501
	s_leq	=	8519
	s_lge	=	8528
	s_lgt	=	8537
	s_lle	=	8546
	s_llt	=	8555
	s_lne	=	8564
	s_lnf	=	8573
	slnf1	=	8591
	slnf2	=	8593
	s_loc	=	8596
	sloc1	=	8631
	s_lod	=	8634
	slod1	=	8663
	slod2	=	8671
	slod3	=	8687
	slod4	=	8730
	slod5	=	8749
	slod6	=	8782
	s_lpd	=	8814
	slpd1	=	8827
	slpd2	=	8849
	slpd3	=	8863
	slpd4	=	8868
	s_ltf	=	8873
	s_nef	=	8882
	s_nay	=	8891
	s_ops	=	8910
	sops1	=	8935
	sops2	=	8939
	sops3	=	8966
	sops4	=	8967
	sops5	=	8976
	sops6	=	8978
	s_oup	=	8986
	s_pos	=	9001
	s_pro	=	9019
	spro1	=	9038
	spro2	=	9041
	spro3	=	9045
	spro4	=	9050
	s_rmd	=	9064
	srm01	=	9079
	srm02	=	9088
	srm03	=	9092
	srm04	=	9096
	srm05	=	9098
	srm06	=	9100
	srm07	=	9109
	srm08	=	9126
	srm09	=	9130
	srm10	=	9134
	s_rpl	=	9137
	srpl1	=	9153
	srpl2	=	9180
	srpl3	=	9193
	srpl4	=	9213
	srpl5	=	9215
	srpl8	=	9249
	srpl6	=	9257
	s_rew	=	9260
	s_rvs	=	9275
	srvs1	=	9293
	srvs4	=	9301
	srvs2	=	9304
	s_rpd	=	9310
	srpd1	=	9323
	srpd2	=	9353
	srpd3	=	9364
	s_rtb	=	9369
	s_set	=	9387
	s_tab	=	9415
	s_rps	=	9433
	s_rsr	=	9451
	s_stx	=	9460
	sstx1	=	9485
	sstx2	=	9496
	s_sin	=	9499
	s_sqr	=	9516
	ssqr1	=	9532
	s_srt	=	9535
	s_spn	=	9544
	s_si_	=	9563
	s_stt	=	9572
	s_sub	=	9582
	ssub2	=	9616
	s_tbl	=	9637
	stbl1	=	9651
	s_tan	=	9656
	s_tim	=	9672
	s_tra	=	9680
	str01	=	9698
	str02	=	9714
	str03	=	9721
	s_trm	=	9724
	s_unl	=	9753
	arref	=	9766
	arf01	=	9800
	arf02	=	9812
	arf03	=	9815
	arf04	=	9834
	arf05	=	9873
	arf06	=	9877
	arf07	=	9889
	arf08	=	9916
	arf09	=	9922
	arf10	=	9924
	arf11	=	9937
	arf12	=	9939
	arf13	=	9941
	cfunc	=	9945
	cfnc1	=	9962
	cfnc2	=	9970
	cfnc3	=	9976
	exfal	=	9979
	exint	=	9995
	exixr	=	10000
	exits	=	10004
	exnam	=	10011
	exnul	=	10023
	exrea	=	10034
	exsid	=	10041
	exsi1	=	10049
	exvnm	=	10057
	flpop	=	10074
	failp	=	10078
	indir	=	10089
	indr1	=	10116
	indr2	=	10119
	match	=	10131
	mtch1	=	10160
	mtch2	=	10195
	retrn	=	10205
	rtn01	=	10211
	rtn02	=	10284
	rtn03	=	10291
	rtn04	=	10316
	rtn05	=	10318
	rtn06	=	10324
	rtn07	=	10328
	rtn7a	=	10364
	rtn7b	=	10367
	rtn7c	=	10369
	rtn08	=	10380
	rtn09	=	10383
	rtn10	=	10399
	rtn11	=	10442
	rtn12	=	10446
	stcov	=	10472
	stmgo	=	10494
	stgo1	=	10521
	stgo2	=	10528
	stgo3	=	10533
	stgo4	=	10579
	stgo5	=	10605
	stopr	=	10610
	stpra	=	10615
	stpr0	=	10628
	stpr1	=	10634
	stpr5	=	10664
	stpr2	=	10770
	stpr3	=	10780
	stpr4	=	10794
	succp	=	10805
	sysab	=	10812
	systu	=	10822
	acess	=	10837
	acs02	=	10844
	acs03	=	10864
	acs04	=	10869
	acs05	=	10871
	acs06	=	10908
	acs6a	=	10916
	acs07	=	10926
	acs08	=	10934
	acs09	=	10953
	acs10	=	10957
	acs11	=	10974
	acs12	=	10980
	acs13	=	10987
	acs14	=	10991
	acs15	=	11003
	acs24	=	11023
	acs25	=	11027
	acs26	=	11031
	acs27	=	11035
	acs28	=	11037
	acs16	=	11041
	acs17	=	11043
	acs18	=	11045
	acs19	=	11047
	acs29	=	11059
	acs20	=	11064
	acs21	=	11068
	acs22	=	11078
	acs23	=	11082
	acomp	=	11086
	acmp1	=	11103
	acmp2	=	11105
	acmp3	=	11107
	acmp4	=	11114
	acmp5	=	11123
	acmp6	=	11125
	acmp7	=	11132
	acmp8	=	11134
	alloc	=	11136
	aloc1	=	11137
	aloc2	=	11150
	alc2a	=	11152
	aloc3	=	11158
	alc3a	=	11165
	alc3b	=	11181
	aloc4	=	11194
	aloc5	=	11231
	alocs	=	11238
	alcs0	=	11253
	alcs1	=	11259
	alcs2	=	11275
	alost	=	11277
	alst1	=	11278
	alst2	=	11291
	alst3	=	11298
	arith	=	11312
	arth1	=	11347
	arth2	=	11351
	arth3	=	11356
	arth4	=	11380
	arth5	=	11388
	arth6	=	11393
	arth7	=	11397
	asign	=	11399
	asg01	=	11400
	asg02	=	11414
	asg03	=	11438
	asg04	=	11442
	asg05	=	11445
	asg06	=	11460
	asg07	=	11468
	asg08	=	11476
	asg09	=	11490
	asg10	=	11496
	asg1b	=	11499
	asg11	=	11517
	asg1a	=	11521
	asg12	=	11528
	asg13	=	11532
	asg14	=	11540
	asg15	=	11580
	asg16	=	11584
	asg25	=	11611
	asg17	=	11620
	asg18	=	11623
	asg19	=	11625
	asg21	=	11636
	asg22	=	11649
	asg23	=	11651
	asg24	=	11661
	asg26	=	11666
	asinp	=	11670
	asnp1	=	11685
	asnp2	=	11725
	blkln	=	11743
	bln00	=	11780
	bln01	=	11784
	bln02	=	11788
	bln03	=	11792
	bln04	=	11796
	bln05	=	11800
	bln06	=	11804
	bln07	=	11808
	bln08	=	11812
	bln09	=	11818
	bln10	=	11822
	bln12	=	11828
	copyb	=	11832
	cop01	=	11874
	cop02	=	11877
	cop03	=	11879
	cop04	=	11887
	cop05	=	11895
	cop06	=	11901
	cop07	=	11915
	cop08	=	11950
	cop09	=	11962
	cop10	=	11967
	cdgcg	=	11969
	cdgc1	=	11979
	cdgc2	=	11985
	cdgex	=	11989
	cdgx1	=	12005
	cdgx2	=	12029
	cdgx3	=	12033
	cdgnm	=	12042
	cgn01	=	12059
	cgn02	=	12061
	cgn03	=	12069
	cgn04	=	12077
	cgn05	=	12094
	cgn06	=	12096
	cgn07	=	12117
	cgn08	=	12123
	cgn09	=	12131
	cgn10	=	12153
	cgn11	=	12161
	cgn12	=	12167
	cdgvl	=	12171
	cgvl0	=	12199
	cgv00	=	12201
	cgv01	=	12207
	cgv02	=	12233
	cgv03	=	12255
	cgv04	=	12257
	cgv05	=	12280
	cgv06	=	12282
	cgv07	=	12289
	cgv08	=	12316
	cgv09	=	12331
	cgv10	=	12337
	cgv11	=	12341
	cgv12	=	12345
	cgv13	=	12356
	cgv14	=	12362
	cgv15	=	12374
	cgv16	=	12384
	cgv17	=	12432
	cgv18	=	12446
	cgv19	=	12450
	cgv20	=	12454
	cgv21	=	12458
	cgv22	=	12475
	cgv23	=	12502
	cgv24	=	12508
	cgv25	=	12539
	cgv26	=	12553
	cgv27	=	12557
	cgv28	=	12589
	cgv29	=	12617
	cgv30	=	12621
	cgv31	=	12643
	cgv32	=	12647
	cgv33	=	12649
	cgv34	=	12651
	cgv35	=	12666
	cgv36	=	12668
	cgv37	=	12695
	cdwrd	=	12703
	cdwd1	=	12710
	cdwd2	=	12730
	cdwd3	=	12754
	cdwd4	=	12781
	cdwd5	=	12803
	cmgen	=	12805
	cmpil	=	12818
	cmp00	=	12821
	cmp01	=	12829
	cmpce	=	12840
	cmpc2	=	12849
	cmp02	=	12865
	cmp03	=	12871
	cmp04	=	12885
	cmple	=	12960
	cmp05	=	12965
	cmp06	=	12973
	cmp07	=	12982
	cmp08	=	13030
	cmp09	=	13032
	cmp10	=	13045
	cmp11	=	13051
	cmp12	=	13063
	cmp13	=	13110
	cmp14	=	13134
	cmp15	=	13139
	cmp16	=	13146
	cmp17	=	13158
	cmp18	=	13160
	cmp19	=	13178
	cmp20	=	13198
	cmp21	=	13207
	cmp22	=	13214
	cmp23	=	13246
	cmpse	=	13259
	cmp25	=	13261
	cmp26	=	13271
	cmp27	=	13317
	cmp28	=	13327
	cmp29	=	13340
	cmp30	=	13349
	cmp31	=	13356
	cmp32	=	13365
	cncrd	=	13373
	cnc01	=	13381
	cnc0a	=	13396
	cnc02	=	13423
	cnc03	=	13429
	cnc04	=	13433
	cnc05	=	13468
	cnc06	=	13478
	cnc07	=	13480
	cnc08	=	13511
	cnc09	=	13520
	cnc10	=	13522
	cnc11	=	13526
	cnc12	=	13530
	cnc13	=	13539
	cnc14	=	13543
	cnc15	=	13547
	cnc16	=	13551
	cnc17	=	13563
	cnc18	=	13567
	cnc19	=	13571
	cnc20	=	13575
	cnc21	=	13579
	cnc22	=	13583
	cnc24	=	13587
	cnc25	=	13591
	cnc27	=	13595
	cnc28	=	13599
	cnc29	=	13621
	cnc30	=	13636
	cnc31	=	13642
	cnc32	=	13647
	cnc33	=	13653
	cnc34	=	13669
	cnc35	=	13697
	cnc36	=	13701
	cnc41	=	13705
	cnc42	=	13831
	cnc43	=	13833
	cnc44	=	13837
	cnc45	=	13859
	cnc46	=	13864
	cnc47	=	13884
	dffnc	=	13890
	dffn1	=	13899
	dffn2	=	13917
	dffn3	=	13938
	dtach	=	13944
	dtch1	=	13951
	dtch2	=	13953
	dtch3	=	13972
	dtch4	=	13987
	dtch5	=	14004
	dtch6	=	14013
	dtype	=	14019
	dtyp1	=	14033
	dumpr	=	14039
	dmp00	=	14069
	dmp01	=	14076
	dmp02	=	14082
	dmp2a	=	14091
	dmp03	=	14105
	dmp04	=	14111
	dmp05	=	14127
	dmp06	=	14144
	dmp07	=	14152
	dmp08	=	14158
	dmp09	=	14171
	dmp10	=	14174
	dmp11	=	14191
	dmp12	=	14205
	dmp13	=	14256
	dmp14	=	14262
	dmp15	=	14279
	dmp16	=	14285
	dmp17	=	14289
	dmp18	=	14295
	dmp19	=	14297
	dmp20	=	14324
	dmp21	=	14336
	dmp2b	=	14345
	dmp22	=	14353
	dmp23	=	14357
	dmp24	=	14367
	dmp25	=	14374
	dmp26	=	14391
	dmp27	=	14403
	dmp28	=	14405
	dmp29	=	14407
	ermsg	=	14411
	ertex	=	14456
	ert01	=	14475
	ert02	=	14481
	evali	=	14485
	evli1	=	14515
	evli2	=	14517
	evli3	=	14519
	evalp	=	14521
	evlp1	=	14537
	evlp2	=	14563
	evlp3	=	14602
	evlp4	=	14606
	evals	=	14627
	evls1	=	14661
	evls2	=	14663
	evalx	=	14668
	evlx1	=	14683
	evlx2	=	14685
	evlx0	=	14733
	evlx3	=	14740
	evlx4	=	14748
	evlx5	=	14761
	evlx6	=	14765
	evlx7	=	14767
	evlx8	=	14774
	evlx9	=	14795
	exbld	=	14797
	exbl1	=	14859
	exbl2	=	14870
	exbl3	=	14878
	exbl4	=	14886
	exbl5	=	14888
	expan	=	14907
	exp01	=	14915
	exp02	=	14958
	exp03	=	14962
	exp04	=	14969
	exp4a	=	14977
	exp05	=	14982
	exp06	=	14984
	exp07	=	14988
	exp08	=	15007
	exp09	=	15009
	exp10	=	15016
	exp11	=	15020
	exp12	=	15034
	exp13	=	15045
	exp14	=	15049
	exp15	=	15054
	exp16	=	15074
	exp17	=	15099
	exp18	=	15116
	exp19	=	15126
	exp20	=	15139
	exp21	=	15148
	exp22	=	15150
	exp23	=	15152
	exp24	=	15154
	exp25	=	15156
	exp26	=	15162
	exp27	=	15171
	expap	=	15185
	expp1	=	15221
	expp2	=	15226
	expdm	=	15231
	exdm1	=	15235
	exdm2	=	15243
	expop	=	15249
	expo1	=	15271
	expo2	=	15285
	filnm	=	15297
	filn1	=	15320
	filn2	=	15339
	filn3	=	15354
	gbcol	=	15361
	gbc0a	=	15387
	gbc00	=	15423
	gbc01	=	15433
	gbc02	=	15439
	gbc03	=	15455
	gbc04	=	15464
	gbc4a	=	15475
	gbc4b	=	15486
	gbc4c	=	15494
	gbc05	=	15508
	gbc06	=	15519
	gbc07	=	15541
	gbc08	=	15550
	gbc09	=	15567
	gbc10	=	15587
	gbc11	=	15592
	gbc12	=	15607
	gbc13	=	15630
	gb13a	=	15674
	gbc14	=	15699
	gbcpf	=	15705
	gpf01	=	15712
	gpf1a	=	15731
	gpf02	=	15737
	gpf2a	=	15739
	gpf03	=	15754
	gpf3a	=	15762
	gpf04	=	15800
	gpf05	=	15804
	gpf06	=	15818
	gpf07	=	15824
	gpf19	=	15830
	gpf08	=	15836
	gpf09	=	15842
	gpf10	=	15848
	gpf11	=	15854
	gpf12	=	15860
	gpf13	=	15866
	gpf14	=	15874
	gpf15	=	15880
	gpf16	=	15886
	gpf17	=	15892
	gtarr	=	15898
	gtar1	=	15919
	gtar2	=	15929
	gtar3	=	15933
	gtar4	=	15940
	gtar5	=	15959
	gta5a	=	15971
	gtar6	=	15979
	gtar7	=	16037
	gtar8	=	16076
	gtar9	=	16078
	gta9a	=	16083
	gta9b	=	16085
	gtcod	=	16087
	gtcd1	=	16132
	gtcd2	=	16134
	gtexp	=	16136
	gtex1	=	16206
	gtex2	=	16208
	gtint	=	16210
	gtin1	=	16233
	gtin2	=	16237
	gtin3	=	16239
	gtnum	=	16241
	gtn01	=	16281
	gtn02	=	16290
	gtna2	=	16293
	gtn03	=	16297
	gtn04	=	16308
	gtn05	=	16312
	gtn06	=	16321
	gtn07	=	16329
	gtn08	=	16338
	gtn09	=	16350
	gtna9	=	16359
	gtn10	=	16363
	gtn11	=	16372
	gtn12	=	16400
	gtn13	=	16413
	gtn14	=	16419
	gtnb4	=	16427
	gtn15	=	16434
	gtn16	=	16445
	gtn17	=	16456
	gtn18	=	16460
	gtn19	=	16463
	gtn20	=	16475
	gtnc0	=	16483
	gtn21	=	16488
	gtn22	=	16499
	gtn23	=	16517
	gtn24	=	16528
	gtn25	=	16535
	gtn26	=	16544
	gtn27	=	16551
	gtn28	=	16564
	gtn29	=	16571
	gtn30	=	16580
	gtn31	=	16585
	gtn32	=	16589
	gtn33	=	16591
	gtn34	=	16595
	gtn35	=	16597
	gtn36	=	16612
	gtnvr	=	16617
	gnv01	=	16627
	gnv02	=	16629
	gnv03	=	16674
	gnv04	=	16690
	gnv05	=	16700
	gnv06	=	16712
	gnv07	=	16721
	gnv08	=	16723
	gnv09	=	16735
	gnv10	=	16749
	gnv11	=	16765
	gnv12	=	16771
	gnv13	=	16779
	gnv14	=	16785
	gnv15	=	16793
	gnv16	=	16826
	gnv17	=	16847
	gnv18	=	16858
	gnv19	=	16868
	gtpat	=	16882
	gtpt1	=	16902
	gtpt2	=	16917
	gtpt3	=	16925
	gtpt4	=	16927
	gtpt5	=	16929
	gtrea	=	16931
	gtre1	=	16944
	gtre2	=	16951
	gtre3	=	16953
	gtsmi	=	16955
	gtsm1	=	16968
	gtsm2	=	16981
	gtsm3	=	16983
	gtstg	=	16985
	gts01	=	16994
	gts02	=	17015
	gts03	=	17023
	gts04	=	17039
	gts05	=	17045
	gts06	=	17057
	gts07	=	17063
	gts08	=	17073
	gts09	=	17097
	gts10	=	17109
	gts11	=	17123
	gts12	=	17126
	gts13	=	17144
	gts14	=	17155
	gts15	=	17173
	gts16	=	17175
	gts17	=	17197
	gts18	=	17221
	gts19	=	17224
	gts20	=	17245
	gts21	=	17250
	gts22	=	17258
	gts23	=	17280
	gts24	=	17287
	gts25	=	17298
	gts26	=	17300
	gts27	=	17309
	gts28	=	17316
	gts29	=	17328
	gts30	=	17337
	gts31	=	17341
	gtvar	=	17351
	gtvr1	=	17368
	gtvr2	=	17370
	gtvr3	=	17382
	gtvr4	=	17389
	hashs	=	17391
	hshs1	=	17412
	hshs2	=	17413
	hshs3	=	17419
	hshsa	=	17429
	hsh24	=	17475
	hsh23	=	17482
	hsh22	=	17489
	hsh21	=	17496
	hsh20	=	17501
	hsh19	=	17508
	hsh18	=	17515
	hsh17	=	17522
	hsh16	=	17527
	hsh15	=	17534
	hsh14	=	17541
	hsh13	=	17548
	hsh12	=	17553
	hsh11	=	17560
	hsh10	=	17567
	hsh09	=	17574
	hsh08	=	17579
	hsh07	=	17586
	hsh06	=	17593
	hsh05	=	17600
	hsh04	=	17605
	hsh03	=	17612
	hsh02	=	17619
	hsh01	=	17626
	hsh00	=	17631
	icbld	=	17636
	icbl1	=	17643
	icbl2	=	17657
	icbl3	=	17669
	ident	=	17674
	iden1	=	17694
	iden2	=	17696
	idn2a	=	17701
	iden3	=	17709
	iden4	=	17725
	iden5	=	17737
	iden6	=	17749
	iden7	=	17757
	iden8	=	17759
	inout	=	17765
	insta	=	17803
	inst1	=	17819
	inst2	=	17855
	iofcb	=	17867
	iofc1	=	17885
	iofc2	=	17901
	iofc3	=	17903
	iofc4	=	17905
	ioppf	=	17907
	iopp1	=	17911
	ioput	=	17938
	iopa0	=	17953
	iop00	=	17969
	iop01	=	17980
	iop02	=	18010
	iop03	=	18024
	iop04	=	18042
	iop05	=	18044
	iop06	=	18060
	iop6a	=	18080
	iop6b	=	18082
	iop07	=	18088
	iop09	=	18106
	iop10	=	18133
	iop1a	=	18135
	iop11	=	18138
	iop12	=	18163
	iop13	=	18167
	iop14	=	18169
	iop15	=	18171
	iop16	=	18175
	iop26	=	18177
	iop17	=	18179
	iopa7	=	18190
	iop18	=	18192
	iopa8	=	18203
	iop19	=	18205
	iop20	=	18207
	iop21	=	18219
	iop22	=	18240
	iop23	=	18245
	iop24	=	18255
	iop25	=	18272
	ktrex	=	18274
	ktrx1	=	18300
	ktrx2	=	18330
	ktrx3	=	18333
	kwnam	=	18335
	kwnm1	=	18383
	lcomp	=	18385
	lcmp1	=	18409
	lcmp7	=	18415
	lcmp2	=	18419
	lcmp3	=	18421
	lcmp4	=	18423
	lcmp5	=	18425
	lcmp6	=	18427
	listr	=	18429
	list0	=	18440
	list1	=	18464
	list2	=	18468
	list8	=	18483
	list3	=	18508
	list4	=	18510
	list5	=	18512
	list6	=	18514
	list7	=	18523
	listt	=	18527
	lstt1	=	18566
	newfn	=	18570
	nwfn1	=	18604
	nexts	=	18608
	nxts1	=	18626
	nxts2	=	18628
	nxts3	=	18648
	patin	=	18656
	ptin1	=	18665
	ptin2	=	18669
	ptin3	=	18677
	patst	=	18679
	pats1	=	18696
	pats2	=	18700
	pats3	=	18729
	pats4	=	18736
	pats5	=	18750
	pats6	=	18767
	pats7	=	18776
	pbild	=	18784
	pbld1	=	18806
	pbld2	=	18810
	pbld3	=	18815
	pbld4	=	18819
	pconc	=	18828
	pcnc1	=	18847
	pcnc2	=	18875
	pcopy	=	18882
	pcop1	=	18888
	pcop2	=	18919
	pcop3	=	18922
	prflr	=	18926
	prfl1	=	18966
	prfl2	=	19008
	prfl3	=	19010
	prfl4	=	19021
	prflu	=	19023
	pflu1	=	19069
	pflu2	=	19074
	pflu3	=	19120
	pflu4	=	19127
	prpar	=	19131
	prpa1	=	19142
	prpa2	=	19154
	prpa3	=	19156
	prpa4	=	19164
	prpa5	=	19201
	prpa6	=	19234
	prpa8	=	19261
	prpa9	=	19285
	prtch	=	19287
	prch1	=	19297
	prtic	=	19314
	prtc1	=	19326
	prtc2	=	19331
	prtis	=	19337
	prts1	=	19346
	prtin	=	19350
	prti1	=	19364
	prtmi	=	19380
	prtmm	=	19392
	prtmx	=	19417
	prtnl	=	19429
	prnl0	=	19435
	prnl1	=	19457
	prnl2	=	19473
	prnl3	=	19480
	prtnm	=	19488
	prn01	=	19505
	prn02	=	19516
	prn03	=	19534
	prn04	=	19542
	prn05	=	19548
	prn06	=	19555
	prn07	=	19557
	prn08	=	19561
	prn09	=	19573
	prn10	=	19582
	prn11	=	19588
	prn12	=	19595
	prn13	=	19601
	prn14	=	19620
	prn15	=	19624
	prn16	=	19639
	prn17	=	19656
	prn18	=	19681
	prn19	=	19685
	prtnv	=	19704
	prtpg	=	19735
	prp01	=	19745
	prp02	=	19757
	prp03	=	19761
	prp04	=	19776
	prp05	=	19812
	prp06	=	19815
	prtps	=	19817
	prtsn	=	19827
	prsn1	=	19851
	prsn2	=	19859
	prtst	=	19870
	prst0	=	19876
	prst1	=	19882
	prst2	=	19907
	prst3	=	19911
	prst4	=	19938
	prttr	=	19944
	prtt1	=	19959
	prtvl	=	19971
	prv01	=	19980
	prv02	=	20008
	prv03	=	20012
	prv04	=	20020
	prv05	=	20024
	prv06	=	20041
	prv07	=	20045
	prv08	=	20059
	prv09	=	20072
	prv10	=	20092
	prv11	=	20098
	prv12	=	20108
	prv13	=	20118
	prv14	=	20141
	prtvn	=	20147
	prvn1	=	20159
	rcbld	=	20166
	rcbl1	=	20181
	readr	=	20193
	reada	=	20205
	read0	=	20240
	read1	=	20247
	read2	=	20251
	read3	=	20253
	read4	=	20255
	read5	=	20268
	read6	=	20359
	sbstr	=	20363
	sbst1	=	20380
	sbst2	=	20384
	stgcc	=	20388
	stgc1	=	20404
	stgc2	=	20410
	stgc3	=	20422
	tfind	=	20430
	tfn00	=	20474
	tfn01	=	20476
	tfn02	=	20480
	tfn03	=	20491
	tfn04	=	20495
	tfn05	=	20499
	tfn06	=	20501
	tfn07	=	20516
	tfn08	=	20537
	tfn09	=	20551
	tfn10	=	20556
	tfn11	=	20561
	tfn12	=	20601
	tmake	=	20603
	tma01	=	20628
	vmake	=	20637
	vmak1	=	20663
	vmak2	=	20670
	scane	=	20672
	scn01	=	20692
	scn02	=	20708
	scn03	=	20715
	scn05	=	20732
	scn06	=	20743
	scn07	=	20881
	scn08	=	20885
	scn09	=	20889
	scn10	=	20896
	scn11	=	20898
	scn12	=	20916
	scn13	=	20918
	scn14	=	20932
	scn15	=	20934
	scn16	=	20947
	scn17	=	20953
	scn18	=	20957
	scn19	=	20981
	scn20	=	20985
	scn21	=	20989
	scn22	=	20991
	scn23	=	20994
	scn24	=	21000
	scn25	=	21004
	scn26	=	21030
	scn27	=	21034
	scn28	=	21038
	scn29	=	21042
	scn30	=	21046
	scn31	=	21050
	scn32	=	21054
	scn33	=	21058
	scn34	=	21064
	scn35	=	21070
	scn36	=	21072
	scn37	=	21074
	scn38	=	21076
	scn39	=	21078
	scn40	=	21080
	scn41	=	21082
	scn42	=	21084
	scn43	=	21086
	scn44	=	21088
	scn45	=	21090
	scn46	=	21092
	scn47	=	21133
	scn48	=	21136
	scn49	=	21138
	scn50	=	21166
	scn51	=	21174
	scngf	=	21180
	scng1	=	21191
	scng2	=	21205
	scng3	=	21211
	scng4	=	21222
	setvr	=	21224
	setv1	=	21252
	sorta	=	21254
	srt01	=	21310
	srt02	=	21321
	srt03	=	21352
	srt04	=	21398
	srt05	=	21413
	srt06	=	21415
	srt07	=	21423
	srt08	=	21445
	srt09	=	21452
	srt10	=	21459
	srt11	=	21467
	srt12	=	21497
	srt13	=	21509
	srt15	=	21529
	srt16	=	21540
	srt17	=	21542
	srt18	=	21544
	sortc	=	21546
	src01	=	21570
	src02	=	21581
	src14	=	21592
	src03	=	21606
	src04	=	21609
	src05	=	21613
	src06	=	21616
	src07	=	21620
	src08	=	21624
	src09	=	21630
	src10	=	21644
	src11	=	21653
	src12	=	21665
	sortf	=	21681
	srtf1	=	21703
	srtf2	=	21705
	srtf3	=	21708
	srtf4	=	21710
	srtf5	=	21722
	srtf6	=	21734
	sorth	=	21746
	srh01	=	21764
	srh02	=	21789
	srh03	=	21836
	trace	=	21856
	trc01	=	21898
	trc02	=	21918
	trc03	=	21922
	trc04	=	21934
	trc05	=	21953
	trc06	=	21960
	trc07	=	21973
	trc08	=	21988
	trc09	=	21992
	trc10	=	21998
	trc11	=	22009
	trc12	=	22028
	trc13	=	22032
	trc14	=	22042
	trc15	=	22051
	trc16	=	22053
	trc17	=	22055
	trbld	=	22057
	trimr	=	22081
	trim0	=	22094
	trim1	=	22102
	trim2	=	22106
	trim3	=	22112
	trim4	=	22128
	trim5	=	22134
	trxeq	=	22138
	trxq1	=	22214
	trxq2	=	22254
	xscan	=	22256
	xscn1	=	22277
	xscn2	=	22303
	xscn3	=	22307
	xscn4	=	22321
	xscn5	=	22326
	xscn6	=	22329
	xscn7	=	22345
	xscn8	=	22359
	xscni	=	22365
	xsci1	=	22379
	xsci2	=	22381
	sec06	=	22384
	stak1	=	22396
	error_	=	22403
	err01	=	22431
	erra1	=	22481
	erra2	=	22489
	err02	=	22506
	erra0	=	22515
	erra3	=	22522
	err03	=	22541
	err04	=	22577
	erra4	=	22595
	errb4	=	22615
	errc4	=	22620
	err05	=	22624
	err06	=	22628
	err07	=	22633
	err08	=	22673
	s_yyy	=	22682
)
const (
	sysax_ = iota
	sysbs_
	sysbx_
	syscm_
	sysdc_
	sysdm_
	sysdt_
	sysea_
	sysef_
	sysej_
	sysem_
	sysen_
	sysep_
	sysex_
	sysfc_
	sysgc_
	syshs_
	sysid_
	sysif_
	sysil_
	sysin_
	sysio_
	sysld_
	sysmm_
	sysmx_
	sysou_
	syspi_
	syspl_
	syspp_
	syspr_
	sysrd_
	sysri_
	sysrw_
	sysst_
	systt_
	systm_
	sysul_
	sysxi_
)
var error_messages = map[int]string {
	1	: "addition left operand is not numeric",
	2	: "addition right operand is not numeric",
	3	: "addition caused integer overflow",
	4	: "affirmation operand is not numeric",
	5	: "alternation right operand is not pattern",
	6	: "alternation left operand is not pattern",
	7	: "compilation error encountered during execution",
	8	: "concatenation left operand is not a string or pattern",
	9	: "concatenation right operand is not a string or pattern",
	10	: "negation operand is not numeric",
	11	: "negation caused integer overflow",
	12	: "division left operand is not numeric",
	13	: "division right operand is not numeric",
	14	: "division caused integer overflow",
	15	: "exponentiation right operand is not numeric",
	16	: "exponentiation left operand is not numeric",
	17	: "exponentiation caused integer overflow",
	18	: "exponentiation result is undefined",
	20	: "goto evaluation failure",
	21	: "function called by name returned a value",
	22	: "undefined function called",
	23	: "goto operand is not a natural variable",
	24	: "goto operand in direct goto is not code",
	25	: "immediate assignment left operand is not pattern",
	26	: "multiplication left operand is not numeric",
	27	: "multiplication right operand is not numeric",
	28	: "multiplication caused integer overflow",
	29	: "undefined operator referenced",
	30	: "pattern assignment left operand is not pattern",
	31	: "pattern replacement right operand is not a string",
	32	: "subtraction left operand is not numeric",
	33	: "subtraction right operand is not numeric",
	34	: "subtraction caused integer overflow",
	35	: "unexpected failure in -nofail mode",
	36	: "goto abort with no preceding error",
	37	: "goto continue with no preceding error",
	38	: "goto undefined label",
	39	: "external function argument is not a string",
	40	: "external function argument is not integer",
	41	: "field function argument is wrong datatype",
	42	: "attempt to change value of protected variable",
	43	: "any evaluated argument is not a string",
	44	: "break evaluated argument is not a string",
	45	: "breakx evaluated argument is not a string",
	46	: "expression does not evaluate to pattern",
	47	: "len evaluated argument is not integer",
	48	: "len evaluated argument is negative or too large",
	49	: "notany evaluated argument is not a string",
	50	: "pos evaluated argument is not integer",
	51	: "pos evaluated argument is negative or too large",
	52	: "rpos evaluated argument is not integer",
	53	: "rpos evaluated argument is negative or too large",
	54	: "rtab evaluated argument is not integer",
	55	: "rtab evaluated argument is negative or too large",
	56	: "span evaluated argument is not a string",
	57	: "tab evaluated argument is not integer",
	58	: "tab evaluated argument is negative or too large",
	59	: "any argument is not a string or expression",
	60	: "apply first arg is not natural variable name",
	61	: "arbno argument is not pattern",
	62	: "arg second argument is not integer",
	63	: "arg first argument is not program function name",
	64	: "array first argument is not integer or string",
	65	: "array first argument lower bound is not integer",
	66	: "array first argument upper bound is not integer",
	67	: "array dimension is zero, negative or out of range",
	68	: "array size exceeds maximum permitted",
	69	: "break argument is not a string or expression",
	70	: "breakx argument is not a string or expression",
	71	: "clear argument is not a string",
	72	: "clear argument has null variable name",
	73	: "collect argument is not integer",
	74	: "convert second argument is not a string",
	75	: "data argument is not a string",
	76	: "data argument is null",
	77	: "data argument is missing a left paren",
	78	: "data argument has null datatype name",
	79	: "data argument is missing a right paren",
	80	: "data argument has null field name",
	81	: "define first argument is not a string",
	82	: "define first argument is null",
	83	: "define first argument is missing a left paren",
	84	: "define first argument has null function name",
	85	: "null arg name or missing ) in define first arg.",
	86	: "define function entry point is not defined label",
	87	: "detach argument is not appropriate name",
	88	: "dump argument is not integer",
	89	: "dump argument is negative or too large",
	90	: "dupl second argument is not integer",
	91	: "dupl first argument is not a string or pattern",
	92	: "eject argument is not a suitable name",
	93	: "eject file does not exist",
	94	: "eject file does not permit page eject",
	95	: "eject caused non-recoverable output error",
	96	: "endfile argument is not a suitable name",
	97	: "endfile argument is null",
	98	: "endfile file does not exist",
	99	: "endfile file does not permit endfile",
	100	: "endfile caused non-recoverable output error",
	101	: "eq first argument is not numeric",
	102	: "eq second argument is not numeric",
	103	: "eval argument is not expression",
	104	: "exit first argument is not suitable integer or string",
	105	: "exit action not available in this implementation",
	106	: "exit action caused irrecoverable error",
	107	: "field second argument is not integer",
	108	: "field first argument is not datatype name",
	109	: "ge first argument is not numeric",
	110	: "ge second argument is not numeric",
	111	: "gt first argument is not numeric",
	112	: "gt second argument is not numeric",
	113	: "input third argument is not a string",
	114	: "inappropriate second argument for input",
	115	: "inappropriate first argument for input",
	116	: "inappropriate file specification for input",
	117	: "input file cannot be read",
	118	: "le first argument is not numeric",
	119	: "le second argument is not numeric",
	120	: "len argument is not integer or expression",
	121	: "len argument is negative or too large",
	122	: "leq first argument is not a string",
	123	: "leq second argument is not a string",
	124	: "lge first argument is not a string",
	125	: "lge second argument is not a string",
	126	: "lgt first argument is not a string",
	127	: "lgt second argument is not a string",
	128	: "lle first argument is not a string",
	129	: "lle second argument is not a string",
	130	: "llt first argument is not a string",
	131	: "llt second argument is not a string",
	132	: "lne first argument is not a string",
	133	: "lne second argument is not a string",
	134	: "local second argument is not integer",
	135	: "local first arg is not a program function name",
	136	: "load second argument is not a string",
	137	: "load first argument is not a string",
	138	: "load first argument is null",
	139	: "load first argument is missing a left paren",
	140	: "load first argument has null function name",
	141	: "load first argument is missing a right paren",
	142	: "load function does not exist",
	143	: "load function caused input error during load",
	144	: "lpad third argument is not a string",
	145	: "lpad second argument is not integer",
	146	: "lpad first argument is not a string",
	147	: "lt first argument is not numeric",
	148	: "lt second argument is not numeric",
	149	: "ne first argument is not numeric",
	150	: "ne second argument is not numeric",
	151	: "notany argument is not a string or expression",
	152	: "opsyn third argument is not integer",
	153	: "opsyn third argument is negative or too large",
	154	: "opsyn second arg is not natural variable name",
	155	: "opsyn first arg is not natural variable name",
	156	: "opsyn first arg is not correct operator name",
	157	: "output third argument is not a string",
	158	: "inappropriate second argument for output",
	159	: "inappropriate first argument for output",
	160	: "inappropriate file specification for output",
	161	: "output file cannot be written to",
	162	: "pos argument is not integer or expression",
	163	: "pos argument is negative or too large",
	164	: "prototype argument is not valid object",
	165	: "remdr second argument is not numeric",
	166	: "remdr first argument is not numeric",
	167	: "remdr caused integer overflow",
	168	: "replace third argument is not a string",
	169	: "replace second argument is not a string",
	170	: "replace first argument is not a string",
	171	: "null or unequally long 2nd, 3rd args to replace",
	172	: "rewind argument is not a suitable name",
	173	: "rewind argument is null",
	174	: "rewind file does not exist",
	175	: "rewind file does not permit rewind",
	176	: "rewind caused non-recoverable error",
	177	: "reverse argument is not a string",
	178	: "rpad third argument is not a string",
	179	: "rpad second argument is not integer",
	180	: "rpad first argument is not a string",
	181	: "rtab argument is not integer or expression",
	182	: "rtab argument is negative or too large",
	183	: "tab argument is not integer or expression",
	184	: "tab argument is negative or too large",
	185	: "rpos argument is not integer or expression",
	186	: "rpos argument is negative or too large",
	187	: "setexit argument is not label name or null",
	188	: "span argument is not a string or expression",
	189	: "size argument is not a string",
	190	: "stoptr first argument is not appropriate name",
	191	: "stoptr second argument is not trace type",
	192	: "substr third argument is not integer",
	193	: "substr second argument is not integer",
	194	: "substr first argument is not a string",
	195	: "table argument is not integer",
	196	: "table argument is out of range",
	197	: "trace fourth arg is not function name or null",
	198	: "trace first argument is not appropriate name",
	199	: "trace second argument is not trace type",
	200	: "trim argument is not a string",
	201	: "unload argument is not natural variable name",
	202	: "input from file caused non-recoverable error",
	203	: "input file record has incorrect format",
	204	: "memory overflow",
	205	: "string length exceeds value of maxlngth keyword",
	206	: "output caused file overflow",
	207	: "output caused non-recoverable error",
	208	: "keyword value assigned is not integer",
	209	: "keyword in assignment is protected",
	210	: "keyword value assigned is negative or too large",
	211	: "value assigned to keyword errtext not a string",
	212	: "syntax error: value used where name is required",
	213	: "syntax error: statement is too complicated.",
	214	: "bad label or misplaced continuation line",
	215	: "syntax error: undefined or erroneous entry label",
	216	: "syntax error: missing end line",
	217	: "syntax error: duplicate label",
	218	: "syntax error: duplicated goto field",
	219	: "syntax error: empty goto field",
	220	: "syntax error: missing operator",
	221	: "syntax error: missing operand",
	222	: "syntax error: invalid use of left bracket",
	223	: "syntax error: invalid use of comma",
	224	: "syntax error: unbalanced right parenthesis",
	225	: "syntax error: unbalanced right bracket",
	226	: "syntax error: missing right paren",
	227	: "syntax error: right paren missing from goto",
	228	: "syntax error: right bracket missing from goto",
	229	: "syntax error: missing right array bracket",
	230	: "syntax error: illegal character",
	231	: "syntax error: invalid numeric item",
	232	: "syntax error: unmatched string quote",
	233	: "syntax error: invalid use of operator",
	234	: "syntax error: goto field incorrect",
	235	: "subscripted operand is not table or array",
	236	: "array referenced with wrong number of subscripts",
	237	: "table referenced with more than one subscript",
	238	: "array subscript is not integer",
	239	: "indirection operand is not name",
	240	: "pattern match right operand is not pattern",
	241	: "pattern match left operand is not a string",
	242	: "function return from level zero",
	243	: "function result in nreturn is not name",
	244	: "statement count exceeds value of stlimit keyword",
	245	: "translation/execution time expired",
	246	: "stack overflow",
	247	: "invalid control statement",
	248	: "attempted redefinition of system function",
	249	: "expression evaluated by name returned value",
	250	: "insufficient memory to complete dump",
	251	: "keyword operand is not name of defined keyword",
	252	: "error on printing to interactive channel",
	253	: "print limit exceeded on standard output channel",
	254	: "erroneous argument for host",
	255	: "error during execution of host",
	256	: "sort/rsort 1st arg not suitable array or table",
	257	: "erroneous 2nd arg in sort/rsort of vector",
	258	: "sort/rsort 2nd arg out of range or non-integer",
	259	: "fence argument is not pattern",
	260	: "conversion array size exceeds maximum permitted",
	261	: "addition caused real overflow",
	262	: "division caused real overflow",
	263	: "multiplication caused real overflow",
	264	: "subtraction caused real overflow",
	265	: "external function argument is not real",
	266	: "exponentiation caused real overflow",
	268	: "inconsistent value assigned to keyword profile",
	274	: "value assigned to keyword fullscan is zero",
	281	: "char argument not integer",
	282	: "char argument not in range",
	284	: "excessively nested include files",
	285	: "include file cannot be opened",
	286	: "function call to undefined entry label",
	287	: "value assigned to keyword maxlngth is too small",
	288	: "exit second argument is not a string",
	289	: "input channel currently in use",
	290	: "output channel currently in use",
	291	: "set first argument is not a suitable name",
	292	: "set first argument is null",
	293	: "inappropriate second argument to set",
	294	: "inappropriate third argument to set",
	295	: "set file does not exist",
	296	: "set file does not permit setting file pointer",
	297	: "set caused non-recoverable i/o error",
	298	: "external function argument is not file",
	301	: "atan argument not numeric",
	302	: "chop argument not numeric",
	303	: "cos argument not numeric",
	304	: "exp argument not numeric",
	305	: "exp produced real overflow",
	306	: "ln argument not numeric",
	307	: "ln produced real overflow",
	308	: "sin argument not numeric",
	309	: "tan argument not numeric",
	310	: "tan produced real overflow or argument is out of range",
	311	: "exponentiation of negative base to non-integral power",
	312	: "remdr caused real overflow",
	313	: "sqrt argument not numeric",
	314	: "sqrt argument negative",
	315	: "ln argument negative",
	316	: "backspace argument is not a suitable name",
	317	: "backspace file does not exist",
	318	: "backspace file does not permit backspace",
	319	: "backspace caused non-recoverable error",
	320	: "user interrupt",
	321	: "goto scontinue with no preceding error",
	322	: "cos argument is out of range",
	323	: "sin argument is out of range",
	326	: "calling external function - bad argument type",
	327	: "calling external function - not found",
	328	: "load function - insufficient memory",
	329	: "requested maxlngth too large",
	330	: "date argument is not integer",
	331	: "goto scontinue with no user interrupt",
	332	: "goto continue with error in failure goto",
}
var prc_names = map[int]string {
	2549	:	"relaj",
	2599	:	"relcr",
	2700	:	"reldn",
	2907	:	"reloc",
	2926	:	"relst",
	2977	:	"relws",
	2999	:	"start",
	3366	:	"rstrt",
	10838	:	"acess",
	11087	:	"acomp",
	11137	:	"alloc",
	11239	:	"alocs",
	11278	:	"alost",
	11313	:	"arith",
	11400	:	"asign",
	11671	:	"asinp",
	11744	:	"blkln",
	11833	:	"copyb",
	11970	:	"cdgcg",
	11990	:	"cdgex",
	12043	:	"cdgnm",
	12172	:	"cdgvl",
	12704	:	"cdwrd",
	12806	:	"cmgen",
	12819	:	"cmpil",
	13374	:	"cncrd",
	13891	:	"dffnc",
	13945	:	"dtach",
	14020	:	"dtype",
	14040	:	"dumpr",
	14412	:	"ermsg",
	14457	:	"ertex",
	14486	:	"evali",
	14522	:	"evalp",
	14628	:	"evals",
	14669	:	"evalx",
	14798	:	"exbld",
	14908	:	"expan",
	15186	:	"expap",
	15232	:	"expdm",
	15250	:	"expop",
	15298	:	"filnm",
	15362	:	"gbcol",
	15706	:	"gbcpf",
	15899	:	"gtarr",
	16088	:	"gtcod",
	16137	:	"gtexp",
	16211	:	"gtint",
	16242	:	"gtnum",
	16618	:	"gtnvr",
	16883	:	"gtpat",
	16932	:	"gtrea",
	16956	:	"gtsmi",
	16986	:	"gtstg",
	17352	:	"gtvar",
	17392	:	"hashs",
	17637	:	"icbld",
	17675	:	"ident",
	17766	:	"inout",
	17804	:	"insta",
	17868	:	"iofcb",
	17908	:	"ioppf",
	17939	:	"ioput",
	18275	:	"ktrex",
	18336	:	"kwnam",
	18386	:	"lcomp",
	18430	:	"listr",
	18528	:	"listt",
	18571	:	"newfn",
	18609	:	"nexts",
	18657	:	"patin",
	18680	:	"patst",
	18785	:	"pbild",
	18829	:	"pconc",
	18883	:	"pcopy",
	18927	:	"prflr",
	19024	:	"prflu",
	19132	:	"prpar",
	19288	:	"prtch",
	19315	:	"prtic",
	19338	:	"prtis",
	19351	:	"prtin",
	19381	:	"prtmi",
	19393	:	"prtmm",
	19418	:	"prtmx",
	19430	:	"prtnl",
	19489	:	"prtnm",
	19705	:	"prtnv",
	19736	:	"prtpg",
	19818	:	"prtps",
	19828	:	"prtsn",
	19871	:	"prtst",
	19945	:	"prttr",
	19972	:	"prtvl",
	20148	:	"prtvn",
	20167	:	"rcbld",
	20194	:	"readr",
	20364	:	"sbstr",
	20389	:	"stgcc",
	20431	:	"tfind",
	20604	:	"tmake",
	20638	:	"vmake",
	20673	:	"scane",
	21181	:	"scngf",
	21225	:	"setvr",
	21255	:	"sorta",
	21547	:	"sortc",
	21682	:	"sortf",
	21747	:	"sorth",
	21857	:	"trace",
	22058	:	"trbld",
	22082	:	"trimr",
	22139	:	"trxeq",
	22257	:	"xscan",
	22366	:	"xscni",
}
var stmt_text = map[int]string {
	1	:	"//relaj	prc e 0  entry point",
	2	:	"//	mov -(xs) xr  save xr",
	3	:	"//	mov -(xs) wa  save wa",
	4	:	"//	mov rlals xl  save ptr to list of bounds",
	5	:	"//	mov xr wb  ptr to first pointer to process",
	6	:	"//rlaj0	mov xl rlals  restore xl",
	7	:	"//	bne xr (xs) rlaj1 proceed if more to do",
	8	:	"//	mov wa (xs)+  restore wa",
	9	:	"//	mov xr (xs)+  restore xr",
	10	:	"//	exi    return to caller",
	11	:	"//rlaj1	mov wa (xr)  load next pointer on list",
	12	:	"//	lct wb =rnsi_  number of sections of adjusters",
	13	:	"//rlaj2	bgt wa rlend(xl) rlaj3 ok if past end of section",
	14	:	"//	blt wa rlstr(xl) rlaj3 or if before start of section",
	15	:	"//	add wa rladj(xl)  within section, add adjustment",
	16	:	"//	mov (xr) wa  return updated ptr to memory",
	17	:	"//	brn rlaj4   done with this pointer",
	18	:	"//rlaj3	add xl *rssi_  advance to next section",
	19	:	"//	bct wb rlaj2  jump if more to go",
	20	:	"//rlaj4	ica xr   increment to next ptr on list",
	21	:	"//	brn rlaj0   jump to check  for completion",
	22	:	"//relcr	prc e 0  entry point",
	23	:	"//	add xl *rlsi_  point past build area",
	24	:	"//	mov -(xl) wa  save original code address",
	25	:	"//	mov wa =s_aaa  compute adjustment",
	26	:	"//	sub wa (xl)  as new s_aaa minus original s_aaa",
	27	:	"//	mov -(xl) wa  save code adjustment",
	28	:	"//	mov wa =s_yyy  end of target code section",
	29	:	"//	sub wa =s_aaa  length of code section",
	30	:	"//	add wa num01(xl)  plus original start address",
	31	:	"//	mov -(xl) wa  end of original code section",
	32	:	"//	mov -(xl) wb  save constant section address",
	33	:	"//	mov wb =c_aaa  start of constants section",
	34	:	"//	mov wa =c_yyy  end of constants section",
	35	:	"//	sub wa wb  length of constants section",
	36	:	"//	sub wb (xl)  new c_aaa minus original c_aaa",
	37	:	"//	mov -(xl) wb  save constant adjustment",
	38	:	"//	add wa num01(xl)  length plus original start adr",
	39	:	"//	mov -(xl) wa  save as end of original constants",
	40	:	"//	mov -(xl) wc  save working globals address",
	41	:	"//	mov wc =g_aaa  start of working globals section",
	42	:	"//	mov wa =w_yyy  end of working section",
	43	:	"//	sub wa wc  length of working globals",
	44	:	"//	sub wc (xl)  new g_aaa minus original g_aaa",
	45	:	"//	mov -(xl) wc  save working globals adjustment",
	46	:	"//	add wa num01(xl)  length plus original start adr",
	47	:	"//	mov -(xl) wa  save as end of working globals",
	48	:	"//	mov wb statb  old start of static region",
	49	:	"//	mov -(xl) wb  save",
	50	:	"//	sub xr wb  compute adjustment",
	51	:	"//	mov -(xl) xr  save new statb minus old statb",
	52	:	"//	mov -(xl) state  old end of static region",
	53	:	"//	mov wb dnamb  old start of dynamic region",
	54	:	"//	mov -(xl) wb  save",
	55	:	"//	scp wa   new start of dynamic",
	56	:	"//	sub wa wb  compute adjustment",
	57	:	"//	mov -(xl) wa  save new dnamb minus old dnamb",
	58	:	"//	mov wc dnamp  old end of dynamic region in use",
	59	:	"//	mov -(xl) wc  save as end of old dynamic region",
	60	:	"//	exi    ",
	61	:	"//reldn	prc e 0  entry point",
	62	:	"//	mov rldcd rlcda(xl)  save code adjustment",
	63	:	"//	mov rldst rlsta(xl)  save static adjustment",
	64	:	"//	mov rldls xl  save list pointer",
	65	:	"//rld01	add (xr) rldcd  adjust block type word",
	66	:	"//	mov xl (xr)  load block type word",
	67	:	"//	lei xl   load entry point id (bl_xx)",
	68	:	"//	bsw xl bl___  switch on block type",
	69	:	"//rld03	mov wa arlen(xr)  load length",
	70	:	"//	mov wb arofs(xr)  set offset to 1st reloc fld (arpro)",
	71	:	"//rld04	add wa xr  point past last reloc field",
	72	:	"//	add wb xr  point to first reloc field",
	73	:	"//	mov xl rldls  point to list of bounds",
	74	:	"//	jsr relaj   adjust pointers",
	75	:	"//rld05	mov wa (xr)  block type word",
	76	:	"//	jsr blkln   get length of block",
	77	:	"//	add xr wa  point to next block",
	78	:	"//	blt xr wc rld01 continue if more to process",
	79	:	"//	mov xl rldls  restore xl",
	80	:	"//	exi    return to caller if done",
	81	:	"//rld07	mov wa cdlen(xr)  load length",
	82	:	"//	mov wb *cdfal  set offset",
	83	:	"//	bne (xr) =b_cdc rld04 jump back if not complex goto",
	84	:	"//	mov wb *cdcod  do not process cdfal word",
	85	:	"//	brn rld04   jump back",
	86	:	"//rld08	mov wa *efrsl  set length",
	87	:	"//	mov wb *efcod  and offset",
	88	:	"//	brn rld04   all set",
	89	:	"//rld09	mov wa *offs3  point past third field",
	90	:	"//	mov wb *evexp  set offset",
	91	:	"//	brn rld04   all set",
	92	:	"//rld10	mov wa exlen(xr)  load length",
	93	:	"//	mov wb *exflc  set offset",
	94	:	"//	brn rld04   jump back",
	95	:	"//rld11	bne ffofs(xr) *pdfld rld12 skip dfblk if not first field",
	96	:	"//	mov -(xs) xr  save xr",
	97	:	"//	mov xr ffdfp(xr)  load old ptr to dfblk",
	98	:	"//	add xr rldst  current location of dfblk",
	99	:	"//	add (xr) rldcd  adjust dfblk type word",
	100	:	"//	mov wa dflen(xr)  length of dfblk",
	101	:	"//	mov wb *dfnam  offset to dfnam field",
	102	:	"//	add wa xr  point past last reloc field",
	103	:	"//	add wb xr  point to first reloc field",
	104	:	"//	mov xl rldls  point to list of bounds",
	105	:	"//	jsr relaj   adjust pointers",
	106	:	"//	mov xr dfnam(xr)  pointer to static scblk",
	107	:	"//	add (xr) rldcd  adjust scblk type word",
	108	:	"//	mov xr (xs)+  restore ffblk pointer",
	109	:	"//rld12	mov wa *ffofs  set length",
	110	:	"//	mov wb *ffdfp  set offset",
	111	:	"//	brn rld04   all set",
	112	:	"//rld13	mov wa *offs2  point past second field",
	113	:	"//	mov wb *offs1  offset is one (only reloc fld is 2)",
	114	:	"//	brn rld04   all set",
	115	:	"//rld14	mov wa *parm2  length (parm2 is non-relocatable)",
	116	:	"//	mov wb *pthen  set offset",
	117	:	"//	brn rld04   all set",
	118	:	"//rld15	mov xl pddfp(xr)  load ptr to dfblk",
	119	:	"//	add xl rldst  adjust for static relocation",
	120	:	"//	mov wa dfpdl(xl)  get pdblk length",
	121	:	"//	mov wb *pddfp  set offset",
	122	:	"//	brn rld04   all set",
	123	:	"//rld16	add pfvbl(xr) rldst  adjust non-contiguous field",
	124	:	"//	mov wa pflen(xr)  get pfblk length",
	125	:	"//	mov wb *pfcod  offset to first reloc",
	126	:	"//	brn rld04   all set",
	127	:	"//rld17	mov wa offs2(xr)  load length",
	128	:	"//	mov wb *offs3  set offset",
	129	:	"//	brn rld04   jump back",
	130	:	"//rld18	mov wa *tesi_  set length",
	131	:	"//	mov wb *tesub  and offset",
	132	:	"//	brn rld04   all set",
	133	:	"//rld19	mov wa *trsi_  set length",
	134	:	"//	mov wb *trval  and offset",
	135	:	"//	brn rld04   all set",
	136	:	"//rld20	mov wa xrlen(xr)  load length",
	137	:	"//	mov wb *xrptr  set offset",
	138	:	"//	brn rld04   jump back",
	139	:	"//reloc	prc e 0  entry point",
	140	:	"//	mov xr rldys(xl)  old start of dynamic",
	141	:	"//	mov wc rldye(xl)  old end of dynamic",
	142	:	"//	add xr rldya(xl)  create new start of dynamic",
	143	:	"//	add wc rldya(xl)  create new end of dynamic",
	144	:	"//	jsr reldn   relocate pointers in dynamic",
	145	:	"//	jsr relws   relocate pointers in working sect",
	146	:	"//	jsr relst   relocate pointers in static",
	147	:	"//	exi    return to caller",
	148	:	"//relst	prc e 0  entry point",
	149	:	"//	mov xr pftbl  profile table",
	150	:	"//	bze xr rls01  branch if no table allocated",
	151	:	"//	add (xr) rlcda(xl)  adjust block type word",
	152	:	"//rls01	mov wc hshtb  point to start of hash table",
	153	:	"//	mov wb wc  point to first hash bucket",
	154	:	"//	mov wa hshte  point beyond hash table",
	155	:	"//	jsr relaj   adjust bucket pointers",
	156	:	"//rls02	beq wc hshte rls05 done if none left",
	157	:	"//	mov xr wc  else copy slot pointer",
	158	:	"//	ica wc   bump slot pointer",
	159	:	"//	sub xr *vrnxt  set offset to merge into loop",
	160	:	"//rls03	mov xr vrnxt(xr)  point to next vrblk on chain",
	161	:	"//	bze xr rls02  jump for next bucket if chain end",
	162	:	"//	mov wa *vrlen  offset of first loc past ptr fields",
	163	:	"//	mov wb *vrget  offset of first location in vrblk",
	164	:	"//	bnz vrlen(xr) rls04  jump if not system variable",
	165	:	"//	mov wa *vrsi_  offset to include vrsvp field",
	166	:	"//rls04	add wa xr  create end ptr",
	167	:	"//	add wb xr  create start ptr",
	168	:	"//	jsr relaj   adjust pointers in vrblk",
	169	:	"//	brn rls03   check for another vrblk on chain",
	170	:	"//rls05	exi    return to caller",
	171	:	"//relws	prc e 0  entry point",
	172	:	"//	mov wb =a_aaa  point to start of adjustables",
	173	:	"//	mov wa =r_yyy  point to end of adjustables",
	174	:	"//	jsr relaj   relocate adjustable pointers",
	175	:	"//	add dname rldya(xl)  adjust ptr missed by relaj",
	176	:	"//	mov wb =kvrtn  case of kvrtn",
	177	:	"//	mov wa wb  handled specially",
	178	:	"//	ica wa   one value to adjust",
	179	:	"//	jsr relaj   adjust kvrtn",
	180	:	"//	exi    return to caller",
	181	:	"//start	prc e 0  entry point",
	182	:	"//	mov mxint wb  ",
	183	:	"//	mov 4,bitsm wb  ",
	184	:	"//	zer wb   ",
	185	:	"//	mov xs wa  discard return",
	186	:	"//	jsr systm   initialise timer",
	187	:	"//	sti timsx   store time",
	188	:	"//	mov statb xr  start address of static",
	189	:	"//	mov rsmem *e_srs  reserve memory",
	190	:	"//	mov stbas xs  store stack base",
	191	:	"//	sss iniss   save s-r stack ptr",
	192	:	"//	ldi 4,intvh   get 100",
	193	:	"//	dvi 4,alfsp   form 100 / alfsp",
	194	:	"//	sti alfsf   store the factor",
	195	:	"//	ldi 4,intvh   get 100",
	196	:	"//	dvi 4,gbsdp   form 100 / gbsdp",
	197	:	"//	sti gbsed   store the factor",
	198	:	"//	lct wb =cfp_s  load counter for significant digits",
	199	:	"//	ldr 4,reav1   load 1.0",
	200	:	"//ini03	mlr 4,reavt   * 10.0",
	201	:	"//	bct wb ini03  loop till done",
	202	:	"//	str gtssc   store 10**(max sig digits)",
	203	:	"//	ldr 4,reap5   load 0.5",
	204	:	"//	dvr gtssc   compute 0.5*10**(max sig digits)",
	205	:	"//	str gtsrn   store as rounding bias",
	206	:	"//	zer wc   set to read parameters",
	207	:	"//	jsr prpar   read them",
	208	:	"//	sub xl *e_srs  allow for reserve memory",
	209	:	"//	mov wa prlen  get print buffer length",
	210	:	"//	add wa =cfp_a  add no. of chars in alphabet",
	211	:	"//	add wa =nstmx  add chars for gtstg bfr",
	212	:	"//	ctb wa 8  convert to bytes, allowing a margin",
	213	:	"//	mov xr statb  point to static base",
	214	:	"//	add xr wa  increment for above buffers",
	215	:	"//	add xr *e_hnb  increment for hash table",
	216	:	"//	add xr *e_sts  bump for initial static block",
	217	:	"//	jsr sysmx   get mxlen",
	218	:	"//	mov kvmxl wa  provisionally store as maxlngth",
	219	:	"//	mov mxlen wa  and as mxlen",
	220	:	"//	bgt xr wa ini06 skip if static hi exceeds mxlen",
	221	:	"//	ctb wa 1  round up and make bigger than mxlen",
	222	:	"//	mov xr wa  use it instead",
	223	:	"//ini06	mov dnamb xr  dynamic base adrs",
	224	:	"//	mov dnamp xr  dynamic ptr",
	225	:	"//	bnz wa ini07  skip if non-zero mxlen",
	226	:	"//	dca xr   point a word in front",
	227	:	"//	mov kvmxl xr  use as maxlngth",
	228	:	"//	mov mxlen xr  and as mxlen",
	229	:	"//ini07	mov dname xl  store dynamic end address",
	230	:	"//	blt dnamb xl ini09 skip if high enough",
	231	:	"//	jsr sysmm   request more memory",
	232	:	"//	wtb xr   get as baus (sgd05)",
	233	:	"//	add xl xr  bump by amount obtained",
	234	:	"//	bnz xr ini07  try again",
	235	:	"//	mov wa =mxern  insufficient memory for maxlength",
	236	:	"//	zer wb   no column number info",
	237	:	"//	zer wc   no line number info",
	238	:	"//	mov xr =stgic  initial compile stage",
	239	:	"//	mov xl =nulls  no file name",
	240	:	"//	jsr sysea   advise of error",
	241	:	"//	brn ini08   force termination",
	242	:	"//	erb 329 requested maxlngth too large  ",
	243	:	"//ini08	mov xr =endmo  point to failure message",
	244	:	"//	mov wa 4,endml  message length",
	245	:	"//	jsr syspr   print it (prtst not yet usable)",
	246	:	"//	zer xl   no fcb chain yet",
	247	:	"//	mov wb =num10  set special code value",
	248	:	"//	jsr sysej   pack up (stopr not yet usable)",
	249	:	"//ini09	mov xr statb  point to static again",
	250	:	"//	jsr insta   initialize static",
	251	:	"//	mov wa =e_hnb  get number of hash headers",
	252	:	"//	mti wa   convert to integer",
	253	:	"//	sti hshnb   store for use by gtnvr procedure",
	254	:	"//	lct wa wa  counter for clearing hash table",
	255	:	"//	mov hshtb xr  pointer to hash table",
	256	:	"//ini11	zer (xr)+   blank a word",
	257	:	"//	bct wa ini11  loop",
	258	:	"//	mov hshte xr  end of hash table adrs is kept",
	259	:	"//	mov state xr  store static end address",
	260	:	"//	mov wc =num01  table will have only one bucket",
	261	:	"//	mov xl =nulls  default table value",
	262	:	"//	mov r_sfc xl  current source file name",
	263	:	"//	jsr tmake   create table",
	264	:	"//	mov r_sfn xr  save ptr to table",
	265	:	"//	mov wc =num01  table will have only one bucket",
	266	:	"//	mov xl =nulls  default table value",
	267	:	"//	jsr tmake   create table",
	268	:	"//	mov r_inc xr  save ptr to table",
	269	:	"//	mov wa =ccinm  maximum nesting level",
	270	:	"//	mov xl =nulls  null string default value",
	271	:	"//	jsr vmake   create array",
	272	:	"//	mov r_ifa xr  save ptr to array",
	273	:	"//	mov wa =ccinm  maximum nesting level",
	274	:	"//	mov xl =inton  integer one default value",
	275	:	"//	jsr vmake   create array",
	276	:	"//	mov r_ifl xr  save ptr to array",
	277	:	"//	mov xl =v_inp  point to string /input/",
	278	:	"//	mov wb =trtin  trblk type for input",
	279	:	"//	jsr inout   perform input association",
	280	:	"//	mov xl =v_oup  point to string /output/",
	281	:	"//	mov wb =trtou  trblk type for output",
	282	:	"//	jsr inout   perform output association",
	283	:	"//	mov wc initr  terminal flag",
	284	:	"//	bze wc ini13  skip if no terminal",
	285	:	"//	jsr prpar   associate terminal",
	286	:	"//ini13	jsr sysdc   call date check",
	287	:	"//	mov flptr xs  in case stack overflows in compiler",
	288	:	"//	jsr cmpil   call compiler",
	289	:	"//	mov r_cod xr  set ptr to first code block",
	290	:	"//	mov r_ttl =nulls  forget title",
	291	:	"//	mov r_stl =nulls  forget sub-title",
	292	:	"//	zer r_cim   forget compiler input image",
	293	:	"//	zer r_ccb   forget interim code block",
	294	:	"//	zer cnind   in case end occurred with include",
	295	:	"//	zer lstid   listing include depth",
	296	:	"//	zer xl   clear dud value",
	297	:	"//	zer wb   dont shift dynamic store up",
	298	:	"//	zer dnams   collect sediment too",
	299	:	"//	jsr gbcol   clear garbage left from compile",
	300	:	"//	mov dnams xr  record new sediment size",
	301	:	"//	bnz cpsts inix0  skip if no listing of comp stats",
	302	:	"//	jsr prtpg   eject page",
	303	:	"//	jsr prtmm   print memory usage",
	304	:	"//	mti cmerc   get count of errors as integer",
	305	:	"//	mov xr =encm3  point to /compile errors/",
	306	:	"//	jsr prtmi   print it",
	307	:	"//	mti gbcnt   garbage collection count",
	308	:	"//	sbi 4,intv1   adjust for unavoidable collect",
	309	:	"//	mov xr =stpm5  point to /storage regenerations/",
	310	:	"//	jsr prtmi   print gbcol count",
	311	:	"//	jsr systm   get time",
	312	:	"//	sbi timsx   get compilation time",
	313	:	"//	mov xr =encm4  point to compilation time (msec)/",
	314	:	"//	jsr prtmi   print message",
	315	:	"//	add lstlc =num05  bump line count",
	316	:	"//	bze headp inix0  no eject if nothing printed",
	317	:	"//	jsr prtpg   eject printer",
	318	:	"//inix0	bgt cswin =iniln inix1 skip if not default -in72 used",
	319	:	"//	mov cswin =inils  else use default record length",
	320	:	"//inix1	jsr systm   get time again",
	321	:	"//	sti timsx   store for end run processing",
	322	:	"//	zer gbcnt   initialise collect count",
	323	:	"//	jsr sysbx   call before starting execution",
	324	:	"//	add noxeq cswex  add -noexecute flag",
	325	:	"//	bnz noxeq inix2  jump if execution suppressed",
	326	:	"//iniy0	mnz headp   mark headers out regardless",
	327	:	"//	zer -(xs)   set failure location on stack",
	328	:	"//	mov flptr xs  save ptr to failure offset word",
	329	:	"//	mov xr r_cod  load ptr to entry code block",
	330	:	"//	mov stage =stgxt  set stage for execute time",
	331	:	"//	mov polcs =num01  reset interface polling interval",
	332	:	"//	mov polct =num01  reset interface polling interval",
	333	:	"//	mov pfnte cmpsn  copy stmts compiled count in case",
	334	:	"//	mov pfdmp kvpfl  start profiling if &profile set",
	335	:	"//	jsr systm   time yet again",
	336	:	"//	sti pfstm   ",
	337	:	"//	jsr stgcc   compute stmgo countdown counters",
	338	:	"//	bri (xr)   start xeq with first statement",
	339	:	"//inix2	zer wa   set abend value to zero",
	340	:	"//	mov wb =nini9  set special code value",
	341	:	"//	zer xl   no fcb chain",
	342	:	"//	jsr sysej   end of job, exit to system",
	343	:	"//rstrt	prc e 0  entry point",
	344	:	"//	mov xs stbas  discard return",
	345	:	"//	zer xl   clear xl",
	346	:	"//	brn iniy0   resume execution",
	347	:	"//	jsr arith   fetch arithmetic operands",
	348	:	"//	adi icval(xl)   add right operand to left",
	349	:	"//	ino exint   return integer if no overflow",
	350	:	"//	erb 003 addition caused integer overflow  ",
	351	:	"//oadd1	adr rcval(xl)   add right operand to left",
	352	:	"//	rno exrea   return real if no overflow",
	353	:	"//	erb 261 addition caused real overflow  ",
	354	:	"//	mov xr (xs)+  load operand",
	355	:	"//	jsr gtnum   convert to numeric",
	356	:	"//	mov -(xs) xr  result if converted to numeric",
	357	:	"//	lcw xr   get next code word",
	358	:	"//	bri (xr)   execute it",
	359	:	"//	mov xr (xs)+  load right operand",
	360	:	"//	jsr gtpat   convert to pattern",
	361	:	"//oalt1	mov wb =p_alt  set pcode for alternative node",
	362	:	"//	jsr pbild   build alternative node",
	363	:	"//	mov xl xr  save address of alternative node",
	364	:	"//	mov xr (xs)+  load left operand",
	365	:	"//	jsr gtpat   convert to pattern",
	366	:	"//	beq xr =p_alt oalt2 jump if left arg is alternation",
	367	:	"//	mov pthen(xl) xr  set left operand as successor",
	368	:	"//	mov -(xs) xl  stack result",
	369	:	"//	lcw xr   get next code word",
	370	:	"//	bri (xr)   execute it",
	371	:	"//oalt2	mov pthen(xl) parm1(xr)  build the (b / c) node",
	372	:	"//	mov -(xs) pthen(xr)  set a as new left arg",
	373	:	"//	mov xr xl  set (b / c) as new right arg",
	374	:	"//	brn oalt1   merge back to build a / (b / c)",
	375	:	"//	lcw xr   load number of subscripts",
	376	:	"//	mov wb xr  set flag for by name",
	377	:	"//	brn arref   jump to array reference routine",
	378	:	"//	lcw xr   load number of subscripts",
	379	:	"//	zer wb   set flag for by value",
	380	:	"//	brn arref   jump to array reference routine",
	381	:	"//	mov xr (xs)  load subscript value",
	382	:	"//	mov xl num01(xs)  load array value",
	383	:	"//	mov wa (xl)  load first word of array operand",
	384	:	"//	beq wa =b_vct oaon2 jump if vector reference",
	385	:	"//	beq wa =b_tbt oaon3 jump if table reference",
	386	:	"//oaon1	mov xr =num01  set number of subscripts to one",
	387	:	"//	mov wb xr  set flag for by name",
	388	:	"//	brn arref   jump to array reference routine",
	389	:	"//oaon2	bne (xr) =b_icl oaon1 use long routine if not integer",
	390	:	"//	ldi icval(xr)   load integer subscript value",
	391	:	"//	mfi wa exfal  copy as address int, fail if ovflo",
	392	:	"//	bze wa exfal  fail if zero",
	393	:	"//	add wa =vcvlb  compute offset in words",
	394	:	"//	wtb wa   convert to bytes",
	395	:	"//	mov (xs) wa  complete name on stack",
	396	:	"//	blt wa vclen(xl) oaon4 exit if subscript not too large",
	397	:	"//	brn exfal   else fail",
	398	:	"//oaon3	mnz wb   set flag for name reference",
	399	:	"//	jsr tfind   locate/create table element",
	400	:	"//	mov num01(xs) xl  store name base on stack",
	401	:	"//	mov (xs) wa  store name offset on stack",
	402	:	"//oaon4	lcw xr   result on stack, get code word",
	403	:	"//	bri (xr)   execute next code word",
	404	:	"//	mov xr (xs)+  load subscript value",
	405	:	"//	mov xl (xs)+  load array value",
	406	:	"//	mov wa (xl)  load first word of array operand",
	407	:	"//	beq wa =b_vct oaov2 jump if vector reference",
	408	:	"//	beq wa =b_tbt oaov3 jump if table reference",
	409	:	"//oaov1	mov -(xs) xl  restack array value",
	410	:	"//	mov -(xs) xr  restack subscript",
	411	:	"//	mov xr =num01  set number of subscripts to one",
	412	:	"//	zer wb   set flag for value call",
	413	:	"//	brn arref   jump to array reference routine",
	414	:	"//oaov2	bne (xr) =b_icl oaov1 use long routine if not integer",
	415	:	"//	ldi icval(xr)   load integer subscript value",
	416	:	"//	mfi wa exfal  move as one word int, fail if ovflo",
	417	:	"//	bze wa exfal  fail if zero",
	418	:	"//	add wa =vcvlb  compute offset in words",
	419	:	"//	wtb wa   convert to bytes",
	420	:	"//	bge wa vclen(xl) exfal fail if subscript too large",
	421	:	"//	jsr acess   access value",
	422	:	"//	mov -(xs) xr  stack result",
	423	:	"//	lcw xr   get next code word",
	424	:	"//	bri (xr)   execute it",
	425	:	"//oaov3	zer wb   set flag for value reference",
	426	:	"//	jsr tfind   call table search routine",
	427	:	"//	mov -(xs) xr  stack result",
	428	:	"//	lcw xr   get next code word",
	429	:	"//	bri (xr)   execute it",
	430	:	"//oass0	mov wb (xs)+  load value to be assigned",
	431	:	"//	mov wa (xs)+  load name offset",
	432	:	"//	mov xl (xs)  load name base",
	433	:	"//	mov (xs) wb  store assigned value as result",
	434	:	"//	jsr asign   perform assignment",
	435	:	"//	lcw xr   result on stack, get code word",
	436	:	"//	bri (xr)   execute next code word",
	437	:	"//	erb 007 compilation error encountered during execution  ",
	438	:	"//	mov wc (xs)+  load name offset (parm2)",
	439	:	"//	mov xr (xs)+  load name base (parm1)",
	440	:	"//	mov wb =p_cas  set pcode for cursor assignment",
	441	:	"//	jsr pbild   build node",
	442	:	"//	mov -(xs) xr  stack result",
	443	:	"//	lcw xr   get next code word",
	444	:	"//	bri (xr)   execute it",
	445	:	"//	mov xr (xs)  load right argument",
	446	:	"//	beq xr =nulls ocnc3 jump if right arg is null",
	447	:	"//	mov xl 1(xs)  load left argument",
	448	:	"//	beq xl =nulls ocnc4 jump if left argument is null",
	449	:	"//	mov wa =b_scl  get constant to test for string",
	450	:	"//	bne wa (xl) ocnc2 jump if left arg not a string",
	451	:	"//	bne wa (xr) ocnc2 jump if right arg not a string",
	452	:	"//ocnc1	mov wa sclen(xl)  load left argument length",
	453	:	"//	add wa sclen(xr)  compute result length",
	454	:	"//	jsr alocs   allocate scblk for result",
	455	:	"//	mov 1(xs) xr  store result ptr over left argument",
	456	:	"//	psc xr   prepare to store chars of result",
	457	:	"//	mov wa sclen(xl)  get number of chars in left arg",
	458	:	"//	plc xl   prepare to load left arg chars",
	459	:	"//	mvc    move characters of left argument",
	460	:	"//	mov xl (xs)+  load right arg pointer, pop stack",
	461	:	"//	mov wa sclen(xl)  load number of chars in right arg",
	462	:	"//	plc xl   prepare to load right arg chars",
	463	:	"//	mvc    move characters of right argument",
	464	:	"//	zer xl   clear garbage value in xl",
	465	:	"//	lcw xr   result on stack, get code word",
	466	:	"//	bri (xr)   execute next code word",
	467	:	"//ocnc2	jsr gtstg   convert right arg to string",
	468	:	"//	mov xl xr  save right arg ptr",
	469	:	"//	jsr gtstg   convert left arg to string",
	470	:	"//	mov -(xs) xr  stack left argument",
	471	:	"//	mov -(xs) xl  stack right argument",
	472	:	"//	mov xl xr  move left arg to proper reg",
	473	:	"//	mov xr (xs)  move right arg to proper reg",
	474	:	"//	brn ocnc1   merge back to concatenate strings",
	475	:	"//ocnc3	ica xs   remove right arg from stack",
	476	:	"//	lcw xr   left argument on stack",
	477	:	"//	bri (xr)   execute next code word",
	478	:	"//ocnc4	ica xs   unstack one argument",
	479	:	"//	mov (xs) xr  store right argument",
	480	:	"//	lcw xr   result on stack, get code word",
	481	:	"//	bri (xr)   execute next code word",
	482	:	"//ocnc5	mov xl xr  move right argument ptr",
	483	:	"//	mov xr (xs)+  load left arg pointer",
	484	:	"//ocnc6	jsr gtpat   convert left arg to pattern",
	485	:	"//	mov -(xs) xr  save result on stack",
	486	:	"//	mov xr xl  point to right operand",
	487	:	"//	jsr gtpat   convert to pattern",
	488	:	"//	mov xl xr  move for pconc",
	489	:	"//	mov xr (xs)+  reload left operand ptr",
	490	:	"//	jsr pconc   concatenate patterns",
	491	:	"//	mov -(xs) xr  stack result",
	492	:	"//	lcw xr   get next code word",
	493	:	"//	bri (xr)   execute it",
	494	:	"//	mov xr (xs)+  load operand",
	495	:	"//	mov wa (xr)  load type word",
	496	:	"//ocom1	beq wa =b_icl ocom2 jump if integer",
	497	:	"//	beq wa =b_rcl ocom3 jump if real",
	498	:	"//	jsr gtnum   else convert to numeric",
	499	:	"//	brn ocom1   back to check cases",
	500	:	"//ocom2	ldi icval(xr)   load integer value",
	501	:	"//	ngi    negate",
	502	:	"//	ino exint   return integer if no overflow",
	503	:	"//	erb 011 negation caused integer overflow  ",
	504	:	"//ocom3	ldr rcval(xr)   load real value",
	505	:	"//	ngr    negate",
	506	:	"//	brn exrea   return real result",
	507	:	"//	jsr arith   fetch arithmetic operands",
	508	:	"//	dvi icval(xl)   divide left operand by right",
	509	:	"//	ino exint   result ok if no overflow",
	510	:	"//	erb 014 division caused integer overflow  ",
	511	:	"//odvd2	dvr rcval(xl)   divide left operand by right",
	512	:	"//	rno exrea   return real if no overflow",
	513	:	"//	erb 262 division caused real overflow  ",
	514	:	"//	mov xr (xs)+  load exponent",
	515	:	"//	jsr gtnum   convert to number",
	516	:	"//	mov xl xr  move exponent to xl",
	517	:	"//	mov xr (xs)+  load base",
	518	:	"//	jsr gtnum   convert to numeric",
	519	:	"//	beq (xl) =b_rcl oexp7 jump if real exponent",
	520	:	"//	ldi icval(xl)   load exponent",
	521	:	"//	ilt oex12   jump if negative exponent",
	522	:	"//	beq wa =b_rcl oexp3 jump if base is real",
	523	:	"//	mfi wa oexp2  convert exponent to 1 word integer",
	524	:	"//	lct wa wa  set loop counter",
	525	:	"//	ldi icval(xr)   load base as initial value",
	526	:	"//	bnz wa oexp1  jump into loop if non-zero exponent",
	527	:	"//	ieq oexp4   error if 0**0",
	528	:	"//	ldi 4,intv1   nonzero**0",
	529	:	"//	brn exint   give one as result for nonzero**0",
	530	:	"//oex13	mli icval(xr)   multiply by base",
	531	:	"//	iov oexp2   jump if overflow",
	532	:	"//oexp1	bct wa oex13  loop if more to go",
	533	:	"//	brn exint   else return integer result",
	534	:	"//oexp2	erb 017 exponentiation caused integer overflow  ",
	535	:	"//oexp3	mfi wa oexp6  convert exponent to one word",
	536	:	"//	lct wa wa  set loop counter",
	537	:	"//	ldr rcval(xr)   load base as initial value",
	538	:	"//	bnz wa oexp5  jump into loop if non-zero exponent",
	539	:	"//	req oexp4   error if 0.0**0",
	540	:	"//	ldr 4,reav1   nonzero**0",
	541	:	"//	brn exrea   return 1.0 if nonzero**zero",
	542	:	"//oexp4	erb 018 exponentiation result is undefined  ",
	543	:	"//oex14	mlr rcval(xr)   multiply by base",
	544	:	"//	rov oexp6   jump if overflow",
	545	:	"//oexp5	bct wa oex14  loop till computation complete",
	546	:	"//	brn exrea   then return real result",
	547	:	"//oexp6	erb 266 exponentiation caused real overflow  ",
	548	:	"//oexp7	beq (xr) =b_rcl oexp8 jump if base real",
	549	:	"//	ldi icval(xr)   load integer base",
	550	:	"//	itr    convert to real",
	551	:	"//	jsr rcbld   create real in (xr)",
	552	:	"//oexp8	zer wb   set positive result flag",
	553	:	"//	ldr rcval(xr)   load base to ra",
	554	:	"//	rne oexp9   jump if base non-zero",
	555	:	"//	ldr rcval(xl)   base is zero.  check exponent",
	556	:	"//	req oexp4   jump if 0.0 ** 0.0",
	557	:	"//	ldr 4,reav0   0.0 to non-zero exponent yields 0.0",
	558	:	"//	brn exrea   return zero result",
	559	:	"//oexp9	rgt oex10   jump if base gt 0.0",
	560	:	"//	ngr    make base positive",
	561	:	"//	jsr rcbld   create positive base in (xr)",
	562	:	"//	ldr rcval(xl)   examine exponent",
	563	:	"//	chp    chop to integral value",
	564	:	"//	rti oexp6   convert to integer, br if too large",
	565	:	"//	sbr rcval(xl)   chop(exponent) - exponent",
	566	:	"//	rne oex11   non-integral power with neg base",
	567	:	"//	mfi wb   record even/odd exponent",
	568	:	"//	anb wb 4,bits1  odd exponent yields negative result",
	569	:	"//	ldr rcval(xr)   restore base to ra",
	570	:	"//oex10	lnf    log of base",
	571	:	"//	rov oexp6   too large",
	572	:	"//	mlr rcval(xl)   times exponent",
	573	:	"//	rov oexp6   too large",
	574	:	"//	etx    e ** (exponent * ln(base))",
	575	:	"//	rov oexp6   too large",
	576	:	"//	bze wb exrea  if no sign fixup required",
	577	:	"//	ngr    negative result needed",
	578	:	"//	brn exrea   ",
	579	:	"//oex11	erb 311 exponentiation of negative base to non-integral power  ",
	580	:	"//oex12	mov -(xs) xr  stack base",
	581	:	"//	itr    convert to real exponent",
	582	:	"//	jsr rcbld   real negative exponent in (xr)",
	583	:	"//	mov xl xr  put exponent in xl",
	584	:	"//	mov xr (xs)+  restore base value",
	585	:	"//	brn oexp7   process real exponent",
	586	:	"//	brn evlx6   jump to failure loc in evalx",
	587	:	"//	erb 020 goto evaluation failure  ",
	588	:	"//	lcw wa   load number of arguments",
	589	:	"//	lcw xr   load function vrblk pointer",
	590	:	"//	mov xl vrfnc(xr)  load function pointer",
	591	:	"//	bne wa fargs(xl) cfunc use central routine if wrong num",
	592	:	"//	bri (xl)   jump to function if arg count ok",
	593	:	"//	lcw wa   get next code word",
	594	:	"//	bne wa =ornm_ ofne1 fail if not evaluating expression",
	595	:	"//	bze num02(xs) evlx3  ok if expr. was wanted by value",
	596	:	"//ofne1	erb 021 function called by name returned a value  ",
	597	:	"//	lcw xr   load function vrblk pointer",
	598	:	"//	mov wa =num01  set number of arguments to one",
	599	:	"//	mov xl vrfnc(xr)  load function pointer",
	600	:	"//	bne wa fargs(xl) cfunc use central routine if wrong num",
	601	:	"//	bri (xl)   jump to function if arg count ok",
	602	:	"//	erb 022 undefined function called  ",
	603	:	"//	mov xr num01(xs)  load name base pointer",
	604	:	"//	bhi xr state ogoc1 jump if not natural variable",
	605	:	"//	add xr *vrtra  else point to vrtra field",
	606	:	"//	bri (xr)   and jump through it",
	607	:	"//ogoc1	erb 023 goto operand is not a natural variable  ",
	608	:	"//	mov xr (xs)  load operand",
	609	:	"//	mov wa (xr)  load first word",
	610	:	"//	beq wa =b_cds bcds0 jump if code block to code routine",
	611	:	"//	beq wa =b_cdc bcdc0 jump if code block to code routine",
	612	:	"//	erb 024 goto operand in direct goto is not code  ",
	613	:	"//	mov xr flptr  point to fail offset on stack",
	614	:	"//	ica (xr)   point failure to o_fif word",
	615	:	"//	icp    point to next code word",
	616	:	"//	lcw xr   fetch next code word",
	617	:	"//	bri (xr)   execute it",
	618	:	"//	mov wb =p_imc  set pcode for last node",
	619	:	"//	mov wc (xs)+  pop name offset (parm2)",
	620	:	"//	mov xr (xs)+  pop name base (parm1)",
	621	:	"//	jsr pbild   build p_imc node",
	622	:	"//	mov xl xr  save ptr to node",
	623	:	"//	mov xr (xs)  load left argument",
	624	:	"//	jsr gtpat   convert to pattern",
	625	:	"//	mov (xs) xr  save ptr to left operand pattern",
	626	:	"//	mov wb =p_ima  set pcode for first node",
	627	:	"//	jsr pbild   build p_ima node",
	628	:	"//	mov pthen(xr) (xs)+  set left operand as p_ima successor",
	629	:	"//	jsr pconc   concatenate to form final pattern",
	630	:	"//	mov -(xs) xr  stack result",
	631	:	"//	lcw xr   get next code word",
	632	:	"//	bri (xr)   execute it",
	633	:	"//	mnz wb   set flag for result by name",
	634	:	"//	brn indir   jump to common routine",
	635	:	"//	mov (xs) =nulls  replace operand with null",
	636	:	"//	lcw xr   get next code word",
	637	:	"//	bri (xr)   execute next code word",
	638	:	"//	zer wb   set flag for by value",
	639	:	"//	brn indir   jump to common routine",
	640	:	"//	jsr kwnam   get keyword name",
	641	:	"//	brn exnam   exit with result name",
	642	:	"//	jsr kwnam   get keyword name",
	643	:	"//	mov dnamp xr  delete kvblk",
	644	:	"//	jsr acess   access value",
	645	:	"//	mov -(xs) xr  stack result",
	646	:	"//	lcw xr   get next code word",
	647	:	"//	bri (xr)   execute it",
	648	:	"//	mov wa *evsi_  set size of evblk",
	649	:	"//	jsr alloc   allocate space for evblk",
	650	:	"//	mov (xr) =b_evt  set type word",
	651	:	"//	mov evvar(xr) =trbev  set dummy trblk pointer",
	652	:	"//	lcw wa   load exblk pointer",
	653	:	"//	mov evexp(xr) wa  set exblk pointer",
	654	:	"//	mov xl xr  move name base to proper reg",
	655	:	"//	mov wa *evvar  set name offset = zero",
	656	:	"//	brn exnam   exit with name in (xl,wa)",
	657	:	"//	lcw xr   load pattern pointer",
	658	:	"//	mov -(xs) xr  stack result",
	659	:	"//	lcw xr   get next code word",
	660	:	"//	bri (xr)   execute it",
	661	:	"//	lcw wa   load vrblk pointer",
	662	:	"//	mov -(xs) wa  stack vrblk ptr (name base)",
	663	:	"//	mov -(xs) *vrval  stack name offset",
	664	:	"//	lcw xr   get next code word",
	665	:	"//	bri (xr)   execute next code word",
	666	:	"//	jsr arith   fetch arithmetic operands",
	667	:	"//	mli icval(xl)   multiply left operand by right",
	668	:	"//	ino exint   return integer if no overflow",
	669	:	"//	erb 028 multiplication caused integer overflow  ",
	670	:	"//omlt1	mlr rcval(xl)   multiply left operand by right",
	671	:	"//	rno exrea   return real if no overflow",
	672	:	"//	erb 263 multiplication caused real overflow  ",
	673	:	"//	mov wa *nmsi_  set length of nmblk",
	674	:	"//	jsr alloc   allocate nmblk",
	675	:	"//	mov (xr) =b_nml  set name block code",
	676	:	"//	mov nmofs(xr) (xs)+  set name offset from operand",
	677	:	"//	mov nmbas(xr) (xs)+  set name base from operand",
	678	:	"//	mov -(xs) xr  stack result",
	679	:	"//	lcw xr   get next code word",
	680	:	"//	bri (xr)   execute it",
	681	:	"//	lcw wa   load new failure offset",
	682	:	"//	mov -(xs) flptr  stack old failure pointer",
	683	:	"//	mov -(xs) wa  stack new failure offset",
	684	:	"//	mov flptr xs  set new failure pointer",
	685	:	"//	lcw xr   get next code word",
	686	:	"//	bri (xr)   execute next code word",
	687	:	"//	mov flptr num02(xs)  restore old failure pointer",
	688	:	"//	brn exfal   and fail",
	689	:	"//	ica xs   pop failure offset",
	690	:	"//	mov flptr (xs)+  restore old failure pointer",
	691	:	"//	brn exnul   exit giving null result",
	692	:	"//	erb 029 undefined operator referenced  ",
	693	:	"//	mov wb =p_pac  load pcode for p_pac node",
	694	:	"//	mov wc (xs)+  load name offset (parm2)",
	695	:	"//	mov xr (xs)+  load name base (parm1)",
	696	:	"//	jsr pbild   build p_pac node",
	697	:	"//	mov xl xr  save ptr to node",
	698	:	"//	mov xr (xs)  load left operand",
	699	:	"//	jsr gtpat   convert to pattern",
	700	:	"//	mov (xs) xr  save ptr to left operand pattern",
	701	:	"//	mov wb =p_paa  set pcode for p_paa node",
	702	:	"//	jsr pbild   build p_paa node",
	703	:	"//	mov pthen(xr) (xs)+  set left operand as p_paa successor",
	704	:	"//	jsr pconc   concatenate to form final pattern",
	705	:	"//	mov -(xs) xr  stack result",
	706	:	"//	lcw xr   get next code word",
	707	:	"//	bri (xr)   execute it",
	708	:	"//	zer wb   set type code for match by name",
	709	:	"//	brn match   jump to routine to start match",
	710	:	"//	mov wb =num02  set flag for statement to match",
	711	:	"//	brn match   jump to routine to start match",
	712	:	"//	mov wb =num01  set type code for value match",
	713	:	"//	brn match   jump to routine to start match",
	714	:	"//	ica xs   pop top stack entry",
	715	:	"//	lcw xr   get next code word",
	716	:	"//	bri (xr)   execute next code word",
	717	:	"//	brn lend0   jump to end circuit",
	718	:	"//	brn evlx4   return to evalx procedure",
	719	:	"//	jsr gtstg   convert replacement val to string",
	720	:	"//	mov xl (xs)  load subject string pointer",
	721	:	"//	add wa sclen(xl)  add subject string length",
	722	:	"//	add wa num02(xs)  add starting cursor",
	723	:	"//	sub wa num01(xs)  minus final cursor = total length",
	724	:	"//	bze wa orpl3  jump if result is null",
	725	:	"//	mov -(xs) xr  restack replacement string",
	726	:	"//	jsr alocs   allocate scblk for result",
	727	:	"//	mov wa num03(xs)  get initial cursor (part 1 len)",
	728	:	"//	mov num03(xs) xr  stack result pointer",
	729	:	"//	psc xr   point to characters of result",
	730	:	"//	bze wa orpl1  jump if first part is null",
	731	:	"//	mov xl num01(xs)  else point to subject string",
	732	:	"//	plc xl   point to subject string chars",
	733	:	"//	mvc    move first part to result",
	734	:	"//orpl1	mov xl (xs)+  load replacement string, pop",
	735	:	"//	mov wa sclen(xl)  load length",
	736	:	"//	bze wa orpl2  jump if null replacement",
	737	:	"//	plc xl   else point to chars of replacement",
	738	:	"//	mvc    move in chars (part 2)",
	739	:	"//orpl2	mov xl (xs)+  load subject string pointer, pop",
	740	:	"//	mov wc (xs)+  load final cursor, pop",
	741	:	"//	mov wa sclen(xl)  load subject string length",
	742	:	"//	sub wa wc  minus final cursor = part 3 length",
	743	:	"//	bze wa oass0  jump to assign if part 3 is null",
	744	:	"//	plc xl wc  else point to last part of string",
	745	:	"//	mvc    move part 3 to result",
	746	:	"//	brn oass0   jump to perform assignment",
	747	:	"//orpl3	add xs *num02  pop subject str ptr, final cursor",
	748	:	"//	mov (xs) =nulls  set null result",
	749	:	"//	brn oass0   jump to assign null value",
	750	:	"//	brn evlx3   return to evalx procedure",
	751	:	"//	lcw wa   load new failure offset",
	752	:	"//	mov -(xs) flptr  stack old failure pointer",
	753	:	"//	mov -(xs) wa  stack new failure offset",
	754	:	"//	mov flptr xs  set new failure pointer",
	755	:	"//	lcw xr   get next code word",
	756	:	"//	bri (xr)   execute next code word",
	757	:	"//	mov xr (xs)+  load result",
	758	:	"//	ica xs   pop fail offset",
	759	:	"//	mov flptr (xs)  restore old failure pointer",
	760	:	"//	mov (xs) xr  restack result",
	761	:	"//	lcw wa   load new code offset",
	762	:	"//	add wa r_cod  point to absolute code location",
	763	:	"//	lcp wa   set new code pointer",
	764	:	"//	lcw xr   get next code word",
	765	:	"//	bri (xr)   execute next code word",
	766	:	"//	lcw wa   load new fail offset",
	767	:	"//	mov (xs) wa  store new fail offset",
	768	:	"//	lcw xr   get next code word",
	769	:	"//	bri (xr)   execute next code word",
	770	:	"//	ica xs   pop failure offset",
	771	:	"//	mov flptr (xs)+  restore old failure pointer",
	772	:	"//	lcw xr   get next code word",
	773	:	"//	bri (xr)   execute next code word",
	774	:	"//	jsr arith   fetch arithmetic operands",
	775	:	"//	sbi icval(xl)   subtract right operand from left",
	776	:	"//	ino exint   return integer if no overflow",
	777	:	"//	erb 034 subtraction caused integer overflow  ",
	778	:	"//osub1	sbr rcval(xl)   subtract right operand from left",
	779	:	"//	rno exrea   return real if no overflow",
	780	:	"//	erb 264 subtraction caused real overflow  ",
	781	:	"//	brn trxq1   jump into trxeq procedure",
	782	:	"//	erb 035 unexpected failure in -nofail mode  ",
	783	:	"//	mov -(xs) xr  stack result",
	784	:	"//	lcw xr   get next code word",
	785	:	"//	bri (xr)   execute it",
	786	:	"//	mov -(xs) xr  stack result",
	787	:	"//	lcw xr   get next code word",
	788	:	"//	bri (xr)   execute it",
	789	:	"//bcdc0	mov xs flptr  pop garbage off stack",
	790	:	"//	mov (xs) cdfal(xr)  set failure offset",
	791	:	"//	brn stmgo   enter stmt",
	792	:	"//bcds0	mov xs flptr  pop garbage off stack",
	793	:	"//	mov (xs) *cdfal  set failure offset",
	794	:	"//	brn stmgo   enter stmt",
	795	:	"//	mov wa dfpdl(xl)  load length of pdblk",
	796	:	"//	jsr alloc   allocate pdblk",
	797	:	"//	mov (xr) =b_pdt  store type word",
	798	:	"//	mov pddfp(xr) xl  store dfblk pointer",
	799	:	"//	mov wc xr  save pointer to pdblk",
	800	:	"//	add xr wa  point past pdblk",
	801	:	"//	lct wa fargs(xl)  set to count fields",
	802	:	"//bdfc1	mov -(xr) (xs)+  move a field value",
	803	:	"//	bct wa bdfc1  loop till all moved",
	804	:	"//	mov xr wc  recall pointer to pdblk",
	805	:	"//	brn exsid   exit setting id field",
	806	:	"//	mov wc fargs(xl)  load number of arguments",
	807	:	"//	wtb wc   convert to offset",
	808	:	"//	mov -(xs) xl  save pointer to efblk",
	809	:	"//	mov xt xs  copy pointer to arguments",
	810	:	"//befc1	ica xt   point to next entry",
	811	:	"//	mov xr (xs)  load pointer to efblk",
	812	:	"//	dca wc   decrement eftar offset",
	813	:	"//	add xr wc  point to next eftar entry",
	814	:	"//	mov xr eftar(xr)  load eftar entry",
	815	:	"//	bsw xr 5  switch on type",
	816	:	"//beff1	mov -(xs) xt  save entry pointer",
	817	:	"//	mov befof wc  save offset",
	818	:	"//	mov -(xs) (xt)  stack arg pointer",
	819	:	"//	jsr iofcb   convert to fcb",
	820	:	"//	mov xr wa  point to fcb",
	821	:	"//	mov xt (xs)+  reload entry pointer",
	822	:	"//	brn befc5   jump to merge",
	823	:	"//befc2	mov -(xs) (xt)  stack arg ptr",
	824	:	"//	jsr gtstg   convert argument to string",
	825	:	"//	brn befc6   jump to merge",
	826	:	"//befc3	mov xr (xt)  load next argument",
	827	:	"//	mov befof wc  save offset",
	828	:	"//	jsr gtint   convert to integer",
	829	:	"//	brn befc5   merge with real case",
	830	:	"//befc4	mov xr (xt)  load next argument",
	831	:	"//	mov befof wc  save offset",
	832	:	"//	jsr gtrea   convert to real",
	833	:	"//befc5	mov wc befof  restore offset",
	834	:	"//befc6	mov (xt) xr  store converted result",
	835	:	"//befc7	bnz wc befc1  loop back if more to go",
	836	:	"//	mov xl (xs)+  restore efblk pointer",
	837	:	"//	mov wa fargs(xl)  get number of args",
	838	:	"//	jsr sysex   call routine to call external fnc",
	839	:	"//	wtb wa   convert number of args to bytes",
	840	:	"//	add xs wa  remove arguments from stack",
	841	:	"//	mov wb efrsl(xl)  get result type id",
	842	:	"//	bnz wb befa8  branch if not unconverted",
	843	:	"//	bne (xr) =b_scl befc8 jump if not a string",
	844	:	"//	bze sclen(xr) exnul  return null if null",
	845	:	"//befa8	bne wb =num01 befc8 jump if not a string",
	846	:	"//	bze sclen(xr) exnul  return null if null",
	847	:	"//befc8	blt xr dnamb befc9 jump if not in dynamic storage",
	848	:	"//	ble xr dnamp exixr return result if already dynamic",
	849	:	"//befc9	mov wa (xr)  get possible type word",
	850	:	"//	bze wb bef11  jump if unconverted result",
	851	:	"//	mov wa =b_scl  string",
	852	:	"//	beq wb =num01 bef10 yes jump",
	853	:	"//	mov wa =b_icl  integer",
	854	:	"//	beq wb =num02 bef10 yes jump",
	855	:	"//	mov wa =b_rcl  real",
	856	:	"//bef10	mov (xr) wa  stored before copying to dynamic",
	857	:	"//bef11	beq (xr) =b_scl bef12 branch if string result",
	858	:	"//	jsr blkln   get length of block",
	859	:	"//	mov xl xr  copy address of old block",
	860	:	"//	jsr alloc   allocate dynamic block same size",
	861	:	"//	mov -(xs) xr  set pointer to new block as result",
	862	:	"//	mvw    copy old block to dynamic block",
	863	:	"//	zer xl   clear garbage value",
	864	:	"//	lcw xr   get next code word",
	865	:	"//	bri (xr)   execute next code word",
	866	:	"//bef12	mov xl xr  save source string pointer",
	867	:	"//	mov wa sclen(xr)  fetch string length",
	868	:	"//	bze wa exnul  return null string if length zero",
	869	:	"//	jsr alocs   allocate space for string",
	870	:	"//	mov -(xs) xr  save as result pointer",
	871	:	"//	psc xr   prepare to store chars of result",
	872	:	"//	plc xl   point to chars in source string",
	873	:	"//	mov wa wc  number of characters to copy",
	874	:	"//	mvc    move characters to result string",
	875	:	"//	zer xl   clear garbage value",
	876	:	"//	lcw xr   get next code word",
	877	:	"//	bri (xr)   execute next code word",
	878	:	"//	mov xr xl  copy ffblk pointer",
	879	:	"//	lcw wc   load next code word",
	880	:	"//	mov xl (xs)  load pdblk pointer",
	881	:	"//	bne (xl) =b_pdt bffc2 jump if not pdblk at all",
	882	:	"//	mov wa pddfp(xl)  load dfblk pointer from pdblk",
	883	:	"//bffc1	beq wa ffdfp(xr) bffc3 jump if this is the correct ffblk",
	884	:	"//	mov xr ffnxt(xr)  else link to next ffblk on chain",
	885	:	"//	bnz xr bffc1  loop back if another entry to check",
	886	:	"//bffc2	erb 041 field function argument is wrong datatype  ",
	887	:	"//bffc3	mov wa ffofs(xr)  load field offset",
	888	:	"//	beq wc =ofne_ bffc5 jump if called by name",
	889	:	"//	add xl wa  else point to value field",
	890	:	"//	mov xr (xl)  load value",
	891	:	"//	bne (xr) =b_trt bffc4 jump if not trapped",
	892	:	"//	sub xl wa  else restore name base,offset",
	893	:	"//	mov (xs) wc  save next code word over pdblk ptr",
	894	:	"//	jsr acess   access value",
	895	:	"//	mov wc (xs)  restore next code word",
	896	:	"//bffc4	mov (xs) xr  store value on stack (over pdblk)",
	897	:	"//	mov xr wc  copy next code word",
	898	:	"//	mov xl (xr)  load entry address",
	899	:	"//	bri xl   jump to routine for next code word",
	900	:	"//bffc5	mov -(xs) wa  store name offset (base is set)",
	901	:	"//	lcw xr   get next code word",
	902	:	"//	bri (xr)   execute next code word",
	903	:	"//	mov -(xs) xr  stack result",
	904	:	"//	lcw xr   get next code word",
	905	:	"//	bri (xr)   execute it",
	906	:	"//	mov -(xs) xr  stack result",
	907	:	"//	lcw xr   get next code word",
	908	:	"//	bri (xr)   execute it",
	909	:	"//	mov bpfpf xl  save pfblk ptr (need not be reloc)",
	910	:	"//	mov xr xl  copy for the moment",
	911	:	"//	mov xl pfvbl(xr)  point to vrblk for function",
	912	:	"//bpf01	mov wb xl  save pointer",
	913	:	"//	mov xl vrval(xl)  load value",
	914	:	"//	beq (xl) =b_trt bpf01 loop if trblk",
	915	:	"//	mov bpfsv xl  save old value",
	916	:	"//	mov xl wb  point back to block with value",
	917	:	"//	mov vrval(xl) =nulls  set value to null",
	918	:	"//	mov wa fargs(xr)  load number of arguments",
	919	:	"//	add xr *pfarg  point to pfarg entries",
	920	:	"//	bze wa bpf04  jump if no arguments",
	921	:	"//	mov xt xs  ptr to last arg",
	922	:	"//	wtb wa   convert no. of args to bytes offset",
	923	:	"//	add xt wa  point before first arg",
	924	:	"//	mov bpfxt xt  remember arg pointer",
	925	:	"//bpf02	mov xl (xr)+  load vrblk ptr for next argument",
	926	:	"//bpf03	mov wc xl  save pointer",
	927	:	"//	mov xl vrval(xl)  load next value",
	928	:	"//	beq (xl) =b_trt bpf03 loop back if trblk",
	929	:	"//	mov wa xl  keep old value",
	930	:	"//	mov xt bpfxt  point before next stacked arg",
	931	:	"//	mov wb -(xt)  load argument (new value)",
	932	:	"//	mov (xt) wa  save old value",
	933	:	"//	mov bpfxt xt  keep arg ptr for next time",
	934	:	"//	mov xl wc  point back to block with value",
	935	:	"//	mov vrval(xl) wb  set new value",
	936	:	"//	bne xs bpfxt bpf02 loop if not all done",
	937	:	"//bpf04	mov xl bpfpf  restore pfblk pointer",
	938	:	"//	mov wa pfnlo(xl)  load number of locals",
	939	:	"//	bze wa bpf07  jump if no locals",
	940	:	"//	mov wb =nulls  get null constant",
	941	:	"//	lct wa wa  set local counter",
	942	:	"//bpf05	mov xl (xr)+  load vrblk ptr for next local",
	943	:	"//bpf06	mov wc xl  save pointer",
	944	:	"//	mov xl vrval(xl)  load next value",
	945	:	"//	beq (xl) =b_trt bpf06 loop back if trblk",
	946	:	"//	mov -(xs) xl  stack old value",
	947	:	"//	mov xl wc  point back to block with value",
	948	:	"//	mov vrval(xl) wb  set null as new value",
	949	:	"//	bct wa bpf05  loop till all locals processed",
	950	:	"//bpf07	zer xr   zero reg xr in case",
	951	:	"//	bze kvpfl bpf7c  skip if profiling is off",
	952	:	"//	beq kvpfl =num02 bpf7a branch on type of profile",
	953	:	"//	jsr systm   get current time",
	954	:	"//	sti pfetm   save for a sec",
	955	:	"//	sbi pfstm   find time used by caller",
	956	:	"//	jsr icbld   build into an icblk",
	957	:	"//	ldi pfetm   reload current time",
	958	:	"//	brn bpf7b   merge",
	959	:	"//bpf7a	ldi pfstm   get start time of calling stmt",
	960	:	"//	jsr icbld   assemble an icblk round it",
	961	:	"//	jsr systm   get now time",
	962	:	"//bpf7b	sti pfstm   set start time of 1st func stmt",
	963	:	"//	mnz pffnc   flag function entry",
	964	:	"//bpf7c	mov -(xs) xr  stack icblk ptr (or zero)",
	965	:	"//	mov wa r_cod  load old code block pointer",
	966	:	"//	scp wb   get code pointer",
	967	:	"//	sub wb wa  make code pointer into offset",
	968	:	"//	mov xl bpfpf  recall pfblk pointer",
	969	:	"//	mov -(xs) bpfsv  stack old value of function name",
	970	:	"//	mov -(xs) wa  stack code block pointer",
	971	:	"//	mov -(xs) wb  stack code offset",
	972	:	"//	mov -(xs) flprt  stack old flprt",
	973	:	"//	mov -(xs) flptr  stack old failure pointer",
	974	:	"//	mov -(xs) xl  stack pointer to pfblk",
	975	:	"//	zer -(xs)   dummy zero entry for fail return",
	976	:	"//	chk    check for stack overflow",
	977	:	"//	mov flptr xs  set new fail return value",
	978	:	"//	mov flprt xs  set new flprt",
	979	:	"//	mov wa kvtra  load trace value",
	980	:	"//	add wa kvftr  add ftrace value",
	981	:	"//	bnz wa bpf09  jump if tracing possible",
	982	:	"//	icv kvfnc   else bump fnclevel",
	983	:	"//bpf08	mov xr pfcod(xl)  point to vrblk of entry label",
	984	:	"//	mov xr vrlbl(xr)  point to target code",
	985	:	"//	beq xr =stndl bpf17 test for undefined label",
	986	:	"//	bne (xr) =b_trt bpf8a jump if not trapped",
	987	:	"//	mov xr trlbl(xr)  else load ptr to real label code",
	988	:	"//bpf8a	bri (xr)   off to execute function",
	989	:	"//bpf09	mov xr pfctr(xl)  load possible call trace trblk",
	990	:	"//	mov xl pfvbl(xl)  load vrblk pointer for function",
	991	:	"//	mov wa *vrval  set name offset for variable",
	992	:	"//	bze kvtra bpf10  jump if trace mode is off",
	993	:	"//	bze xr bpf10  or if there is no call trace",
	994	:	"//	dcv kvtra   decrement trace count",
	995	:	"//	bze trfnc(xr) bpf11  jump if print trace",
	996	:	"//	jsr trxeq   execute function type trace",
	997	:	"//bpf10	bze kvftr bpf16  jump if ftrace is off",
	998	:	"//	dcv kvftr   else decrement ftrace",
	999	:	"//bpf11	jsr prtsn   print statement number",
	1000	:	"//	jsr prtnm   print function name",
	1001	:	"//	mov wa =ch_pp  load left paren",
	1002	:	"//	jsr prtch   print left paren",
	1003	:	"//	mov xl num01(xs)  recover pfblk pointer",
	1004	:	"//	bze fargs(xl) bpf15  skip if no arguments",
	1005	:	"//	zer wb   else set argument counter",
	1006	:	"//	brn bpf13   jump into loop",
	1007	:	"//bpf12	mov wa =ch_cm  load comma",
	1008	:	"//	jsr prtch   print to separate from last arg",
	1009	:	"//bpf13	mov (xs) wb  save arg ctr (over failoffs is ok)",
	1010	:	"//	wtb wb   convert to byte offset",
	1011	:	"//	add xl wb  point to next argument pointer",
	1012	:	"//	mov xr pfarg(xl)  load next argument vrblk ptr",
	1013	:	"//	sub xl wb  restore pfblk pointer",
	1014	:	"//	mov xr vrval(xr)  load next value",
	1015	:	"//	jsr prtvl   print argument value",
	1016	:	"//	mov wb (xs)  restore argument counter",
	1017	:	"//	icv wb   increment argument counter",
	1018	:	"//	blt wb fargs(xl) bpf12 loop if more to print",
	1019	:	"//bpf15	mov wa =ch_rp  load right paren",
	1020	:	"//	jsr prtch   print to terminate output",
	1021	:	"//	jsr prtnl   terminate print line",
	1022	:	"//bpf16	icv kvfnc   increment fnclevel",
	1023	:	"//	mov xl r_fnc  load ptr to possible trblk",
	1024	:	"//	jsr ktrex   call keyword trace routine",
	1025	:	"//	mov xl num01(xs)  restore pfblk pointer",
	1026	:	"//	brn bpf08   jump back to execute function",
	1027	:	"//bpf17	mov flptr num02(xs)  reset so exfal can return to evalx",
	1028	:	"//	erb 286 function call to undefined entry label  ",
	1029	:	"//	mov -(xs) xr  stack result",
	1030	:	"//	lcw xr   get next code word",
	1031	:	"//	bri (xr)   execute it",
	1032	:	"//	mov -(xs) xr  stack result",
	1033	:	"//	lcw xr   get next code word",
	1034	:	"//	bri (xr)   execute it",
	1035	:	"//	mov xl xr  copy name base (vrget = 0)",
	1036	:	"//	mov wa *vrval  set name offset",
	1037	:	"//	jsr acess   access value",
	1038	:	"//	mov -(xs) xr  stack result",
	1039	:	"//	lcw xr   get next code word",
	1040	:	"//	bri (xr)   execute it",
	1041	:	"//	erb 042 attempt to change value of protected variable  ",
	1042	:	"//	mov xr vrlbo(xr)  load code pointer",
	1043	:	"//	mov xl (xr)  load entry address",
	1044	:	"//	bri xl   jump to routine for next code word",
	1045	:	"//	mov -(xs) vrval(xr)  load value onto stack (vrget = 0)",
	1046	:	"//	lcw xr   get next code word",
	1047	:	"//	bri (xr)   execute next code word",
	1048	:	"//	mov vrvlo(xr) (xs)  store value, leave on stack",
	1049	:	"//	lcw xr   get next code word",
	1050	:	"//	bri (xr)   execute next code word",
	1051	:	"//	sub xr *vrtra  point back to start of vrblk",
	1052	:	"//	mov xl xr  copy vrblk pointer",
	1053	:	"//	mov wa *vrval  set name offset",
	1054	:	"//	mov xr vrlbl(xl)  load pointer to trblk",
	1055	:	"//	bze kvtra bvrt2  jump if trace is off",
	1056	:	"//	dcv kvtra   else decrement trace count",
	1057	:	"//	bze trfnc(xr) bvrt1  jump if print trace case",
	1058	:	"//	jsr trxeq   else execute full trace",
	1059	:	"//	brn bvrt2   merge to jump to label",
	1060	:	"//bvrt1	jsr prtsn   print statement number",
	1061	:	"//	mov xr xl  copy vrblk pointer",
	1062	:	"//	mov wa =ch_cl  colon",
	1063	:	"//	jsr prtch   print it",
	1064	:	"//	mov wa =ch_pp  left paren",
	1065	:	"//	jsr prtch   print it",
	1066	:	"//	jsr prtvn   print label name",
	1067	:	"//	mov wa =ch_rp  right paren",
	1068	:	"//	jsr prtch   print it",
	1069	:	"//	jsr prtnl   terminate line",
	1070	:	"//	mov xr vrlbl(xl)  point back to trblk",
	1071	:	"//bvrt2	mov xr trlbl(xr)  load pointer to actual code",
	1072	:	"//	bri (xr)   execute statement at label",
	1073	:	"//	mov wb (xs)  load value (leave copy on stack)",
	1074	:	"//	sub xr *vrsto  point to vrblk",
	1075	:	"//	mov xl xr  copy vrblk pointer",
	1076	:	"//	mov wa *vrval  set offset",
	1077	:	"//	jsr asign   call assignment routine",
	1078	:	"//	lcw xr   else get next code word",
	1079	:	"//	bri (xr)   execute next code word",
	1080	:	"//	mov -(xs) wb  stack cursor",
	1081	:	"//	mov -(xs) xr  stack dummy node ptr",
	1082	:	"//	mov -(xs) pmhbs  stack old stack base ptr",
	1083	:	"//	mov -(xs) =ndabb  stack ptr to node ndabb",
	1084	:	"//	mov pmhbs xs  store new stack base ptr",
	1085	:	"//	brn succp   succeed",
	1086	:	"//	mov pmhbs wb  restore history stack base ptr",
	1087	:	"//	brn flpop   fail and pop dummy node ptr",
	1088	:	"//	mov xt pmhbs  keep p_abb stack base",
	1089	:	"//	mov wa num03(xt)  load initial cursor",
	1090	:	"//	mov pmhbs num01(xt)  restore outer stack base ptr",
	1091	:	"//	beq xt xs pabc1 jump if no history stack entries",
	1092	:	"//	mov -(xs) xt  else save inner pmhbs entry",
	1093	:	"//	mov -(xs) =ndabd  stack ptr to special node ndabd",
	1094	:	"//	brn pabc2   merge",
	1095	:	"//pabc1	add xs *num04  remove ndabb entry and cursor",
	1096	:	"//pabc2	bne wa wb succp allow further attempt if non-null",
	1097	:	"//	mov xr pthen(xr)  bypass alternative node so as to ...",
	1098	:	"//	brn succp   ... refuse further match attempts",
	1099	:	"//	mov pmhbs wb  restore inner stack base ptr",
	1100	:	"//	brn failp   and fail",
	1101	:	"//	brn exfal   signal statement failure",
	1102	:	"//	mov -(xs) wb  stack cursor",
	1103	:	"//	mov -(xs) parm1(xr)  stack pointer to alternative",
	1104	:	"//	chk    check for stack overflow",
	1105	:	"//	brn succp   if all ok, then succeed",
	1106	:	"//	beq wb pmssl failp fail if no chars left",
	1107	:	"//	mov xl r_pms  else point to subject string",
	1108	:	"//	plc xl wb  point to current character",
	1109	:	"//	lch wa (xl)  load current character",
	1110	:	"//	bne wa parm1(xr) failp fail if no match",
	1111	:	"//	icv wb   else bump cursor",
	1112	:	"//	brn succp   and succeed",
	1113	:	"//pany1	beq wb pmssl failp fail if no characters left",
	1114	:	"//	mov xl r_pms  else point to subject string",
	1115	:	"//	plc xl wb  get char ptr to current character",
	1116	:	"//	lch wa (xl)  load current character",
	1117	:	"//	mov xl parm1(xr)  point to ctblk",
	1118	:	"//	wtb wa   change to byte offset",
	1119	:	"//	add xl wa  point to entry in ctblk",
	1120	:	"//	mov wa ctchs(xl)  load word from ctblk",
	1121	:	"//	anb wa parm2(xr)  and with selected bit",
	1122	:	"//	zrb wa failp  fail if no match",
	1123	:	"//	icv wb   else bump cursor",
	1124	:	"//	brn succp   and succeed",
	1125	:	"//	jsr evals   evaluate string argument",
	1126	:	"//	mov xr pthen(xr)  load successor pointer",
	1127	:	"//	mov -(xs) wb  stack dummy cursor",
	1128	:	"//	mov -(xs) xr  stack successor pointer",
	1129	:	"//	mov -(xs) wb  stack cursor",
	1130	:	"//	mov -(xs) =ndarc  stack ptr to special node ndarc",
	1131	:	"//	bri (xr)   execute next node matching null",
	1132	:	"//	beq wb pmssl flpop fail and pop stack to successor",
	1133	:	"//	icv wb   else bump cursor",
	1134	:	"//	mov -(xs) wb  stack updated cursor",
	1135	:	"//	mov -(xs) xr  restack pointer to ndarc node",
	1136	:	"//	mov xr num02(xs)  load successor pointer",
	1137	:	"//	bri (xr)   off to reexecute successor node",
	1138	:	"//	zer wc   zero parentheses level counter",
	1139	:	"//	mov xl r_pms  point to subject string",
	1140	:	"//	plc xl wb  point to current character",
	1141	:	"//	brn pbal2   jump into scan loop",
	1142	:	"//pbal1	lch wa (xl)+  load next character, bump pointer",
	1143	:	"//	icv wb   push cursor for character",
	1144	:	"//	beq wa =ch_pp pbal3 jump if left paren",
	1145	:	"//	beq wa =ch_rp pbal4 jump if right paren",
	1146	:	"//	bze wc pbal5  else succeed if at outer level",
	1147	:	"//pbal2	bne wb pmssl pbal1 loop back unless end of string",
	1148	:	"//	brn failp   in which case, fail",
	1149	:	"//pbal3	icv wc   bump paren level",
	1150	:	"//	brn pbal2   loop back to check end of string",
	1151	:	"//pbal4	bze wc failp  fail if no matching left paren",
	1152	:	"//	dcv wc   else decrement level counter",
	1153	:	"//	bnz wc pbal2  loop back if not at outer level",
	1154	:	"//pbal5	mov -(xs) wb  stack cursor",
	1155	:	"//	mov -(xs) xr  stack ptr to bal node for extend",
	1156	:	"//	brn succp   and succeed",
	1157	:	"//	jsr evals   evaluate string expression",
	1158	:	"//	mov wc pmssl  get subject string length",
	1159	:	"//	sub wc wb  get number of characters left",
	1160	:	"//	bze wc failp  fail if no characters left",
	1161	:	"//	lct wc wc  set counter for chars left",
	1162	:	"//	mov xl r_pms  point to subject string",
	1163	:	"//	plc xl wb  point to current character",
	1164	:	"//pbks1	lch wa (xl)+  load next char, bump pointer",
	1165	:	"//	beq wa parm1(xr) succp succeed if break character found",
	1166	:	"//	icv wb   else push cursor",
	1167	:	"//	bct wc pbks1  loop back if more to go",
	1168	:	"//	brn failp   fail if end of string, no break chr",
	1169	:	"//pbrk1	mov wc pmssl  load subject string length",
	1170	:	"//	sub wc wb  get number of characters left",
	1171	:	"//	bze wc failp  fail if no characters left",
	1172	:	"//	lct wc wc  set counter for characters left",
	1173	:	"//	mov xl r_pms  else point to subject string",
	1174	:	"//	plc xl wb  point to current character",
	1175	:	"//	mov psave xr  save node pointer",
	1176	:	"//pbrk2	lch wa (xl)+  load next char, bump pointer",
	1177	:	"//	mov xr parm1(xr)  load pointer to ctblk",
	1178	:	"//	wtb wa   convert to byte offset",
	1179	:	"//	add xr wa  point to ctblk entry",
	1180	:	"//	mov wa ctchs(xr)  load ctblk word",
	1181	:	"//	mov xr psave  restore node pointer",
	1182	:	"//	anb wa parm2(xr)  and with selected bit",
	1183	:	"//	nzb wa succp  succeed if break character found",
	1184	:	"//	icv wb   else push cursor",
	1185	:	"//	bct wc pbrk2  loop back unless end of string",
	1186	:	"//	brn failp   fail if end of string, no break chr",
	1187	:	"//	icv wb   step cursor past previous break chr",
	1188	:	"//	brn succp   succeed to rematch break",
	1189	:	"//	jsr evals   evaluate string argument",
	1190	:	"//	mov -(xs) xr  save node pointer",
	1191	:	"//	mov -(xs) wb  save cursor",
	1192	:	"//	mov xl parm1(xr)  load name base",
	1193	:	"//	mti wb   load cursor as integer",
	1194	:	"//	mov wb parm2(xr)  load name offset",
	1195	:	"//	jsr icbld   get icblk for cursor value",
	1196	:	"//	mov wa wb  move name offset",
	1197	:	"//	mov wb xr  move value to assign",
	1198	:	"//	jsr asinp   perform assignment",
	1199	:	"//	mov wb (xs)+  else restore cursor",
	1200	:	"//	mov xr (xs)+  restore node pointer",
	1201	:	"//	brn succp   and succeed matching null",
	1202	:	"//	jsr evalp   evaluate expression",
	1203	:	"//	blo wa =p_aaa pexa1 jump if result is not a pattern",
	1204	:	"//	mov -(xs) wb  stack dummy cursor",
	1205	:	"//	mov -(xs) xr  stack ptr to p_exa node",
	1206	:	"//	mov -(xs) pmhbs  stack history stack base ptr",
	1207	:	"//	mov -(xs) =ndexb  stack ptr to special node ndexb",
	1208	:	"//	mov pmhbs xs  store new stack base pointer",
	1209	:	"//	mov xr xl  copy node pointer",
	1210	:	"//	bri (xr)   match first node in expression pat",
	1211	:	"//pexa1	beq wa =b_scl pexa2 jump if it is already a string",
	1212	:	"//	mov -(xs) xl  else stack result",
	1213	:	"//	mov xl xr  save node pointer",
	1214	:	"//	jsr gtstg   convert result to string",
	1215	:	"//	mov wc xr  copy string pointer",
	1216	:	"//	mov xr xl  restore node pointer",
	1217	:	"//	mov xl wc  copy string pointer again",
	1218	:	"//pexa2	bze sclen(xl) succp  just succeed if null string",
	1219	:	"//	brn pstr1   else merge with string circuit",
	1220	:	"//	mov pmhbs wb  restore outer level stack pointer",
	1221	:	"//	brn flpop   fail and pop p_exa node ptr",
	1222	:	"//	mov pmhbs wb  restore inner stack base pointer",
	1223	:	"//	brn failp   and fail into expr pattern alternvs",
	1224	:	"//	brn failp   just signal failure",
	1225	:	"//	mov -(xs) wb  stack dummy cursor",
	1226	:	"//	mov -(xs) =ndabo  stack ptr to abort node",
	1227	:	"//	brn succp   and succeed matching null",
	1228	:	"//	mov -(xs) pmhbs  stack current history stack base",
	1229	:	"//	mov -(xs) =ndfnb  stack indir ptr to p_fnb (failure)",
	1230	:	"//	mov pmhbs xs  begin new history stack",
	1231	:	"//	brn succp   succeed",
	1232	:	"//	mov pmhbs wb  restore outer pmhbs stack base",
	1233	:	"//	brn failp   ...and fail",
	1234	:	"//	mov xt pmhbs  get inner stack base ptr",
	1235	:	"//	mov pmhbs num01(xt)  restore outer stack base",
	1236	:	"//	beq xt xs pfnc1 optimize if no alternatives",
	1237	:	"//	mov -(xs) xt  else stack inner stack base",
	1238	:	"//	mov -(xs) =ndfnd  stack ptr to ndfnd",
	1239	:	"//	brn succp   succeed",
	1240	:	"//pfnc1	add xs *num02  pop off p_fnb entry",
	1241	:	"//	brn succp   succeed",
	1242	:	"//	mov xs wb  pop stack to fence() history base",
	1243	:	"//	brn flpop   pop base entry and fail",
	1244	:	"//	mov -(xs) wb  stack cursor",
	1245	:	"//	mov -(xs) xr  stack dummy node pointer",
	1246	:	"//	mov -(xs) pmhbs  stack old stack base pointer",
	1247	:	"//	mov -(xs) =ndimb  stack ptr to special node ndimb",
	1248	:	"//	mov pmhbs xs  store new stack base pointer",
	1249	:	"//	brn succp   and succeed",
	1250	:	"//	mov pmhbs wb  restore history stack base ptr",
	1251	:	"//	brn flpop   fail and pop dummy node ptr",
	1252	:	"//	mov xt pmhbs  load pointer to p_imb entry",
	1253	:	"//	mov wa wb  copy final cursor",
	1254	:	"//	mov wb num03(xt)  load initial cursor",
	1255	:	"//	mov pmhbs num01(xt)  restore outer stack base pointer",
	1256	:	"//	beq xt xs pimc1 jump if no history stack entries",
	1257	:	"//	mov -(xs) xt  else save inner pmhbs pointer",
	1258	:	"//	mov -(xs) =ndimd  and a ptr to special node ndimd",
	1259	:	"//	brn pimc2   merge",
	1260	:	"//pimc1	add xs *num04  remove ndimb entry and cursor",
	1261	:	"//pimc2	mov -(xs) wa  save current (final) cursor",
	1262	:	"//	mov -(xs) xr  save current node pointer",
	1263	:	"//	mov xl r_pms  point to subject string",
	1264	:	"//	sub wa wb  compute substring length",
	1265	:	"//	jsr sbstr   build substring",
	1266	:	"//	mov wb xr  move result",
	1267	:	"//	mov xr (xs)  reload node pointer",
	1268	:	"//	mov xl parm1(xr)  load name base",
	1269	:	"//	mov wa parm2(xr)  load name offset",
	1270	:	"//	jsr asinp   perform assignment",
	1271	:	"//	mov xr (xs)+  else restore node pointer",
	1272	:	"//	mov wb (xs)+  restore cursor",
	1273	:	"//	brn succp   and succeed",
	1274	:	"//	mov pmhbs wb  restore inner stack base pointer",
	1275	:	"//	brn failp   and fail",
	1276	:	"//plen1	add wb parm1(xr)  push cursor indicated amount",
	1277	:	"//	ble wb pmssl succp succeed if not off end",
	1278	:	"//	brn failp   else fail",
	1279	:	"//	jsr evali   evaluate integer argument",
	1280	:	"//	jsr evals   evaluate string argument",
	1281	:	"//	beq wb pmssl failp fail if no chars left",
	1282	:	"//	mov xl r_pms  else point to subject string",
	1283	:	"//	plc xl wb  point to current character in strin",
	1284	:	"//	lch wa (xl)  load current character",
	1285	:	"//	beq wa parm1(xr) failp fail if match",
	1286	:	"//	icv wb   else bump cursor",
	1287	:	"//	brn succp   and succeed",
	1288	:	"//pnay1	beq wb pmssl failp fail if no characters left",
	1289	:	"//	mov xl r_pms  else point to subject string",
	1290	:	"//	plc xl wb  point to current character",
	1291	:	"//	lch wa (xl)  load current character",
	1292	:	"//	wtb wa   convert to byte offset",
	1293	:	"//	mov xl parm1(xr)  load pointer to ctblk",
	1294	:	"//	add xl wa  point to entry in ctblk",
	1295	:	"//	mov wa ctchs(xl)  load entry from ctblk",
	1296	:	"//	anb wa parm2(xr)  and with selected bit",
	1297	:	"//	nzb wa failp  fail if character is matched",
	1298	:	"//	icv wb   else bump cursor",
	1299	:	"//	brn succp   and succeed",
	1300	:	"//	mov xt pmhbs  load pointer to base of stack",
	1301	:	"//	mov wa num01(xt)  load saved pmhbs (or pattern type)",
	1302	:	"//	ble wa =num02 pnth2 jump if outer level (pattern type)",
	1303	:	"//	mov pmhbs wa  restore outer stack base pointer",
	1304	:	"//	mov xr num02(xt)  restore pointer to p_exa node",
	1305	:	"//	beq xt xs pnth1 jump if no history stack entries",
	1306	:	"//	mov -(xs) xt  else stack inner stack base ptr",
	1307	:	"//	mov -(xs) =ndexc  stack ptr to special node ndexc",
	1308	:	"//	brn succp   and succeed",
	1309	:	"//pnth1	add xs *num04  remove p_exb entry and node ptr",
	1310	:	"//	brn succp   and succeed",
	1311	:	"//pnth2	mov pmssl wb  save final cursor in safe place",
	1312	:	"//	bze pmdfl pnth6  jump if no pattern assignments",
	1313	:	"//pnth3	dca xt   point past cursor entry",
	1314	:	"//	mov wa -(xt)  load node pointer",
	1315	:	"//	beq wa =ndpad pnth4 jump if ndpad entry",
	1316	:	"//	bne wa =ndpab pnth5 jump if not ndpab entry",
	1317	:	"//	mov -(xs) num01(xt)  stack initial cursor",
	1318	:	"//	chk    check for stack overflow",
	1319	:	"//	brn pnth3   loop back if ok",
	1320	:	"//pnth4	mov wa num01(xt)  load final cursor",
	1321	:	"//	mov wb (xs)  load initial cursor from stack",
	1322	:	"//	mov (xs) xt  save history stack scan ptr",
	1323	:	"//	sub wa wb  compute length of string",
	1324	:	"//	mov xl r_pms  point to subject string",
	1325	:	"//	jsr sbstr   construct substring",
	1326	:	"//	mov wb xr  copy substring pointer",
	1327	:	"//	mov xt (xs)  reload history stack scan ptr",
	1328	:	"//	mov xl num02(xt)  load pointer to p_pac node with nam",
	1329	:	"//	mov wa parm2(xl)  load name offset",
	1330	:	"//	mov xl parm1(xl)  load name base",
	1331	:	"//	jsr asinp   perform assignment",
	1332	:	"//	mov xt (xs)+  else restore history stack ptr",
	1333	:	"//pnth5	bne xt xs pnth3 loop if more entries to scan",
	1334	:	"//pnth6	mov xs pmhbs  wipe out history stack",
	1335	:	"//	mov wb (xs)+  load initial cursor",
	1336	:	"//	mov wc (xs)+  load match type code",
	1337	:	"//	mov wa pmssl  load final cursor value",
	1338	:	"//	mov xl r_pms  point to subject string",
	1339	:	"//	zer r_pms   clear subject string ptr for gbcol",
	1340	:	"//	bze wc pnth7  jump if call by name",
	1341	:	"//	beq wc =num02 pnth9 exit if statement level call",
	1342	:	"//	sub wa wb  compute length of string",
	1343	:	"//	jsr sbstr   build substring",
	1344	:	"//	mov -(xs) xr  stack result",
	1345	:	"//	lcw xr   get next code word",
	1346	:	"//	bri (xr)   execute it",
	1347	:	"//pnth7	mov -(xs) wb  stack initial cursor",
	1348	:	"//	mov -(xs) wa  stack final cursor",
	1349	:	"//pnth8	mov -(xs) xl  stack subject pointer",
	1350	:	"//pnth9	lcw xr   get next code word",
	1351	:	"//	bri (xr)   execute next code word",
	1352	:	"//	beq wb parm1(xr) succp succeed if at right location",
	1353	:	"//	bnz wb failp  don't look further if cursor not 0",
	1354	:	"//	mov xt pmhbs  get history stack base ptr",
	1355	:	"//	bne xr -(xt) failp fail if pos is not first node",
	1356	:	"//ppos2	bne -(xt) =nduna failp fail if not unanchored mode",
	1357	:	"//	mov wb parm1(xr)  get desired cursor position",
	1358	:	"//	bgt wb pmssl exfal abort if off end",
	1359	:	"//	mov num02(xt) wb  fake number of unanchored moves",
	1360	:	"//	brn succp   continue match with adjusted cursor",
	1361	:	"//	jsr evali   evaluate integer argument",
	1362	:	"//ppos1	beq wb parm1(xr) succp succeed if at right location",
	1363	:	"//	bnz wb failp  don't look further if cursor not 0",
	1364	:	"//	bnz evlif failp  fail if complex argument",
	1365	:	"//	mov xt pmhbs  get history stack base ptr",
	1366	:	"//	mov wa evlio  get original node ptr",
	1367	:	"//	bne wa -(xt) failp fail if pos is not first node",
	1368	:	"//	brn ppos2   merge with integer argument code",
	1369	:	"//	mov -(xs) wb  stack initial cursor",
	1370	:	"//	mov -(xs) =ndpab  stack ptr to ndpab special node",
	1371	:	"//	brn succp   and succeed matching null",
	1372	:	"//	brn failp   just fail (entry is already popped)",
	1373	:	"//	mov -(xs) wb  stack dummy cursor value",
	1374	:	"//	mov -(xs) xr  stack pointer to p_pac node",
	1375	:	"//	mov -(xs) wb  stack final cursor",
	1376	:	"//	mov -(xs) =ndpad  stack ptr to special ndpad node",
	1377	:	"//	mnz pmdfl   set dot flag non-zero",
	1378	:	"//	brn succp   and succeed",
	1379	:	"//	brn flpop   fail and remove p_pac node",
	1380	:	"//	mov wb pmssl  point cursor to end of string",
	1381	:	"//	brn succp   and succeed",
	1382	:	"//	jsr evali   evaluate integer argument",
	1383	:	"//prps1	mov wc pmssl  get length of string",
	1384	:	"//	sub wc wb  get number of characters remaining",
	1385	:	"//	beq wc parm1(xr) succp succeed if at right location",
	1386	:	"//	bnz wb failp  don't look further if cursor not 0",
	1387	:	"//	bnz evlif failp  fail if complex argument",
	1388	:	"//	mov xt pmhbs  get history stack base ptr",
	1389	:	"//	mov wa evlio  get original node ptr",
	1390	:	"//	bne wa -(xt) failp fail if pos is not first node",
	1391	:	"//	brn prps2   merge with integer arg code",
	1392	:	"//	mov wc pmssl  get length of string",
	1393	:	"//	sub wc wb  get number of characters remaining",
	1394	:	"//	beq wc parm1(xr) succp succeed if at right location",
	1395	:	"//	bnz wb failp  don't look further if cursor not 0",
	1396	:	"//	mov xt pmhbs  get history stack base ptr",
	1397	:	"//	bne xr -(xt) failp fail if rpos is not first node",
	1398	:	"//prps2	bne -(xt) =nduna failp fail if not unanchored mode",
	1399	:	"//	mov wb pmssl  point to end of string",
	1400	:	"//	blt wb parm1(xr) failp fail if string not long enough",
	1401	:	"//	sub wb parm1(xr)  else set new cursor",
	1402	:	"//	mov num02(xt) wb  fake number of unanchored moves",
	1403	:	"//	brn succp   continue match with adjusted cursor",
	1404	:	"//prtb1	mov wc wb  save initial cursor",
	1405	:	"//	mov wb pmssl  point to end of string",
	1406	:	"//	blt wb parm1(xr) failp fail if string not long enough",
	1407	:	"//	sub wb parm1(xr)  else set new cursor",
	1408	:	"//	bge wb wc succp and succeed if not too far already",
	1409	:	"//	brn failp   in which case, fail",
	1410	:	"//	jsr evali   evaluate integer argument",
	1411	:	"//	jsr evals   evaluate string argument",
	1412	:	"//pspn1	mov wc pmssl  copy subject string length",
	1413	:	"//	sub wc wb  calculate number of characters left",
	1414	:	"//	bze wc failp  fail if no characters left",
	1415	:	"//	mov xl r_pms  point to subject string",
	1416	:	"//	plc xl wb  point to current character",
	1417	:	"//	mov psavc wb  save initial cursor",
	1418	:	"//	mov psave xr  save node pointer",
	1419	:	"//	lct wc wc  set counter for chars left",
	1420	:	"//pspn2	lch wa (xl)+  load next character, bump pointer",
	1421	:	"//	wtb wa   convert to byte offset",
	1422	:	"//	mov xr parm1(xr)  point to ctblk",
	1423	:	"//	add xr wa  point to ctblk entry",
	1424	:	"//	mov wa ctchs(xr)  load ctblk entry",
	1425	:	"//	mov xr psave  restore node pointer",
	1426	:	"//	anb wa parm2(xr)  and with selected bit",
	1427	:	"//	zrb wa pspn3  jump if no match",
	1428	:	"//	icv wb   else push cursor",
	1429	:	"//	bct wc pspn2  loop back unless end of string",
	1430	:	"//pspn3	bne wb psavc succp succeed if chars matched",
	1431	:	"//	brn failp   else fail if null string matched",
	1432	:	"//	mov wc pmssl  get subject string length",
	1433	:	"//	sub wc wb  calculate number of characters left",
	1434	:	"//	bze wc failp  fail if no characters left",
	1435	:	"//	mov xl r_pms  else point to subject string",
	1436	:	"//	plc xl wb  point to current character",
	1437	:	"//	mov psavc wb  save initial cursor",
	1438	:	"//	lct wc wc  set counter for characters left",
	1439	:	"//psps1	lch wa (xl)+  load next character, bump pointer",
	1440	:	"//	bne wa parm1(xr) psps2 jump if no match",
	1441	:	"//	icv wb   else push cursor",
	1442	:	"//	bct wc psps1  and loop unless end of string",
	1443	:	"//psps2	bne wb psavc succp succeed if chars matched",
	1444	:	"//	brn failp   fail if null string matched",
	1445	:	"//	mov xl parm1(xr)  get pointer to string",
	1446	:	"//pstr1	mov psave xr  save node pointer",
	1447	:	"//	mov xr r_pms  load subject string pointer",
	1448	:	"//	plc xr wb  point to current character",
	1449	:	"//	add wb sclen(xl)  compute new cursor position",
	1450	:	"//	bgt wb pmssl failp fail if past end of string",
	1451	:	"//	mov psavc wb  save updated cursor",
	1452	:	"//	mov wa sclen(xl)  get number of chars to compare",
	1453	:	"//	plc xl   point to chars of test string",
	1454	:	"//	cmc failp failp  compare, fail if not equal",
	1455	:	"//	mov xr psave  if all matched, restore node ptr",
	1456	:	"//	mov wb psavc  restore updated cursor",
	1457	:	"//	brn succp   and succeed",
	1458	:	"//	mov -(xs) wb  stack cursor",
	1459	:	"//	mov -(xs) xr  stack pointer to this node",
	1460	:	"//	brn succp   succeed matching null",
	1461	:	"//ptab1	bgt wb parm1(xr) failp fail if too far already",
	1462	:	"//	mov wb parm1(xr)  else set new cursor position",
	1463	:	"//	ble wb pmssl succp succeed if not off end",
	1464	:	"//	brn failp   else fail",
	1465	:	"//	jsr evali   evaluate integer argument",
	1466	:	"//	mov xr wb  copy initial pattern node pointer",
	1467	:	"//	mov wb (xs)  get initial cursor",
	1468	:	"//	beq wb pmssl exfal match fails if at end of string",
	1469	:	"//	icv wb   else increment cursor",
	1470	:	"//	mov (xs) wb  store incremented cursor",
	1471	:	"//	mov -(xs) xr  restack initial node ptr",
	1472	:	"//	mov -(xs) =nduna  restack unanchored node",
	1473	:	"//	bri (xr)   rematch first node",
	1474	:	"//labo1	mov wa kvert  load error code",
	1475	:	"//	bze wa labo3  jump if no error has occured",
	1476	:	"//	jsr sysax   call after execution proc",
	1477	:	"//	mov wc kvstn  current statement",
	1478	:	"//	jsr filnm   obtain file name for this statement",
	1479	:	"//	mov xr r_cod  current code block",
	1480	:	"//	mov wc cdsln(xr)  line number",
	1481	:	"//	zer wb   column number",
	1482	:	"//	mov xr stage  ",
	1483	:	"//	jsr sysea   advise system of error",
	1484	:	"//	jsr prtpg   else eject printer",
	1485	:	"//	bze xr labo2  did sysea request print",
	1486	:	"//	jsr prtst   print text from sysea",
	1487	:	"//labo2	jsr ermsg   print error message",
	1488	:	"//	zer xr   indicate no message to print",
	1489	:	"//	brn stopr   jump to routine to stop run",
	1490	:	"//labo3	erb 036 goto abort with no preceding error  ",
	1491	:	"//lcnt1	mov xr r_cnt  load continuation code block ptr",
	1492	:	"//	bze xr lcnt3  jump if no previous error",
	1493	:	"//	zer r_cnt   clear flag",
	1494	:	"//	mov r_cod xr  else store as new code block ptr",
	1495	:	"//	bne (xr) =b_cdc lcnt2 jump if not complex go",
	1496	:	"//	mov wa stxoc  get offset of error",
	1497	:	"//	bge wa stxof lcnt4 jump if error in goto evaluation",
	1498	:	"//lcnt2	add xr stxof  add failure offset",
	1499	:	"//	lcp xr   load code pointer",
	1500	:	"//	mov xs flptr  reset stack pointer",
	1501	:	"//	lcw xr   get next code word",
	1502	:	"//	bri (xr)   execute next code word",
	1503	:	"//lcnt3	icv errft   fatal error",
	1504	:	"//	erb 037 goto continue with no preceding error  ",
	1505	:	"//lcnt4	icv errft   fatal error",
	1506	:	"//	erb 332 goto continue with error in failure goto  ",
	1507	:	"//lend0	mov xr =endms  point to message /normal term.../",
	1508	:	"//	brn stopr   jump to routine to stop run",
	1509	:	"//	mov wa =scfrt  point to string /freturn/",
	1510	:	"//	brn retrn   jump to common return routine",
	1511	:	"//	mov wa =scnrt  point to string /nreturn/",
	1512	:	"//	brn retrn   jump to common return routine",
	1513	:	"//	mov wa =scrtn  point to string /return/",
	1514	:	"//	brn retrn   jump to common return routine",
	1515	:	"//	mov xr r_cnt  load continuation code block ptr",
	1516	:	"//	bze xr lscn2  jump if no previous error",
	1517	:	"//	zer r_cnt   clear flag",
	1518	:	"//	bne kvert =nm320 lscn1 error must be user interrupt",
	1519	:	"//	beq kvert =nm321 lscn2 detect scontinue loop",
	1520	:	"//	mov r_cod xr  else store as new code block ptr",
	1521	:	"//	add xr stxoc  add resume offset",
	1522	:	"//	lcp xr   load code pointer",
	1523	:	"//	lcw xr   get next code word",
	1524	:	"//	bri (xr)   execute next code word",
	1525	:	"//lscn1	icv errft   fatal error",
	1526	:	"//	erb 331 goto scontinue with no user interrupt  ",
	1527	:	"//lscn2	icv errft   fatal error",
	1528	:	"//	erb 321 goto scontinue with no preceding error  ",
	1529	:	"//	erb 038 goto undefined label  ",
	1530	:	"//	mov wb =p_ans  set pcode for single char case",
	1531	:	"//	mov xl =p_any  pcode for multi-char case",
	1532	:	"//	mov wc =p_ayd  pcode for expression case",
	1533	:	"//	jsr patst   call common routine to build node",
	1534	:	"//	mov -(xs) xr  stack result",
	1535	:	"//	lcw xr   get next code word",
	1536	:	"//	bri (xr)   execute it",
	1537	:	"//	bze wa sapp3  jump if no arguments",
	1538	:	"//	dcv wa   else get applied func arg count",
	1539	:	"//	mov wb wa  copy",
	1540	:	"//	wtb wb   convert to bytes",
	1541	:	"//	mov xt xs  copy stack pointer",
	1542	:	"//	add xt wb  point to function argument on stack",
	1543	:	"//	mov xr (xt)  load function ptr (apply 1st arg)",
	1544	:	"//	bze wa sapp2  jump if no args for applied func",
	1545	:	"//	lct wb wa  else set counter for loop",
	1546	:	"//sapp1	dca xt   point to next argument",
	1547	:	"//	mov num01(xt) (xt)  move argument up",
	1548	:	"//	bct wb sapp1  loop till all moved",
	1549	:	"//sapp2	ica xs   adjust stack ptr for apply 1st arg",
	1550	:	"//	jsr gtnvr   get variable block addr for func",
	1551	:	"//	mov xl vrfnc(xr)  else point to function block",
	1552	:	"//	brn cfunc   go call applied function",
	1553	:	"//sapp3	erb 060 apply first arg is not natural variable name  ",
	1554	:	"//	zer xr   set parm1 = 0 for the moment",
	1555	:	"//	mov wb =p_alt  set pcode for alternative node",
	1556	:	"//	jsr pbild   build alternative node",
	1557	:	"//	mov xl xr  save ptr to alternative pattern",
	1558	:	"//	mov wb =p_abc  pcode for p_abc",
	1559	:	"//	zer xr   p0blk",
	1560	:	"//	jsr pbild   build p_abc node",
	1561	:	"//	mov pthen(xr) xl  put alternative node as successor",
	1562	:	"//	mov wa xl  remember alternative node pointer",
	1563	:	"//	mov xl xr  copy p_abc node ptr",
	1564	:	"//	mov xr (xs)  load arbno argument",
	1565	:	"//	mov (xs) wa  stack alternative node pointer",
	1566	:	"//	jsr gtpat   get arbno argument as pattern",
	1567	:	"//	jsr pconc   concat arg with p_abc node",
	1568	:	"//	mov xl xr  remember ptr to concd patterns",
	1569	:	"//	mov wb =p_aba  pcode for p_aba",
	1570	:	"//	zer xr   p0blk",
	1571	:	"//	jsr pbild   build p_aba node",
	1572	:	"//	mov pthen(xr) xl  concatenate nodes",
	1573	:	"//	mov xl (xs)  recall ptr to alternative node",
	1574	:	"//	mov parm1(xl) xr  point alternative back to argument",
	1575	:	"//	lcw xr   get next code word",
	1576	:	"//	bri (xr)   execute next code word",
	1577	:	"//	jsr gtsmi   get second arg as small integer",
	1578	:	"//	mov wa xr  save argument number",
	1579	:	"//	mov xr (xs)+  load first argument",
	1580	:	"//	jsr gtnvr   locate vrblk",
	1581	:	"//	mov xr vrfnc(xr)  else load function block pointer",
	1582	:	"//	bne (xr) =b_pfc sarg1 jump if not program defined",
	1583	:	"//	bze wa exfal  fail if arg number is zero",
	1584	:	"//	bgt wa fargs(xr) exfal fail if arg number is too large",
	1585	:	"//	wtb wa   else convert to byte offset",
	1586	:	"//	add xr wa  point to argument selected",
	1587	:	"//	mov xr pfagb(xr)  load argument vrblk pointer",
	1588	:	"//	brn exvnm   exit to build nmblk",
	1589	:	"//sarg1	erb 063 arg first argument is not program function name  ",
	1590	:	"//	mov xl (xs)+  load initial element value",
	1591	:	"//	mov xr (xs)+  load first argument",
	1592	:	"//	jsr gtint   convert first arg to integer",
	1593	:	"//	ldi icval(xr)   load integer value",
	1594	:	"//	ile sar10   jump if zero or neg (bad dimension)",
	1595	:	"//	mfi wa sar11  else convert to one word, test ovfl",
	1596	:	"//	jsr vmake   create vector",
	1597	:	"//	brn exsid   exit setting idval",
	1598	:	"//sar02	mov -(xs) xr  replace argument on stack",
	1599	:	"//	jsr xscni   initialize scan of first argument",
	1600	:	"//	mov -(xs) r_xsc  save prototype pointer",
	1601	:	"//	mov -(xs) xl  save default value",
	1602	:	"//	zer arcdm   zero count of dimensions",
	1603	:	"//	zer arptr   zero offset to indicate pass one",
	1604	:	"//	ldi 4,intv1   load integer one",
	1605	:	"//	sti arnel   initialize element count",
	1606	:	"//sar03	ldi 4,intv1   load one as default low bound",
	1607	:	"//	sti arsvl   save as low bound",
	1608	:	"//	mov wc =ch_cl  set delimiter one = colon",
	1609	:	"//	mov xl =ch_cm  set delimiter two = comma",
	1610	:	"//	zer wa   retain blanks in prototype",
	1611	:	"//	jsr xscan   scan next bound",
	1612	:	"//	bne wa =num01 sar04 jump if not colon",
	1613	:	"//	jsr gtint   convert low bound",
	1614	:	"//	ldi icval(xr)   load value of low bound",
	1615	:	"//	sti arsvl   store low bound value",
	1616	:	"//	mov wc =ch_cm  set delimiter one = comma",
	1617	:	"//	mov xl wc  and delimiter two = comma",
	1618	:	"//	zer wa   retain blanks in prototype",
	1619	:	"//	jsr xscan   scan high bound",
	1620	:	"//sar04	jsr gtint   convert high bound to integer",
	1621	:	"//	ldi icval(xr)   get high bound",
	1622	:	"//	sbi arsvl   subtract lower bound",
	1623	:	"//	iov sar10   bad dimension if overflow",
	1624	:	"//	ilt sar10   bad dimension if negative",
	1625	:	"//	adi 4,intv1   add 1 to get dimension",
	1626	:	"//	iov sar10   bad dimension if overflow",
	1627	:	"//	mov xl arptr  load offset (also pass indicator)",
	1628	:	"//	bze xl sar05  jump if first pass",
	1629	:	"//	add xl (xs)  point to current location in arblk",
	1630	:	"//	sti cfp_i(xl)   store dimension",
	1631	:	"//	ldi arsvl   load low bound",
	1632	:	"//	sti (xl)   store low bound",
	1633	:	"//	add arptr *ardms  bump offset to next bounds",
	1634	:	"//	brn sar06   jump to check for end of bounds",
	1635	:	"//sar05	icv arcdm   bump dimension count",
	1636	:	"//	mli arnel   multiply dimension by count so far",
	1637	:	"//	iov sar11   too large if overflow",
	1638	:	"//	sti arnel   else store updated element count",
	1639	:	"//sar06	bnz wa sar03  loop back unless end of bounds",
	1640	:	"//	bnz arptr sar09  jump if end of pass 2",
	1641	:	"//	ldi arnel   get number of elements",
	1642	:	"//	mfi wb sar11  get as addr integer, test ovflo",
	1643	:	"//	wtb wb   else convert to length in bytes",
	1644	:	"//	mov wa *arsi_  set size of standard fields",
	1645	:	"//	lct wc arcdm  set dimension count to control loop",
	1646	:	"//sar07	add wa *ardms  allow space for one set of bounds",
	1647	:	"//	bct wc sar07  loop back till all accounted for",
	1648	:	"//	mov xl wa  save size (=arofs)",
	1649	:	"//	add wa wb  add space for elements",
	1650	:	"//	ica wa   allow for arpro prototype field",
	1651	:	"//	bgt wa mxlen sar11 fail if too large",
	1652	:	"//	jsr alloc   else allocate arblk",
	1653	:	"//	mov wb (xs)  load default value",
	1654	:	"//	mov (xs) xr  save arblk pointer",
	1655	:	"//	mov wc wa  save length in bytes",
	1656	:	"//	btw wa   convert length back to words",
	1657	:	"//	lct wa wa  set counter to control loop",
	1658	:	"//sar08	mov (xr)+ wb  set one word",
	1659	:	"//	bct wa sar08  loop till all set",
	1660	:	"//	mov xr (xs)+  reload arblk pointer",
	1661	:	"//	mov wb (xs)  load prototype",
	1662	:	"//	mov (xr) =b_art  set type word",
	1663	:	"//	mov arlen(xr) wc  store length in bytes",
	1664	:	"//	zer idval(xr)   zero id till we get it built",
	1665	:	"//	mov arofs(xr) xl  set prototype field ptr",
	1666	:	"//	mov arndm(xr) arcdm  set number of dimensions",
	1667	:	"//	mov wc xr  save arblk pointer",
	1668	:	"//	add xr xl  point to prototype field",
	1669	:	"//	mov (xr) wb  store prototype ptr in arblk",
	1670	:	"//	mov arptr *arlbd  set offset for pass 2 bounds scan",
	1671	:	"//	mov r_xsc wb  reset string pointer for xscan",
	1672	:	"//	mov (xs) wc  store arblk pointer on stack",
	1673	:	"//	zer xsofs   reset offset ptr to start of string",
	1674	:	"//	brn sar03   jump back to rescan bounds",
	1675	:	"//sar09	mov xr (xs)+  reload pointer to arblk",
	1676	:	"//	brn exsid   exit setting idval",
	1677	:	"//sar10	erb 067 array dimension is zero, negative or out of range  ",
	1678	:	"//sar11	erb 068 array size exceeds maximum permitted  ",
	1679	:	"//	mov xr (xs)+  get argument",
	1680	:	"//	jsr gtrea   convert to real",
	1681	:	"//	ldr rcval(xr)   load accumulator with argument",
	1682	:	"//	atn    take arctangent",
	1683	:	"//	brn exrea   overflow, out of range not possible",
	1684	:	"//	jsr iofcb   call fcblk routine",
	1685	:	"//	jsr sysbs   call backspace file function",
	1686	:	"//	brn exnul   return null as result",
	1687	:	"//	mov wb =p_bks  set pcode for single char case",
	1688	:	"//	mov xl =p_brk  pcode for multi-char case",
	1689	:	"//	mov wc =p_bkd  pcode for expression case",
	1690	:	"//	jsr patst   call common routine to build node",
	1691	:	"//	mov -(xs) xr  stack result",
	1692	:	"//	lcw xr   get next code word",
	1693	:	"//	bri (xr)   execute it",
	1694	:	"//	mov wb =p_bks  pcode for single char argument",
	1695	:	"//	mov xl =p_brk  pcode for multi-char argument",
	1696	:	"//	mov wc =p_bxd  pcode for expression case",
	1697	:	"//	jsr patst   call common routine to build node",
	1698	:	"//	mov -(xs) xr  save ptr to break node",
	1699	:	"//	mov wb =p_bkx  set pcode for breakx node",
	1700	:	"//	jsr pbild   build it",
	1701	:	"//	mov pthen(xr) (xs)  set break node as successor",
	1702	:	"//	mov wb =p_alt  set pcode for alternation node",
	1703	:	"//	jsr pbild   build (parm1=alt=breakx node)",
	1704	:	"//	mov wa xr  save ptr to alternation node",
	1705	:	"//	mov xr (xs)  point to break node",
	1706	:	"//	mov pthen(xr) wa  set alternate node as successor",
	1707	:	"//	lcw xr   result on stack",
	1708	:	"//	bri (xr)   execute next code word",
	1709	:	"//	jsr gtsmi   convert arg to integer",
	1710	:	"//	bge wc =cfp_a schr1 see if out of range of host set",
	1711	:	"//	mov wa =num01  if not set scblk allocation",
	1712	:	"//	mov wb wc  save char code",
	1713	:	"//	jsr alocs   allocate 1 bau scblk",
	1714	:	"//	mov xl xr  copy scblk pointer",
	1715	:	"//	psc xl   get set to stuff char",
	1716	:	"//	sch wb (xl)  stuff it",
	1717	:	"//	csc xl   complete store character",
	1718	:	"//	zer xl   clear slop in xl",
	1719	:	"//	mov -(xs) xr  stack result",
	1720	:	"//	lcw xr   get next code word",
	1721	:	"//	bri (xr)   execute it",
	1722	:	"//schr1	erb 282 char argument not in range  ",
	1723	:	"//	mov xr (xs)+  get argument",
	1724	:	"//	jsr gtrea   convert to real",
	1725	:	"//	ldr rcval(xr)   load accumulator with argument",
	1726	:	"//	chp    truncate to integer valued real",
	1727	:	"//	brn exrea   no overflow possible",
	1728	:	"//	jsr xscni   initialize to scan argument",
	1729	:	"//sclr1	mov wc =ch_cm  set delimiter one = comma",
	1730	:	"//	mov xl wc  delimiter two = comma",
	1731	:	"//	mnz wa   skip/trim blanks in prototype",
	1732	:	"//	jsr xscan   scan next variable name",
	1733	:	"//	jsr gtnvr   locate vrblk",
	1734	:	"//	zer vrget(xr)   else flag by zeroing vrget field",
	1735	:	"//	bnz wa sclr1  loop back if stopped by comma",
	1736	:	"//sclr2	mov wb hshtb  point to start of hash table",
	1737	:	"//sclr3	beq wb hshte exnul exit returning null if none left",
	1738	:	"//	mov xr wb  else copy slot pointer",
	1739	:	"//	ica wb   bump slot pointer",
	1740	:	"//	sub xr *vrnxt  set offset to merge into loop",
	1741	:	"//sclr4	mov xr vrnxt(xr)  point to next vrblk on chain",
	1742	:	"//	bze xr sclr3  jump for next bucket if chain end",
	1743	:	"//	bnz vrget(xr) sclr5  jump if not flagged",
	1744	:	"//	jsr setvr   for flagged var, restore vrget",
	1745	:	"//	brn sclr4   and loop back for next vrblk",
	1746	:	"//sclr5	beq vrsto(xr) =b_vre sclr4 check for protected variable",
	1747	:	"//	mov xl xr  copy vrblk pointer",
	1748	:	"//sclr6	mov wa xl  save block pointer",
	1749	:	"//	mov xl vrval(xl)  load next value field",
	1750	:	"//	beq (xl) =b_trt sclr6 loop back if trapped",
	1751	:	"//	mov xl wa  restore block pointer",
	1752	:	"//	mov vrval(xl) =nulls  store null constant value",
	1753	:	"//	brn sclr4   loop back for next vrblk",
	1754	:	"//	mov xr (xs)+  load argument",
	1755	:	"//	jsr gtcod   convert to code",
	1756	:	"//	mov -(xs) xr  stack result",
	1757	:	"//	zer r_ccb   forget interim code block",
	1758	:	"//	lcw xr   get next code word",
	1759	:	"//	bri (xr)   execute it",
	1760	:	"//	mov xr (xs)+  load argument",
	1761	:	"//	jsr gtint   convert to integer",
	1762	:	"//	ldi icval(xr)   load collect argument",
	1763	:	"//	sti clsvi   save collect argument",
	1764	:	"//	zer wb   set no move up",
	1765	:	"//	zer r_ccb   forget interim code block",
	1766	:	"//	zer dnams   collect sediment too",
	1767	:	"//	jsr gbcol   perform garbage collection",
	1768	:	"//	mov dnams xr  record new sediment size",
	1769	:	"//	mov wa dname  point to end of memory",
	1770	:	"//	sub wa dnamp  subtract next location",
	1771	:	"//	btw wa   convert bytes to words",
	1772	:	"//	mti wa   convert words available as integer",
	1773	:	"//	sbi clsvi   subtract argument",
	1774	:	"//	iov exfal   fail if overflow",
	1775	:	"//	ilt exfal   fail if not enough",
	1776	:	"//	adi clsvi   else recompute available",
	1777	:	"//	brn exint   and exit with integer result",
	1778	:	"//	jsr gtstg   convert second argument to string",
	1779	:	"//	bze wa scv29  or if null string",
	1780	:	"//	mov xl (xs)  load first argument",
	1781	:	"//	bne (xl) =b_pdt scv01 jump if not program defined",
	1782	:	"//	mov xl pddfp(xl)  point to dfblk",
	1783	:	"//	mov xl dfnam(xl)  load datatype name",
	1784	:	"//	jsr ident   compare with second arg",
	1785	:	"//	brn exfal   else fail",
	1786	:	"//scv01	mov -(xs) xr  save string argument",
	1787	:	"//	mov xl =svctb  point to table of names to compare",
	1788	:	"//	zer wb   initialize counter",
	1789	:	"//	mov wc wa  save length of argument string",
	1790	:	"//scv02	mov xr (xl)+  load next table entry, bump pointer",
	1791	:	"//	bze xr exfal  fail if zero marking end of list",
	1792	:	"//	bne wc sclen(xr) scv05 jump if wrong length",
	1793	:	"//	mov cnvtp xl  else store table pointer",
	1794	:	"//	plc xr   point to chars of table entry",
	1795	:	"//	mov xl (xs)  load pointer to string argument",
	1796	:	"//	plc xl   point to chars of string arg",
	1797	:	"//	mov wa wc  set number of chars to compare",
	1798	:	"//	cmc scv04 scv04  compare, jump if no match",
	1799	:	"//scv03	mov xl wb  copy entry number",
	1800	:	"//	ica xs   pop string arg off stack",
	1801	:	"//	mov xr (xs)+  load first argument",
	1802	:	"//	bsw xl cnvtt  jump to appropriate routine",
	1803	:	"//scv04	mov xl cnvtp  restore table pointer, merge",
	1804	:	"//scv05	icv wb   bump entry number",
	1805	:	"//	brn scv02   loop back to check next entry",
	1806	:	"//scv06	mov -(xs) xr  replace string argument on stack",
	1807	:	"//	jsr gtstg   convert to string",
	1808	:	"//	mov -(xs) xr  stack result",
	1809	:	"//	lcw xr   get next code word",
	1810	:	"//	bri (xr)   execute it",
	1811	:	"//scv07	jsr gtint   convert to integer",
	1812	:	"//	mov -(xs) xr  stack result",
	1813	:	"//	lcw xr   get next code word",
	1814	:	"//	bri (xr)   execute it",
	1815	:	"//scv08	jsr gtrea   convert to real",
	1816	:	"//	mov -(xs) xr  stack result",
	1817	:	"//	lcw xr   get next code word",
	1818	:	"//	bri (xr)   execute it",
	1819	:	"//scv09	beq (xr) =b_nml exixr return if already a name",
	1820	:	"//	jsr gtnvr   else try string to name convert",
	1821	:	"//	brn exvnm   else exit building nmblk for vrblk",
	1822	:	"//scv10	jsr gtpat   convert to pattern",
	1823	:	"//	mov -(xs) xr  stack result",
	1824	:	"//	lcw xr   get next code word",
	1825	:	"//	bri (xr)   execute it",
	1826	:	"//scv11	mov -(xs) xr  save argument on stack",
	1827	:	"//	zer wa   use table chain block addresses",
	1828	:	"//	jsr gtarr   get an array",
	1829	:	"//	mov xl (xs)+  reload original arg",
	1830	:	"//	bne (xl) =b_tbt exsid exit if original not a table",
	1831	:	"//	mov -(xs) xr  sort the intermediate array",
	1832	:	"//	mov -(xs) =nulls  on first column",
	1833	:	"//	zer wa   sort ascending",
	1834	:	"//	jsr sorta   do sort",
	1835	:	"//	mov wb xr  save array result",
	1836	:	"//	ldi ardim(xr)   load dim 1 (number of elements)",
	1837	:	"//	mfi wa   get as one word integer",
	1838	:	"//	lct wa wa  copy to control loop",
	1839	:	"//	add xr *arvl2  point to first element in array",
	1840	:	"//scv12	mov xl (xr)  get teblk address",
	1841	:	"//	mov (xr)+ tesub(xl)  replace with subscript",
	1842	:	"//	mov (xr)+ teval(xl)  replace with value",
	1843	:	"//	bct wa scv12  loop till all copied over",
	1844	:	"//	mov xr wb  retrieve array address",
	1845	:	"//	brn exsid   exit setting id field",
	1846	:	"//scv19	mov wa (xr)  load first word of block",
	1847	:	"//	mov -(xs) xr  replace arblk pointer on stack",
	1848	:	"//	beq wa =b_tbt exits return arg if already a table",
	1849	:	"//	bne wa =b_art exfal else fail if not an array",
	1850	:	"//	bne arndm(xr) =num02 exfal fail if not 2-dim array",
	1851	:	"//	ldi ardm2(xr)   load dim 2",
	1852	:	"//	sbi 4,intv2   subtract 2 to compare",
	1853	:	"//	ine exfal   fail if dim2 not 2",
	1854	:	"//	ldi ardim(xr)   load dim 1 (number of elements)",
	1855	:	"//	mfi wa   get as one word integer",
	1856	:	"//	lct wb wa  copy to control loop",
	1857	:	"//	add wa =tbsi_  add space for standard fields",
	1858	:	"//	wtb wa   convert length to bytes",
	1859	:	"//	jsr alloc   allocate space for tbblk",
	1860	:	"//	mov wc xr  copy tbblk pointer",
	1861	:	"//	mov -(xs) xr  save tbblk pointer",
	1862	:	"//	mov (xr)+ =b_tbt  store type word",
	1863	:	"//	zer (xr)+   store zero for idval for now",
	1864	:	"//	mov (xr)+ wa  store length",
	1865	:	"//	mov (xr)+ =nulls  null initial lookup value",
	1866	:	"//scv20	mov (xr)+ wc  set bucket ptr to point to tbblk",
	1867	:	"//	bct wb scv20  loop till all initialized",
	1868	:	"//	mov wb *arvl2  set offset to first arblk element",
	1869	:	"//scv21	mov xl num01(xs)  point to arblk",
	1870	:	"//	beq wb arlen(xl) scv24 jump if all moved",
	1871	:	"//	add xl wb  else point to current location",
	1872	:	"//	add wb *num02  bump offset",
	1873	:	"//	mov xr (xl)  load subscript name",
	1874	:	"//	dca xl   adjust ptr to merge (trval=1+1)",
	1875	:	"//scv22	mov xl trval(xl)  point to next value",
	1876	:	"//	beq (xl) =b_trt scv22 loop back if trapped",
	1877	:	"//scv23	mov -(xs) xl  stack value",
	1878	:	"//	mov xl num01(xs)  load tbblk pointer",
	1879	:	"//	jsr tfind   build teblk (note wb gt 0 by name)",
	1880	:	"//	mov teval(xl) (xs)+  store value in teblk",
	1881	:	"//	brn scv21   loop back for next element",
	1882	:	"//scv24	mov xr (xs)+  load tbblk pointer",
	1883	:	"//	ica xs   pop arblk pointer",
	1884	:	"//	brn exsid   exit setting idval",
	1885	:	"//scv25	zer wb   by value",
	1886	:	"//	jsr gtexp   convert to expression",
	1887	:	"//	zer r_ccb   forget interim code block",
	1888	:	"//	mov -(xs) xr  stack result",
	1889	:	"//	lcw xr   get next code word",
	1890	:	"//	bri (xr)   execute it",
	1891	:	"//scv26	jsr gtcod   convert to code",
	1892	:	"//	zer r_ccb   forget interim code block",
	1893	:	"//	mov -(xs) xr  stack result",
	1894	:	"//	lcw xr   get next code word",
	1895	:	"//	bri (xr)   execute it",
	1896	:	"//scv27	jsr gtnum   convert to numeric",
	1897	:	"//scv31	mov -(xs) xr  stack result",
	1898	:	"//	lcw xr   get next code word",
	1899	:	"//	bri (xr)   execute it",
	1900	:	"//scv29	erb 074 convert second argument is not a string  ",
	1901	:	"//	jsr copyb   copy the block",
	1902	:	"//	brn exsid   exit setting id value",
	1903	:	"//	mov xr (xs)+  get argument",
	1904	:	"//	jsr gtrea   convert to real",
	1905	:	"//	ldr rcval(xr)   load accumulator with argument",
	1906	:	"//	cos    take cosine",
	1907	:	"//	rno exrea   if no overflow, return result in ra",
	1908	:	"//	erb 322 cos argument is out of range  ",
	1909	:	"//	jsr xscni   prepare to scan argument",
	1910	:	"//	mov wc =ch_pp  delimiter one = left paren",
	1911	:	"//	mov xl wc  delimiter two = left paren",
	1912	:	"//	mnz wa   skip/trim blanks in prototype",
	1913	:	"//	jsr xscan   scan datatype name",
	1914	:	"//	bnz wa sdat1  skip if left paren found",
	1915	:	"//	erb 077 data argument is missing a left paren  ",
	1916	:	"//sdat1	mov xl xr  save name ptr",
	1917	:	"//	mov wa sclen(xr)  get length",
	1918	:	"//	ctb wa scsi_  compute space needed",
	1919	:	"//	jsr alost   request static store for name",
	1920	:	"//	mov -(xs) xr  save datatype name",
	1921	:	"//	mvw    copy name to static",
	1922	:	"//	mov xr (xs)  get name ptr",
	1923	:	"//	zer xl   scrub dud register",
	1924	:	"//	jsr gtnvr   locate vrblk for datatype name",
	1925	:	"//	mov datdv xr  save vrblk pointer for datatype",
	1926	:	"//	mov datxs xs  store starting stack value",
	1927	:	"//	zer wb   zero count of field names",
	1928	:	"//sdat2	mov wc =ch_rp  delimiter one = right paren",
	1929	:	"//	mov xl =ch_cm  delimiter two = comma",
	1930	:	"//	mnz wa   skip/trim blanks in prototype",
	1931	:	"//	jsr xscan   scan next field name",
	1932	:	"//	bnz wa sdat3  jump if delimiter found",
	1933	:	"//	erb 079 data argument is missing a right paren  ",
	1934	:	"//sdat3	jsr gtnvr   locate vrblk for field name",
	1935	:	"//	mov -(xs) xr  stack vrblk pointer",
	1936	:	"//	icv wb   increment counter",
	1937	:	"//	beq wa =num02 sdat2 loop back if stopped by comma",
	1938	:	"//	mov wa =dfsi_  set size of dfblk standard fields",
	1939	:	"//	add wa wb  add number of fields",
	1940	:	"//	wtb wa   convert length to bytes",
	1941	:	"//	mov wc wb  preserve no. of fields",
	1942	:	"//	jsr alost   allocate space for dfblk",
	1943	:	"//	mov wb wc  get no of fields",
	1944	:	"//	mov xt datxs  point to start of stack",
	1945	:	"//	mov wc (xt)  load datatype name",
	1946	:	"//	mov (xt) xr  save dfblk pointer on stack",
	1947	:	"//	mov (xr)+ =b_dfc  store type word",
	1948	:	"//	mov (xr)+ wb  store number of fields (fargs)",
	1949	:	"//	mov (xr)+ wa  store length (dflen)",
	1950	:	"//	sub wa *pddfs  compute pdblk length (for dfpdl)",
	1951	:	"//	mov (xr)+ wa  store pdblk length (dfpdl)",
	1952	:	"//	mov (xr)+ wc  store datatype name (dfnam)",
	1953	:	"//	lct wc wb  copy number of fields",
	1954	:	"//sdat4	mov (xr)+ -(xt)  move one field name vrblk pointer",
	1955	:	"//	bct wc sdat4  loop till all moved",
	1956	:	"//	mov wc wa  copy length of pdblk for later loop",
	1957	:	"//	mov xr datdv  point to vrblk",
	1958	:	"//	mov xt datxs  point back on stack",
	1959	:	"//	mov xl (xt)  load dfblk pointer",
	1960	:	"//	jsr dffnc   define function",
	1961	:	"//sdat5	mov wa *ffsi_  set length of ffblk",
	1962	:	"//	jsr alloc   allocate space for ffblk",
	1963	:	"//	mov (xr) =b_ffc  set type word",
	1964	:	"//	mov fargs(xr) =num01  store fargs (always one)",
	1965	:	"//	mov xt datxs  point back on stack",
	1966	:	"//	mov ffdfp(xr) (xt)  copy dfblk ptr to ffblk",
	1967	:	"//	dca wc   decrement old dfpdl to get next ofs",
	1968	:	"//	mov ffofs(xr) wc  set offset to this field",
	1969	:	"//	zer ffnxt(xr)   tentatively set zero forward ptr",
	1970	:	"//	mov xl xr  copy ffblk pointer for dffnc",
	1971	:	"//	mov xr (xs)  load vrblk pointer for field",
	1972	:	"//	mov xr vrfnc(xr)  load current function pointer",
	1973	:	"//	bne (xr) =b_ffc sdat6 skip if not currently a field func",
	1974	:	"//	mov ffnxt(xl) xr  link new ffblk to previous chain",
	1975	:	"//sdat6	mov xr (xs)+  load vrblk pointer",
	1976	:	"//	jsr dffnc   define field function",
	1977	:	"//	bne xs datxs sdat5 loop back till all done",
	1978	:	"//	ica xs   pop dfblk pointer",
	1979	:	"//	brn exnul   return with null result",
	1980	:	"//	mov xr (xs)+  load argument",
	1981	:	"//	jsr dtype   get datatype",
	1982	:	"//	mov -(xs) xr  stack result",
	1983	:	"//	lcw xr   get next code word",
	1984	:	"//	bri (xr)   execute it",
	1985	:	"//	mov xr (xs)+  load argument",
	1986	:	"//	jsr gtint   convert to an integer",
	1987	:	"//	jsr sysdt   call system date routine",
	1988	:	"//	mov wa num01(xl)  load length for sbstr",
	1989	:	"//	bze wa exnul  return null if length is zero",
	1990	:	"//	zer wb   set zero offset",
	1991	:	"//	jsr sbstr   use sbstr to build scblk",
	1992	:	"//	mov -(xs) xr  stack result",
	1993	:	"//	lcw xr   get next code word",
	1994	:	"//	bri (xr)   execute it",
	1995	:	"//	mov xr (xs)+  load second argument",
	1996	:	"//	zer deflb   zero label pointer in case null",
	1997	:	"//	beq xr =nulls sdf01 jump if null second argument",
	1998	:	"//	jsr gtnvr   else find vrblk for label",
	1999	:	"//	mov deflb xr  else set specified entry",
	2000	:	"//sdf01	jsr xscni   prepare to scan first argument",
	2001	:	"//	mov wc =ch_pp  delimiter one = left paren",
	2002	:	"//	mov xl wc  delimiter two = left paren",
	2003	:	"//	mnz wa   skip/trim blanks in prototype",
	2004	:	"//	jsr xscan   scan out function name",
	2005	:	"//	bnz wa sdf02  jump if left paren found",
	2006	:	"//	erb 083 define first argument is missing a left paren  ",
	2007	:	"//sdf02	jsr gtnvr   get variable name",
	2008	:	"//	mov defvr xr  save vrblk pointer for function nam",
	2009	:	"//	zer wb   zero count of arguments",
	2010	:	"//	mov defxs xs  save initial stack pointer",
	2011	:	"//	bnz deflb sdf03  jump if second argument given",
	2012	:	"//	mov deflb xr  else default is function name",
	2013	:	"//sdf03	mov wc =ch_rp  delimiter one = right paren",
	2014	:	"//	mov xl =ch_cm  delimiter two = comma",
	2015	:	"//	mnz wa   skip/trim blanks in prototype",
	2016	:	"//	jsr xscan   scan out next argument name",
	2017	:	"//	bnz wa sdf04  skip if delimiter found",
	2018	:	"//	erb 085 null arg name or missing ) in define first arg.  ",
	2019	:	"//sdf04	bne xr =nulls sdf05 skip if non-null",
	2020	:	"//	bze wb sdf06  ignore null if case of no arguments",
	2021	:	"//sdf05	jsr gtnvr   get vrblk pointer",
	2022	:	"//	mov -(xs) xr  stack argument vrblk pointer",
	2023	:	"//	icv wb   increment counter",
	2024	:	"//	beq wa =num02 sdf03 loop back if stopped by a comma",
	2025	:	"//sdf06	mov defna wb  save number of arguments",
	2026	:	"//	zer wb   zero count of locals",
	2027	:	"//sdf07	mov wc =ch_cm  set delimiter one = comma",
	2028	:	"//	mov xl wc  set delimiter two = comma",
	2029	:	"//	mnz wa   skip/trim blanks in prototype",
	2030	:	"//	jsr xscan   scan out next local name",
	2031	:	"//	bne xr =nulls sdf08 skip if non-null",
	2032	:	"//	bze wa sdf09  exit scan if end of string",
	2033	:	"//sdf08	jsr gtnvr   get vrblk pointer",
	2034	:	"//	icv wb   if ok, increment count",
	2035	:	"//	mov -(xs) xr  stack vrblk pointer",
	2036	:	"//	bnz wa sdf07  loop back if stopped by a comma",
	2037	:	"//sdf09	mov wa wb  copy count of locals",
	2038	:	"//	add wa defna  add number of arguments",
	2039	:	"//	mov wc wa  set sum args+locals as loop count",
	2040	:	"//	add wa =pfsi_  add space for standard fields",
	2041	:	"//	wtb wa   convert length to bytes",
	2042	:	"//	jsr alloc   allocate space for pfblk",
	2043	:	"//	mov xl xr  save pointer to pfblk",
	2044	:	"//	mov (xr)+ =b_pfc  store first word",
	2045	:	"//	mov (xr)+ defna  store number of arguments",
	2046	:	"//	mov (xr)+ wa  store length (pflen)",
	2047	:	"//	mov (xr)+ defvr  store vrblk ptr for function name",
	2048	:	"//	mov (xr)+ wb  store number of locals",
	2049	:	"//	zer (xr)+   deal with label later",
	2050	:	"//	zer (xr)+   zero pfctr",
	2051	:	"//	zer (xr)+   zero pfrtr",
	2052	:	"//	bze wc sdf11  skip if no args or locals",
	2053	:	"//	mov wa xl  keep pfblk pointer",
	2054	:	"//	mov xt defxs  point before arguments",
	2055	:	"//	lct wc wc  get count of args+locals for loop",
	2056	:	"//sdf10	mov (xr)+ -(xt)  store one entry and bump pointers",
	2057	:	"//	bct wc sdf10  loop till all stored",
	2058	:	"//	mov xl wa  recover pfblk pointer",
	2059	:	"//sdf11	mov xs defxs  pop stack",
	2060	:	"//	mov pfcod(xl) deflb  store label vrblk in pfblk",
	2061	:	"//	mov xr defvr  point back to vrblk for function",
	2062	:	"//	jsr dffnc   define function",
	2063	:	"//	brn exnul   and exit returning null",
	2064	:	"//sdf12	erb 086 define function entry point is not defined label  ",
	2065	:	"//	mov xr (xs)+  load argument",
	2066	:	"//	jsr gtvar   locate variable",
	2067	:	"//	jsr dtach   detach i/o association from name",
	2068	:	"//	brn exnul   return null result",
	2069	:	"//	mov xr (xs)+  load second argument",
	2070	:	"//	mov xl (xs)+  load first argument",
	2071	:	"//	jsr ident   call ident comparison routine",
	2072	:	"//	brn exnul   return null if differ",
	2073	:	"//	jsr gtsmi   load dump arg as small integer",
	2074	:	"//	jsr dumpr   else call dump routine",
	2075	:	"//	brn exnul   and return null as result",
	2076	:	"//	jsr gtsmi   get second argument as small integr",
	2077	:	"//	mov wb xr  save duplication factor",
	2078	:	"//	jsr gtstg   get first arg as string",
	2079	:	"//	mti wa   acquire length as integer",
	2080	:	"//	sti dupsi   save for the moment",
	2081	:	"//	mti wb   get duplication factor as integer",
	2082	:	"//	mli dupsi   form product",
	2083	:	"//	iov sdup3   jump if overflow",
	2084	:	"//	ieq exnul   return null if result length = 0",
	2085	:	"//	mfi wa sdup3  get as addr integer, check ovflo",
	2086	:	"//sdup1	mov xl xr  save string pointer",
	2087	:	"//	jsr alocs   allocate space for string",
	2088	:	"//	mov -(xs) xr  save as result pointer",
	2089	:	"//	mov wc xl  save pointer to argument string",
	2090	:	"//	psc xr   prepare to store chars of result",
	2091	:	"//	lct wb wb  set counter to control loop",
	2092	:	"//sdup2	mov xl wc  point back to argument string",
	2093	:	"//	mov wa sclen(xl)  get number of characters",
	2094	:	"//	plc xl   point to chars in argument string",
	2095	:	"//	mvc    move characters to result string",
	2096	:	"//	bct wb sdup2  loop till all duplications done",
	2097	:	"//	zer xl   clear garbage value",
	2098	:	"//	lcw xr   get next code word",
	2099	:	"//	bri (xr)   execute next code word",
	2100	:	"//sdup3	mov wa dname  set impossible length for alocs",
	2101	:	"//	brn sdup1   merge back",
	2102	:	"//sdup4	jsr gtpat   convert argument to pattern",
	2103	:	"//	mov -(xs) xr  store pattern on stack",
	2104	:	"//	mov xr =ndnth  start off with null pattern",
	2105	:	"//	bze wb sdup6  null pattern is result if dupfac=0",
	2106	:	"//	mov -(xs) wb  preserve loop count",
	2107	:	"//sdup5	mov xl xr  copy current value as right argumnt",
	2108	:	"//	mov xr num01(xs)  get a new copy of left",
	2109	:	"//	jsr pconc   concatenate",
	2110	:	"//	dcv (xs)   count down",
	2111	:	"//	bnz (xs) sdup5  loop",
	2112	:	"//	ica xs   pop loop count",
	2113	:	"//sdup6	mov (xs) xr  store result on stack",
	2114	:	"//	lcw xr   get next code word",
	2115	:	"//	bri (xr)   execute next code word",
	2116	:	"//sdup7	ica xs   pop first argument",
	2117	:	"//	brn exfal   fail",
	2118	:	"//	jsr iofcb   call fcblk routine",
	2119	:	"//	jsr sysef   call eject file function",
	2120	:	"//	brn exnul   return null as result",
	2121	:	"//sejc1	jsr sysep   call routine to eject printer",
	2122	:	"//	brn exnul   exit with null result",
	2123	:	"//	jsr iofcb   call fcblk routine",
	2124	:	"//	jsr sysen   call endfile routine",
	2125	:	"//	mov wb xl  remember vrblk ptr from iofcb call",
	2126	:	"//	mov xr xl  copy pointer",
	2127	:	"//senf1	mov xl xr  remember previous entry",
	2128	:	"//	mov xr trval(xr)  chain along",
	2129	:	"//	bne (xr) =b_trt exnul skip out if chain end",
	2130	:	"//	bne trtyp(xr) =trtfc senf1 loop if not found",
	2131	:	"//	mov trval(xl) trval(xr)  remove trtrf",
	2132	:	"//	mov enfch trtrf(xr)  point to head of iochn",
	2133	:	"//	mov wc trfpt(xr)  point to fcblk",
	2134	:	"//	mov xr wb  filearg1 vrblk from iofcb",
	2135	:	"//	jsr setvr   reset it",
	2136	:	"//	mov xl =r_fcb  ptr to head of fcblk chain",
	2137	:	"//	sub xl *num02  adjust ready to enter loop",
	2138	:	"//senf2	mov xr xl  copy ptr",
	2139	:	"//	mov xl num02(xl)  get next link",
	2140	:	"//	bze xl senf4  stop if chain end",
	2141	:	"//	beq num03(xl) wc senf3 jump if fcblk found",
	2142	:	"//	brn senf2   loop",
	2143	:	"//senf3	mov num02(xr) num02(xl)  delete fcblk from chain",
	2144	:	"//senf4	mov xl enfch  get chain head",
	2145	:	"//	bze xl exnul  finished if chain end",
	2146	:	"//	mov enfch trtrf(xl)  chain along",
	2147	:	"//	mov wa ionmo(xl)  name offset",
	2148	:	"//	mov xl ionmb(xl)  name base",
	2149	:	"//	jsr dtach   detach name",
	2150	:	"//	brn senf4   loop till done",
	2151	:	"//	jsr acomp   call arithmetic comparison routine",
	2152	:	"//	mov xr (xs)+  load argument",
	2153	:	"//	lcw wc   load next code word",
	2154	:	"//	bne wc =ofne_ sevl1 jump if called by value",
	2155	:	"//	scp xl   copy code pointer",
	2156	:	"//	mov wa (xl)  get next code word",
	2157	:	"//	bne wa =ornm_ sevl2 by name unless expression",
	2158	:	"//	bnz num01(xs) sevl2  jump if by name",
	2159	:	"//sevl1	zer wb   set flag for by value",
	2160	:	"//	mov -(xs) wc  save code word",
	2161	:	"//	jsr gtexp   convert to expression",
	2162	:	"//	zer r_ccb   forget interim code block",
	2163	:	"//	zer wb   set flag for by value",
	2164	:	"//	jsr evalx   evaluate expression by value",
	2165	:	"//	mov xl xr  copy result",
	2166	:	"//	mov xr (xs)  reload next code word",
	2167	:	"//	mov (xs) xl  stack result",
	2168	:	"//	bri (xr)   jump to execute next code word",
	2169	:	"//sevl2	mov wb =num01  set flag for by name",
	2170	:	"//	jsr gtexp   convert to expression",
	2171	:	"//	zer r_ccb   forget interim code block",
	2172	:	"//	mov wb =num01  set flag for by name",
	2173	:	"//	jsr evalx   evaluate expression by name",
	2174	:	"//	brn exnam   exit with name",
	2175	:	"//	zer wb   clear amount of static shift",
	2176	:	"//	zer r_ccb   forget interim code block",
	2177	:	"//	zer dnams   collect sediment too",
	2178	:	"//	jsr gbcol   compact memory by collecting",
	2179	:	"//	mov dnams xr  record new sediment size",
	2180	:	"//	jsr gtstg   ",
	2181	:	"//	mov xl xr  copy second arg string pointer",
	2182	:	"//	jsr gtstg   convert arg to string",
	2183	:	"//	mov -(xs) xl  save second argument",
	2184	:	"//	mov xl xr  copy first arg string ptr",
	2185	:	"//	jsr gtint   check it is integer",
	2186	:	"//	zer xl   note it is integer",
	2187	:	"//	ldi icval(xr)   get integer arg",
	2188	:	"//sext1	mov wb r_fcb  get fcblk chain header",
	2189	:	"//	mov xr =headv  point to v.v string",
	2190	:	"//	mov wa (xs)+  provide second argument scblk",
	2191	:	"//	jsr sysxi   call external routine",
	2192	:	"//	ieq exnul   return if argument 0",
	2193	:	"//	igt sext2   skip if positive",
	2194	:	"//	ngi    make positive",
	2195	:	"//sext2	mfi wc   get value in work reg",
	2196	:	"//	add wa wc  prepare to test for continue",
	2197	:	"//	beq wa =num05 sext5 continued execution if 4 plus 1",
	2198	:	"//	zer gbcnt   resuming execution so reset",
	2199	:	"//	bge wc =num03 sext3 skip if was 3 or 4",
	2200	:	"//	mov -(xs) wc  save value",
	2201	:	"//	zer wc   set to read options",
	2202	:	"//	jsr prpar   read syspp options",
	2203	:	"//	mov wc (xs)+  restore value",
	2204	:	"//sext3	mnz headp   assume no headers",
	2205	:	"//	bne wc =num01 sext4 skip if not 1",
	2206	:	"//	zer headp   request header printing",
	2207	:	"//sext4	jsr systm   get execution time start (sgd11)",
	2208	:	"//	sti timsx   save as initial time",
	2209	:	"//	ldi kvstc   reset to ensure ...",
	2210	:	"//	sti kvstl   ... correct execution stats",
	2211	:	"//	jsr stgcc   recompute countdown counters",
	2212	:	"//	brn exnul   resume execution",
	2213	:	"//sext5	mov xr =inton  integer one",
	2214	:	"//	brn exixr   return as result",
	2215	:	"//	mov xr (xs)+  get argument",
	2216	:	"//	jsr gtrea   convert to real",
	2217	:	"//	ldr rcval(xr)   load accumulator with argument",
	2218	:	"//	etx    take exponential",
	2219	:	"//	rno exrea   if no overflow, return result in ra",
	2220	:	"//	erb 305 exp produced real overflow  ",
	2221	:	"//	jsr gtsmi   get second argument (field number)",
	2222	:	"//	mov wb xr  else save integer value",
	2223	:	"//	mov xr (xs)+  load first argument",
	2224	:	"//	jsr gtnvr   point to vrblk",
	2225	:	"//	mov xr vrfnc(xr)  else point to function block",
	2226	:	"//	bne (xr) =b_dfc sfld1 error if not datatype function",
	2227	:	"//	bze wb exfal  fail if argument number is zero",
	2228	:	"//	bgt wb fargs(xr) exfal fail if too large",
	2229	:	"//	wtb wb   else convert to byte offset",
	2230	:	"//	add xr wb  point to field name",
	2231	:	"//	mov xr dfflb(xr)  load vrblk pointer",
	2232	:	"//	brn exvnm   exit to build nmblk",
	2233	:	"//sfld1	erb 108 field first argument is not datatype name  ",
	2234	:	"//	mov wb =p_fnc  set pcode for p_fnc",
	2235	:	"//	zer xr   p0blk",
	2236	:	"//	jsr pbild   build p_fnc node",
	2237	:	"//	mov xl xr  save pointer to it",
	2238	:	"//	mov xr (xs)+  get argument",
	2239	:	"//	jsr gtpat   convert to pattern",
	2240	:	"//	jsr pconc   concatenate to p_fnc node",
	2241	:	"//	mov xl xr  save ptr to concatenated pattern",
	2242	:	"//	mov wb =p_fna  set for p_fna pcode",
	2243	:	"//	zer xr   p0blk",
	2244	:	"//	jsr pbild   construct p_fna node",
	2245	:	"//	mov pthen(xr) xl  set pattern as pthen",
	2246	:	"//	mov -(xs) xr  set as result",
	2247	:	"//	lcw xr   get next code word",
	2248	:	"//	bri (xr)   execute next code word",
	2249	:	"//	jsr acomp   call arithmetic comparison routine",
	2250	:	"//	jsr acomp   call arithmetic comparison routine",
	2251	:	"//	mov wc (xs)+  get fifth arg",
	2252	:	"//	mov wb (xs)+  get fourth arg",
	2253	:	"//	mov xr (xs)+  get third arg",
	2254	:	"//	mov xl (xs)+  get second arg",
	2255	:	"//	mov wa (xs)+  get first arg",
	2256	:	"//	jsr syshs   enter syshs routine",
	2257	:	"//shst1	bze xl exnul  null string if syshs uncooperative",
	2258	:	"//	mov wa sclen(xl)  length",
	2259	:	"//	zer wb   zero offset",
	2260	:	"//shst2	jsr sbstr   build copy of string",
	2261	:	"//	mov -(xs) xr  stack the result",
	2262	:	"//	lcw xr   load next code word",
	2263	:	"//	bri (xr)   execute it",
	2264	:	"//shst3	zer wb   treat xl like an scblk ptr",
	2265	:	"//	sub wb =cfp_f  by creating a negative offset",
	2266	:	"//	brn shst2   join to copy string",
	2267	:	"//shst4	mov -(xs) xr  stack results",
	2268	:	"//	jsr copyb   make copy of block",
	2269	:	"//	brn exsid   set current id value otherwise",
	2270	:	"//	mov xr (xs)+  load second argument",
	2271	:	"//	mov xl (xs)+  load first argument",
	2272	:	"//	jsr ident   call ident comparison routine",
	2273	:	"//	brn exfal   fail if differ",
	2274	:	"//	zer wb   input flag",
	2275	:	"//	jsr ioput   call input/output assoc. routine",
	2276	:	"//	brn exnul   return null string",
	2277	:	"//	mov xr (xs)+  load argument",
	2278	:	"//	jsr gtnum   convert to numeric",
	2279	:	"//	beq wa =b_icl exnul return null if integer",
	2280	:	"//	brn exfal   fail if real",
	2281	:	"//	bnz wa sitm1  jump if at least one arg",
	2282	:	"//	mov -(xs) =nulls  else supply garbage null arg",
	2283	:	"//	mov wa =num01  and fix argument count",
	2284	:	"//sitm1	scp xr   get current code pointer",
	2285	:	"//	mov xl (xr)  load next code word",
	2286	:	"//	dcv wa   get number of subscripts",
	2287	:	"//	mov xr wa  copy for arref",
	2288	:	"//	beq xl =ofne_ sitm2 jump if called by name",
	2289	:	"//	zer wb   set code for call by value",
	2290	:	"//	brn arref   off to array reference routine",
	2291	:	"//sitm2	mnz wb   set code for call by name",
	2292	:	"//	lcw wa   load and ignore ofne_ call",
	2293	:	"//	brn arref   off to array reference routine",
	2294	:	"//	jsr acomp   call arithmetic comparison routine",
	2295	:	"//	mov wb =p_len  set pcode for integer arg case",
	2296	:	"//	mov wa =p_lnd  set pcode for expr arg case",
	2297	:	"//	jsr patin   call common routine to build node",
	2298	:	"//	mov -(xs) xr  stack result",
	2299	:	"//	lcw xr   get next code word",
	2300	:	"//	bri (xr)   execute it",
	2301	:	"//	jsr lcomp   call string comparison routine",
	2302	:	"//	jsr lcomp   call string comparison routine",
	2303	:	"//	jsr lcomp   call string comparison routine",
	2304	:	"//	jsr lcomp   call string comparison routine",
	2305	:	"//	jsr lcomp   call string comparison routine",
	2306	:	"//	jsr lcomp   call string comparison routine",
	2307	:	"//	mov xr (xs)+  get argument",
	2308	:	"//	jsr gtrea   convert to real",
	2309	:	"//	ldr rcval(xr)   load accumulator with argument",
	2310	:	"//	req slnf1   overflow if argument is 0",
	2311	:	"//	rlt slnf2   error if argument less than 0",
	2312	:	"//	lnf    take natural logarithm",
	2313	:	"//	rno exrea   if no overflow, return result in ra",
	2314	:	"//slnf1	erb 307 ln produced real overflow  ",
	2315	:	"//slnf2	erb 315 ln argument negative  ",
	2316	:	"//	jsr gtsmi   get second argument (local number)",
	2317	:	"//	mov wb xr  save local number",
	2318	:	"//	mov xr (xs)+  load first argument",
	2319	:	"//	jsr gtnvr   point to vrblk",
	2320	:	"//	mov xr vrfnc(xr)  else load function pointer",
	2321	:	"//	bne (xr) =b_pfc sloc1 jump if not program defined",
	2322	:	"//	bze wb exfal  fail if second arg is zero",
	2323	:	"//	bgt wb pfnlo(xr) exfal or too large",
	2324	:	"//	add wb fargs(xr)  else adjust offset to include args",
	2325	:	"//	wtb wb   convert to bytes",
	2326	:	"//	add xr wb  point to local pointer",
	2327	:	"//	mov xr pfagb(xr)  load vrblk pointer",
	2328	:	"//	brn exvnm   exit building nmblk",
	2329	:	"//sloc1	erb 135 local first arg is not a program function name  ",
	2330	:	"//	jsr gtstg   load library name",
	2331	:	"//	mov xl xr  save library name",
	2332	:	"//	jsr xscni   prepare to scan first argument",
	2333	:	"//	mov -(xs) xl  stack library name",
	2334	:	"//	mov wc =ch_pp  set delimiter one = left paren",
	2335	:	"//	mov xl wc  set delimiter two = left paren",
	2336	:	"//	mnz wa   skip/trim blanks in prototype",
	2337	:	"//	jsr xscan   scan function name",
	2338	:	"//	mov -(xs) xr  save ptr to function name",
	2339	:	"//	bnz wa slod1  jump if left paren found",
	2340	:	"//	erb 139 load first argument is missing a left paren  ",
	2341	:	"//slod1	jsr gtnvr   locate vrblk",
	2342	:	"//	mov lodfn xr  save vrblk pointer",
	2343	:	"//	zer lodna   zero count of arguments",
	2344	:	"//slod2	mov wc =ch_rp  delimiter one is right paren",
	2345	:	"//	mov xl =ch_cm  delimiter two is comma",
	2346	:	"//	mnz wa   skip/trim blanks in prototype",
	2347	:	"//	jsr xscan   scan next argument name",
	2348	:	"//	icv lodna   bump argument count",
	2349	:	"//	bnz wa slod3  jump if ok delimiter was found",
	2350	:	"//	erb 141 load first argument is missing a right paren  ",
	2351	:	"//slod3	mov -(xs) xr  stack datatype name pointer",
	2352	:	"//	mov wb =num01  set string code in case",
	2353	:	"//	mov xl =scstr  point to /string/",
	2354	:	"//	jsr ident   check for match",
	2355	:	"//	mov xr (xs)  else reload name",
	2356	:	"//	add wb wb  set code for integer (2)",
	2357	:	"//	mov xl =scint  point to /integer/",
	2358	:	"//	jsr ident   check for match",
	2359	:	"//	mov xr (xs)  else reload string pointer",
	2360	:	"//	icv wb   set code for real (3)",
	2361	:	"//	mov xl =screa  point to /real/",
	2362	:	"//	jsr ident   check for match",
	2363	:	"//	mov xr (xs)  reload string pointer",
	2364	:	"//	icv wb   code for file (4, or 3 if no reals)",
	2365	:	"//	mov xl =scfil  point to /file/",
	2366	:	"//	jsr ident   check for match",
	2367	:	"//	zer wb   else get code for no convert",
	2368	:	"//slod4	mov (xs) wb  store code on stack",
	2369	:	"//	beq wa =num02 slod2 loop back if arg stopped by comma",
	2370	:	"//	bze wa slod5  jump if that was the result type",
	2371	:	"//	mov wc mxlen  set dummy (impossible) delimiter 1",
	2372	:	"//	mov xl wc  and delimiter two",
	2373	:	"//	mnz wa   skip/trim blanks in prototype",
	2374	:	"//	jsr xscan   scan result name",
	2375	:	"//	zer wa   set code for processing result",
	2376	:	"//	brn slod3   jump back to process result name",
	2377	:	"//slod5	mov wa lodna  get number of arguments",
	2378	:	"//	mov wc wa  copy for later",
	2379	:	"//	wtb wa   convert length to bytes",
	2380	:	"//	add wa *efsi_  add space for standard fields",
	2381	:	"//	jsr alloc   allocate efblk",
	2382	:	"//	mov (xr) =b_efc  set type word",
	2383	:	"//	mov fargs(xr) wc  set number of arguments",
	2384	:	"//	zer efuse(xr)   set use count (dffnc will set to 1)",
	2385	:	"//	zer efcod(xr)   zero code pointer for now",
	2386	:	"//	mov efrsl(xr) (xs)+  store result type code",
	2387	:	"//	mov efvar(xr) lodfn  store function vrblk pointer",
	2388	:	"//	mov eflen(xr) wa  store efblk length",
	2389	:	"//	mov wb xr  save efblk pointer",
	2390	:	"//	add xr wa  point past end of efblk",
	2391	:	"//	lct wc wc  set number of arguments for loop",
	2392	:	"//slod6	mov -(xr) (xs)+  store one type code from stack",
	2393	:	"//	bct wc slod6  loop till all stored",
	2394	:	"//	mov xr (xs)+  load function string name",
	2395	:	"//	mov xl (xs)  load library name",
	2396	:	"//	mov (xs) wb  store efblk pointer",
	2397	:	"//	jsr sysld   call function to load external func",
	2398	:	"//	mov xl (xs)+  recall efblk pointer",
	2399	:	"//	mov efcod(xl) xr  store code pointer",
	2400	:	"//	mov xr lodfn  point to vrblk for function",
	2401	:	"//	jsr dffnc   perform function definition",
	2402	:	"//	brn exnul   return null result",
	2403	:	"//	jsr gtstg   get pad character",
	2404	:	"//	plc xr   point to character (null is blank)",
	2405	:	"//	lch wb (xr)  load pad character",
	2406	:	"//	jsr gtsmi   get pad length",
	2407	:	"//slpd1	jsr gtstg   get first argument (string to pad)",
	2408	:	"//	bge wa wc exixr return 1st arg if too long to pad",
	2409	:	"//	mov xl xr  else move ptr to string to pad",
	2410	:	"//	mov wa wc  copy length",
	2411	:	"//	jsr alocs   allocate scblk for new string",
	2412	:	"//	mov -(xs) xr  save as result",
	2413	:	"//	mov wa sclen(xl)  load length of argument",
	2414	:	"//	sub wc wa  calculate number of pad characters",
	2415	:	"//	psc xr   point to chars in result string",
	2416	:	"//	lct wc wc  set counter for pad loop",
	2417	:	"//slpd2	sch wb (xr)+  store pad character, bump ptr",
	2418	:	"//	bct wc slpd2  loop till all pad chars stored",
	2419	:	"//	csc xr   complete store characters",
	2420	:	"//	bze wa slpd3  exit if null string",
	2421	:	"//	plc xl   else point to chars in argument",
	2422	:	"//	mvc    move characters to result string",
	2423	:	"//	zer xl   clear garbage xl",
	2424	:	"//slpd3	lcw xr   load next code word",
	2425	:	"//	bri (xr)   execute it",
	2426	:	"//slpd4	zer wc   zero pad count",
	2427	:	"//	brn slpd1   merge",
	2428	:	"//	jsr acomp   call arithmetic comparison routine",
	2429	:	"//	jsr acomp   call arithmetic comparison routine",
	2430	:	"//	mov wb =p_nas  set pcode for single char arg",
	2431	:	"//	mov xl =p_nay  pcode for multi-char arg",
	2432	:	"//	mov wc =p_nad  set pcode for expr arg",
	2433	:	"//	jsr patst   call common routine to build node",
	2434	:	"//	mov -(xs) xr  stack result",
	2435	:	"//	lcw xr   get next code word",
	2436	:	"//	bri (xr)   execute it",
	2437	:	"//	jsr gtsmi   load third argument",
	2438	:	"//	mov wb wc  if ok, save third argumnet",
	2439	:	"//	mov xr (xs)+  load second argument",
	2440	:	"//	jsr gtnvr   locate variable block",
	2441	:	"//	mov xl vrfnc(xr)  if ok, load function block pointer",
	2442	:	"//	bnz wb sops2  jump if operator opsyn case",
	2443	:	"//	mov xr (xs)+  load first argument",
	2444	:	"//	jsr gtnvr   get vrblk pointer",
	2445	:	"//sops1	jsr dffnc   call function definer",
	2446	:	"//	brn exnul   exit with null result",
	2447	:	"//sops2	jsr gtstg   get operator name",
	2448	:	"//	bne wa =num01 sops5 error if not one char long",
	2449	:	"//	plc xr   else point to character",
	2450	:	"//	lch wc (xr)  load character name",
	2451	:	"//	mov wa =r_uub  point to unop pointers in case",
	2452	:	"//	mov xr =opnsu  point to names of unary operators",
	2453	:	"//	add wb =opbun  add no. of undefined binary ops",
	2454	:	"//	beq wb =opuun sops3 jump if unop (third arg was 1)",
	2455	:	"//	mov wa =r_uba  else point to binary operator ptrs",
	2456	:	"//	mov xr =opsnb  point to names of binary operators",
	2457	:	"//	mov wb =opbun  set number of undefined binops",
	2458	:	"//sops3	lct wb wb  set counter to control loop",
	2459	:	"//sops4	beq wc (xr) sops6 jump if names match",
	2460	:	"//	ica wa   else push pointer to function ptr",
	2461	:	"//	ica xr   bump pointer",
	2462	:	"//	bct wb sops4  loop back till all checked",
	2463	:	"//sops5	erb 156 opsyn first arg is not correct operator name  ",
	2464	:	"//sops6	mov xr wa  copy pointer to function block ptr",
	2465	:	"//	sub xr *vrfnc  make it look like dummy vrblk",
	2466	:	"//	brn sops1   merge back to define operator",
	2467	:	"//	mov wb =num03  output flag",
	2468	:	"//	jsr ioput   call input/output assoc. routine",
	2469	:	"//	brn exnul   return null string",
	2470	:	"//	mov wb =p_pos  set pcode for integer arg case",
	2471	:	"//	mov wa =p_psd  set pcode for expression arg case",
	2472	:	"//	jsr patin   call common routine to build node",
	2473	:	"//	mov -(xs) xr  stack result",
	2474	:	"//	lcw xr   get next code word",
	2475	:	"//	bri (xr)   execute it",
	2476	:	"//	mov xr (xs)+  load argument",
	2477	:	"//	mov wb tblen(xr)  length if table, vector (=vclen)",
	2478	:	"//	btw wb   convert to words",
	2479	:	"//	mov wa (xr)  load type word of argument block",
	2480	:	"//	beq wa =b_art spro4 jump if array",
	2481	:	"//	beq wa =b_tbt spro1 jump if table",
	2482	:	"//	beq wa =b_vct spro3 jump if vector",
	2483	:	"//	erb 164 prototype argument is not valid object  ",
	2484	:	"//spro1	sub wb =tbsi_  subtract standard fields",
	2485	:	"//spro2	mti wb   convert to integer",
	2486	:	"//	brn exint   exit with integer result",
	2487	:	"//spro3	sub wb =vcsi_  subtract standard fields",
	2488	:	"//	brn spro2   merge",
	2489	:	"//spro4	add xr arofs(xr)  point to prototype field",
	2490	:	"//	mov xr (xr)  load prototype",
	2491	:	"//	mov -(xs) xr  stack result",
	2492	:	"//	lcw xr   get next code word",
	2493	:	"//	bri (xr)   execute it",
	2494	:	"//	jsr arith   get two integers or two reals",
	2495	:	"//	zer wb   set positive flag",
	2496	:	"//	ldi icval(xr)   load left argument value",
	2497	:	"//	ige srm01   jump if positive",
	2498	:	"//	mnz wb   set negative flag",
	2499	:	"//srm01	rmi icval(xl)   get remainder",
	2500	:	"//	iov srm05   error if overflow",
	2501	:	"//	bze wb srm03  if result should be positive",
	2502	:	"//	ile exint   if should be negative, and is",
	2503	:	"//srm02	ngi    adjust sign of result",
	2504	:	"//	brn exint   return result",
	2505	:	"//srm03	ilt srm02   should be pos, and result negative",
	2506	:	"//	brn exint   should be positive, and is",
	2507	:	"//srm04	erb 166 remdr first argument is not numeric  ",
	2508	:	"//srm05	erb 167 remdr caused integer overflow  ",
	2509	:	"//srm06	zer wb   set positive flag",
	2510	:	"//	ldr rcval(xr)   load left argument value",
	2511	:	"//	rge srm07   jump if positive",
	2512	:	"//	mnz wb   set negative flag",
	2513	:	"//srm07	dvr rcval(xl)   compute n1/n2",
	2514	:	"//	rov srm10   jump if overflow",
	2515	:	"//	chp    chop result",
	2516	:	"//	mlr rcval(xl)   times n2",
	2517	:	"//	sbr rcval(xr)   compute difference",
	2518	:	"//	bze wb srm09  if result should be positive",
	2519	:	"//	rle exrea   if should be negative, and is",
	2520	:	"//srm08	ngr    adjust sign of result",
	2521	:	"//	brn exrea   return result",
	2522	:	"//srm09	rlt srm08   should be pos, and result negative",
	2523	:	"//	brn exrea   should be positive, and is",
	2524	:	"//srm10	erb 312 remdr caused real overflow  ",
	2525	:	"//	jsr gtstg   load third argument as string",
	2526	:	"//	mov xl xr  save third arg ptr",
	2527	:	"//	jsr gtstg   get second argument",
	2528	:	"//	bne xr r_ra2 srpl1 jump if 2nd argument different",
	2529	:	"//	beq xl r_ra3 srpl4 jump if args same as last time",
	2530	:	"//srpl1	mov wb sclen(xl)  load 3rd argument length",
	2531	:	"//	bne wa wb srpl6 jump if arguments not same length",
	2532	:	"//	beq xr kvalp srpl5 jump if 2nd arg is alphabet string",
	2533	:	"//	bze wb srpl6  jump if null 2nd argument",
	2534	:	"//	mov r_ra3 xl  save third arg for next time in",
	2535	:	"//	mov r_ra2 xr  save second arg for next time in",
	2536	:	"//	mov xl kvalp  point to alphabet string",
	2537	:	"//	mov wa sclen(xl)  load alphabet scblk length",
	2538	:	"//	mov xr r_rpt  point to current table (if any)",
	2539	:	"//	bnz xr srpl2  jump if we already have a table",
	2540	:	"//	jsr alocs   allocate new table",
	2541	:	"//	mov wa wc  keep scblk length",
	2542	:	"//	mov r_rpt xr  save table pointer for next time",
	2543	:	"//srpl2	ctb wa scsi_  compute length of scblk",
	2544	:	"//	mvw    copy to get initial table values",
	2545	:	"//	mov xl r_ra2  point to second argument",
	2546	:	"//	lct wb wb  number of chars to plug",
	2547	:	"//	zer wc   zero char offset",
	2548	:	"//	mov xr r_ra3  point to 3rd arg",
	2549	:	"//	plc xr   get char ptr for 3rd arg",
	2550	:	"//srpl3	mov xl r_ra2  point to 2nd arg",
	2551	:	"//	plc xl wc  point to next char",
	2552	:	"//	icv wc   increment offset",
	2553	:	"//	lch wa (xl)  get next char",
	2554	:	"//	mov xl r_rpt  point to translate table",
	2555	:	"//	psc xl wa  convert char to offset into table",
	2556	:	"//	lch wa (xr)+  get translated char",
	2557	:	"//	sch wa (xl)  store in table",
	2558	:	"//	csc xl   complete store characters",
	2559	:	"//	bct wb srpl3  loop till done",
	2560	:	"//srpl4	mov xl r_rpt  replace table to use",
	2561	:	"//srpl5	jsr gtstg   get first argument",
	2562	:	"//	bze wa exnul  return null if null argument",
	2563	:	"//	mov -(xs) xl  stack replace table to use",
	2564	:	"//	mov xl xr  copy pointer",
	2565	:	"//	mov wc wa  save length",
	2566	:	"//	ctb wa schar  get scblk length",
	2567	:	"//	jsr alloc   allocate space for copy",
	2568	:	"//	mov wb xr  save address of copy",
	2569	:	"//	mvw    move scblk contents to copy",
	2570	:	"//	mov xr (xs)+  unstack replace table",
	2571	:	"//	plc xr   point to chars of table",
	2572	:	"//	mov xl wb  point to string to translate",
	2573	:	"//	plc xl   point to chars of string",
	2574	:	"//	mov wa wc  set number of chars to translate",
	2575	:	"//	trc    perform translation",
	2576	:	"//srpl8	mov -(xs) wb  stack result",
	2577	:	"//	lcw xr   load next code word",
	2578	:	"//	bri (xr)   execute it",
	2579	:	"//srpl6	erb 171 null or unequally long 2nd, 3rd args to replace  ",
	2580	:	"//	jsr iofcb   call fcblk routine",
	2581	:	"//	jsr sysrw   call system rewind function",
	2582	:	"//	brn exnul   exit with null result if no error",
	2583	:	"//	jsr gtstg   load string argument",
	2584	:	"//	bze wa exixr  return argument if null",
	2585	:	"//	mov xl xr  else save pointer to string arg",
	2586	:	"//	jsr alocs   allocate space for new scblk",
	2587	:	"//	mov -(xs) xr  store scblk ptr on stack as result",
	2588	:	"//	psc xr   prepare to store in new scblk",
	2589	:	"//	plc xl wc  point past last char in argument",
	2590	:	"//	lct wc wc  set loop counter",
	2591	:	"//srvs1	lch wb -(xl)  load next char from argument",
	2592	:	"//	sch wb (xr)+  store in result",
	2593	:	"//	bct wc srvs1  loop till all moved",
	2594	:	"//srvs4	csc xr   complete store characters",
	2595	:	"//	zer xl   clear garbage xl",
	2596	:	"//srvs2	lcw xr   load next code word",
	2597	:	"//	bri (xr)   execute it",
	2598	:	"//	jsr gtstg   get pad character",
	2599	:	"//	plc xr   point to character (null is blank)",
	2600	:	"//	lch wb (xr)  load pad character",
	2601	:	"//	jsr gtsmi   get pad length",
	2602	:	"//srpd1	jsr gtstg   get first argument (string to pad)",
	2603	:	"//	bge wa wc exixr return 1st arg if too long to pad",
	2604	:	"//	mov xl xr  else move ptr to string to pad",
	2605	:	"//	mov wa wc  copy length",
	2606	:	"//	jsr alocs   allocate scblk for new string",
	2607	:	"//	mov -(xs) xr  save as result",
	2608	:	"//	mov wa sclen(xl)  load length of argument",
	2609	:	"//	sub wc wa  calculate number of pad characters",
	2610	:	"//	psc xr   point to chars in result string",
	2611	:	"//	lct wc wc  set counter for pad loop",
	2612	:	"//	bze wa srpd2  jump if argument is null",
	2613	:	"//	plc xl   else point to argument chars",
	2614	:	"//	mvc    move characters to result string",
	2615	:	"//	zer xl   clear garbage xl",
	2616	:	"//srpd2	sch wb (xr)+  store pad character, bump ptr",
	2617	:	"//	bct wc srpd2  loop till all pad chars stored",
	2618	:	"//	csc xr   complete character storing",
	2619	:	"//	lcw xr   load next code word",
	2620	:	"//	bri (xr)   execute it",
	2621	:	"//srpd3	zer wc   zero pad count",
	2622	:	"//	brn srpd1   merge",
	2623	:	"//	mov wb =p_rtb  set pcode for integer arg case",
	2624	:	"//	mov wa =p_rtd  set pcode for expression arg case",
	2625	:	"//	jsr patin   call common routine to build node",
	2626	:	"//	mov -(xs) xr  stack result",
	2627	:	"//	lcw xr   get next code word",
	2628	:	"//	bri (xr)   execute it",
	2629	:	"//	mov r_io2 (xs)+  save third arg (whence)",
	2630	:	"//	mov r_io1 (xs)+  save second arg (offset)",
	2631	:	"//	jsr iofcb   call fcblk routine",
	2632	:	"//	mov wb r_io1  load second arg",
	2633	:	"//	mov wc r_io2  load third arg",
	2634	:	"//	jsr sysst   call system set routine",
	2635	:	"//	brn exint   otherwise return position",
	2636	:	"//	mov wb =p_tab  set pcode for integer arg case",
	2637	:	"//	mov wa =p_tbd  set pcode for expression arg case",
	2638	:	"//	jsr patin   call common routine to build node",
	2639	:	"//	mov -(xs) xr  stack result",
	2640	:	"//	lcw xr   get next code word",
	2641	:	"//	bri (xr)   execute it",
	2642	:	"//	mov wb =p_rps  set pcode for integer arg case",
	2643	:	"//	mov wa =p_rpd  set pcode for expression arg case",
	2644	:	"//	jsr patin   call common routine to build node",
	2645	:	"//	mov -(xs) xr  stack result",
	2646	:	"//	lcw xr   get next code word",
	2647	:	"//	bri (xr)   execute it",
	2648	:	"//	mnz wa   mark as rsort",
	2649	:	"//	jsr sorta   call sort routine",
	2650	:	"//	brn exsid   return, setting idval",
	2651	:	"//	mov xr (xs)+  load argument",
	2652	:	"//	mov wa stxvr  load old vrblk pointer",
	2653	:	"//	zer xl   load zero in case null arg",
	2654	:	"//	beq xr =nulls sstx1 jump if null argument (reset call)",
	2655	:	"//	jsr gtnvr   else get specified vrblk",
	2656	:	"//	mov xl vrlbl(xr)  else load label",
	2657	:	"//	beq xl =stndl sstx2 jump if label is not defined",
	2658	:	"//	bne (xl) =b_trt sstx1 jump if not trapped",
	2659	:	"//	mov xl trlbl(xl)  else load ptr to real label code",
	2660	:	"//sstx1	mov stxvr xr  store new vrblk pointer (or null)",
	2661	:	"//	mov r_sxc xl  store new code ptr (or zero)",
	2662	:	"//	beq wa =nulls exnul return null if null result",
	2663	:	"//	mov xr wa  else copy vrblk pointer",
	2664	:	"//	brn exvnm   and return building nmblk",
	2665	:	"//sstx2	erb 187 setexit argument is not label name or null  ",
	2666	:	"//	mov xr (xs)+  get argument",
	2667	:	"//	jsr gtrea   convert to real",
	2668	:	"//	ldr rcval(xr)   load accumulator with argument",
	2669	:	"//	sin    take sine",
	2670	:	"//	rno exrea   if no overflow, return result in ra",
	2671	:	"//	erb 323 sin argument is out of range  ",
	2672	:	"//	mov xr (xs)+  get argument",
	2673	:	"//	jsr gtrea   convert to real",
	2674	:	"//	ldr rcval(xr)   load accumulator with argument",
	2675	:	"//	rlt ssqr1   negative number",
	2676	:	"//	sqr    take square root",
	2677	:	"//	brn exrea   no overflow possible, result in ra",
	2678	:	"//ssqr1	erb 314 sqrt argument negative  ",
	2679	:	"//	zer wa   mark as sort",
	2680	:	"//	jsr sorta   call sort routine",
	2681	:	"//	brn exsid   return, setting idval",
	2682	:	"//	mov wb =p_sps  set pcode for single char arg",
	2683	:	"//	mov xl =p_spn  set pcode for multi-char arg",
	2684	:	"//	mov wc =p_spd  set pcode for expression arg",
	2685	:	"//	jsr patst   call common routine to build node",
	2686	:	"//	mov -(xs) xr  stack result",
	2687	:	"//	lcw xr   get next code word",
	2688	:	"//	bri (xr)   execute it",
	2689	:	"//	jsr gtstg   load string argument",
	2690	:	"//	mti wa   load length as integer",
	2691	:	"//	brn exint   exit with integer result",
	2692	:	"//	zer xl   indicate stoptr case",
	2693	:	"//	jsr trace   call trace procedure",
	2694	:	"//	brn exnul   return null",
	2695	:	"//	jsr gtsmi   load third argument",
	2696	:	"//	mov sbssv xr  save third argument",
	2697	:	"//	jsr gtsmi   load second argument",
	2698	:	"//	mov wc xr  save second argument",
	2699	:	"//	bze wc exfal  jump if second argument zero",
	2700	:	"//	dcv wc   else decrement for ones origin",
	2701	:	"//	jsr gtstg   load first argument",
	2702	:	"//	mov wb wc  copy second arg to wb",
	2703	:	"//	mov wc sbssv  reload third argument",
	2704	:	"//	bnz wc ssub2  skip if third arg given",
	2705	:	"//	mov wc wa  else get string length",
	2706	:	"//	bgt wb wc exfal fail if improper",
	2707	:	"//	sub wc wb  reduce by offset to start",
	2708	:	"//ssub2	mov xl wa  save string length",
	2709	:	"//	mov wa wc  set length of substring",
	2710	:	"//	add wc wb  add 2nd arg to 3rd arg",
	2711	:	"//	bgt wc xl exfal jump if improper substring",
	2712	:	"//	mov xl xr  copy pointer to first arg",
	2713	:	"//	jsr sbstr   build substring",
	2714	:	"//	mov -(xs) xr  stack result",
	2715	:	"//	lcw xr   get next code word",
	2716	:	"//	bri (xr)   execute it",
	2717	:	"//	mov xl (xs)+  get initial lookup value",
	2718	:	"//	ica xs   pop second argument",
	2719	:	"//	jsr gtsmi   load argument",
	2720	:	"//	bnz wc stbl1  jump if non-zero",
	2721	:	"//	mov wc =tbnbk  else supply default value",
	2722	:	"//stbl1	jsr tmake   make table",
	2723	:	"//	brn exsid   exit setting idval",
	2724	:	"//	mov xr (xs)+  get argument",
	2725	:	"//	jsr gtrea   convert to real",
	2726	:	"//	ldr rcval(xr)   load accumulator with argument",
	2727	:	"//	rno exrea   if no overflow, return result in ra",
	2728	:	"//	erb 310 tan produced real overflow or argument is out of range  ",
	2729	:	"//	jsr systm   get timer value",
	2730	:	"//	sbi timsx   subtract starting time",
	2731	:	"//	brn exint   exit with integer value",
	2732	:	"//	beq num03(xs) =nulls str02 jump if first argument is null",
	2733	:	"//	mov xr (xs)+  load fourth argument",
	2734	:	"//	zer xl   tentatively set zero pointer",
	2735	:	"//	beq xr =nulls str01 jump if 4th argument is null",
	2736	:	"//	jsr gtnvr   else point to vrblk",
	2737	:	"//	mov xl xr  else save vrblk in trfnc",
	2738	:	"//str01	mov xr (xs)+  load third argument (tag)",
	2739	:	"//	zer wb   set zero as trtyp value for now",
	2740	:	"//	jsr trbld   build trblk for trace call",
	2741	:	"//	mov xl xr  move trblk pointer for trace",
	2742	:	"//	jsr trace   call trace procedure",
	2743	:	"//	brn exnul   return null",
	2744	:	"//str02	jsr systt   call it",
	2745	:	"//	add xs *num04  pop trace arguments",
	2746	:	"//	brn exnul   return",
	2747	:	"//str03	erb 197 trace fourth arg is not function name or null  ",
	2748	:	"//	jsr gtstg   load argument as string",
	2749	:	"//	bze wa exnul  return null if argument is null",
	2750	:	"//	mov xl xr  copy string pointer",
	2751	:	"//	ctb wa schar  get block length",
	2752	:	"//	jsr alloc   allocate copy same size",
	2753	:	"//	mov wb xr  save pointer to copy",
	2754	:	"//	mvw    copy old string block to new",
	2755	:	"//	mov xr wb  restore ptr to new block",
	2756	:	"//	jsr trimr   trim blanks (wb is non-zero)",
	2757	:	"//	mov -(xs) xr  stack result",
	2758	:	"//	lcw xr   get next code word",
	2759	:	"//	bri (xr)   execute it",
	2760	:	"//	mov xr (xs)+  load argument",
	2761	:	"//	jsr gtnvr   point to vrblk",
	2762	:	"//	mov xl =stndf  get ptr to undefined function",
	2763	:	"//	jsr dffnc   undefine named function",
	2764	:	"//	brn exnul   return null as result",
	2765	:	"//arref	rtn    ",
	2766	:	"//	mov wa xr  copy number of subscripts",
	2767	:	"//	mov xt xs  point to stack front",
	2768	:	"//	wtb xr   convert to byte offset",
	2769	:	"//	add xt xr  point to array operand on stack",
	2770	:	"//	ica xt   final value for stack popping",
	2771	:	"//	mov arfxs xt  keep for later",
	2772	:	"//	mov xr -(xt)  load array operand pointer",
	2773	:	"//	mov r_arf xr  keep array pointer",
	2774	:	"//	mov xr xt  save pointer to subscripts",
	2775	:	"//	mov xl r_arf  point xl to possible vcblk or tbblk",
	2776	:	"//	mov wc (xl)  load first word",
	2777	:	"//	beq wc =b_art arf01 jump if arblk",
	2778	:	"//	beq wc =b_vct arf07 jump if vcblk",
	2779	:	"//	beq wc =b_tbt arf10 jump if tbblk",
	2780	:	"//	erb 235 subscripted operand is not table or array  ",
	2781	:	"//arf01	bne wa arndm(xl) arf09 jump if wrong number of dims",
	2782	:	"//	ldi 4,intv0   get initial subscript of zero",
	2783	:	"//	mov xt xr  point before subscripts",
	2784	:	"//	zer wa   initial offset to bounds",
	2785	:	"//	brn arf03   jump into loop",
	2786	:	"//arf02	mli ardm2(xr)   multiply total by next dimension",
	2787	:	"//arf03	mov xr -(xt)  load next subscript",
	2788	:	"//	sti arfsi   save current subscript",
	2789	:	"//	ldi icval(xr)   load integer value in case",
	2790	:	"//	beq (xr) =b_icl arf04 jump if it was an integer",
	2791	:	"//	jsr gtint   convert to integer",
	2792	:	"//	ldi icval(xr)   if ok, load integer value",
	2793	:	"//arf04	mov xr r_arf  point to array",
	2794	:	"//	add xr wa  offset to next bounds",
	2795	:	"//	sbi arlbd(xr)   subtract low bound to compare",
	2796	:	"//	iov arf13   out of range fail if overflow",
	2797	:	"//	ilt arf13   out of range fail if too small",
	2798	:	"//	sbi ardim(xr)   subtract dimension",
	2799	:	"//	ige arf13   out of range fail if too large",
	2800	:	"//	adi ardim(xr)   else restore subscript offset",
	2801	:	"//	adi arfsi   add to current total",
	2802	:	"//	add wa *ardms  point to next bounds",
	2803	:	"//	bne xt xs arf02 loop back if more to go",
	2804	:	"//	mfi wa   get as one word integer",
	2805	:	"//	wtb wa   convert to offset",
	2806	:	"//	mov xl r_arf  point to arblk",
	2807	:	"//	add wa arofs(xl)  add offset past bounds",
	2808	:	"//	ica wa   adjust for arpro field",
	2809	:	"//	bnz wb arf08  exit with name if name call",
	2810	:	"//arf05	jsr acess   get value",
	2811	:	"//arf06	mov xs arfxs  pop stack entries",
	2812	:	"//	zer r_arf   finished with array pointer",
	2813	:	"//	mov -(xs) xr  stack result",
	2814	:	"//	lcw xr   get next code word",
	2815	:	"//	bri (xr)   execute it",
	2816	:	"//arf07	bne wa =num01 arf09 error if more than 1 subscript",
	2817	:	"//	mov xr (xs)  else load subscript",
	2818	:	"//	jsr gtint   convert to integer",
	2819	:	"//	ldi icval(xr)   else load integer value",
	2820	:	"//	sbi 4,intv1   subtract for ones offset",
	2821	:	"//	mfi wa arf13  get subscript as one word",
	2822	:	"//	add wa =vcvls  add offset for standard fields",
	2823	:	"//	wtb wa   convert offset to bytes",
	2824	:	"//	bge wa vclen(xl) arf13 fail if out of range subscript",
	2825	:	"//	bze wb arf05  back to get value if value call",
	2826	:	"//arf08	mov xs arfxs  pop stack entries",
	2827	:	"//	zer r_arf   finished with array pointer",
	2828	:	"//	brn exnam   else exit with name",
	2829	:	"//arf09	erb 236 array referenced with wrong number of subscripts  ",
	2830	:	"//arf10	bne wa =num01 arf11 error if more than 1 subscript",
	2831	:	"//	mov xr (xs)  else load subscript",
	2832	:	"//	jsr tfind   call table search routine",
	2833	:	"//	bnz wb arf08  exit with name if name call",
	2834	:	"//	brn arf06   else exit with value",
	2835	:	"//arf11	erb 237 table referenced with more than one subscript  ",
	2836	:	"//arf12	erb 238 array subscript is not integer  ",
	2837	:	"//arf13	zer r_arf   finished with array pointer",
	2838	:	"//	brn exfal   fail",
	2839	:	"//cfunc	rtn    ",
	2840	:	"//	blt wa fargs(xl) cfnc1 jump if too few arguments",
	2841	:	"//	beq wa fargs(xl) cfnc3 jump if correct number of args",
	2842	:	"//	mov wb wa  copy actual number",
	2843	:	"//	sub wb fargs(xl)  get number of extra args",
	2844	:	"//	wtb wb   convert to bytes",
	2845	:	"//	add xs wb  pop off unwanted arguments",
	2846	:	"//	brn cfnc3   jump to go off to function",
	2847	:	"//cfnc1	mov wb fargs(xl)  load required number of arguments",
	2848	:	"//	beq wb =nini9 cfnc3 jump if case of var num of args",
	2849	:	"//	sub wb wa  calculate number missing",
	2850	:	"//	lct wb wb  set counter to control loop",
	2851	:	"//cfnc2	mov -(xs) =nulls  stack a null argument",
	2852	:	"//	bct wb cfnc2  loop till proper number stacked",
	2853	:	"//cfnc3	bri (xl)   jump through fcode field",
	2854	:	"//exfal	rtn    ",
	2855	:	"//	mov xs flptr  pop stack",
	2856	:	"//	mov xr (xs)  load failure offset",
	2857	:	"//	add xr r_cod  point to failure code location",
	2858	:	"//	lcp xr   set code pointer",
	2859	:	"//	lcw xr   load next code word",
	2860	:	"//	mov xl (xr)  load entry address",
	2861	:	"//	bri xl   jump to execute next code word",
	2862	:	"//exint	rtn    ",
	2863	:	"//	zer xl   clear dud value",
	2864	:	"//	jsr icbld   build icblk",
	2865	:	"//exixr	rtn    ",
	2866	:	"//	mov -(xs) xr  stack result",
	2867	:	"//exits	rtn    ",
	2868	:	"//	lcw xr   load next code word",
	2869	:	"//	mov xl (xr)  load entry address",
	2870	:	"//	bri xl   jump to execute next code word",
	2871	:	"//exnam	rtn    ",
	2872	:	"//	mov -(xs) xl  stack name base",
	2873	:	"//	mov -(xs) wa  stack name offset",
	2874	:	"//	lcw xr   load next code word",
	2875	:	"//	bri (xr)   execute it",
	2876	:	"//exnul	rtn    ",
	2877	:	"//	mov -(xs) =nulls  stack null value",
	2878	:	"//	lcw xr   load next code word",
	2879	:	"//	mov xl (xr)  load entry address",
	2880	:	"//	bri xl   jump to execute next code word",
	2881	:	"//exrea	rtn    ",
	2882	:	"//	zer xl   clear dud value",
	2883	:	"//	jsr rcbld   build rcblk",
	2884	:	"//	brn exixr   jump to exit with result in xr",
	2885	:	"//exsid	rtn    ",
	2886	:	"//	mov wa curid  load current id value",
	2887	:	"//	bne wa mxint exsi1 jump if no overflow",
	2888	:	"//	zer wa   else reset for wraparound",
	2889	:	"//exsi1	icv wa   bump id value",
	2890	:	"//	mov curid wa  store for next time",
	2891	:	"//	mov idval(xr) wa  store id value",
	2892	:	"//	brn exixr   exit with result in (xr)",
	2893	:	"//exvnm	rtn    ",
	2894	:	"//	mov xl xr  copy name base pointer",
	2895	:	"//	mov wa *nmsi_  set size of nmblk",
	2896	:	"//	jsr alloc   allocate nmblk",
	2897	:	"//	mov (xr) =b_nml  store type word",
	2898	:	"//	mov nmbas(xr) xl  store name base",
	2899	:	"//	mov nmofs(xr) *vrval  store name offset",
	2900	:	"//	brn exixr   exit with result in xr",
	2901	:	"//flpop	rtn    ",
	2902	:	"//	add xs *num02  pop two entries off stack",
	2903	:	"//failp	rtn    ",
	2904	:	"//	mov xr (xs)+  load alternative node pointer",
	2905	:	"//	mov wb (xs)+  restore old cursor",
	2906	:	"//	mov xl (xr)  load pcode entry pointer",
	2907	:	"//	bri xl   jump to execute code for node",
	2908	:	"//indir	rtn    ",
	2909	:	"//	mov xr (xs)+  load argument",
	2910	:	"//	beq (xr) =b_nml indr2 jump if a name",
	2911	:	"//	jsr gtnvr   else convert to variable",
	2912	:	"//	bze wb indr1  skip if by value",
	2913	:	"//	mov -(xs) xr  else stack vrblk ptr",
	2914	:	"//	mov -(xs) *vrval  stack name offset",
	2915	:	"//	lcw xr   load next code word",
	2916	:	"//	mov xl (xr)  load entry address",
	2917	:	"//	bri xl   jump to execute next code word",
	2918	:	"//indr1	bri (xr)   jump through vrget field of vrblk",
	2919	:	"//indr2	mov xl nmbas(xr)  load name base",
	2920	:	"//	mov wa nmofs(xr)  load name offset",
	2921	:	"//	bnz wb exnam  exit if called by name",
	2922	:	"//	jsr acess   else get value first",
	2923	:	"//	brn exixr   else return with value in xr",
	2924	:	"//match	rtn    ",
	2925	:	"//	mov xr (xs)+  load pattern operand",
	2926	:	"//	jsr gtpat   convert to pattern",
	2927	:	"//	mov xl xr  if ok, save pattern pointer",
	2928	:	"//	bnz wb mtch1  jump if not match by name",
	2929	:	"//	mov wa (xs)  else load name offset",
	2930	:	"//	mov -(xs) xl  save pattern pointer",
	2931	:	"//	mov xl num02(xs)  load name base",
	2932	:	"//	jsr acess   access subject value",
	2933	:	"//	mov xl (xs)  restore pattern pointer",
	2934	:	"//	mov (xs) xr  stack subject string val for merge",
	2935	:	"//	zer wb   restore type code",
	2936	:	"//mtch1	jsr gtstg   convert subject to string",
	2937	:	"//	mov -(xs) wb  stack match type code",
	2938	:	"//	mov r_pms xr  if ok, store subject string pointer",
	2939	:	"//	mov pmssl wa  and length",
	2940	:	"//	zer -(xs)   stack initial cursor (zero)",
	2941	:	"//	zer wb   set initial cursor",
	2942	:	"//	mov pmhbs xs  set history stack base ptr",
	2943	:	"//	zer pmdfl   reset pattern assignment flag",
	2944	:	"//	mov xr xl  set initial node pointer",
	2945	:	"//	bnz kvanc mtch2  jump if anchored",
	2946	:	"//	mov -(xs) xr  stack initial node pointer",
	2947	:	"//	mov -(xs) =nduna  stack pointer to anchor move node",
	2948	:	"//	bri (xr)   start match of first node",
	2949	:	"//mtch2	zer -(xs)   dummy cursor value",
	2950	:	"//	mov -(xs) =ndabo  stack pointer to abort node",
	2951	:	"//	bri (xr)   start match of first node",
	2952	:	"//retrn	rtn    ",
	2953	:	"//	bnz kvfnc rtn01  jump if not level zero",
	2954	:	"//	erb 242 function return from level zero  ",
	2955	:	"//rtn01	mov xs flprt  pop stack",
	2956	:	"//	ica xs   remove failure offset",
	2957	:	"//	mov xr (xs)+  pop pfblk pointer",
	2958	:	"//	mov flptr (xs)+  pop failure pointer",
	2959	:	"//	mov flprt (xs)+  pop old flprt",
	2960	:	"//	mov wb (xs)+  pop code pointer offset",
	2961	:	"//	mov wc (xs)+  pop old code block pointer",
	2962	:	"//	add wb wc  make old code pointer absolute",
	2963	:	"//	lcp wb   restore old code pointer",
	2964	:	"//	mov r_cod wc  restore old code block pointer",
	2965	:	"//	dcv kvfnc   decrement function level",
	2966	:	"//	mov wb kvtra  load trace",
	2967	:	"//	add wb kvftr  add ftrace",
	2968	:	"//	bze wb rtn06  jump if no tracing possible",
	2969	:	"//	mov -(xs) wa  save function return type",
	2970	:	"//	mov -(xs) xr  save pfblk pointer",
	2971	:	"//	mov kvrtn wa  set rtntype for trace function",
	2972	:	"//	mov xl r_fnc  load fnclevel trblk ptr (if any)",
	2973	:	"//	jsr ktrex   execute possible fnclevel trace",
	2974	:	"//	mov xl pfvbl(xr)  load vrblk ptr (sgd13)",
	2975	:	"//	bze kvtra rtn02  jump if trace is off",
	2976	:	"//	mov xr pfrtr(xr)  else load return trace trblk ptr",
	2977	:	"//	bze xr rtn02  jump if not return traced",
	2978	:	"//	dcv kvtra   else decrement trace count",
	2979	:	"//	bze trfnc(xr) rtn03  jump if print trace",
	2980	:	"//	mov wa *vrval  else set name offset",
	2981	:	"//	mov kvrtn num01(xs)  make sure rtntype is set right",
	2982	:	"//	jsr trxeq   execute full trace",
	2983	:	"//rtn02	bze kvftr rtn05  jump if ftrace is off",
	2984	:	"//	dcv kvftr   else decrement ftrace",
	2985	:	"//rtn03	jsr prtsn   print statement number",
	2986	:	"//	mov xr num01(xs)  load return type",
	2987	:	"//	jsr prtst   print it",
	2988	:	"//	mov wa =ch_bl  load blank",
	2989	:	"//	jsr prtch   print it",
	2990	:	"//	mov xl 0(xs)  load pfblk ptr",
	2991	:	"//	mov xl pfvbl(xl)  load function vrblk ptr",
	2992	:	"//	mov wa *vrval  set vrblk name offset",
	2993	:	"//	bne xr =scfrt rtn04 jump if not freturn case",
	2994	:	"//	jsr prtnm   print name",
	2995	:	"//	jsr prtnl   terminate print line",
	2996	:	"//	brn rtn05   merge",
	2997	:	"//rtn04	jsr prtnv   print name = value",
	2998	:	"//rtn05	mov xr (xs)+  pop pfblk pointer",
	2999	:	"//	mov wa (xs)+  pop return type string",
	3000	:	"//rtn06	mov kvrtn wa  set rtntype keyword",
	3001	:	"//	mov xl pfvbl(xr)  load pointer to fn vrblk",
	3002	:	"//rtn07	mov rtnbp xl  save block pointer",
	3003	:	"//	mov xl vrval(xl)  load value",
	3004	:	"//	beq (xl) =b_trt rtn07 loop back if trapped",
	3005	:	"//	mov rtnfv xl  else save function result value",
	3006	:	"//	mov rtnsv (xs)+  save original function value",
	3007	:	"//	mov xl (xs)+  pop saved pointer",
	3008	:	"//	bze xl rtn7c  no action if none",
	3009	:	"//	bze kvpfl rtn7c  jump if no profiling",
	3010	:	"//	jsr prflu   else profile last func stmt",
	3011	:	"//	beq kvpfl =num02 rtn7a branch on value of profile keywd",
	3012	:	"//	ldi pfstm   load current time",
	3013	:	"//	sbi icval(xl)   frig by subtracting saved amount",
	3014	:	"//	brn rtn7b   and merge",
	3015	:	"//rtn7a	ldi icval(xl)   load saved time",
	3016	:	"//rtn7b	sti pfstm   store back correct start time",
	3017	:	"//rtn7c	mov wb fargs(xr)  get number of args",
	3018	:	"//	add wb pfnlo(xr)  add number of locals",
	3019	:	"//	bze wb rtn10  jump if no args/locals",
	3020	:	"//	lct wb wb  else set loop counter",
	3021	:	"//	add xr pflen(xr)  and point to end of pfblk",
	3022	:	"//rtn08	mov xl -(xr)  load next vrblk pointer",
	3023	:	"//rtn09	mov wa xl  save block pointer",
	3024	:	"//	mov xl vrval(xl)  load pointer to next value",
	3025	:	"//	beq (xl) =b_trt rtn09 loop back if trapped",
	3026	:	"//	mov xl wa  else restore last block pointer",
	3027	:	"//	mov vrval(xl) (xs)+  restore old variable value",
	3028	:	"//	bct wb rtn08  loop till all processed",
	3029	:	"//rtn10	mov xl rtnbp  restore ptr to last function block",
	3030	:	"//	mov vrval(xl) rtnsv  restore old function value",
	3031	:	"//	mov xr rtnfv  reload function result",
	3032	:	"//	mov xl r_cod  point to new code block",
	3033	:	"//	mov kvlst kvstn  set lastno from stno",
	3034	:	"//	mov kvstn cdstm(xl)  reset proper stno value",
	3035	:	"//	mov kvlln kvlin  set lastline from line",
	3036	:	"//	mov kvlin cdsln(xl)  reset proper line value",
	3037	:	"//	mov wa kvrtn  load return type",
	3038	:	"//	beq wa =scrtn exixr exit with result in xr if return",
	3039	:	"//	beq wa =scfrt exfal fail if freturn",
	3040	:	"//	beq (xr) =b_nml rtn11 jump if is a name",
	3041	:	"//	jsr gtnvr   else try convert to variable name",
	3042	:	"//	mov xl xr  if ok, copy vrblk (name base) ptr",
	3043	:	"//	mov wa *vrval  set name offset",
	3044	:	"//	brn rtn12   and merge",
	3045	:	"//rtn11	mov xl nmbas(xr)  load name base",
	3046	:	"//	mov wa nmofs(xr)  load name offset",
	3047	:	"//rtn12	mov xr xl  preserve xl",
	3048	:	"//	lcw wb   load next word",
	3049	:	"//	mov xl xr  restore xl",
	3050	:	"//	beq wb =ofne_ exnam exit if called by name",
	3051	:	"//	mov -(xs) wb  else save code word",
	3052	:	"//	jsr acess   get value",
	3053	:	"//	mov xl xr  if ok, copy result",
	3054	:	"//	mov xr (xs)  reload next code word",
	3055	:	"//	mov (xs) xl  store result on stack",
	3056	:	"//	mov xl (xr)  load routine address",
	3057	:	"//	bri xl   jump to execute next code word",
	3058	:	"//stcov	rtn    ",
	3059	:	"//	icv errft   fatal error",
	3060	:	"//	ldi 4,intvt   get 10",
	3061	:	"//	adi kvstl   add to former limit",
	3062	:	"//	sti kvstl   store as new stlimit",
	3063	:	"//	ldi 4,intvt   get 10",
	3064	:	"//	sti kvstc   set as new count",
	3065	:	"//	jsr stgcc   recompute countdown counters",
	3066	:	"//	erb 244 statement count exceeds value of stlimit keyword  ",
	3067	:	"//stmgo	rtn    ",
	3068	:	"//	mov r_cod xr  set new code block pointer",
	3069	:	"//	dcv stmct   see if time to check something",
	3070	:	"//	bze stmct stgo2  jump if so",
	3071	:	"//	mov kvlst kvstn  set lastno",
	3072	:	"//	mov kvstn cdstm(xr)  set stno",
	3073	:	"//	mov kvlln kvlin  set lastline",
	3074	:	"//	mov kvlin cdsln(xr)  set line",
	3075	:	"//	add xr *cdcod  point to first code word",
	3076	:	"//	lcp xr   set code pointer",
	3077	:	"//stgo1	lcw xr   load next code word",
	3078	:	"//	zer xl   clear garbage xl",
	3079	:	"//	bri (xr)   execute it",
	3080	:	"//stgo2	bze kvpfl stgo3  skip if no profiling",
	3081	:	"//	jsr prflu   else profile the statement in kvstn",
	3082	:	"//stgo3	mov kvlst kvstn  set lastno",
	3083	:	"//	mov kvstn cdstm(xr)  set stno",
	3084	:	"//	mov kvlln kvlin  set lastline",
	3085	:	"//	mov kvlin cdsln(xr)  set line",
	3086	:	"//	add xr *cdcod  point to first code word",
	3087	:	"//	lcp xr   set code pointer",
	3088	:	"//	mov -(xs) stmcs  save present count start on stack",
	3089	:	"//	dcv polct   poll interval within stmct",
	3090	:	"//	bnz polct stgo4  jump if not poll time yet",
	3091	:	"//	zer wa   =0 for poll",
	3092	:	"//	mov wb kvstn  statement number",
	3093	:	"//	mov xl xr  make collectable",
	3094	:	"//	jsr syspl   allow interactive access",
	3095	:	"//	mov xr xl  restore code block pointer",
	3096	:	"//	mov polcs wa  poll interval start value",
	3097	:	"//	jsr stgcc   recompute counter values",
	3098	:	"//stgo4	ldi kvstc   get stmt count",
	3099	:	"//	ilt stgo5   omit counting if negative",
	3100	:	"//	mti (xs)+   reload start value of counter",
	3101	:	"//	ngi    negate",
	3102	:	"//	adi kvstc   stmt count minus counter",
	3103	:	"//	sti kvstc   replace it",
	3104	:	"//	ile stcov   fail if stlimit reached",
	3105	:	"//	bze r_stc stgo5  jump if no statement trace",
	3106	:	"//	zer xr   clear garbage value in xr",
	3107	:	"//	mov xl r_stc  load pointer to stcount trblk",
	3108	:	"//	jsr ktrex   execute keyword trace",
	3109	:	"//stgo5	mov stmct stmcs  reset counter",
	3110	:	"//	brn stgo1   fetch next code word",
	3111	:	"//stopr	rtn    ",
	3112	:	"//	bze xr stpra  skip if sysax already called",
	3113	:	"//	jsr sysax   call after execution proc",
	3114	:	"//stpra	add dname rsmem  use the reserve memory",
	3115	:	"//	bne xr =endms stpr0 skip if not normal end message",
	3116	:	"//	bnz exsts stpr3  skip if exec stats suppressed",
	3117	:	"//	zer erich   clear errors to int.ch. flag",
	3118	:	"//stpr0	jsr prtpg   eject printer",
	3119	:	"//	bze xr stpr1  skip if no message",
	3120	:	"//	jsr prtst   print message",
	3121	:	"//stpr1	jsr prtis   print blank line",
	3122	:	"//	bnz gbcfl stpr5  if in garbage collection, skip",
	3123	:	"//	mov xr =stpm6  point to message /in file xxx/",
	3124	:	"//	jsr prtst   print it",
	3125	:	"//	mov profs =prtmf  set column offset",
	3126	:	"//	mov wc kvstn  get statement number",
	3127	:	"//	jsr filnm   get file name",
	3128	:	"//	mov xr xl  prepare to print",
	3129	:	"//	jsr prtst   print file name",
	3130	:	"//	jsr prtis   print to interactive channel",
	3131	:	"//	mov xr r_cod  get code pointer",
	3132	:	"//	mti cdsln(xr)   get source line number",
	3133	:	"//	mov xr =stpm4  point to message /in line xxx/",
	3134	:	"//	jsr prtmx   print it",
	3135	:	"//stpr5	mti kvstn   get statement number",
	3136	:	"//	mov xr =stpm1  point to message /in statement xxx/",
	3137	:	"//	jsr prtmx   print it",
	3138	:	"//	ldi kvstl   get statement limit",
	3139	:	"//	ilt stpr2   skip if negative",
	3140	:	"//	sbi kvstc   minus counter = course count",
	3141	:	"//	sti stpsi   save",
	3142	:	"//	mov wa stmcs  refine with counter start value",
	3143	:	"//	sub wa stmct  minus current counter",
	3144	:	"//	mti wa   convert to integer",
	3145	:	"//	adi stpsi   add in course count",
	3146	:	"//	sti stpsi   save",
	3147	:	"//	mov xr =stpm2  point to message /stmts executed/",
	3148	:	"//	jsr prtmx   print it",
	3149	:	"//	jsr systm   get current time",
	3150	:	"//	sbi timsx   minus start time = elapsed exec tim in nanosec",
	3151	:	"//	sti stpti   save for later",
	3152	:	"//	dvi 4,intth   divide by 1000 to convert to microseconds",
	3153	:	"//	iov stpr2   jump if we cannot compute",
	3154	:	"//	dvi 4,intth   divide by 1000 to convert to milliseconds",
	3155	:	"//	iov stpr2   jump if we cannot compute",
	3156	:	"//	sti stpti   save elapsed time in milliseconds",
	3157	:	"//	mov xr =stpm3  point to msg /execution time msec /",
	3158	:	"//	jsr prtmx   print it",
	3159	:	"//	ldi stpti   reload execution time in milliseconds",
	3160	:	"//	ile stpr2   jump if exection time less than a millisecond",
	3161	:	"//	ldi stpsi   load statement count",
	3162	:	"//	dvi stpti   divide to get stmts per millisecond",
	3163	:	"//	iov stpr2   jump if we cannot compute",
	3164	:	"//	dvi 4,intth   divide to get stmts per microsecond",
	3165	:	"//	iov stpr2   jump if we cannot compute",
	3166	:	"//	mov xr =stpm7  point to msg (stmt / microsec)",
	3167	:	"//	jsr prtmx   print it",
	3168	:	"//	ldi stpsi   reload statement count",
	3169	:	"//	dvi stpti   divide to get stmts per millisecond",
	3170	:	"//	iov stpr2   jump if we cannot compute",
	3171	:	"//	mov xr =stpm8  point to msg (stmt / millisec )",
	3172	:	"//	jsr prtmx   print it",
	3173	:	"//	ldi stpsi   reload statement count",
	3174	:	"//	dvi stpti   divide to get stmts per millisecond",
	3175	:	"//	iov stpr2   jump if we cannot compute",
	3176	:	"//	mli 4,intth   multiply by 1000 to get stmts per microsecond",
	3177	:	"//	iov stpr2   jump if overflow",
	3178	:	"//	mov xr =stpm9  point to msg ( stmt / second )",
	3179	:	"//	jsr prtmx   print it",
	3180	:	"//stpr2	mti gbcnt   load count of collections",
	3181	:	"//	mov xr =stpm4  point to message /regenerations /",
	3182	:	"//	jsr prtmx   print it",
	3183	:	"//	jsr prtmm   print memory usage",
	3184	:	"//	jsr prtis   one more blank for luck",
	3185	:	"//stpr3	jsr prflr   print profile if wanted",
	3186	:	"//	mov xr kvdmp  load dump keyword",
	3187	:	"//	jsr dumpr   execute dump if requested",
	3188	:	"//	mov xl r_fcb  get fcblk chain head",
	3189	:	"//	mov wa kvabe  load abend value",
	3190	:	"//	mov wb kvcod  load code value",
	3191	:	"//	jsr sysej   exit to system",
	3192	:	"//stpr4	rtn    ",
	3193	:	"//	add dname rsmem  use the reserve memory",
	3194	:	"//	bze exsts stpr1  if execution stats requested",
	3195	:	"//	brn stpr3   check if dump or profile needed",
	3196	:	"//succp	rtn    ",
	3197	:	"//	mov xr pthen(xr)  load successor node",
	3198	:	"//	mov xl (xr)  load node code entry address",
	3199	:	"//	bri xl   jump to match successor node",
	3200	:	"//sysab	rtn    ",
	3201	:	"//	mov xr =endab  point to message",
	3202	:	"//	mov kvabe =num01  set abend flag",
	3203	:	"//	jsr prtnl   skip to new line",
	3204	:	"//	brn stopr   jump to pack up",
	3205	:	"//systu	rtn    ",
	3206	:	"//	mov xr =endtu  point to message",
	3207	:	"//	mov wa 4,strtu  get chars /tu/",
	3208	:	"//	mov kvcod wa  put in kvcod",
	3209	:	"//	mov wa timup  check state of timeup switch",
	3210	:	"//	mnz timup   set switch",
	3211	:	"//	bnz wa stopr  stop run if already set",
	3212	:	"//	erb 245 translation/execution time expired  ",
	3213	:	"//acess	prc r 1  entry point (recursive)",
	3214	:	"//	mov xr xl  copy name base",
	3215	:	"//	add xr wa  point to variable location",
	3216	:	"//	mov xr (xr)  load variable value",
	3217	:	"//acs02	bne (xr) =b_trt acs18 jump if not trapped",
	3218	:	"//	beq xr =trbkv acs12 jump if keyword variable",
	3219	:	"//	bne xr =trbev acs05 jump if not expression variable",
	3220	:	"//	mov xr evexp(xl)  load expression pointer",
	3221	:	"//	zer wb   evaluate by value",
	3222	:	"//	jsr evalx   evaluate expression",
	3223	:	"//	brn acs02   check value for more trblks",
	3224	:	"//acs03	add xs *num03  pop trblk ptr, name base and offset",
	3225	:	"//	mov dnamp xr  pop unused scblk",
	3226	:	"//acs04	exi 1   take alternate (failure) return",
	3227	:	"//acs05	mov wb trtyp(xr)  load trap type code",
	3228	:	"//	bnz wb acs10  jump if not input association",
	3229	:	"//	bze kvinp acs09  ignore input assoc if input is off",
	3230	:	"//	mov -(xs) xl  stack name base",
	3231	:	"//	mov -(xs) wa  stack name offset",
	3232	:	"//	mov -(xs) xr  stack trblk pointer",
	3233	:	"//	mov actrm kvtrm  temp to hold trim keyword",
	3234	:	"//	mov xl trfpt(xr)  get file ctrl blk ptr or zero",
	3235	:	"//	bnz xl acs06  jump if not standard input file",
	3236	:	"//	beq trter(xr) =v_ter acs21 jump if terminal",
	3237	:	"//	mov wa cswin  length for read buffer",
	3238	:	"//	jsr alocs   build string of appropriate length",
	3239	:	"//	jsr sysrd   read next standard input image",
	3240	:	"//	brn acs07   else merge with other file case",
	3241	:	"//acs06	mov wa xl  fcblk ptr",
	3242	:	"//	jsr sysil   get input record max length (to wa)",
	3243	:	"//	bnz wc acs6a  jump if not binary file",
	3244	:	"//	mov actrm wc  disable trim for binary file",
	3245	:	"//acs6a	jsr alocs   allocate string of correct size",
	3246	:	"//	mov wa xl  fcblk ptr",
	3247	:	"//	jsr sysin   call system input routine",
	3248	:	"//acs07	mov wb actrm  load trim indicator",
	3249	:	"//	jsr trimr   trim record as required",
	3250	:	"//	mov wb xr  copy result pointer",
	3251	:	"//	mov xr (xs)  reload pointer to trblk",
	3252	:	"//acs08	mov xl xr  save pointer to this trblk",
	3253	:	"//	mov xr trnxt(xr)  load forward pointer",
	3254	:	"//	beq (xr) =b_trt acs08 loop if this is another trblk",
	3255	:	"//	mov trnxt(xl) wb  else store result at end of chain",
	3256	:	"//	mov xr (xs)+  restore initial trblk pointer",
	3257	:	"//	mov wa (xs)+  restore name offset",
	3258	:	"//	mov xl (xs)+  restore name base pointer",
	3259	:	"//acs09	mov xr trnxt(xr)  load forward ptr to next value",
	3260	:	"//	brn acs02   back to check if trapped",
	3261	:	"//acs10	bne wb =trtac acs09 loop back if not access trace",
	3262	:	"//	bze kvtra acs09  ignore access trace if trace off",
	3263	:	"//	dcv kvtra   else decrement trace count",
	3264	:	"//	bze trfnc(xr) acs11  jump if print trace",
	3265	:	"//	jsr trxeq   call routine to execute trace",
	3266	:	"//	brn acs09   jump for next trblk",
	3267	:	"//acs11	jsr prtsn   print statement number",
	3268	:	"//	jsr prtnv   print name = value",
	3269	:	"//	brn acs09   jump back for next trblk",
	3270	:	"//acs12	mov xr kvnum(xl)  load keyword number",
	3271	:	"//	bge xr =k_v__ acs14 jump if not one word value",
	3272	:	"//	mti kvabe(xr)   else load value as integer",
	3273	:	"//acs13	jsr icbld   build icblk",
	3274	:	"//	brn acs18   jump to exit",
	3275	:	"//acs14	bge xr =k_s__ acs15 jump if special case",
	3276	:	"//	sub xr =k_v__  else get offset",
	3277	:	"//	wtb xr   convert to byte offset",
	3278	:	"//	add xr =ndabo  point to pattern value",
	3279	:	"//	brn acs18   jump to exit",
	3280	:	"//acs15	mov xl kvrtn  load rtntype in case",
	3281	:	"//	ldi kvstl   load stlimit in case",
	3282	:	"//	sub xr =k_s__  get case number",
	3283	:	"//	bsw xr k__n_  switch on keyword number",
	3284	:	"//acs24	mov xr =lcase  load pointer to lcase string",
	3285	:	"//	brn acs18   common return",
	3286	:	"//acs25	mov xr =ucase  load pointer to ucase string",
	3287	:	"//	brn acs18   common return",
	3288	:	"//acs26	mov wc kvstn  load current stmt number",
	3289	:	"//	brn acs28   merge to obtain file name",
	3290	:	"//acs27	mov wc kvlst  load last stmt number",
	3291	:	"//acs28	jsr filnm   obtain file name for this stmt",
	3292	:	"//	brn acs17   merge to return string in xl",
	3293	:	"//acs16	mov xl kvalp  load pointer to alphabet string",
	3294	:	"//acs17	mov xr xl  copy string ptr to proper reg",
	3295	:	"//acs18	exi    return to acess caller",
	3296	:	"//acs19	ilt acs29   if counting suppressed",
	3297	:	"//	mov wa stmcs  refine with counter start value",
	3298	:	"//	sub wa stmct  minus current counter",
	3299	:	"//	mti wa   convert to integer",
	3300	:	"//	adi kvstl   add stlimit",
	3301	:	"//acs29	sbi kvstc   stcount = limit - left",
	3302	:	"//	brn acs13   merge back with integer result",
	3303	:	"//acs20	mov xr r_etx  get errtext string",
	3304	:	"//	brn acs18   merge with result",
	3305	:	"//acs21	mov wa =rilen  buffer length",
	3306	:	"//	jsr alocs   allocate buffer",
	3307	:	"//	jsr sysri   read record",
	3308	:	"//	brn acs07   merge with record read",
	3309	:	"//acs22	mov dnamp xr  pop unused scblk",
	3310	:	"//	erb 202 input from file caused non-recoverable error  ",
	3311	:	"//acs23	mov dnamp xr  pop unused scblk",
	3312	:	"//	erb 203 input file record has incorrect format  ",
	3313	:	"//acomp	prc n 5  entry point",
	3314	:	"//	jsr arith   load arithmetic operands",
	3315	:	"//	sbi icval(xl)   subtract to compare",
	3316	:	"//	iov acmp3   jump if overflow",
	3317	:	"//	ilt acmp5   else jump if arg1 lt arg2",
	3318	:	"//	ieq acmp2   jump if arg1 eq arg2",
	3319	:	"//acmp1	exi 5   take gt exit",
	3320	:	"//acmp2	exi 4   take eq exit",
	3321	:	"//acmp3	ldi icval(xl)   load second argument",
	3322	:	"//	ilt acmp1   gt if negative",
	3323	:	"//	brn acmp5   else lt",
	3324	:	"//acmp4	sbr rcval(xl)   subtract to compare",
	3325	:	"//	rov acmp6   jump if overflow",
	3326	:	"//	rgt acmp1   else jump if arg1 gt",
	3327	:	"//	req acmp2   jump if arg1 eq arg2",
	3328	:	"//acmp5	exi 3   take lt exit",
	3329	:	"//acmp6	ldr rcval(xl)   reload arg2",
	3330	:	"//	rlt acmp1   gt if negative",
	3331	:	"//	brn acmp5   else lt",
	3332	:	"//acmp7	exi 1   take error exit",
	3333	:	"//acmp8	exi 2   take error exit",
	3334	:	"//alloc	prc e 0  entry point",
	3335	:	"//aloc1	mov xr dnamp  point to next available loc",
	3336	:	"//	aov wa xr aloc2 point past allocated block",
	3337	:	"//	bgt xr dname aloc2 jump if not enough room",
	3338	:	"//	mov dnamp xr  store new pointer",
	3339	:	"//	sub xr wa  point back to start of allocated bk",
	3340	:	"//	exi    return to caller",
	3341	:	"//aloc2	mov allsv wb  save wb",
	3342	:	"//alc2a	zer wb   set no upward move for gbcol",
	3343	:	"//	jsr gbcol   garbage collect",
	3344	:	"//	mov wb xr  remember new sediment size",
	3345	:	"//aloc3	mov xr dnamp  point to first available loc",
	3346	:	"//	aov wa xr alc3a point past new block",
	3347	:	"//	blo xr dname aloc4 jump if there is room now",
	3348	:	"//alc3a	jsr sysmm   try to get more memory",
	3349	:	"//	wtb xr   convert to baus (sgd05)",
	3350	:	"//	add dname xr  bump ptr by amount obtained",
	3351	:	"//	bnz xr aloc3  jump if got more core",
	3352	:	"//	bze dnams alc3b  jump if there was no sediment",
	3353	:	"//	zer dnams   try collecting the sediment",
	3354	:	"//	brn alc2a   ",
	3355	:	"//alc3b	add dname rsmem  get the reserve memory",
	3356	:	"//	zer rsmem   only permissible once",
	3357	:	"//	icv errft   fatal error",
	3358	:	"//	erb 204 memory overflow  ",
	3359	:	"//aloc4	sti allia   save ia",
	3360	:	"//	mov dnams wb  record new sediment size",
	3361	:	"//	mov wb dname  get dynamic end adrs",
	3362	:	"//	sub wb dnamp  compute free store",
	3363	:	"//	btw wb   convert bytes to words",
	3364	:	"//	mti wb   put free store in ia",
	3365	:	"//	mli alfsf   multiply by free store factor",
	3366	:	"//	iov aloc5   jump if overflowed",
	3367	:	"//	mov wb dname  dynamic end adrs",
	3368	:	"//	sub wb dnamb  compute total amount of dynamic",
	3369	:	"//	btw wb   convert to words",
	3370	:	"//	mov aldyn wb  store it",
	3371	:	"//	sbi aldyn   subtract from scaled up free store",
	3372	:	"//	igt aloc5   jump if sufficient free store",
	3373	:	"//	jsr sysmm   try to get more store",
	3374	:	"//	wtb xr   convert to baus (sgd05)",
	3375	:	"//	add dname xr  adjust dynamic end adrs",
	3376	:	"//aloc5	ldi allia   recover ia",
	3377	:	"//	mov wb allsv  restore wb",
	3378	:	"//	brn aloc1   jump back to exit",
	3379	:	"//alocs	prc e 0  entry point",
	3380	:	"//	bgt wa kvmxl alcs2 jump if length exceeds maxlength",
	3381	:	"//	mov wc wa  else copy length",
	3382	:	"//	ctb wa scsi_  compute length of scblk in bytes",
	3383	:	"//	mov xr dnamp  point to next available location",
	3384	:	"//	aov wa xr alcs0 point past block",
	3385	:	"//	blo xr dname alcs1 jump if there is room",
	3386	:	"//alcs0	zer xr   else clear garbage xr value",
	3387	:	"//	jsr alloc   and use standard allocator",
	3388	:	"//	add xr wa  point past end of block to merge",
	3389	:	"//alcs1	mov dnamp xr  set updated storage pointer",
	3390	:	"//	zer -(xr)   store zero chars in last word",
	3391	:	"//	dca wa   decrement length",
	3392	:	"//	sub xr wa  point back to start of block",
	3393	:	"//	mov (xr) =b_scl  set type word",
	3394	:	"//	mov sclen(xr) wc  store length in chars",
	3395	:	"//	exi    return to alocs caller",
	3396	:	"//alcs2	erb 205 string length exceeds value of maxlngth keyword  ",
	3397	:	"//alost	prc e 0  entry point",
	3398	:	"//alst1	mov xr state  point to current end of area",
	3399	:	"//	aov wa xr alst2 point beyond proposed block",
	3400	:	"//	bge xr dnamb alst2 jump if overlap with dynamic area",
	3401	:	"//	mov state xr  else store new pointer",
	3402	:	"//	sub xr wa  point back to start of block",
	3403	:	"//	exi    return to alost caller",
	3404	:	"//alst2	mov alsta wa  save wa",
	3405	:	"//	bge wa *e_sts alst3 skip if requested chunk is large",
	3406	:	"//	mov wa *e_sts  else set to get large enough chunk",
	3407	:	"//alst3	jsr alloc   allocate block to ensure room",
	3408	:	"//	mov dnamp xr  and delete it",
	3409	:	"//	mov wb wa  copy move up amount",
	3410	:	"//	jsr gbcol   call gbcol to move dynamic area up",
	3411	:	"//	mov dnams xr  remember new sediment size",
	3412	:	"//	mov wa alsta  restore wa",
	3413	:	"//	brn alst1   loop back to try again",
	3414	:	"//arith	prc n 3  entry point",
	3415	:	"//	mov xl (xs)+  load right operand",
	3416	:	"//	mov xr (xs)+  load left operand",
	3417	:	"//	mov wa (xl)  get right operand type word",
	3418	:	"//	beq wa =b_icl arth1 jump if integer",
	3419	:	"//	beq wa =b_rcl arth4 jump if real",
	3420	:	"//	mov -(xs) xr  else replace left arg on stack",
	3421	:	"//	mov xr xl  copy left arg pointer",
	3422	:	"//	jsr gtnum   convert to numeric",
	3423	:	"//	mov xl xr  else copy converted result",
	3424	:	"//	mov wa (xl)  get right operand type word",
	3425	:	"//	mov xr (xs)+  reload left argument",
	3426	:	"//	beq wa =b_rcl arth4 jump if right arg is real",
	3427	:	"//arth1	bne (xr) =b_icl arth3 jump if left arg not integer",
	3428	:	"//arth2	ldi icval(xr)   load left operand value",
	3429	:	"//	exi    return to arith caller",
	3430	:	"//arth3	jsr gtnum   convert left arg to numeric",
	3431	:	"//	beq wa =b_icl arth2 jump back if integer-integer",
	3432	:	"//	mov -(xs) xr  put left arg back on stack",
	3433	:	"//	ldi icval(xl)   load right argument value",
	3434	:	"//	itr    convert to real",
	3435	:	"//	jsr rcbld   get real block for right arg, merge",
	3436	:	"//	mov xl xr  copy right arg ptr",
	3437	:	"//	mov xr (xs)+  load left argument",
	3438	:	"//	brn arth5   merge for real-real case",
	3439	:	"//arth4	beq (xr) =b_rcl arth5 jump if left arg real",
	3440	:	"//	jsr gtrea   else convert to real",
	3441	:	"//arth5	ldr rcval(xr)   load left operand value",
	3442	:	"//	exi 3   take real-real exit",
	3443	:	"//arth6	ica xs   pop unwanted left arg",
	3444	:	"//	exi 2   take appropriate error exit",
	3445	:	"//arth7	exi 1   take appropriate error return",
	3446	:	"//asign	prc r 1  entry point (recursive)",
	3447	:	"//asg01	add xl wa  point to variable value",
	3448	:	"//	mov xr (xl)  load variable value",
	3449	:	"//	beq (xr) =b_trt asg02 jump if trapped",
	3450	:	"//	mov (xl) wb  else perform assignment",
	3451	:	"//	zer xl   clear garbage value in xl",
	3452	:	"//	exi    and return to asign caller",
	3453	:	"//asg02	sub xl wa  restore name base",
	3454	:	"//	beq xr =trbkv asg14 jump if keyword variable",
	3455	:	"//	bne xr =trbev asg04 jump if not expression variable",
	3456	:	"//	mov xr evexp(xl)  point to expression",
	3457	:	"//	mov -(xs) wb  store value to assign on stack",
	3458	:	"//	mov wb =num01  set for evaluation by name",
	3459	:	"//	jsr evalx   evaluate expression by name",
	3460	:	"//	mov wb (xs)+  else reload value to assign",
	3461	:	"//	brn asg01   loop back to perform assignment",
	3462	:	"//asg03	ica xs   remove stacked value entry",
	3463	:	"//	exi 1   take failure exit",
	3464	:	"//asg04	mov -(xs) xr  save ptr to first trblk",
	3465	:	"//asg05	mov wc xr  save ptr to this trblk",
	3466	:	"//	mov xr trnxt(xr)  point to next trblk",
	3467	:	"//	beq (xr) =b_trt asg05 loop back if another trblk",
	3468	:	"//	mov xr wc  else point back to last trblk",
	3469	:	"//	mov trval(xr) wb  store value at end of chain",
	3470	:	"//	mov xr (xs)+  restore ptr to first trblk",
	3471	:	"//asg06	mov wb trtyp(xr)  load type code of trblk",
	3472	:	"//	beq wb =trtvl asg08 jump if value trace",
	3473	:	"//	beq wb =trtou asg10 jump if output association",
	3474	:	"//asg07	mov xr trnxt(xr)  point to next trblk on chain",
	3475	:	"//	beq (xr) =b_trt asg06 loop back if another trblk",
	3476	:	"//	exi    else end of chain, return to caller",
	3477	:	"//asg08	bze kvtra asg07  ignore value trace if trace off",
	3478	:	"//	dcv kvtra   else decrement trace count",
	3479	:	"//	bze trfnc(xr) asg09  jump if print trace",
	3480	:	"//	jsr trxeq   else execute function trace",
	3481	:	"//	brn asg07   and loop back",
	3482	:	"//asg09	jsr prtsn   print statement number",
	3483	:	"//	jsr prtnv   print name = value",
	3484	:	"//	brn asg07   loop back for next trblk",
	3485	:	"//asg10	bze kvoup asg07  ignore output assoc if output off",
	3486	:	"//asg1b	mov xl xr  copy trblk pointer",
	3487	:	"//	mov xr trnxt(xr)  point to next trblk",
	3488	:	"//	beq (xr) =b_trt asg1b loop back if another trblk",
	3489	:	"//	mov xr xl  else point back to last trblk",
	3490	:	"//	mov -(xs) trval(xr)  stack value to output",
	3491	:	"//	jsr gtstg   convert to string",
	3492	:	"//asg11	mov wa trfpt(xl)  fcblk ptr",
	3493	:	"//	bze wa asg13  jump if standard output file",
	3494	:	"//asg1a	jsr sysou   call system output routine",
	3495	:	"//	exi    else all done, return to caller",
	3496	:	"//asg12	jsr dtype   call datatype routine",
	3497	:	"//	brn asg11   merge",
	3498	:	"//asg13	beq trter(xl) =v_ter asg1a jump if terminal output",
	3499	:	"//	icv wa   signal standard output",
	3500	:	"//	brn asg1a   use sysou to perform output",
	3501	:	"//asg14	mov xl kvnum(xl)  load keyword number",
	3502	:	"//	beq xl =k_etx asg19 jump if errtext",
	3503	:	"//	mov xr wb  copy value to be assigned",
	3504	:	"//	jsr gtint   convert to integer",
	3505	:	"//	ldi icval(xr)   else load value",
	3506	:	"//	beq xl =k_stl asg16 jump if special case of stlimit",
	3507	:	"//	mfi wa asg18  else get addr integer, test ovflow",
	3508	:	"//	bgt wa mxlen asg18 fail if too large",
	3509	:	"//	beq xl =k_ert asg17 jump if special case of errtype",
	3510	:	"//	beq xl =k_pfl asg21 jump if special case of profile",
	3511	:	"//	beq xl =k_mxl asg24 jump if special case of maxlngth",
	3512	:	"//	beq xl =k_fls asg26 jump if special case of fullscan",
	3513	:	"//	blt xl =k_p__ asg15 jump unless protected",
	3514	:	"//	erb 209 keyword in assignment is protected  ",
	3515	:	"//asg15	mov kvabe(xl) wa  store new value",
	3516	:	"//	exi    return to asign caller",
	3517	:	"//asg16	sbi kvstl   subtract old limit",
	3518	:	"//	adi kvstc   add old counter",
	3519	:	"//	sti kvstc   store course counter value",
	3520	:	"//	ldi kvstl   check if counting suppressed",
	3521	:	"//	ilt asg25   do not refine if so",
	3522	:	"//	mov wa stmcs  refine with counter breakout",
	3523	:	"//	sub wa stmct  values",
	3524	:	"//	mti wa   convert to integer",
	3525	:	"//	ngi    current-start value",
	3526	:	"//	adi kvstc   add in course counter value",
	3527	:	"//	sti kvstc   save refined value",
	3528	:	"//asg25	ldi icval(xr)   reload new limit value",
	3529	:	"//	sti kvstl   store new limit value",
	3530	:	"//	jsr stgcc   recompute countdown counters",
	3531	:	"//	exi    return to asign caller",
	3532	:	"//asg17	ble wa =nini9 error ok to signal if in range",
	3533	:	"//asg18	erb 210 keyword value assigned is negative or too large  ",
	3534	:	"//asg19	mov -(xs) wb  stack value",
	3535	:	"//	jsr gtstg   convert to string",
	3536	:	"//	mov r_etx xr  make assignment",
	3537	:	"//	exi    return to caller",
	3538	:	"//asg21	bgt wa =num02 asg18 moan if not 0,1, or 2",
	3539	:	"//	bze wa asg15  just assign if zero",
	3540	:	"//	bze pfdmp asg22  branch if first assignment",
	3541	:	"//	beq wa pfdmp asg23 also if same value as before",
	3542	:	"//	erb 268 inconsistent value assigned to keyword profile  ",
	3543	:	"//asg22	mov pfdmp wa  note value on first assignment",
	3544	:	"//asg23	mov kvpfl wa  store new value",
	3545	:	"//	jsr stgcc   recompute countdown counts",
	3546	:	"//	jsr systm   get the time",
	3547	:	"//	sti pfstm   fudge some kind of start time",
	3548	:	"//	exi    return to asign caller",
	3549	:	"//asg24	bge wa =mnlen asg15 if acceptable value",
	3550	:	"//	erb 287 value assigned to keyword maxlngth is too small  ",
	3551	:	"//asg26	bnz wa asg15  if acceptable value",
	3552	:	"//	erb 274 value assigned to keyword fullscan is zero  ",
	3553	:	"//asinp	prc r 1  entry point, recursive",
	3554	:	"//	add xl wa  point to variable",
	3555	:	"//	mov xr (xl)  load current contents",
	3556	:	"//	beq (xr) =b_trt asnp1 jump if trapped",
	3557	:	"//	mov (xl) wb  else perform assignment",
	3558	:	"//	zer xl   clear garbage value in xl",
	3559	:	"//	exi    return to asinp caller",
	3560	:	"//asnp1	sub xl wa  restore base pointer",
	3561	:	"//	mov -(xs) pmssl  stack subject string length",
	3562	:	"//	mov -(xs) pmhbs  stack history stack base ptr",
	3563	:	"//	mov -(xs) r_pms  stack subject string pointer",
	3564	:	"//	mov -(xs) pmdfl  stack dot flag",
	3565	:	"//	jsr asign   call full-blown assignment routine",
	3566	:	"//	mov pmdfl (xs)+  restore dot flag",
	3567	:	"//	mov r_pms (xs)+  restore subject string pointer",
	3568	:	"//	mov pmhbs (xs)+  restore history stack base pointer",
	3569	:	"//	mov pmssl (xs)+  restore subject string length",
	3570	:	"//	exi    return to asinp caller",
	3571	:	"//asnp2	mov pmdfl (xs)+  restore dot flag",
	3572	:	"//	mov r_pms (xs)+  restore subject string pointer",
	3573	:	"//	mov pmhbs (xs)+  restore history stack base pointer",
	3574	:	"//	mov pmssl (xs)+  restore subject string length",
	3575	:	"//	exi 1   take failure exit",
	3576	:	"//blkln	prc e 0  entry point",
	3577	:	"//	mov xl wa  copy first word",
	3578	:	"//	lei xl   get entry id (bl_xx)",
	3579	:	"//	bsw xl bl___ bln00 switch on block type",
	3580	:	"//bln00	mov wa num01(xr)  load length",
	3581	:	"//	exi    return to blkln caller",
	3582	:	"//bln01	mov wa num02(xr)  load length from third word",
	3583	:	"//	exi    return to blkln caller",
	3584	:	"//bln02	mov wa *num02  load length (two words)",
	3585	:	"//	exi    return to blkln caller",
	3586	:	"//bln03	mov wa *num03  load length (three words)",
	3587	:	"//	exi    return to blkln caller",
	3588	:	"//bln04	mov wa *num04  load length (four words)",
	3589	:	"//	exi    return to blkln caller",
	3590	:	"//bln05	mov wa *num05  load length",
	3591	:	"//	exi    return to blkln caller",
	3592	:	"//bln06	mov wa *ctsi_  set size of ctblk",
	3593	:	"//	exi    return to blkln caller",
	3594	:	"//bln07	mov wa *icsi_  set size of icblk",
	3595	:	"//	exi    return to blkln caller",
	3596	:	"//bln08	mov xl pddfp(xr)  point to dfblk",
	3597	:	"//	mov wa dfpdl(xl)  load pdblk length from dfblk",
	3598	:	"//	exi    return to blkln caller",
	3599	:	"//bln09	mov wa *rcsi_  set size of rcblk",
	3600	:	"//	exi    return to blkln caller",
	3601	:	"//bln10	mov wa sclen(xr)  load length in characters",
	3602	:	"//	ctb wa scsi_  calculate length in bytes",
	3603	:	"//	exi    return to blkln caller",
	3604	:	"//bln12	mov wa num03(xr)  load length from cdlen/exlen",
	3605	:	"//	exi    return to blkln caller",
	3606	:	"//copyb	prc n 1  entry point",
	3607	:	"//	mov xr (xs)  load argument",
	3608	:	"//	beq xr =nulls cop10 return argument if it is null",
	3609	:	"//	mov wa (xr)  else load type word",
	3610	:	"//	mov wb wa  copy type word",
	3611	:	"//	jsr blkln   get length of argument block",
	3612	:	"//	mov xl xr  copy pointer",
	3613	:	"//	jsr alloc   allocate block of same size",
	3614	:	"//	mov (xs) xr  store pointer to copy",
	3615	:	"//	mvw    copy contents of old block to new",
	3616	:	"//	zer xl   clear garbage xl",
	3617	:	"//	mov xr (xs)  reload pointer to start of copy",
	3618	:	"//	beq wb =b_tbt cop05 jump if table",
	3619	:	"//	beq wb =b_vct cop01 jump if vector",
	3620	:	"//	beq wb =b_pdt cop01 jump if program defined",
	3621	:	"//	bne wb =b_art cop10 return copy if not array",
	3622	:	"//	add xr arofs(xr)  point to prototype field",
	3623	:	"//	brn cop02   jump to merge",
	3624	:	"//cop01	add xr *pdfld  point to pdfld = vcvls",
	3625	:	"//cop02	mov xl (xr)  load next pointer",
	3626	:	"//cop03	bne (xl) =b_trt cop04 jump if not trapped",
	3627	:	"//	mov xl trval(xl)  else point to next value",
	3628	:	"//	brn cop03   and loop back",
	3629	:	"//cop04	mov (xr)+ xl  store real value, bump pointer",
	3630	:	"//	bne xr dnamp cop02 loop back if more to go",
	3631	:	"//	brn cop09   else jump to exit",
	3632	:	"//cop05	zer idval(xr)   zero id to stop dump blowing up",
	3633	:	"//	mov wa *tesi_  set size of teblk",
	3634	:	"//	mov wc *tbbuk  set initial offset",
	3635	:	"//cop06	mov xr (xs)  load table pointer",
	3636	:	"//	beq wc tblen(xr) cop09 jump to exit if all done",
	3637	:	"//	mov wb wc  else copy offset",
	3638	:	"//	sub wb *tenxt  subtract link offset to merge",
	3639	:	"//	add xr wb  next bucket header less link offset",
	3640	:	"//	ica wc   bump offset",
	3641	:	"//cop07	mov xl tenxt(xr)  load pointer to next teblk",
	3642	:	"//	mov tenxt(xr) (xs)  set end of chain pointer in case",
	3643	:	"//	beq (xl) =b_tbt cop06 back for next bucket if chain end",
	3644	:	"//	sub xr wb  point to head of previous block",
	3645	:	"//	mov -(xs) xr  stack ptr to previous block",
	3646	:	"//	mov wa *tesi_  set size of teblk",
	3647	:	"//	jsr alloc   allocate new teblk",
	3648	:	"//	mov -(xs) xr  stack ptr to new teblk",
	3649	:	"//	mvw    copy old teblk to new teblk",
	3650	:	"//	mov xr (xs)+  restore pointer to new teblk",
	3651	:	"//	mov xl (xs)+  restore pointer to previous block",
	3652	:	"//	add xl wb  add offset back in",
	3653	:	"//	mov tenxt(xl) xr  link new block to previous",
	3654	:	"//	mov xl xr  copy pointer to new block",
	3655	:	"//cop08	mov xl teval(xl)  load value",
	3656	:	"//	beq (xl) =b_trt cop08 loop back if trapped",
	3657	:	"//	mov teval(xr) xl  store untrapped value in teblk",
	3658	:	"//	zer wb   zero offset within teblk",
	3659	:	"//	brn cop07   back for next teblk",
	3660	:	"//cop09	mov xr (xs)+  load pointer to block",
	3661	:	"//	exi    return",
	3662	:	"//cop10	exi 1   return",
	3663	:	"//cdgcg	prc e 0  entry point",
	3664	:	"//	mov xl cmopn(xr)  get unary goto operator",
	3665	:	"//	mov xr cmrop(xr)  point to goto operand",
	3666	:	"//	beq xl =opdvd cdgc2 jump if direct goto",
	3667	:	"//	jsr cdgnm   generate opnd by name if not direct",
	3668	:	"//cdgc1	mov wa xl  goto operator",
	3669	:	"//	jsr cdwrd   generate it",
	3670	:	"//	exi    return to caller",
	3671	:	"//cdgc2	jsr cdgvl   generate operand by value",
	3672	:	"//	brn cdgc1   merge to return",
	3673	:	"//cdgex	prc r 0  entry point, recursive",
	3674	:	"//	blo (xl) =b_vr_ cdgx1 jump if not variable",
	3675	:	"//	mov wa *sesi_  set size of seblk",
	3676	:	"//	jsr alloc   allocate space for seblk",
	3677	:	"//	mov (xr) =b_sel  set type word",
	3678	:	"//	mov sevar(xr) xl  store vrblk pointer",
	3679	:	"//	exi    return to cdgex caller",
	3680	:	"//cdgx1	mov xr xl  copy tree pointer",
	3681	:	"//	mov -(xs) wc  save wc",
	3682	:	"//	mov xl cwcof  save current offset",
	3683	:	"//	bze wa cdgx2  jump if by value",
	3684	:	"//	mov wa (xr)  get type word",
	3685	:	"//	bne wa =b_cmt cdgx2 call by value if not cmblk",
	3686	:	"//	bge cmtyp(xr) =c__nm cdgx2 jump if cmblk only by value",
	3687	:	"//	jsr cdgnm   generate code by name",
	3688	:	"//	mov wa =ornm_  load return by name word",
	3689	:	"//	brn cdgx3   merge with value case",
	3690	:	"//cdgx2	jsr cdgvl   generate code by value",
	3691	:	"//	mov wa =orvl_  load return by value word",
	3692	:	"//cdgx3	jsr cdwrd   generate return word",
	3693	:	"//	jsr exbld   build exblk",
	3694	:	"//	mov wc (xs)+  restore wc",
	3695	:	"//	exi    return to cdgex caller",
	3696	:	"//cdgnm	prc r 0  entry point, recursive",
	3697	:	"//	mov -(xs) xl  save entry xl",
	3698	:	"//	mov -(xs) wb  save entry wb",
	3699	:	"//	chk    check for stack overflow",
	3700	:	"//	mov wa (xr)  load type word",
	3701	:	"//	beq wa =b_cmt cgn04 jump if cmblk",
	3702	:	"//	bhi wa =b_vr_ cgn02 jump if simple variable",
	3703	:	"//cgn01	erb 212 syntax error: value used where name is required  ",
	3704	:	"//cgn02	mov wa =olvn_  load variable load call",
	3705	:	"//	jsr cdwrd   generate it",
	3706	:	"//	mov wa xr  copy vrblk pointer",
	3707	:	"//	jsr cdwrd   generate vrblk pointer",
	3708	:	"//cgn03	mov wb (xs)+  restore entry wb",
	3709	:	"//	mov xl (xs)+  restore entry xl",
	3710	:	"//	exi    return to cdgnm caller",
	3711	:	"//cgn04	mov xl xr  copy cmblk pointer",
	3712	:	"//	mov xr cmtyp(xr)  load cmblk type",
	3713	:	"//	bge xr =c__nm cgn01 error if not name operand",
	3714	:	"//	bsw xr c__nm  else switch on type",
	3715	:	"//cgn05	mov wb *cmopn  point to array operand",
	3716	:	"//cgn06	jsr cmgen   generate code for next operand",
	3717	:	"//	mov wc cmlen(xl)  load length of cmblk",
	3718	:	"//	blt wb wc cgn06 loop till all generated",
	3719	:	"//	mov wa =oaon_  load one-subscript case call",
	3720	:	"//	beq wc *cmar1 cgn07 jump to exit if one subscript case",
	3721	:	"//	mov wa =oamn_  else load multi-subscript case call",
	3722	:	"//	jsr cdwrd   generate call",
	3723	:	"//	mov wa wc  copy cmblk length",
	3724	:	"//	btw wa   convert to words",
	3725	:	"//	sub wa =cmvls  calculate number of subscripts",
	3726	:	"//cgn07	mnz wc   set result non-constant",
	3727	:	"//	jsr cdwrd   generate word",
	3728	:	"//	brn cgn03   back to exit",
	3729	:	"//cgn08	mov xr xl  copy cmblk pointer",
	3730	:	"//	jsr cdgvl   gen code by value for call",
	3731	:	"//	mov wa =ofne_  get extra call for by name",
	3732	:	"//	brn cgn07   back to generate and exit",
	3733	:	"//cgn09	mov xr cmrop(xl)  check if variable",
	3734	:	"//	bhi (xr) =b_vr_ cgn02 treat *variable as simple var",
	3735	:	"//	mov xl xr  copy ptr to expression tree",
	3736	:	"//	mov wa =num01  return name",
	3737	:	"//	jsr cdgex   else build exblk",
	3738	:	"//	mov wa =olex_  set call to load expr by name",
	3739	:	"//	jsr cdwrd   generate it",
	3740	:	"//	mov wa xr  copy exblk pointer",
	3741	:	"//	jsr cdwrd   generate exblk pointer",
	3742	:	"//	brn cgn03   back to exit",
	3743	:	"//cgn10	mov xr cmrop(xl)  get operand",
	3744	:	"//	jsr cdgvl   generate code by value for it",
	3745	:	"//	mov wa =oinn_  load call for indirect by name",
	3746	:	"//	brn cgn12   merge",
	3747	:	"//cgn11	mov xr cmrop(xl)  get operand",
	3748	:	"//	jsr cdgnm   generate code by name for it",
	3749	:	"//	mov wa =okwn_  load call for keyword by name",
	3750	:	"//cgn12	jsr cdwrd   generate code for operator",
	3751	:	"//	brn cgn03   exit",
	3752	:	"//cdgvl	prc r 0  entry point, recursive",
	3753	:	"//	mov wa (xr)  load type word",
	3754	:	"//	beq wa =b_cmt cgv01 jump if cmblk",
	3755	:	"//	blt wa =b_vra cgv00 jump if icblk, rcblk, scblk",
	3756	:	"//	bnz vrlen(xr) cgvl0  jump if not system variable",
	3757	:	"//	mov -(xs) xr  stack xr",
	3758	:	"//	mov xr vrsvp(xr)  point to svblk",
	3759	:	"//	mov wa svbit(xr)  get svblk property bits",
	3760	:	"//	mov xr (xs)+  recover xr",
	3761	:	"//	anb wa 4,btkwv  check if constant keyword value",
	3762	:	"//	beq wa 4,btkwv cgv00 jump if constant keyword value",
	3763	:	"//cgvl0	mnz wc   indicate non-constant value",
	3764	:	"//cgv00	mov wa xr  copy ptr to var or constant",
	3765	:	"//	jsr cdwrd   generate as code word",
	3766	:	"//	exi    return to caller",
	3767	:	"//cgv01	mov -(xs) wb  save entry wb",
	3768	:	"//	mov -(xs) xl  save entry xl",
	3769	:	"//	mov -(xs) wc  save entry constant flag",
	3770	:	"//	mov -(xs) cwcof  save initial code offset",
	3771	:	"//	chk    check for stack overflow",
	3772	:	"//	mov xl xr  copy cmblk pointer",
	3773	:	"//	mov xr cmtyp(xr)  load cmblk type",
	3774	:	"//	mov wc cswno  reset constant flag",
	3775	:	"//	ble xr =c_pr_ cgv02 jump if not predicate value",
	3776	:	"//	mnz wc   else force non-constant case",
	3777	:	"//cgv02	bsw xr c__nv  switch to appropriate generator",
	3778	:	"//cgv03	mov wb *cmopn  set offset to array operand",
	3779	:	"//cgv04	jsr cmgen   gen value code for next operand",
	3780	:	"//	mov wc cmlen(xl)  load cmblk length",
	3781	:	"//	blt wb wc cgv04 loop back if more to go",
	3782	:	"//	mov wa =oaov_  set one subscript call in case",
	3783	:	"//	beq wc *cmar1 cgv32 jump to exit if 1-sub case",
	3784	:	"//	mov wa =oamv_  else set call for multi-subscripts",
	3785	:	"//	jsr cdwrd   generate call",
	3786	:	"//	mov wa wc  copy length of cmblk",
	3787	:	"//	sub wa *cmvls  subtract standard length",
	3788	:	"//	btw wa   get number of words",
	3789	:	"//	brn cgv32   jump to generate subscript count",
	3790	:	"//cgv05	mov wb *cmvls  set offset to first argument",
	3791	:	"//cgv06	beq wb cmlen(xl) cgv07 jump if all generated",
	3792	:	"//	jsr cmgen   else gen value code for next arg",
	3793	:	"//	brn cgv06   back to generate next argument",
	3794	:	"//cgv07	sub wb *cmvls  get number of arg ptrs (bytes)",
	3795	:	"//	btw wb   convert bytes to words",
	3796	:	"//	mov xr cmopn(xl)  load function vrblk pointer",
	3797	:	"//	bnz vrlen(xr) cgv12  jump if not system function",
	3798	:	"//	mov xl vrsvp(xr)  load svblk ptr if system var",
	3799	:	"//	mov wa svbit(xl)  load bit mask",
	3800	:	"//	anb wa 4,btffc  test for fast function call allowed",
	3801	:	"//	zrb wa cgv12  jump if not",
	3802	:	"//	mov wa svbit(xl)  reload bit indicators",
	3803	:	"//	anb wa 4,btpre  test for preevaluation ok",
	3804	:	"//	nzb wa cgv08  jump if preevaluation permitted",
	3805	:	"//	mnz wc   else set result non-constant",
	3806	:	"//cgv08	mov xl vrfnc(xr)  load ptr to svfnc field",
	3807	:	"//	mov wa fargs(xl)  load svnar field value",
	3808	:	"//	beq wa wb cgv11 jump if argument count is correct",
	3809	:	"//	bhi wa wb cgv09 jump if too few arguments given",
	3810	:	"//	sub wb wa  get number of extra args",
	3811	:	"//	lct wb wb  set as count to control loop",
	3812	:	"//	mov wa =opop_  set pop call",
	3813	:	"//	brn cgv10   jump to common loop",
	3814	:	"//cgv09	sub wa wb  get number of missing arguments",
	3815	:	"//	lct wb wa  load as count to control loop",
	3816	:	"//	mov wa =nulls  load ptr to null constant",
	3817	:	"//cgv10	jsr cdwrd   generate one call",
	3818	:	"//	bct wb cgv10  loop till all generated",
	3819	:	"//cgv11	mov wa xl  copy pointer to svfnc field",
	3820	:	"//	brn cgv36   jump to generate call",
	3821	:	"//cgv12	mov wa =ofns_  set one arg call in case",
	3822	:	"//	beq wb =num01 cgv13 jump if one arg case",
	3823	:	"//	mov wa =ofnc_  else load call for more than 1 arg",
	3824	:	"//	jsr cdwrd   generate it",
	3825	:	"//	mov wa wb  copy argument count",
	3826	:	"//cgv13	jsr cdwrd   generate =o_fns or arg count",
	3827	:	"//	mov wa xr  copy vrblk pointer",
	3828	:	"//	brn cgv32   jump to generate vrblk ptr",
	3829	:	"//cgv14	mov xl cmrop(xl)  point to expression tree",
	3830	:	"//	zer wa   return value",
	3831	:	"//	jsr cdgex   build exblk or seblk",
	3832	:	"//	mov wa xr  copy block ptr",
	3833	:	"//	jsr cdwrd   generate ptr to exblk or seblk",
	3834	:	"//	brn cgv34   jump to exit, constant test",
	3835	:	"//cgv15	zer -(xs)   zero ptr to chain of forward jumps",
	3836	:	"//	zer -(xs)   zero ptr to prev o_slc forward ptr",
	3837	:	"//	mov wb *cmvls  point to first alternative",
	3838	:	"//	mov wa =osla_  set initial code word",
	3839	:	"//cgv16	jsr cdwrd   generate o_slc (o_sla first time)",
	3840	:	"//	mov (xs) cwcof  set current loc as ptr to fill in",
	3841	:	"//	jsr cdwrd   generate garbage word there for now",
	3842	:	"//	jsr cmgen   gen value code for alternative",
	3843	:	"//	mov wa =oslb_  load o_slb pointer",
	3844	:	"//	jsr cdwrd   generate o_slb call",
	3845	:	"//	mov wa num01(xs)  load old chain ptr",
	3846	:	"//	mov num01(xs) cwcof  set current loc as new chain head",
	3847	:	"//	jsr cdwrd   generate forward chain link",
	3848	:	"//	mov xr (xs)  load offset to word to plug",
	3849	:	"//	add xr r_ccb  point to actual location to plug",
	3850	:	"//	mov (xr) cwcof  plug proper offset in",
	3851	:	"//	mov wa =oslc_  load o_slc ptr for next alternative",
	3852	:	"//	mov xr wb  copy offset (destroy garbage xr)",
	3853	:	"//	ica xr   bump extra time for test",
	3854	:	"//	blt xr cmlen(xl) cgv16 loop back if not last alternative",
	3855	:	"//	mov wa =osld_  get header call",
	3856	:	"//	jsr cdwrd   generate o_sld call",
	3857	:	"//	jsr cmgen   generate code for last alternative",
	3858	:	"//	ica xs   pop offset ptr",
	3859	:	"//	mov xr (xs)+  load chain ptr",
	3860	:	"//cgv17	add xr r_ccb  make next ptr absolute",
	3861	:	"//	mov wa (xr)  load forward ptr",
	3862	:	"//	mov (xr) cwcof  plug required offset",
	3863	:	"//	mov xr wa  copy forward ptr",
	3864	:	"//	bnz wa cgv17  loop back if more to go",
	3865	:	"//	brn cgv33   else jump to exit (not constant)",
	3866	:	"//cgv18	mov xr cmlop(xl)  load left operand pointer",
	3867	:	"//	jsr cdgvl   gen value code for left operand",
	3868	:	"//cgv19	mov xr cmrop(xl)  load right (only) operand ptr",
	3869	:	"//	jsr cdgvl   gen code by value",
	3870	:	"//cgv20	mov wa cmopn(xl)  load operator call pointer",
	3871	:	"//	brn cgv36   jump to generate it with cons test",
	3872	:	"//cgv21	mov xr cmlop(xl)  load left operand pointer",
	3873	:	"//	blo (xr) =b_vr_ cgv22 jump if not variable",
	3874	:	"//	mov xr cmrop(xl)  load right operand ptr",
	3875	:	"//	jsr cdgvl   generate code by value",
	3876	:	"//	mov wa cmlop(xl)  reload left operand vrblk ptr",
	3877	:	"//	add wa *vrsto  point to vrsto field",
	3878	:	"//	brn cgv32   jump to generate store ptr",
	3879	:	"//cgv22	jsr expap   test for pattern match on left side",
	3880	:	"//	mov cmlop(xl) cmrop(xr)  save pattern ptr in safe place",
	3881	:	"//	mov xr cmlop(xr)  load subject ptr",
	3882	:	"//	jsr cdgnm   gen code by name for subject",
	3883	:	"//	mov xr cmlop(xl)  load pattern ptr",
	3884	:	"//	jsr cdgvl   gen code by value for pattern",
	3885	:	"//	mov wa =opmn_  load match by name call",
	3886	:	"//	jsr cdwrd   generate it",
	3887	:	"//	mov xr cmrop(xl)  load replacement value ptr",
	3888	:	"//	jsr cdgvl   gen code by value",
	3889	:	"//	mov wa =orpl_  load replace call",
	3890	:	"//	brn cgv32   jump to gen and exit (not constant)",
	3891	:	"//cgv23	mnz wc   inhibit pre-evaluation",
	3892	:	"//	jsr cdgnm   gen code by name for left side",
	3893	:	"//	brn cgv31   merge with unop circuit",
	3894	:	"//cgv24	mov xr cmlop(xl)  load left operand ptr",
	3895	:	"//	bne (xr) =b_cmt cgv18 ordinary binop if not cmblk",
	3896	:	"//	mov wb cmtyp(xr)  load cmblk type code",
	3897	:	"//	beq wb =c_int cgv25 special case if interrogation",
	3898	:	"//	beq wb =c_neg cgv25 or negation",
	3899	:	"//	bne wb =c_fnc cgv18 else ordinary binop if not function",
	3900	:	"//	mov xr cmopn(xr)  else load function vrblk ptr",
	3901	:	"//	bnz vrlen(xr) cgv18  ordinary binop if not system var",
	3902	:	"//	mov xr vrsvp(xr)  else point to svblk",
	3903	:	"//	mov wa svbit(xr)  load bit indicators",
	3904	:	"//	anb wa 4,btprd  test for predicate function",
	3905	:	"//	zrb wa cgv18  ordinary binop if not",
	3906	:	"//cgv25	mov xr cmlop(xl)  reload left arg",
	3907	:	"//	jsr cdgvl   gen code by value",
	3908	:	"//	mov wa =opop_  load pop call",
	3909	:	"//	jsr cdwrd   generate it",
	3910	:	"//	mov xr cmrop(xl)  load right operand",
	3911	:	"//	jsr cdgvl   gen code by value as result code",
	3912	:	"//	brn cgv33   exit (not constant)",
	3913	:	"//cgv26	mov xr cmlop(xl)  load left operand",
	3914	:	"//	jsr cdgvl   gen code by value, merge",
	3915	:	"//cgv27	mov xr cmrop(xl)  load right operand ptr",
	3916	:	"//	jsr cdgnm   gen code by name for right arg",
	3917	:	"//	mov xr cmopn(xl)  get operator code word",
	3918	:	"//	bne (xr) =o_kwv cgv20 gen call unless keyword value",
	3919	:	"//	bnz wc cgv20  gen call if non-constant (not var)",
	3920	:	"//	mnz wc   else set non-constant in case",
	3921	:	"//	mov xr cmrop(xl)  load ptr to operand vrblk",
	3922	:	"//	bnz vrlen(xr) cgv20  gen (non-constant) if not sys var",
	3923	:	"//	mov xr vrsvp(xr)  else load ptr to svblk",
	3924	:	"//	mov wa svbit(xr)  load bit mask",
	3925	:	"//	anb wa 4,btckw  test for constant keyword",
	3926	:	"//	zrb wa cgv20  go gen if not constant",
	3927	:	"//	zer wc   else set result constant",
	3928	:	"//	brn cgv20   and jump back to generate call",
	3929	:	"//cgv28	mov wa =onta_  get initial word",
	3930	:	"//	jsr cdwrd   generate it",
	3931	:	"//	mov wb cwcof  save next offset",
	3932	:	"//	jsr cdwrd   generate gunk word for now",
	3933	:	"//	mov xr cmrop(xl)  load right operand ptr",
	3934	:	"//	jsr cdgvl   gen code by value",
	3935	:	"//	mov wa =ontb_  load end of evaluation call",
	3936	:	"//	jsr cdwrd   generate it",
	3937	:	"//	mov xr wb  copy offset to word to plug",
	3938	:	"//	add xr r_ccb  point to actual word to plug",
	3939	:	"//	mov (xr) cwcof  plug word with current offset",
	3940	:	"//	mov wa =ontc_  load final call",
	3941	:	"//	brn cgv32   jump to generate it (not constant)",
	3942	:	"//cgv29	mov xr cmlop(xl)  load left operand ptr",
	3943	:	"//	jsr cdgvl   generate code by value",
	3944	:	"//cgv30	mov wb =c_uo_  set unop code + 1",
	3945	:	"//	sub wb cmtyp(xl)  set number of args (1 or 2)",
	3946	:	"//	mov xr cmrop(xl)  load right (only) operand pointer",
	3947	:	"//	jsr cdgvl   gen value code for right operand",
	3948	:	"//	mov xr cmopn(xl)  load pointer to operator dv",
	3949	:	"//	mov xr dvopn(xr)  load pointer offset",
	3950	:	"//	wtb xr   convert word offset to bytes",
	3951	:	"//	add xr =r_uba  point to proper function ptr",
	3952	:	"//	sub xr *vrfnc  set standard function offset",
	3953	:	"//	brn cgv12   merge with function call circuit",
	3954	:	"//cgv31	mnz wc   set non constant",
	3955	:	"//	brn cgv19   merge",
	3956	:	"//cgv32	jsr cdwrd   generate word, merge",
	3957	:	"//cgv33	mnz wc   indicate result is not constant",
	3958	:	"//cgv34	ica xs   pop initial code offset",
	3959	:	"//	mov wa (xs)+  restore old constant flag",
	3960	:	"//	mov xl (xs)+  restore entry xl",
	3961	:	"//	mov wb (xs)+  restore entry wb",
	3962	:	"//	bnz wc cgv35  jump if not constant",
	3963	:	"//	mov wc wa  else restore entry constant flag",
	3964	:	"//cgv35	exi    return to cdgvl caller",
	3965	:	"//cgv36	jsr cdwrd   generate word",
	3966	:	"//	bnz wc cgv34  jump to exit if not constant",
	3967	:	"//	mov wa =orvl_  load call to return value",
	3968	:	"//	jsr cdwrd   generate it",
	3969	:	"//	mov xl (xs)  load initial code offset",
	3970	:	"//	jsr exbld   build exblk for expression",
	3971	:	"//	zer wb   set to evaluate by value",
	3972	:	"//	jsr evalx   evaluate expression",
	3973	:	"//	mov wa (xr)  load type word of result",
	3974	:	"//	blo wa =p_aaa cgv37 jump if not pattern",
	3975	:	"//	mov wa =olpt_  else load special pattern load call",
	3976	:	"//	jsr cdwrd   generate it",
	3977	:	"//cgv37	mov wa xr  copy constant pointer",
	3978	:	"//	jsr cdwrd   generate ptr",
	3979	:	"//	zer wc   set result constant",
	3980	:	"//	brn cgv34   jump back to exit",
	3981	:	"//cdwrd	prc e 0  entry point",
	3982	:	"//	mov -(xs) xr  save entry xr",
	3983	:	"//	mov -(xs) wa  save code word to be generated",
	3984	:	"//cdwd1	mov xr r_ccb  load ptr to ccblk being built",
	3985	:	"//	bnz xr cdwd2  jump if block allocated",
	3986	:	"//	mov wa *e_cbs  load initial length",
	3987	:	"//	jsr alloc   allocate ccblk",
	3988	:	"//	mov (xr) =b_cct  store type word",
	3989	:	"//	mov cwcof *cccod  set initial offset",
	3990	:	"//	mov cclen(xr) wa  store block length",
	3991	:	"//	zer ccsln(xr)   zero line number",
	3992	:	"//	mov r_ccb xr  store ptr to new block",
	3993	:	"//cdwd2	mov wa cwcof  load current offset",
	3994	:	"//	add wa *num05  adjust for test (five words)",
	3995	:	"//	blo wa cclen(xr) cdwd4 jump if room in this block",
	3996	:	"//	bge wa mxlen cdwd5 jump if already at max size",
	3997	:	"//	add wa *e_cbs  else get new size",
	3998	:	"//	mov -(xs) xl  save entry xl",
	3999	:	"//	mov xl xr  copy pointer",
	4000	:	"//	blt wa mxlen cdwd3 jump if not too large",
	4001	:	"//	mov wa mxlen  else reset to max allowed size",
	4002	:	"//cdwd3	jsr alloc   allocate new block",
	4003	:	"//	mov r_ccb xr  store pointer to new block",
	4004	:	"//	mov (xr)+ =b_cct  store type word in new block",
	4005	:	"//	mov (xr)+ wa  store block length",
	4006	:	"//	mov (xr)+ ccsln(xl)  copy source line number word",
	4007	:	"//	add xl *ccuse  point to ccuse,cccod fields in old",
	4008	:	"//	mov wa (xl)  load ccuse value",
	4009	:	"//	mvw    copy useful words from old block",
	4010	:	"//	mov xl (xs)+  restore xl",
	4011	:	"//	brn cdwd1   merge back to try again",
	4012	:	"//cdwd4	mov wa cwcof  load current offset",
	4013	:	"//	ica wa   get new offset",
	4014	:	"//	mov cwcof wa  store new offset",
	4015	:	"//	mov ccuse(xr) wa  store in ccblk for gbcol",
	4016	:	"//	dca wa   restore ptr to this word",
	4017	:	"//	add xr wa  point to current entry",
	4018	:	"//	mov wa (xs)+  reload word to generate",
	4019	:	"//	mov (xr) wa  store word in block",
	4020	:	"//	mov xr (xs)+  restore entry xr",
	4021	:	"//	exi    return to caller",
	4022	:	"//cdwd5	erb 213 syntax error: statement is too complicated.  ",
	4023	:	"//cmgen	prc r 0  entry point, recursive",
	4024	:	"//	mov xr xl  copy cmblk pointer",
	4025	:	"//	add xr wb  point to cmblk pointer",
	4026	:	"//	mov xr (xr)  load cmblk pointer",
	4027	:	"//	jsr cdgvl   generate code by value",
	4028	:	"//	ica wb   bump offset",
	4029	:	"//	exi    return to caller",
	4030	:	"//cmpil	prc e 0  entry point",
	4031	:	"//	lct wb =cmnen  set number of stack work locations",
	4032	:	"//cmp00	zer -(xs)   store a zero, make one entry",
	4033	:	"//	bct wb cmp00  loop back until all set",
	4034	:	"//	mov cmpxs xs  save stack pointer for error sec",
	4035	:	"//	sss cmpss   save s-r stack pointer if any",
	4036	:	"//cmp01	mov wb scnpt  set scan pointer offset",
	4037	:	"//	mov scnse wb  set start of element location",
	4038	:	"//	mov wa =ocer_  point to compile error call",
	4039	:	"//	jsr cdwrd   generate as temporary cdfal",
	4040	:	"//	blt wb scnil cmp04 jump if chars left on this image",
	4041	:	"//cmpce	zer xr   clear possible garbage xr value",
	4042	:	"//	bnz cnind cmpc2  if within include file",
	4043	:	"//	bne stage =stgic cmp02 skip unless initial compile",
	4044	:	"//cmpc2	jsr readr   read next input image",
	4045	:	"//	bze xr cmp09  jump if no input available",
	4046	:	"//	jsr nexts   acquire next source image",
	4047	:	"//	mov lstsn cmpsn  store stmt no for use by listr",
	4048	:	"//	mov cmpln rdcln  store line number at start of stmt",
	4049	:	"//	zer scnpt   reset scan pointer",
	4050	:	"//	brn cmp04   go process image",
	4051	:	"//cmp02	mov xr r_cim  get current image",
	4052	:	"//	mov wb scnpt  get current offset",
	4053	:	"//	plc xr wb  prepare to get chars",
	4054	:	"//cmp03	bge scnpt scnil cmp09 end loop if end of image",
	4055	:	"//	lch wc (xr)+  get char",
	4056	:	"//	icv scnpt   advance offset",
	4057	:	"//	bne wc =ch_sm cmp03 loop if not semi-colon",
	4058	:	"//cmp04	mov xr r_cim  point to current image",
	4059	:	"//	mov wb scnpt  load current offset",
	4060	:	"//	mov wa wb  copy for label scan",
	4061	:	"//	plc xr wb  point to first character",
	4062	:	"//	lch wc (xr)+  load first character",
	4063	:	"//	beq wc =ch_sm cmp12 no label if semicolon",
	4064	:	"//	beq wc =ch_as cmpce loop back if comment card",
	4065	:	"//	beq wc =ch_mn cmp32 jump if control card",
	4066	:	"//	mov r_cmp r_cim  about to destroy r_cim",
	4067	:	"//	mov xl =cmlab  point to label work string",
	4068	:	"//	mov r_cim xl  scane is to scan work string",
	4069	:	"//	psc xl   point to first character position",
	4070	:	"//	sch wc (xl)+  store char just loaded",
	4071	:	"//	mov wc =ch_sm  get a semicolon",
	4072	:	"//	sch wc (xl)  store after first char",
	4073	:	"//	csc xl   finished character storing",
	4074	:	"//	zer xl   clear pointer",
	4075	:	"//	zer scnpt   start at first character",
	4076	:	"//	mov -(xs) scnil  preserve image length",
	4077	:	"//	mov scnil =num02  read 2 chars at most",
	4078	:	"//	jsr scane   scan first char for type",
	4079	:	"//	mov scnil (xs)+  restore image length",
	4080	:	"//	mov wc xl  note return code",
	4081	:	"//	mov xl r_cmp  get old r_cim",
	4082	:	"//	mov r_cim xl  put it back",
	4083	:	"//	mov scnpt wb  reinstate offset",
	4084	:	"//	bnz scnbl cmp12  blank seen - cant be label",
	4085	:	"//	mov xr xl  point to current image",
	4086	:	"//	plc xr wb  point to first char again",
	4087	:	"//	beq wc =t_var cmp06 ok if letter",
	4088	:	"//	beq wc =t_con cmp06 ok if digit",
	4089	:	"//cmple	mov r_cim r_cmp  point to bad line",
	4090	:	"//	erb 214 bad label or misplaced continuation line  ",
	4091	:	"//cmp05	beq wc =ch_sm cmp07 skip if semicolon",
	4092	:	"//	icv wa   bump offset",
	4093	:	"//	beq wa scnil cmp07 jump if end of image (label end)",
	4094	:	"//cmp06	lch wc (xr)+  else load next character",
	4095	:	"//	beq wc =ch_ht cmp07 jump if horizontal tab",
	4096	:	"//	bne wc =ch_bl cmp05 loop back if non-blank",
	4097	:	"//cmp07	mov scnpt wa  save updated scan offset",
	4098	:	"//	sub wa wb  get length of label",
	4099	:	"//	bze wa cmp12  skip if label length zero",
	4100	:	"//	zer xr   clear garbage xr value",
	4101	:	"//	jsr sbstr   build scblk for label name",
	4102	:	"//	jsr gtnvr   locate/contruct vrblk",
	4103	:	"//	mov cmlbl(xs) xr  store label pointer",
	4104	:	"//	bnz vrlen(xr) cmp11  jump if not system label",
	4105	:	"//	bne vrsvp(xr) =v_end cmp11 jump if not end label",
	4106	:	"//	add stage =stgnd  adjust stage appropriately",
	4107	:	"//	jsr scane   scan out next element",
	4108	:	"//	beq xl =t_smc cmp10 jump if end of image",
	4109	:	"//	bne xl =t_var cmp08 else error if not variable",
	4110	:	"//	beq vrlbl(xr) =stndl cmp08 jump if not defined (error)",
	4111	:	"//	mov cmtra(xs) vrlbl(xr)  else set initial entry pointer",
	4112	:	"//	jsr scane   scan next element",
	4113	:	"//	beq xl =t_smc cmp10 jump if ok (end of image)",
	4114	:	"//cmp08	erb 215 syntax error: undefined or erroneous entry label  ",
	4115	:	"//cmp09	zer xr   clear garbage xr value",
	4116	:	"//	add stage =stgnd  adjust stage appropriately",
	4117	:	"//	beq stage =stgxe cmp10 jump if code call (ok)",
	4118	:	"//	erb 216 syntax error: missing end line  ",
	4119	:	"//cmp10	mov wa =ostp_  set stop call pointer",
	4120	:	"//	jsr cdwrd   generate as statement call",
	4121	:	"//	brn cmpse   jump to generate as failure",
	4122	:	"//cmp11	bne stage =stgic cmp12 jump if code call - redef. ok",
	4123	:	"//	beq vrlbl(xr) =stndl cmp12 else check for redefinition",
	4124	:	"//	zer cmlbl(xs)   leave first label decln undisturbed",
	4125	:	"//	erb 217 syntax error: duplicate label  ",
	4126	:	"//cmp12	zer wb   set flag for statement body",
	4127	:	"//	jsr expan   get tree for statement body",
	4128	:	"//	mov cmstm(xs) xr  store for later use",
	4129	:	"//	zer cmsgo(xs)   clear success goto pointer",
	4130	:	"//	zer cmfgo(xs)   clear failure goto pointer",
	4131	:	"//	zer cmcgo(xs)   clear conditional goto flag",
	4132	:	"//	jsr scane   scan next element",
	4133	:	"//	beq xl =t_col cmp13 jump if colon (goto)",
	4134	:	"//	bnz cswno cmp18  jump if not optimizing",
	4135	:	"//	bnz cmlbl(xs) cmp18  jump if label present",
	4136	:	"//	mov xr cmstm(xs)  load tree ptr for statement body",
	4137	:	"//	mov wa (xr)  load type word",
	4138	:	"//	beq wa =b_cmt cmp18 jump if cmblk",
	4139	:	"//	bge wa =b_vra cmp18 jump if not icblk, scblk, or rcblk",
	4140	:	"//	mov xl r_ccb  load ptr to ccblk",
	4141	:	"//	mov ccuse(xl) *cccod  reset use offset in ccblk",
	4142	:	"//	mov cwcof *cccod  and in global",
	4143	:	"//	icv cmpsn   bump statement number",
	4144	:	"//	brn cmp01   generate no code for statement",
	4145	:	"//cmp13	mnz scngo   set goto flag",
	4146	:	"//	jsr scane   scan next element",
	4147	:	"//	beq xl =t_smc cmp31 jump if no fields left",
	4148	:	"//	beq xl =t_sgo cmp14 jump if s for success goto",
	4149	:	"//	beq xl =t_fgo cmp16 jump if f for failure goto",
	4150	:	"//	mnz scnrs   set to rescan element not f,s",
	4151	:	"//	jsr scngf   scan out goto field",
	4152	:	"//	bnz cmfgo(xs) cmp17  error if fgoto already",
	4153	:	"//	mov cmfgo(xs) xr  else set as fgoto",
	4154	:	"//	brn cmp15   merge with sgoto circuit",
	4155	:	"//cmp14	jsr scngf   scan success goto field",
	4156	:	"//	mov cmcgo(xs) =num01  set conditional goto flag",
	4157	:	"//cmp15	bnz cmsgo(xs) cmp17  error if sgoto already given",
	4158	:	"//	mov cmsgo(xs) xr  else set sgoto",
	4159	:	"//	brn cmp13   loop back for next goto field",
	4160	:	"//cmp16	jsr scngf   scan goto field",
	4161	:	"//	mov cmcgo(xs) =num01  set conditonal goto flag",
	4162	:	"//	bnz cmfgo(xs) cmp17  error if fgoto already given",
	4163	:	"//	mov cmfgo(xs) xr  else store fgoto pointer",
	4164	:	"//	brn cmp13   loop back for next field",
	4165	:	"//cmp17	erb 218 syntax error: duplicated goto field  ",
	4166	:	"//cmp18	zer scnse   stop positional error flags",
	4167	:	"//	mov xr cmstm(xs)  load tree ptr for statement body",
	4168	:	"//	zer wb   collectable value for wb for cdgvl",
	4169	:	"//	zer wc   reset constant flag for cdgvl",
	4170	:	"//	jsr expap   test for pattern match",
	4171	:	"//	mov cmopn(xr) =opms_  else set pattern match pointer",
	4172	:	"//	mov cmtyp(xr) =c_pmt  ",
	4173	:	"//cmp19	jsr cdgvl   generate code for body of statement",
	4174	:	"//	mov xr cmsgo(xs)  load sgoto pointer",
	4175	:	"//	mov wa xr  copy it",
	4176	:	"//	bze xr cmp21  jump if no success goto",
	4177	:	"//	zer cmsoc(xs)   clear success offset fillin ptr",
	4178	:	"//	bhi xr state cmp20 jump if complex goto",
	4179	:	"//	add wa *vrtra  point to vrtra field as required",
	4180	:	"//	jsr cdwrd   generate success goto",
	4181	:	"//	brn cmp22   jump to deal with fgoto",
	4182	:	"//cmp20	beq xr cmfgo(xs) cmp22 no code if same as fgoto",
	4183	:	"//	zer wb   else set ok value for cdgvl in wb",
	4184	:	"//	jsr cdgcg   generate code for success goto",
	4185	:	"//	brn cmp22   jump to deal with fgoto",
	4186	:	"//cmp21	mov cmsoc(xs) cwcof  set success fill in offset",
	4187	:	"//	mov wa =ocer_  point to compile error call",
	4188	:	"//	jsr cdwrd   generate as temporary value",
	4189	:	"//cmp22	mov xr cmfgo(xs)  load failure goto pointer",
	4190	:	"//	mov wa xr  copy it",
	4191	:	"//	zer cmffc(xs)   set no fill in required yet",
	4192	:	"//	bze xr cmp23  jump if no failure goto given",
	4193	:	"//	add wa *vrtra  point to vrtra field in case",
	4194	:	"//	blo xr state cmpse jump to gen if simple fgoto",
	4195	:	"//	mov wb cwcof  save offset to o_gof call",
	4196	:	"//	mov wa =ogof_  point to failure goto call",
	4197	:	"//	jsr cdwrd   generate",
	4198	:	"//	mov wa =ofif_  point to fail in fail word",
	4199	:	"//	jsr cdwrd   generate",
	4200	:	"//	jsr cdgcg   generate code for failure goto",
	4201	:	"//	mov wa wb  copy offset to o_gof for cdfal",
	4202	:	"//	mov wb =b_cdc  set complex case cdtyp",
	4203	:	"//	brn cmp25   jump to build cdblk",
	4204	:	"//cmp23	mov wa =ounf_  load unexpected failure call in cas",
	4205	:	"//	mov wc cswfl  get -nofail flag",
	4206	:	"//	orb wc cmcgo(xs)  check if conditional goto",
	4207	:	"//	zrb wc cmpse  jump if -nofail and no cond. goto",
	4208	:	"//	mnz cmffc(xs)   else set fill in flag",
	4209	:	"//	mov wa =ocer_  and set compile error for temporary",
	4210	:	"//cmpse	mov wb =b_cds  set cdtyp for simple case",
	4211	:	"//cmp25	mov xr r_ccb  point to ccblk",
	4212	:	"//	mov xl cmlbl(xs)  get possible label pointer",
	4213	:	"//	bze xl cmp26  skip if no label",
	4214	:	"//	zer cmlbl(xs)   clear flag for next statement",
	4215	:	"//	mov vrlbl(xl) xr  put cdblk ptr in vrblk label field",
	4216	:	"//cmp26	mov (xr) wb  set type word for new cdblk",
	4217	:	"//	mov cdfal(xr) wa  set failure word",
	4218	:	"//	mov xl xr  copy pointer to ccblk",
	4219	:	"//	mov wb ccuse(xr)  load length gen (= new cdlen)",
	4220	:	"//	mov wc cclen(xr)  load total ccblk length",
	4221	:	"//	add xl wb  point past cdblk",
	4222	:	"//	sub wc wb  get length left for chop off",
	4223	:	"//	mov (xl) =b_cct  set type code for new ccblk at end",
	4224	:	"//	mov ccuse(xl) *cccod  set initial code offset",
	4225	:	"//	mov cwcof *cccod  reinitialise cwcof",
	4226	:	"//	mov cclen(xl) wc  set new length",
	4227	:	"//	mov r_ccb xl  set new ccblk pointer",
	4228	:	"//	zer ccsln(xl)   initialize new line number",
	4229	:	"//	mov cdsln(xr) cmpln  set line number in old block",
	4230	:	"//	mov cdstm(xr) cmpsn  set statement number",
	4231	:	"//	icv cmpsn   bump statement number",
	4232	:	"//	mov xl cmpcd(xs)  load ptr to previous cdblk",
	4233	:	"//	bze cmffp(xs) cmp27  jump if no failure fill in required",
	4234	:	"//	mov cdfal(xl) xr  else set failure ptr in previous",
	4235	:	"//cmp27	mov wa cmsop(xs)  load success offset",
	4236	:	"//	bze wa cmp28  jump if no fill in required",
	4237	:	"//	add xl wa  else point to fill in location",
	4238	:	"//	mov (xl) xr  store forward pointer",
	4239	:	"//	zer xl   clear garbage xl value",
	4240	:	"//cmp28	mov cmffp(xs) cmffc(xs)  copy failure fill in flag",
	4241	:	"//	mov cmsop(xs) cmsoc(xs)  copy success fill in offset",
	4242	:	"//	mov cmpcd(xs) xr  save ptr to this cdblk",
	4243	:	"//	bnz cmtra(xs) cmp29  jump if initial entry already set",
	4244	:	"//	mov cmtra(xs) xr  else set ptr here as default",
	4245	:	"//cmp29	blt stage =stgce cmp01 jump if not end line just done",
	4246	:	"//	bze cswls cmp30  skip if -nolist",
	4247	:	"//	jsr listr   list last line",
	4248	:	"//cmp30	mov xr cmtra(xs)  load initial entry cdblk pointer",
	4249	:	"//	add xs *cmnen  pop work locations off stack",
	4250	:	"//	exi    and return to cmpil caller",
	4251	:	"//cmp31	mov wb cmfgo(xs)  get fail goto",
	4252	:	"//	orb wb cmsgo(xs)  or in success goto",
	4253	:	"//	bnz wb cmp18  ok if non-null field",
	4254	:	"//	erb 219 syntax error: empty goto field  ",
	4255	:	"//cmp32	icv wb   point past ch_mn",
	4256	:	"//	jsr cncrd   process control card",
	4257	:	"//	zer scnse   clear start of element loc.",
	4258	:	"//	brn cmpce   loop for next statement",
	4259	:	"//cncrd	prc e 0  entry point",
	4260	:	"//	mov scnpt wb  offset for control card scan",
	4261	:	"//	mov wa =ccnoc  number of chars for comparison",
	4262	:	"//	ctw wa 0  convert to word count",
	4263	:	"//	mov cnswc wa  save word count",
	4264	:	"//cnc01	bge scnpt scnil cnc09 return if end of image",
	4265	:	"//	mov xr r_cim  point to image",
	4266	:	"//	plc xr scnpt  char ptr for first char",
	4267	:	"//	lch wa (xr)+  get first char",
	4268	:	"//	beq wa =ch_li cnc07 special case of -inxxx",
	4269	:	"//cnc0a	mnz scncc   set flag for scane",
	4270	:	"//	jsr scane   scan card name",
	4271	:	"//	zer scncc   clear scane flag",
	4272	:	"//	bnz xl cnc06  fail unless control card name",
	4273	:	"//	mov wa =ccnoc  no. of chars to be compared",
	4274	:	"//	blt sclen(xr) wa cnc08 fail if too few chars",
	4275	:	"//	mov xl xr  point to control card name",
	4276	:	"//	zer wb   zero offset for substring",
	4277	:	"//	jsr sbstr   extract substring for comparison",
	4278	:	"//	mov cnscc xr  keep control card substring ptr",
	4279	:	"//	mov xr =ccnms  point to list of standard names",
	4280	:	"//	zer wb   initialise name offset",
	4281	:	"//	lct wc =cc_nc  number of standard names",
	4282	:	"//cnc02	mov xl cnscc  point to name",
	4283	:	"//	lct wa cnswc  counter for inner loop",
	4284	:	"//	brn cnc04   jump into loop",
	4285	:	"//cnc03	ica xr   bump standard names ptr",
	4286	:	"//	ica xl   bump name pointer",
	4287	:	"//cnc04	cne schar(xl) (xr) cnc05 comp. up to cfp_c chars at once",
	4288	:	"//	bct wa cnc03  loop if more words to compare",
	4289	:	"//	mov xl wb  get name offset",
	4290	:	"//	bsw xl cc_nc cnc08 switch",
	4291	:	"//cnc05	ica xr   bump standard names ptr",
	4292	:	"//	bct wa cnc05  loop",
	4293	:	"//	icv wb   bump names offset",
	4294	:	"//	bct wc cnc02  continue if more names",
	4295	:	"//	brn cnc08   ignore unrecognized control card",
	4296	:	"//cnc06	erb 247 invalid control statement  ",
	4297	:	"//cnc07	lch wa (xr)+  get next char",
	4298	:	"//	bne wa =ch_ln cnc0a if not letter n",
	4299	:	"//	lch wa (xr)  get third char",
	4300	:	"//	blt wa =ch_d0 cnc0a if not digit",
	4301	:	"//	bgt wa =ch_d9 cnc0a if not digit",
	4302	:	"//	add scnpt =num02  bump offset past -in",
	4303	:	"//	jsr scane   scan integer after -in",
	4304	:	"//	mov -(xs) xr  stack scanned item",
	4305	:	"//	jsr gtsmi   check if integer",
	4306	:	"//	mov cswin xr  keep integer",
	4307	:	"//cnc08	mov wa scnpt  preserve in case xeq time compile",
	4308	:	"//	jsr scane   look for comma",
	4309	:	"//	beq xl =t_cma cnc01 loop if comma found",
	4310	:	"//	mov scnpt wa  restore scnpt in case xeq time",
	4311	:	"//cnc09	exi    return",
	4312	:	"//cnc10	mnz cswdb   set switch",
	4313	:	"//	brn cnc08   merge",
	4314	:	"//cnc11	jsr sysdm   call dumper",
	4315	:	"//	brn cnc09   finished",
	4316	:	"//cnc12	bze cswls cnc09  return if -nolist",
	4317	:	"//	jsr prtps   eject",
	4318	:	"//	jsr listt   list title",
	4319	:	"//	brn cnc09   finished",
	4320	:	"//cnc13	zer cswer   clear switch",
	4321	:	"//	brn cnc08   merge",
	4322	:	"//cnc14	zer cswex   clear switch",
	4323	:	"//	brn cnc08   merge",
	4324	:	"//cnc15	mnz cswfl   set switch",
	4325	:	"//	brn cnc08   merge",
	4326	:	"//cnc16	mnz cswls   set switch",
	4327	:	"//	beq stage =stgic cnc08 done if compile time",
	4328	:	"//	zer lstpf   permit listing",
	4329	:	"//	jsr listr   list line",
	4330	:	"//	brn cnc08   merge",
	4331	:	"//cnc17	mnz cswer   set switch",
	4332	:	"//	brn cnc08   merge",
	4333	:	"//cnc18	mnz cswex   set switch",
	4334	:	"//	brn cnc08   merge",
	4335	:	"//cnc19	zer cswfl   clear switch",
	4336	:	"//	brn cnc08   merge",
	4337	:	"//cnc20	zer cswls   clear switch",
	4338	:	"//	brn cnc08   merge",
	4339	:	"//cnc21	mnz cswno   set switch",
	4340	:	"//	brn cnc08   merge",
	4341	:	"//cnc22	zer cswpr   clear switch",
	4342	:	"//	brn cnc08   merge",
	4343	:	"//cnc24	zer cswno   clear switch",
	4344	:	"//	brn cnc08   merge",
	4345	:	"//cnc25	mnz cswpr   set switch",
	4346	:	"//	brn cnc08   merge",
	4347	:	"//cnc27	zer cswdb   clear switch",
	4348	:	"//	brn cnc08   merge",
	4349	:	"//cnc28	bze cswls cnc09  return if -nolist",
	4350	:	"//	jsr scane   scan integer after -space",
	4351	:	"//	mov wc =num01  1 space in case",
	4352	:	"//	beq xr =t_smc cnc29 jump if no integer",
	4353	:	"//	mov -(xs) xr  stack it",
	4354	:	"//	jsr gtsmi   check integer",
	4355	:	"//	bnz wc cnc29  jump if non zero",
	4356	:	"//	mov wc =num01  else 1 space",
	4357	:	"//cnc29	add lstlc wc  bump line count",
	4358	:	"//	lct wc wc  convert to loop counter",
	4359	:	"//	blt lstlc lstnp cnc30 jump if fits on page",
	4360	:	"//	jsr prtps   eject",
	4361	:	"//	jsr listt   list title",
	4362	:	"//	brn cnc09   merge",
	4363	:	"//cnc30	jsr prtnl   print a blank",
	4364	:	"//	bct wc cnc30  loop",
	4365	:	"//	brn cnc09   merge",
	4366	:	"//cnc31	mov cnr_t =r_stl  ptr to r_stl",
	4367	:	"//	brn cnc33   merge",
	4368	:	"//cnc32	mov r_stl =nulls  clear subtitle",
	4369	:	"//	mov cnr_t =r_ttl  ptr to r_ttl",
	4370	:	"//cnc33	mov xr =nulls  null in case needed",
	4371	:	"//	mnz cnttl   set flag for next listr call",
	4372	:	"//	mov wb =ccofs  offset to title/subtitle",
	4373	:	"//	mov wa scnil  input image length",
	4374	:	"//	blo wa wb cnc34 jump if no chars left",
	4375	:	"//	sub wa wb  no of chars to extract",
	4376	:	"//	mov xl r_cim  point to image",
	4377	:	"//	jsr sbstr   get title/subtitle",
	4378	:	"//cnc34	mov xl cnr_t  point to storage location",
	4379	:	"//	mov (xl) xr  store title/subtitle",
	4380	:	"//	beq xl =r_stl cnc09 return if stitl",
	4381	:	"//	bnz precl cnc09  return if extended listing",
	4382	:	"//	bze prich cnc09  return if regular printer",
	4383	:	"//	mov xl sclen(xr)  get length of title",
	4384	:	"//	mov wa xl  copy it",
	4385	:	"//	bze xl cnc35  jump if null",
	4386	:	"//	add xl =num10  increment",
	4387	:	"//	bhi xl prlen cnc09 use default lstp0 val if too long",
	4388	:	"//	add wa =num04  point just past title",
	4389	:	"//cnc35	mov lstpo wa  store offset",
	4390	:	"//	brn cnc09   return",
	4391	:	"//cnc36	jsr systt   toggle switch",
	4392	:	"//	brn cnc08   merge",
	4393	:	"//cnc41	mnz scncc   set flag for scane",
	4394	:	"//	jsr scane   scan quoted file name",
	4395	:	"//	zer scncc   clear scane flag",
	4396	:	"//	bne xl =t_con cnc06 if not constant",
	4397	:	"//	bne (xr) =b_scl cnc06 if not string constant",
	4398	:	"//	mov r_ifn xr  save file name",
	4399	:	"//	mov xl r_inc  examine include file name table",
	4400	:	"//	zer wb   lookup by value",
	4401	:	"//	jsr tfind   do lookup",
	4402	:	"//	beq xr =inton cnc09 ignore if already in table",
	4403	:	"//	mnz wb   set for trim",
	4404	:	"//	mov xr r_ifn  file name",
	4405	:	"//	jsr trimr   remove trailing blanks",
	4406	:	"//	mov xl r_inc  include file name table",
	4407	:	"//	mnz wb   lookup by name this time",
	4408	:	"//	jsr tfind   do lookup",
	4409	:	"//	mov teval(xl) =inton  make table value integer 1",
	4410	:	"//	icv cnind   increase nesting level",
	4411	:	"//	mov wa cnind  load new nest level",
	4412	:	"//	bgt wa =ccinm cnc42 fail if excessive nesting",
	4413	:	"//	mov xl r_ifa  array of nested file names",
	4414	:	"//	add wa =vcvlb  compute offset in words",
	4415	:	"//	wtb wa   convert to bytes",
	4416	:	"//	add xl wa  point to element",
	4417	:	"//	mov (xl) r_sfc  record current file name",
	4418	:	"//	mov xl wa  preserve nesting byte offset",
	4419	:	"//	mti rdnln   fetch source line number as integer",
	4420	:	"//	jsr icbld   convert to icblk",
	4421	:	"//	add xl r_ifl  entry in nested line number array",
	4422	:	"//	mov (xl) xr  record in array",
	4423	:	"//	mov wa cswin  max read length",
	4424	:	"//	mov xl r_ifn  include file name",
	4425	:	"//	jsr alocs   get buffer for complete file name",
	4426	:	"//	jsr sysif   open include file",
	4427	:	"//	zer wb   do not trim trailing blanks",
	4428	:	"//	jsr trimr   adjust scblk for actual length",
	4429	:	"//	mov r_sfc xr  save ptr to file name",
	4430	:	"//	mti cmpsn   current statement as integer",
	4431	:	"//	jsr icbld   build icblk for stmt number",
	4432	:	"//	mov xl r_sfn  file name table",
	4433	:	"//	mnz wb   lookup statement number by name",
	4434	:	"//	jsr tfind   allocate new teblk",
	4435	:	"//	mov teval(xl) r_sfc  record file name as entry value",
	4436	:	"//	zer rdnln   restart line counter for new file",
	4437	:	"//	beq stage =stgic cnc09 if initial compile",
	4438	:	"//	bne cnind =num01 cnc09 if not first execute-time nesting",
	4439	:	"//	mov r_ici r_cim  remember code argument string",
	4440	:	"//	mov cnspt scnpt  save position in string",
	4441	:	"//	mov cnsil scnil  and length of string",
	4442	:	"//	brn cnc09   all done, merge",
	4443	:	"//cnc42	erb 284 excessively nested include files  ",
	4444	:	"//cnc43	mov dnamp xr  release allocated scblk",
	4445	:	"//	erb 285 include file cannot be opened  ",
	4446	:	"//cnc44	jsr scane   scan integer after -line",
	4447	:	"//	bne xl =t_con cnc06 jump if no line number",
	4448	:	"//	bne (xr) =b_icl cnc06 jump if not integer",
	4449	:	"//	ldi icval(xr)   fetch integer line number",
	4450	:	"//	ile cnc06   error if negative or zero",
	4451	:	"//	beq stage =stgic cnc45 skip if initial compile",
	4452	:	"//	mfi cmpln   set directly for other compiles",
	4453	:	"//	brn cnc46   no need to set rdnln",
	4454	:	"//cnc45	sbi 4,intv1   adjust number by one",
	4455	:	"//	mfi rdnln   save line number",
	4456	:	"//cnc46	mnz scncc   set flag for scane",
	4457	:	"//	jsr scane   scan quoted file name",
	4458	:	"//	zer scncc   clear scane flag",
	4459	:	"//	beq xl =t_smc cnc47 done if no file name",
	4460	:	"//	bne xl =t_con cnc06 error if not constant",
	4461	:	"//	bne (xr) =b_scl cnc06 if not string constant",
	4462	:	"//	jsr newfn   record new file name",
	4463	:	"//	brn cnc09   merge",
	4464	:	"//cnc47	dcv scnpt   set to rescan the terminator",
	4465	:	"//	brn cnc09   merge",
	4466	:	"//dffnc	prc e 0  entry point",
	4467	:	"//	bne (xl) =b_efc dffn1 skip if new function not external",
	4468	:	"//	icv efuse(xl)   else increment its use count",
	4469	:	"//dffn1	mov wa xr  save vrblk pointer",
	4470	:	"//	mov xr vrfnc(xr)  load old function pointer",
	4471	:	"//	bne (xr) =b_efc dffn2 jump if old function not external",
	4472	:	"//	mov wb efuse(xr)  else get use count",
	4473	:	"//	dcv wb   decrement",
	4474	:	"//	mov efuse(xr) wb  store decremented value",
	4475	:	"//	bnz wb dffn2  jump if use count still non-zero",
	4476	:	"//	jsr sysul   else call system unload function",
	4477	:	"//dffn2	mov xr wa  restore vrblk pointer",
	4478	:	"//	mov wa xl  copy function block ptr",
	4479	:	"//	blt xr =r_yyy dffn3 skip checks if opsyn op definition",
	4480	:	"//	bnz vrlen(xr) dffn3  jump if not system variable",
	4481	:	"//	mov xl vrsvp(xr)  point to svblk",
	4482	:	"//	mov wb svbit(xl)  load bit indicators",
	4483	:	"//	anb wb 4,btfnc  is it a system function",
	4484	:	"//	zrb wb dffn3  redef ok if not",
	4485	:	"//	erb 248 attempted redefinition of system function  ",
	4486	:	"//dffn3	mov vrfnc(xr) wa  store new function pointer",
	4487	:	"//	mov xl wa  restore function block pointer",
	4488	:	"//	exi    return to dffnc caller",
	4489	:	"//dtach	prc e 0  entry point",
	4490	:	"//	mov dtcnb xl  store name base (gbcol not called)",
	4491	:	"//	add xl wa  point to name location",
	4492	:	"//	mov dtcnm xl  store it",
	4493	:	"//dtch1	mov xr xl  copy name pointer",
	4494	:	"//dtch2	mov xl (xl)  point to next value",
	4495	:	"//	bne (xl) =b_trt dtch6 jump at chain end",
	4496	:	"//	mov wa trtyp(xl)  get trap block type",
	4497	:	"//	beq wa =trtin dtch3 jump if input",
	4498	:	"//	beq wa =trtou dtch3 jump if output",
	4499	:	"//	add xl *trnxt  point to next link",
	4500	:	"//	brn dtch1   loop",
	4501	:	"//dtch3	mov (xr) trval(xl)  delete trblk",
	4502	:	"//	mov wa xl  dump xl ...",
	4503	:	"//	mov wb xr  ... and xr",
	4504	:	"//	mov xl trtrf(xl)  point to trtrf trap block",
	4505	:	"//	bze xl dtch5  jump if no iochn",
	4506	:	"//	bne (xl) =b_trt dtch5 jump if input, output, terminal",
	4507	:	"//dtch4	mov xr xl  remember link ptr",
	4508	:	"//	mov xl trtrf(xl)  point to next link",
	4509	:	"//	bze xl dtch5  jump if end of chain",
	4510	:	"//	mov wc ionmb(xl)  get name base",
	4511	:	"//	add wc ionmo(xl)  add offset",
	4512	:	"//	bne wc dtcnm dtch4 loop if no match",
	4513	:	"//	mov trtrf(xr) trtrf(xl)  remove name from chain",
	4514	:	"//dtch5	mov xl wa  recover xl ...",
	4515	:	"//	mov xr wb  ... and xr",
	4516	:	"//	add xl *trval  point to value field",
	4517	:	"//	brn dtch2   continue",
	4518	:	"//dtch6	mov xr dtcnb  possible vrblk ptr",
	4519	:	"//	jsr setvr   reset vrblk if necessary",
	4520	:	"//	exi    return",
	4521	:	"//dtype	prc e 0  entry point",
	4522	:	"//	beq (xr) =b_pdt dtyp1 jump if prog.defined",
	4523	:	"//	mov xr (xr)  load type word",
	4524	:	"//	lei xr   get entry point id (block code)",
	4525	:	"//	wtb xr   convert to byte offset",
	4526	:	"//	mov xr 14,scnmt(xr)  load table entry",
	4527	:	"//	exi    exit to dtype caller",
	4528	:	"//dtyp1	mov xr pddfp(xr)  point to dfblk",
	4529	:	"//	mov xr dfnam(xr)  get datatype name from dfblk",
	4530	:	"//	exi    return to dtype caller",
	4531	:	"//dumpr	prc e 0  entry point",
	4532	:	"//	bze xr dmp28  skip dump if argument is zero",
	4533	:	"//	bgt xr =num03 dmp29 jump if core dump required",
	4534	:	"//	zer xl   clear xl",
	4535	:	"//	zer wb   zero move offset",
	4536	:	"//	mov dmarg xr  save dump argument",
	4537	:	"//	zer dnams   collect sediment too",
	4538	:	"//	jsr gbcol   collect garbage",
	4539	:	"//	jsr prtpg   eject printer",
	4540	:	"//	mov xr =dmhdv  point to heading for variables",
	4541	:	"//	jsr prtst   print it",
	4542	:	"//	jsr prtnl   terminate print line",
	4543	:	"//	jsr prtnl   and print a blank line",
	4544	:	"//	zer dmvch   set null chain to start",
	4545	:	"//	mov wa hshtb  point to hash table",
	4546	:	"//dmp00	mov xr wa  copy hash bucket pointer",
	4547	:	"//	ica wa   bump pointer",
	4548	:	"//	sub xr *vrnxt  set offset to merge",
	4549	:	"//dmp01	mov xr vrnxt(xr)  point to next vrblk on chain",
	4550	:	"//	bze xr dmp09  jump if end of this hash chain",
	4551	:	"//	mov xl xr  else copy vrblk pointer",
	4552	:	"//dmp02	mov xl vrval(xl)  load value",
	4553	:	"//	beq dmarg =num03 dmp2a skip null value check if dump(3)",
	4554	:	"//	beq xl =nulls dmp01 loop for next vrblk if null value",
	4555	:	"//dmp2a	beq (xl) =b_trt dmp02 loop back if value is trapped",
	4556	:	"//	mov wc xr  save vrblk pointer",
	4557	:	"//	add xr *vrsof  adjust ptr to be like scblk ptr",
	4558	:	"//	bnz sclen(xr) dmp03  jump if non-system variable",
	4559	:	"//	mov xr vrsvo(xr)  else load ptr to name in svblk",
	4560	:	"//dmp03	mov wb xr  save pointer to chars",
	4561	:	"//	mov dmpsv wa  save hash bucket pointer",
	4562	:	"//	mov wa =dmvch  point to chain head",
	4563	:	"//dmp04	mov dmpch wa  save chain pointer",
	4564	:	"//	mov xl wa  copy it",
	4565	:	"//	mov xr (xl)  load pointer to next entry",
	4566	:	"//	bze xr dmp08  jump if end of chain to insert",
	4567	:	"//	add xr *vrsof  else get name ptr for chained vrblk",
	4568	:	"//	bnz sclen(xr) dmp05  jump if not system variable",
	4569	:	"//	mov xr vrsvo(xr)  else point to name in svblk",
	4570	:	"//dmp05	mov xl wb  point to entering vrblk string",
	4571	:	"//	mov wa sclen(xl)  load its length",
	4572	:	"//	plc xl   point to chars of entering string",
	4573	:	"//	bhi wa sclen(xr) dmp06 jump if entering length high",
	4574	:	"//	plc xr   else point to chars of old string",
	4575	:	"//	cmc dmp08 dmp07  compare, insert if new is llt old",
	4576	:	"//	brn dmp08   or if leq (we had shorter length)",
	4577	:	"//dmp06	mov wa sclen(xr)  load shorter length",
	4578	:	"//	plc xr   point to chars of old string",
	4579	:	"//	cmc dmp08 dmp07  compare, insert if new one low",
	4580	:	"//dmp07	mov xl dmpch  copy chain pointer",
	4581	:	"//	mov wa (xl)  move to next entry on chain",
	4582	:	"//	brn dmp04   loop back",
	4583	:	"//dmp08	mov xl dmpch  copy chain pointer",
	4584	:	"//	mov wa dmpsv  restore hash bucket pointer",
	4585	:	"//	mov xr wc  restore vrblk pointer",
	4586	:	"//	mov vrget(xr) (xl)  link vrblk to rest of chain",
	4587	:	"//	mov (xl) xr  link vrblk into current chain loc",
	4588	:	"//	brn dmp01   loop back for next vrblk",
	4589	:	"//dmp09	bne wa hshte dmp00 loop back if more buckets to go",
	4590	:	"//dmp10	mov xr dmvch  load pointer to next entry on chain",
	4591	:	"//	bze xr dmp11  jump if end of chain",
	4592	:	"//	mov dmvch (xr)  else update chain ptr to next entry",
	4593	:	"//	jsr setvr   restore vrget field",
	4594	:	"//	mov xl xr  copy vrblk pointer (name base)",
	4595	:	"//	mov wa *vrval  set offset for vrblk name",
	4596	:	"//	jsr prtnv   print name = value",
	4597	:	"//	brn dmp10   loop back till all printed",
	4598	:	"//dmp11	jsr prtnl   print blank line",
	4599	:	"//	jsr prtnl   and another",
	4600	:	"//	mov xr =dmhdk  point to keyword heading",
	4601	:	"//	jsr prtst   print heading",
	4602	:	"//	jsr prtnl   end line",
	4603	:	"//	jsr prtnl   print one blank line",
	4604	:	"//	mov xl =vdmkw  point to list of keyword svblk ptrs",
	4605	:	"//dmp12	mov xr (xl)+  load next svblk ptr from table",
	4606	:	"//	bze xr dmp13  jump if end of list",
	4607	:	"//	beq xr =num01 dmp12 &compare ignored if not implemented",
	4608	:	"//	mov wa =ch_am  load ampersand",
	4609	:	"//	jsr prtch   print ampersand",
	4610	:	"//	jsr prtst   print keyword name",
	4611	:	"//	mov wa svlen(xr)  load name length from svblk",
	4612	:	"//	ctb wa svchs  get length of name",
	4613	:	"//	add xr wa  point to svknm field",
	4614	:	"//	mov dmpkn (xr)  store in dummy kvblk",
	4615	:	"//	mov xr =tmbeb  point to blank-equal-blank",
	4616	:	"//	jsr prtst   print it",
	4617	:	"//	mov dmpsv xl  save table pointer",
	4618	:	"//	mov xl =dmpkb  point to dummy kvblk",
	4619	:	"//	mov (xl) =b_kvt  build type word",
	4620	:	"//	mov kvvar(xl) =trbkv  build ptr to dummy trace block",
	4621	:	"//	mov wa *kvvar  set zero offset",
	4622	:	"//	jsr acess   get keyword value",
	4623	:	"//	jsr prtvl   print keyword value",
	4624	:	"//	jsr prtnl   terminate print line",
	4625	:	"//	mov xl dmpsv  restore table pointer",
	4626	:	"//	brn dmp12   loop back till all printed",
	4627	:	"//dmp13	beq dmarg =num01 dmp27 exit if partial dump complete",
	4628	:	"//	mov xr dnamb  else point to first dynamic block",
	4629	:	"//dmp14	beq xr dnamp dmp27 jump if end of used region",
	4630	:	"//	mov wa (xr)  else load first word of block",
	4631	:	"//	beq wa =b_vct dmp16 jump if vector",
	4632	:	"//	beq wa =b_art dmp17 jump if array",
	4633	:	"//	beq wa =b_pdt dmp18 jump if program defined",
	4634	:	"//	beq wa =b_tbt dmp19 jump if table",
	4635	:	"//dmp15	jsr blkln   get length of block",
	4636	:	"//	add xr wa  point past this block",
	4637	:	"//	brn dmp14   loop back for next block",
	4638	:	"//dmp16	mov wb *vcvls  set offset to first value",
	4639	:	"//	brn dmp19   jump to merge",
	4640	:	"//dmp17	mov wb arofs(xr)  set offset to arpro field",
	4641	:	"//	ica wb   bump to get offset to values",
	4642	:	"//	brn dmp19   jump to merge",
	4643	:	"//dmp18	mov wb *pdfld  point to values, merge",
	4644	:	"//dmp19	bze idval(xr) dmp15  ignore block if zero id value",
	4645	:	"//	jsr blkln   else get block length",
	4646	:	"//	mov xl xr  copy block pointer",
	4647	:	"//	mov dmpsv wa  save length",
	4648	:	"//	mov wa wb  copy offset to first value",
	4649	:	"//	jsr prtnl   print blank line",
	4650	:	"//	mov dmpsa wa  preserve offset",
	4651	:	"//	jsr prtvl   print block value (for title)",
	4652	:	"//	mov wa dmpsa  recover offset",
	4653	:	"//	jsr prtnl   end print line",
	4654	:	"//	beq (xr) =b_tbt dmp22 jump if table",
	4655	:	"//	dca wa   point before first word",
	4656	:	"//dmp20	mov xr xl  copy block pointer",
	4657	:	"//	ica wa   bump offset",
	4658	:	"//	add xr wa  point to next value",
	4659	:	"//	beq wa dmpsv dmp14 exit if end (xr past block)",
	4660	:	"//	sub xr *vrval  subtract offset to merge into loop",
	4661	:	"//dmp21	mov xr vrval(xr)  load next value",
	4662	:	"//	beq dmarg =num03 dmp2b skip null value check if dump(3)",
	4663	:	"//	beq xr =nulls dmp20 loop back if null value",
	4664	:	"//dmp2b	beq (xr) =b_trt dmp21 loop back if trapped",
	4665	:	"//	jsr prtnv   else print name = value",
	4666	:	"//	brn dmp20   loop back for next field",
	4667	:	"//dmp22	mov wc *tbbuk  set offset to first bucket",
	4668	:	"//	mov wa *teval  set name offset for all teblks",
	4669	:	"//dmp23	mov -(xs) xl  save tbblk pointer",
	4670	:	"//	add xl wc  point to next bucket header",
	4671	:	"//	ica wc   bump bucket offset",
	4672	:	"//	sub xl *tenxt  subtract offset to merge into loop",
	4673	:	"//dmp24	mov xl tenxt(xl)  point to next teblk",
	4674	:	"//	beq xl (xs) dmp26 jump if end of chain",
	4675	:	"//	mov xr xl  else copy teblk pointer",
	4676	:	"//dmp25	mov xr teval(xr)  load next value",
	4677	:	"//	beq xr =nulls dmp24 ignore if null value",
	4678	:	"//	beq (xr) =b_trt dmp25 loop back if trapped",
	4679	:	"//	mov dmpsv wc  else save offset pointer",
	4680	:	"//	jsr prtnv   print name = value",
	4681	:	"//	mov wc dmpsv  reload offset",
	4682	:	"//	brn dmp24   loop back for next teblk",
	4683	:	"//dmp26	mov xl (xs)+  restore tbblk pointer",
	4684	:	"//	bne wc tblen(xl) dmp23 loop back if more buckets to go",
	4685	:	"//	mov xr xl  else copy table pointer",
	4686	:	"//	add xr wc  point to following block",
	4687	:	"//	brn dmp14   loop back to process next block",
	4688	:	"//dmp27	jsr prtpg   eject printer",
	4689	:	"//dmp28	exi    return to dump caller",
	4690	:	"//dmp29	jsr sysdm   call it",
	4691	:	"//	brn dmp28   return",
	4692	:	"//ermsg	prc e 0  entry point",
	4693	:	"//	mov wa kvert  load error code",
	4694	:	"//	mov xr =ermms  point to error message /error/",
	4695	:	"//	jsr prtst   print it",
	4696	:	"//	jsr ertex   get error message text",
	4697	:	"//	add wa =thsnd  bump error code for print",
	4698	:	"//	mti wa   fail code in int acc",
	4699	:	"//	mov wb profs  save current buffer position",
	4700	:	"//	jsr prtin   print code (now have error1xxx)",
	4701	:	"//	mov xl prbuf  point to print buffer",
	4702	:	"//	psc xl wb  point to the 1",
	4703	:	"//	mov wa =ch_bl  load a blank",
	4704	:	"//	sch wa (xl)  store blank over 1 (error xxx)",
	4705	:	"//	csc xl   complete store characters",
	4706	:	"//	zer xl   clear garbage pointer in xl",
	4707	:	"//	mov wa xr  keep error text",
	4708	:	"//	mov xr =ermns  point to / -- /",
	4709	:	"//	jsr prtst   print it",
	4710	:	"//	mov xr wa  get error text again",
	4711	:	"//	jsr prtst   print error message text",
	4712	:	"//	jsr prtis   print line",
	4713	:	"//	jsr prtis   print blank line",
	4714	:	"//	exi    return to ermsg caller",
	4715	:	"//ertex	prc e 0  entry point",
	4716	:	"//	mov ertwa wa  save wa",
	4717	:	"//	mov ertwb wb  save wb",
	4718	:	"//	jsr sysem   get failure message text",
	4719	:	"//	mov xl xr  copy pointer to it",
	4720	:	"//	mov wa sclen(xr)  get length of string",
	4721	:	"//	bze wa ert02  jump if null",
	4722	:	"//	zer wb   offset of zero",
	4723	:	"//	jsr sbstr   copy into dynamic store",
	4724	:	"//	mov r_etx xr  store for relocation",
	4725	:	"//ert01	mov wb ertwb  restore wb",
	4726	:	"//	mov wa ertwa  restore wa",
	4727	:	"//	exi    return to caller",
	4728	:	"//ert02	mov xr r_etx  get errtext",
	4729	:	"//	brn ert01   return",
	4730	:	"//evali	prc r 4  entry point (recursive)",
	4731	:	"//	jsr evalp   evaluate expression",
	4732	:	"//	mov -(xs) xl  stack result for gtsmi",
	4733	:	"//	mov xl pthen(xr)  load successor pointer",
	4734	:	"//	mov evlio xr  save original node pointer",
	4735	:	"//	mov evlif wc  zero if simple argument",
	4736	:	"//	jsr gtsmi   convert arg to small integer",
	4737	:	"//	mov evliv xr  store result in special dummy node",
	4738	:	"//	mov xr =evlin  point to dummy node with result",
	4739	:	"//	mov (xr) =p_len  dummy pattern block pcode",
	4740	:	"//	mov pthen(xr) xl  store successor pointer",
	4741	:	"//	exi 4   take successful exit",
	4742	:	"//evli1	exi 3   take failure return",
	4743	:	"//evli2	exi 1   take non-integer error exit",
	4744	:	"//evli3	exi 2   take out-of-range error exit",
	4745	:	"//evalp	prc r 1  entry point (recursive)",
	4746	:	"//	mov xl parm1(xr)  load expression pointer",
	4747	:	"//	beq (xl) =b_exl evlp1 jump if exblk case",
	4748	:	"//	mov xl sevar(xl)  load vrblk pointer",
	4749	:	"//	mov xl vrval(xl)  load value of vrblk",
	4750	:	"//	mov wa (xl)  load first word of value",
	4751	:	"//	bhi wa =b_t__ evlp3 jump if not seblk, trblk or exblk",
	4752	:	"//evlp1	chk    check for stack space",
	4753	:	"//	mov -(xs) xr  stack node pointer",
	4754	:	"//	mov -(xs) wb  stack cursor",
	4755	:	"//	mov -(xs) r_pms  stack subject string pointer",
	4756	:	"//	mov -(xs) pmssl  stack subject string length",
	4757	:	"//	mov -(xs) pmdfl  stack dot flag",
	4758	:	"//	mov -(xs) pmhbs  stack history stack base pointer",
	4759	:	"//	mov xr parm1(xr)  load expression pointer",
	4760	:	"//evlp2	zer wb   set flag for by value",
	4761	:	"//	jsr evalx   evaluate expression",
	4762	:	"//	mov wa (xr)  else load first word of value",
	4763	:	"//	blo wa =b_e__ evlp2 loop back to reevaluate expression",
	4764	:	"//	mov xl xr  copy result pointer",
	4765	:	"//	mov pmhbs (xs)+  restore history stack base pointer",
	4766	:	"//	mov pmdfl (xs)+  restore dot flag",
	4767	:	"//	mov pmssl (xs)+  restore subject string length",
	4768	:	"//	mov r_pms (xs)+  restore subject string pointer",
	4769	:	"//	mov wb (xs)+  restore cursor",
	4770	:	"//	mov xr (xs)+  restore node pointer",
	4771	:	"//	mov wc xr  non-zero for simple vrblk",
	4772	:	"//	exi    return to evalp caller",
	4773	:	"//evlp3	zer wc   simple vrblk, no side effects",
	4774	:	"//	exi    return to evalp caller",
	4775	:	"//evlp4	mov pmhbs (xs)+  restore history stack base pointer",
	4776	:	"//	mov pmdfl (xs)+  restore dot flag",
	4777	:	"//	mov pmssl (xs)+  restore subject string length",
	4778	:	"//	mov r_pms (xs)+  restore subject string pointer",
	4779	:	"//	add xs *num02  remove node ptr, cursor",
	4780	:	"//	exi 1   take failure exit",
	4781	:	"//evals	prc r 3  entry point (recursive)",
	4782	:	"//	jsr evalp   evaluate expression",
	4783	:	"//	mov -(xs) pthen(xr)  save successor pointer",
	4784	:	"//	mov -(xs) wb  save cursor",
	4785	:	"//	mov -(xs) xl  stack result ptr for patst",
	4786	:	"//	zer wb   dummy pcode for one char string",
	4787	:	"//	zer wc   dummy pcode for expression arg",
	4788	:	"//	mov xl =p_brk  appropriate pcode for our use",
	4789	:	"//	jsr patst   call routine to build node",
	4790	:	"//	mov wb (xs)+  restore cursor",
	4791	:	"//	mov pthen(xr) (xs)+  store successor pointer",
	4792	:	"//	exi 3   take success return",
	4793	:	"//evls1	exi 2   take failure return",
	4794	:	"//evls2	add xs *num02  pop successor and cursor",
	4795	:	"//	exi 1   take non-string error exit",
	4796	:	"//evalx	prc r 1  entry point, recursive",
	4797	:	"//	beq (xr) =b_exl evlx2 jump if exblk case",
	4798	:	"//	mov xl sevar(xr)  load vrblk pointer (name base)",
	4799	:	"//	mov wa *vrval  set name offset",
	4800	:	"//	bnz wb evlx1  jump if called by name",
	4801	:	"//	jsr acess   call routine to access value",
	4802	:	"//evlx1	exi    return to evalx caller",
	4803	:	"//evlx2	scp wc   get code pointer",
	4804	:	"//	mov wa r_cod  load code block pointer",
	4805	:	"//	sub wc wa  get code pointer as offset",
	4806	:	"//	mov -(xs) wa  stack old code block pointer",
	4807	:	"//	mov -(xs) wc  stack relative code offset",
	4808	:	"//	mov -(xs) flptr  stack old failure pointer",
	4809	:	"//	mov -(xs) wb  stack name/value indicator",
	4810	:	"//	mov -(xs) *exflc  stack new fail offset",
	4811	:	"//	mov gtcef flptr  keep in case of error",
	4812	:	"//	mov r_gtc r_cod  keep code block pointer similarly",
	4813	:	"//	mov flptr xs  set new failure pointer",
	4814	:	"//	mov r_cod xr  set new code block pointer",
	4815	:	"//	mov exstm(xr) kvstn  remember stmnt number",
	4816	:	"//	add xr *excod  point to first code word",
	4817	:	"//	lcp xr   set code pointer",
	4818	:	"//	bne stage =stgxt evlx0 jump if not execution time",
	4819	:	"//	mov stage =stgee  evaluating expression",
	4820	:	"//evlx0	zer xl   clear garbage xl",
	4821	:	"//	lcw xr   load first code word",
	4822	:	"//	bri (xr)   execute it",
	4823	:	"//evlx3	mov xr (xs)+  load value",
	4824	:	"//	bze num01(xs) evlx5  jump if called by value",
	4825	:	"//	erb 249 expression evaluated by name returned value  ",
	4826	:	"//evlx4	mov wa (xs)+  load name offset",
	4827	:	"//	mov xl (xs)+  load name base",
	4828	:	"//	bnz num01(xs) evlx5  jump if called by name",
	4829	:	"//	jsr acess   else access value first",
	4830	:	"//evlx5	zer wb   note successful",
	4831	:	"//	brn evlx7   merge",
	4832	:	"//evlx6	mnz wb   note unsuccessful",
	4833	:	"//evlx7	bne stage =stgee evlx8 skip if was not previously xt",
	4834	:	"//	mov stage =stgxt  execute time",
	4835	:	"//evlx8	add xs *num02  pop name/value indicator, *exfal",
	4836	:	"//	mov flptr (xs)+  restore old failure pointer",
	4837	:	"//	mov wc (xs)+  load code offset",
	4838	:	"//	add wc (xs)  make code pointer absolute",
	4839	:	"//	mov r_cod (xs)+  restore old code block pointer",
	4840	:	"//	lcp wc   restore old code pointer",
	4841	:	"//	bze wb evlx1  jump for successful return",
	4842	:	"//evlx9	exi 1   take failure exit",
	4843	:	"//exbld	prc e 0  entry point",
	4844	:	"//	mov wa xl  copy offset to start of code",
	4845	:	"//	sub wa *excod  calc reduction in offset in exblk",
	4846	:	"//	mov -(xs) wa  stack for later",
	4847	:	"//	mov wa cwcof  load final offset",
	4848	:	"//	sub wa xl  compute length of code",
	4849	:	"//	add wa *exsi_  add space for standard fields",
	4850	:	"//	jsr alloc   allocate space for exblk",
	4851	:	"//	mov -(xs) xr  save pointer to exblk",
	4852	:	"//	mov extyp(xr) =b_exl  store type word",
	4853	:	"//	zer exstm(xr)   zeroise stmnt number field",
	4854	:	"//	mov exsln(xr) cmpln  set line number field",
	4855	:	"//	mov exlen(xr) wa  store length",
	4856	:	"//	mov exflc(xr) =ofex_  store failure word",
	4857	:	"//	add xr *exsi_  set xr for mvw",
	4858	:	"//	mov cwcof xl  reset offset to start of code",
	4859	:	"//	add xl r_ccb  point to start of code",
	4860	:	"//	sub wa *exsi_  length of code to move",
	4861	:	"//	mov -(xs) wa  stack length of code",
	4862	:	"//	mvw    move code to exblk",
	4863	:	"//	mov wa (xs)+  get length of code",
	4864	:	"//	btw wa   convert byte count to word count",
	4865	:	"//	lct wa wa  prepare counter for loop",
	4866	:	"//	mov xl (xs)  copy exblk ptr, dont unstack",
	4867	:	"//	add xl *excod  point to code itself",
	4868	:	"//	mov wb num01(xs)  get reduction in offset",
	4869	:	"//exbl1	mov xr (xl)+  get next code word",
	4870	:	"//	beq xr =osla_ exbl3 jump if selection found",
	4871	:	"//	beq xr =onta_ exbl3 jump if negation found",
	4872	:	"//	bct wa exbl1  loop to end of code",
	4873	:	"//exbl2	mov xr (xs)+  pop exblk ptr into xr",
	4874	:	"//	mov xl (xs)+  pop reduction constant",
	4875	:	"//	exi    return to caller",
	4876	:	"//exbl3	sub (xl)+ wb  adjust offset",
	4877	:	"//	bct wa exbl4  decrement count",
	4878	:	"//exbl4	bct wa exbl5  decrement count",
	4879	:	"//exbl5	mov xr (xl)+  get next code word",
	4880	:	"//	beq xr =osla_ exbl3 jump if offset found",
	4881	:	"//	beq xr =oslb_ exbl3 jump if offset found",
	4882	:	"//	beq xr =oslc_ exbl3 jump if offset found",
	4883	:	"//	beq xr =onta_ exbl3 jump if offset found",
	4884	:	"//	bct wa exbl5  loop",
	4885	:	"//	brn exbl2   merge to return",
	4886	:	"//expan	prc e 0  entry point",
	4887	:	"//	zer -(xs)   set top of stack indicator",
	4888	:	"//	zer wa   set initial state to zero",
	4889	:	"//	zer wc   zero counter value",
	4890	:	"//exp01	jsr scane   scan next element",
	4891	:	"//	add xl wa  add state to syntax code",
	4892	:	"//	bsw xl t_nes  switch on element type/state",
	4893	:	"//exp02	mnz scnrs   set to rescan element",
	4894	:	"//	mov xr =nulls  point to null, merge",
	4895	:	"//exp03	mov -(xs) xr  stack pointer to operand",
	4896	:	"//	mov wa =num02  set state 2",
	4897	:	"//	brn exp01   jump for next element",
	4898	:	"//exp04	mnz scnrs   set to rescan element",
	4899	:	"//	mov xr =opdvc  point to concat operator dv",
	4900	:	"//	bze wb exp4a  ok if at top level",
	4901	:	"//	mov xr =opdvp  else point to unmistakable concat.",
	4902	:	"//exp4a	bnz scnbl exp26  merge bop if blanks, else error",
	4903	:	"//	erb 220 syntax error: missing operator  ",
	4904	:	"//exp05	erb 221 syntax error: missing operand  ",
	4905	:	"//exp06	mov xl =num04  set new level indicator",
	4906	:	"//	zer xr   set zero value for cmopn",
	4907	:	"//exp07	mov -(xs) xr  stack cmopn value",
	4908	:	"//	mov -(xs) wc  stack old counter",
	4909	:	"//	mov -(xs) wb  stack old level indicator",
	4910	:	"//	chk    check for stack overflow",
	4911	:	"//	zer wa   set new state to zero",
	4912	:	"//	mov wb xl  set new level indicator",
	4913	:	"//	mov wc =num01  initialize new counter",
	4914	:	"//	brn exp01   jump to scan next element",
	4915	:	"//exp08	erb 222 syntax error: invalid use of left bracket  ",
	4916	:	"//exp09	mov xr (xs)+  load array ptr for cmopn",
	4917	:	"//	mov xl =num03  set new level indicator",
	4918	:	"//	brn exp07   jump to stack old and start new",
	4919	:	"//exp10	mov xl =num05  set new lev indic (xr=vrblk=cmopn)",
	4920	:	"//	brn exp07   jump to stack old and start new",
	4921	:	"//exp11	icv wc   increment counter",
	4922	:	"//	jsr expdm   dump operators at this level",
	4923	:	"//	zer -(xs)   set new level for parameter",
	4924	:	"//	zer wa   set new state",
	4925	:	"//	bgt wb =num02 exp01 loop back unless outer level",
	4926	:	"//	erb 223 syntax error: invalid use of comma  ",
	4927	:	"//exp12	beq wb =num01 exp20 end of normal goto",
	4928	:	"//	beq wb =num05 exp13 end of function arguments",
	4929	:	"//	beq wb =num04 exp14 end of grouping / selection",
	4930	:	"//	erb 224 syntax error: unbalanced right parenthesis  ",
	4931	:	"//exp13	mov xl =c_fnc  set cmtyp value for function",
	4932	:	"//	brn exp15   jump to build cmblk",
	4933	:	"//exp14	beq wc =num01 exp17 jump if end of grouping",
	4934	:	"//	mov xl =c_sel  else set cmtyp for selection",
	4935	:	"//exp15	jsr expdm   dump operators at this level",
	4936	:	"//	mov wa wc  copy count",
	4937	:	"//	add wa =cmvls  add for standard fields at start",
	4938	:	"//	wtb wa   convert length to bytes",
	4939	:	"//	jsr alloc   allocate space for cmblk",
	4940	:	"//	mov (xr) =b_cmt  store type code for cmblk",
	4941	:	"//	mov cmtyp(xr) xl  store cmblk node type indicator",
	4942	:	"//	mov cmlen(xr) wa  store length",
	4943	:	"//	add xr wa  point past end of block",
	4944	:	"//	lct wc wc  set loop counter",
	4945	:	"//exp16	mov -(xr) (xs)+  move one operand ptr from stack",
	4946	:	"//	mov wb (xs)+  pop to old level indicator",
	4947	:	"//	bct wc exp16  loop till all moved",
	4948	:	"//	sub xr *cmvls  point back to start of block",
	4949	:	"//	mov wc (xs)+  restore old counter",
	4950	:	"//	mov cmopn(xr) (xs)  store operand ptr in cmblk",
	4951	:	"//	mov (xs) xr  stack cmblk pointer",
	4952	:	"//	mov wa =num02  set new state",
	4953	:	"//	brn exp01   back for next element",
	4954	:	"//exp17	jsr expdm   dump operators at this level",
	4955	:	"//	mov xr (xs)+  restore xr",
	4956	:	"//	mov wb (xs)+  restore outer level",
	4957	:	"//	mov wc (xs)+  restore outer count",
	4958	:	"//	mov (xs) xr  store opnd over unused cmopn val",
	4959	:	"//	mov wa =num02  set new state",
	4960	:	"//	brn exp01   back for next ele8ent",
	4961	:	"//exp18	mov xl =c_arr  set cmtyp for array reference",
	4962	:	"//	beq wb =num03 exp15 jump to build cmblk if end arrayref",
	4963	:	"//	beq wb =num02 exp20 jump if end of direct goto",
	4964	:	"//	erb 225 syntax error: unbalanced right bracket  ",
	4965	:	"//exp19	mnz scnrs   rescan terminator",
	4966	:	"//	mov xl wb  copy level indicator",
	4967	:	"//	bsw xl 6  switch on level indicator",
	4968	:	"//exp20	jsr expdm   dump remaining operators",
	4969	:	"//	mov xr (xs)+  load tree pointer",
	4970	:	"//	ica xs   pop off bottom of stack marker",
	4971	:	"//	exi    return to expan caller",
	4972	:	"//exp21	erb 226 syntax error: missing right paren  ",
	4973	:	"//exp22	erb 227 syntax error: right paren missing from goto  ",
	4974	:	"//exp23	erb 228 syntax error: right bracket missing from goto  ",
	4975	:	"//exp24	erb 229 syntax error: missing right array bracket  ",
	4976	:	"//exp25	mov expsv xr  ",
	4977	:	"//	jsr expop   pop one operator",
	4978	:	"//	mov xr expsv  restore op dv pointer and merge",
	4979	:	"//exp26	mov xl num01(xs)  load operator dvptr from stack",
	4980	:	"//	ble xl =num05 exp27 jump if bottom of stack level",
	4981	:	"//	blt dvrpr(xr) dvlpr(xl) exp25 else pop if new prec is lo",
	4982	:	"//exp27	mov -(xs) xr  stack operator dvptr on stack",
	4983	:	"//	chk    check for stack overflow",
	4984	:	"//	mov wa =num01  set new state",
	4985	:	"//	bne xr =opdvs exp01 back for next element unless =",
	4986	:	"//	zer wa   set state zero",
	4987	:	"//	brn exp01   jump for next element",
	4988	:	"//expap	prc e 1  entry point",
	4989	:	"//	mov -(xs) xl  save xl",
	4990	:	"//	bne (xr) =b_cmt expp2 no match if not complex",
	4991	:	"//	mov wa cmtyp(xr)  else load type code",
	4992	:	"//	beq wa =c_cnc expp1 concatenation is a match",
	4993	:	"//	beq wa =c_pmt expp1 binary question mark is a match",
	4994	:	"//	bne wa =c_alt expp2 else not match unless alternation",
	4995	:	"//	mov xl cmlop(xr)  load left operand pointer",
	4996	:	"//	bne (xl) =b_cmt expp2 not match if left opnd not complex",
	4997	:	"//	bne cmtyp(xl) =c_cnc expp2 not match if left op not conc",
	4998	:	"//	mov cmlop(xr) cmrop(xl)  xr points to (b / c)",
	4999	:	"//	mov cmrop(xl) xr  set xl opnds to a, (b / c)",
	5000	:	"//	mov xr xl  point to this altered node",
	5001	:	"//expp1	mov xl (xs)+  restore entry xl",
	5002	:	"//	exi    give pattern match return",
	5003	:	"//expp2	mov xl (xs)+  restore entry xl",
	5004	:	"//	exi 1   give non-match return",
	5005	:	"//expdm	prc n 0  entry point",
	5006	:	"//	mov r_exs xl  save xl value",
	5007	:	"//exdm1	ble num01(xs) =num05 exdm2 jump if stack bottom (saved level",
	5008	:	"//	jsr expop   else pop one operator",
	5009	:	"//	brn exdm1   and loop back",
	5010	:	"//exdm2	mov xl r_exs  restore xl",
	5011	:	"//	zer r_exs   release save location",
	5012	:	"//	exi    return to expdm caller",
	5013	:	"//expop	prc n 0  entry point",
	5014	:	"//	mov xr num01(xs)  load operator dv pointer",
	5015	:	"//	beq dvlpr(xr) =lluno expo2 jump if unary",
	5016	:	"//	mov wa *cmbs_  set size of binary operator cmblk",
	5017	:	"//	jsr alloc   allocate space for cmblk",
	5018	:	"//	mov cmrop(xr) (xs)+  pop and store right operand ptr",
	5019	:	"//	mov xl (xs)+  pop and load operator dv ptr",
	5020	:	"//	mov cmlop(xr) (xs)  store left operand pointer",
	5021	:	"//expo1	mov (xr) =b_cmt  store type code for cmblk",
	5022	:	"//	mov cmtyp(xr) dvtyp(xl)  store cmblk node type code",
	5023	:	"//	mov cmopn(xr) xl  store dvptr (=ptr to dac o_xxx)",
	5024	:	"//	mov cmlen(xr) wa  store cmblk length",
	5025	:	"//	mov (xs) xr  store resulting node ptr on stack",
	5026	:	"//	exi    return to expop caller",
	5027	:	"//expo2	mov wa *cmus_  set size of unary operator cmblk",
	5028	:	"//	jsr alloc   allocate space for cmblk",
	5029	:	"//	mov cmrop(xr) (xs)+  pop and store operand pointer",
	5030	:	"//	mov xl (xs)  load operator dv pointer",
	5031	:	"//	brn expo1   merge back to exit",
	5032	:	"//filnm	prc e 0  entry point",
	5033	:	"//	mov -(xs) wb  preserve wb",
	5034	:	"//	bze wc filn3  return nulls if stno is zero",
	5035	:	"//	mov xl r_sfn  file name table",
	5036	:	"//	bze xl filn3  if no table",
	5037	:	"//	mov wb tbbuk(xl)  get bucket entry",
	5038	:	"//	beq wb r_sfn filn3 jump if no teblks on chain",
	5039	:	"//	mov -(xs) xr  preserve xr",
	5040	:	"//	mov xr wb  previous block pointer",
	5041	:	"//	mov -(xs) wc  preserve stmt number",
	5042	:	"//filn1	mov xl xr  next element to examine",
	5043	:	"//	mov xr tesub(xl)  load subscript value (an icblk)",
	5044	:	"//	ldi icval(xr)   load the statement number",
	5045	:	"//	mfi wc   convert to address constant",
	5046	:	"//	blt (xs) wc filn2 compare arg with teblk stmt number",
	5047	:	"//	mov wb xl  save previous entry pointer",
	5048	:	"//	mov xr tenxt(xl)  point to next teblk on chain",
	5049	:	"//	bne xr r_sfn filn1 jump if there is one",
	5050	:	"//filn2	mov xl wb  previous teblk",
	5051	:	"//	mov xl teval(xl)  get ptr to file name scblk",
	5052	:	"//	mov wc (xs)+  restore stmt number",
	5053	:	"//	mov xr (xs)+  restore xr",
	5054	:	"//	mov wb (xs)+  restore wb",
	5055	:	"//	exi    ",
	5056	:	"//filn3	mov wb (xs)+  restore wb",
	5057	:	"//	mov xl =nulls  return null string",
	5058	:	"//	exi    ",
	5059	:	"//gbcol	prc e 0  entry point",
	5060	:	"//	bnz dmvch gbc14  fail if in mid-dump",
	5061	:	"//	mnz gbcfl   note gbcol entered",
	5062	:	"//	mov gbsva wa  save entry wa",
	5063	:	"//	mov gbsvb wb  save entry wb",
	5064	:	"//	mov gbsvc wc  save entry wc",
	5065	:	"//	mov -(xs) xl  save entry xl",
	5066	:	"//	scp wa   get code pointer value",
	5067	:	"//	sub wa r_cod  make relative",
	5068	:	"//	lcp wa   and restore",
	5069	:	"//	bze wb gbc0a  check there is no move offset",
	5070	:	"//	zer dnams   collect sediment if must move it",
	5071	:	"//gbc0a	mov wa dnamb  start of dynamic area",
	5072	:	"//	add wa dnams  size of sediment",
	5073	:	"//	mov gbcsd wa  first location past sediment",
	5074	:	"//	mov wa =p_yyy  last entry point",
	5075	:	"//	icv wa   address past last entry point",
	5076	:	"//	sub wa =b_aaa  size of entry point area",
	5077	:	"//	mov gbcmk wa  use to mark processed sed. blocks",
	5078	:	"//	mnz xr   non-zero flags start of collection",
	5079	:	"//	mov wa dnamb  start of dynamic area",
	5080	:	"//	mov wb dnamp  next available location",
	5081	:	"//	mov wc dname  last available location + 1",
	5082	:	"//	jsr sysgc   inform of collection",
	5083	:	"//	mov xr xs  point to stack front",
	5084	:	"//	mov xl stbas  point past end of stack",
	5085	:	"//	bge xl xr gbc00 ok if d-stack",
	5086	:	"//	mov xr xl  reverse if ...",
	5087	:	"//	mov xl xs  ... u-stack",
	5088	:	"//gbc00	jsr gbcpf   process pointers on stack",
	5089	:	"//	mov xr =r_aaa  point to start of relocatable locs",
	5090	:	"//	mov xl =r_yyy  point past end of relocatable locs",
	5091	:	"//	jsr gbcpf   process work fields",
	5092	:	"//	mov wa hshtb  point to first hash slot pointer",
	5093	:	"//gbc01	mov xl wa  point to next slot",
	5094	:	"//	ica wa   bump bucket pointer",
	5095	:	"//	mov gbcnm wa  save bucket pointer",
	5096	:	"//gbc02	mov xr (xl)  load ptr to next vrblk",
	5097	:	"//	bze xr gbc03  jump if end of chain",
	5098	:	"//	mov xl xr  else copy vrblk pointer",
	5099	:	"//	add xr *vrval  point to first reloc fld",
	5100	:	"//	add xl *vrnxt  point past last (and to link ptr)",
	5101	:	"//	jsr gbcpf   process reloc fields in vrblk",
	5102	:	"//	brn gbc02   loop back for next block",
	5103	:	"//gbc03	mov wa gbcnm  restore bucket pointer",
	5104	:	"//	bne wa hshte gbc01 loop back if more buckets to go",
	5105	:	"//	mov xr dnamb  point to first block",
	5106	:	"//	zer wb   accumulate size of dead blocks",
	5107	:	"//gbc04	beq xr gbcsd gbc4c jump if end of sediment",
	5108	:	"//	mov wa (xr)  else get first word",
	5109	:	"//	bhi wa =p_yyy gbc4a skip if not entry ptr (in use)",
	5110	:	"//	bhi wa =b_aaa gbc4b jump if entry pointer (unused)",
	5111	:	"//gbc4a	sub wa gbcmk  restore entry pointer",
	5112	:	"//	mov (xr) wa  restore first word",
	5113	:	"//	jsr blkln   get length of this block",
	5114	:	"//	add xr wa  bump actual pointer",
	5115	:	"//	brn gbc04   continue scan through sediment",
	5116	:	"//gbc4b	jsr blkln   get length of this block",
	5117	:	"//	add xr wa  bump actual pointer",
	5118	:	"//	add wb wa  count size of unused blocks",
	5119	:	"//	brn gbc04   continue scan through sediment",
	5120	:	"//gbc4c	mov gbcsf wb  size of sediment free space",
	5121	:	"//	mov wc xr  set as first eventual location",
	5122	:	"//	add wc gbsvb  add offset for eventual move up",
	5123	:	"//	zer gbcnm   clear initial forward pointer",
	5124	:	"//	mov gbclm =gbcnm  initialize ptr to last move block",
	5125	:	"//	mov gbcns xr  initialize first address",
	5126	:	"//gbc05	beq xr dnamp gbc07 jump if end of used region",
	5127	:	"//	mov wa (xr)  else get first word",
	5128	:	"//	bhi wa =p_yyy gbc06 skip if not entry ptr (in use)",
	5129	:	"//	bhi wa =b_aaa gbc07 jump if entry pointer (unused)",
	5130	:	"//gbc06	mov xl wa  copy pointer",
	5131	:	"//	mov wa (xl)  load forward pointer",
	5132	:	"//	mov (xl) wc  relocate reference",
	5133	:	"//	bhi wa =p_yyy gbc06 loop back if not end of chain",
	5134	:	"//	blo wa =b_aaa gbc06 loop back if not end of chain",
	5135	:	"//	mov (xr) wa  restore first word",
	5136	:	"//	jsr blkln   get length of this block",
	5137	:	"//	add xr wa  bump actual pointer",
	5138	:	"//	add wc wa  bump eventual pointer",
	5139	:	"//	brn gbc05   loop back for next block",
	5140	:	"//gbc07	mov wa xr  copy pointer past last block",
	5141	:	"//	mov xl gbclm  point to previous move block",
	5142	:	"//	sub wa num01(xl)  subtract starting address",
	5143	:	"//	mov num01(xl) wa  store length of block to be moved",
	5144	:	"//gbc08	beq xr dnamp gbc10 jump if end of used region",
	5145	:	"//	mov wa (xr)  else load first word of next block",
	5146	:	"//	bhi wa =p_yyy gbc09 jump if in use",
	5147	:	"//	blo wa =b_aaa gbc09 jump if in use",
	5148	:	"//	jsr blkln   else get length of next block",
	5149	:	"//	add xr wa  push pointer",
	5150	:	"//	brn gbc08   and loop back",
	5151	:	"//gbc09	sub xr *num02  point 2 words behind for move block",
	5152	:	"//	mov xl gbclm  point to previous move block",
	5153	:	"//	mov (xl) xr  set forward ptr in previous block",
	5154	:	"//	zer (xr)   zero forward ptr of new block",
	5155	:	"//	mov gbclm xr  remember address of this block",
	5156	:	"//	mov xl xr  copy ptr to move block",
	5157	:	"//	add xr *num02  point back to block in use",
	5158	:	"//	mov num01(xl) xr  store starting address",
	5159	:	"//	brn gbc06   jump to process block in use",
	5160	:	"//gbc10	mov xr gbcsd  point to storage above sediment",
	5161	:	"//	add xr gbcns  bump past unmoved blocks at start",
	5162	:	"//gbc11	mov xl gbcnm  point to next move block",
	5163	:	"//	bze xl gbc12  jump if end of chain",
	5164	:	"//	mov gbcnm (xl)+  move pointer down chain",
	5165	:	"//	mov wa (xl)+  get length to move",
	5166	:	"//	mvw    perform move",
	5167	:	"//	brn gbc11   loop back",
	5168	:	"//gbc12	mov dnamp xr  set next available loc ptr",
	5169	:	"//	mov wb gbsvb  reload move offset",
	5170	:	"//	bze wb gbc13  jump if no move required",
	5171	:	"//	mov xl xr  else copy old top of core",
	5172	:	"//	add xr wb  point to new top of core",
	5173	:	"//	mov dnamp xr  save new top of core pointer",
	5174	:	"//	mov wa xl  copy old top",
	5175	:	"//	sub wa dnamb  minus old bottom = length",
	5176	:	"//	add dnamb wb  bump bottom to get new value",
	5177	:	"//	mwb    perform move (backwards)",
	5178	:	"//gbc13	zer xr   clear garbage value in xr",
	5179	:	"//	mov gbcfl xr  note exit from gbcol",
	5180	:	"//	mov wa dnamb  start of dynamic area",
	5181	:	"//	mov wb dnamp  next available location",
	5182	:	"//	mov wc dname  last available location + 1",
	5183	:	"//	jsr sysgc   inform sysgc of completion",
	5184	:	"//	sti gbcia   save ia",
	5185	:	"//	zer xr   presume no sediment will remain",
	5186	:	"//	mov wb gbcsf  free space in sediment",
	5187	:	"//	btw wb   convert bytes to words",
	5188	:	"//	mti wb   put sediment free store in ia",
	5189	:	"//	mli gbsed   multiply by sediment factor",
	5190	:	"//	iov gb13a   jump if overflowed",
	5191	:	"//	mov wb dnamp  end of dynamic area in use",
	5192	:	"//	sub wb dnamb  minus start is sediment remaining",
	5193	:	"//	btw wb   convert to words",
	5194	:	"//	mov gbcsf wb  store it",
	5195	:	"//	sbi gbcsf   subtract from scaled up free store",
	5196	:	"//	igt gb13a   jump if large free store in sedimnt",
	5197	:	"//	mov xr dnamp  below threshold, return sediment",
	5198	:	"//	sub xr dnamb  for use by caller",
	5199	:	"//gb13a	ldi gbcia   restore ia",
	5200	:	"//	mov wa gbsva  restore wa",
	5201	:	"//	mov wb gbsvb  restore wb",
	5202	:	"//	scp wc   get code pointer",
	5203	:	"//	add wc r_cod  make absolute again",
	5204	:	"//	lcp wc   and replace absolute value",
	5205	:	"//	mov wc gbsvc  restore wc",
	5206	:	"//	mov xl (xs)+  restore entry xl",
	5207	:	"//	icv gbcnt   increment count of collections",
	5208	:	"//	exi    exit to gbcol caller",
	5209	:	"//gbc14	icv errft   fatal error",
	5210	:	"//	erb 250 insufficient memory to complete dump  ",
	5211	:	"//gbcpf	prc e 0  entry point",
	5212	:	"//	zer -(xs)   set zero to mark bottom of stack",
	5213	:	"//	mov -(xs) xl  save end pointer",
	5214	:	"//gpf01	mov xl (xr)  load field contents",
	5215	:	"//	mov wc xr  save field pointer",
	5216	:	"//	blt xl dnamb gpf2a jump if not ptr into dynamic area",
	5217	:	"//	bge xl dnamp gpf2a jump if not ptr into dynamic area",
	5218	:	"//	mov wa (xl)  load ptr to chain (or entry ptr)",
	5219	:	"//	blt xl gbcsd gpf1a do not chain if within sediment",
	5220	:	"//	mov (xl) xr  set this field as new head of chain",
	5221	:	"//	mov (xr) wa  set forward pointer",
	5222	:	"//gpf1a	bhi wa =p_yyy gpf2a jump if already processed",
	5223	:	"//	bhi wa =b_aaa gpf03 jump if not already processed",
	5224	:	"//gpf02	mov xr wc  restore field pointer",
	5225	:	"//gpf2a	ica xr   bump to next field",
	5226	:	"//	bne xr (xs) gpf01 loop back if more to go",
	5227	:	"//	mov xl (xs)+  restore pointer past end",
	5228	:	"//	mov xr (xs)+  restore block pointer",
	5229	:	"//	bnz xr gpf2a  continue loop unless outer levl",
	5230	:	"//	exi    return to caller if outer level",
	5231	:	"//gpf03	bge xl gbcsd gpf3a if not within sediment",
	5232	:	"//	add (xl) gbcmk  mark by biasing entry point",
	5233	:	"//gpf3a	mov xr xl  copy block pointer",
	5234	:	"//	mov xl wa  copy first word of block",
	5235	:	"//	lei xl   load entry point id (bl_xx)",
	5236	:	"//	bsw xl bl___  switch on block type",
	5237	:	"//gpf04	mov wa cmlen(xr)  load length",
	5238	:	"//	mov wb *cmtyp  set offset",
	5239	:	"//gpf05	add wa xr  point past last reloc field",
	5240	:	"//	add xr wb  point to first reloc field",
	5241	:	"//	mov -(xs) wc  stack old field pointer",
	5242	:	"//	mov -(xs) wa  stack new limit pointer",
	5243	:	"//	chk    check for stack overflow",
	5244	:	"//	brn gpf01   if ok, back to process",
	5245	:	"//gpf06	mov wa arlen(xr)  load length",
	5246	:	"//	mov wb arofs(xr)  set offset to 1st reloc fld (arpro)",
	5247	:	"//	brn gpf05   all set",
	5248	:	"//gpf07	mov wa ccuse(xr)  set length in use",
	5249	:	"//	mov wb *ccuse  1st word (make sure at least one)",
	5250	:	"//	brn gpf05   all set",
	5251	:	"//gpf19	mov wa cdlen(xr)  load length",
	5252	:	"//	mov wb *cdfal  set offset",
	5253	:	"//	brn gpf05   jump back",
	5254	:	"//gpf08	mov wa offs2(xr)  load length",
	5255	:	"//	mov wb *offs3  set offset",
	5256	:	"//	brn gpf05   jump back",
	5257	:	"//gpf09	mov wa xrlen(xr)  load length",
	5258	:	"//	mov wb *xrptr  set offset",
	5259	:	"//	brn gpf05   jump back",
	5260	:	"//gpf10	mov wa *offs2  point past second field",
	5261	:	"//	mov wb *offs1  offset is one (only reloc fld is 2)",
	5262	:	"//	brn gpf05   all set",
	5263	:	"//gpf11	mov wa *ffofs  set length",
	5264	:	"//	mov wb *ffnxt  set offset",
	5265	:	"//	brn gpf05   all set",
	5266	:	"//gpf12	mov wa *parm2  length (parm2 is non-relocatable)",
	5267	:	"//	mov wb *pthen  set offset",
	5268	:	"//	brn gpf05   all set",
	5269	:	"//gpf13	mov xl pddfp(xr)  load ptr to dfblk",
	5270	:	"//	mov wa dfpdl(xl)  get pdblk length",
	5271	:	"//	mov wb *pdfld  set offset",
	5272	:	"//	brn gpf05   all set",
	5273	:	"//gpf14	mov wa *pfarg  length past last reloc",
	5274	:	"//	mov wb *pfcod  offset to first reloc",
	5275	:	"//	brn gpf05   all set",
	5276	:	"//gpf15	mov wa *tesi_  set length",
	5277	:	"//	mov wb *tesub  and offset",
	5278	:	"//	brn gpf05   all set",
	5279	:	"//gpf16	mov wa *trsi_  set length",
	5280	:	"//	mov wb *trval  and offset",
	5281	:	"//	brn gpf05   all set",
	5282	:	"//gpf17	mov wa exlen(xr)  load length",
	5283	:	"//	mov wb *exflc  set offset",
	5284	:	"//	brn gpf05   jump back",
	5285	:	"//gtarr	prc e 2  entry point",
	5286	:	"//	mov gtawa wa  save wa indicator",
	5287	:	"//	mov wa (xr)  load type word",
	5288	:	"//	beq wa =b_art gtar8 exit if already an array",
	5289	:	"//	beq wa =b_vct gtar8 exit if already an array",
	5290	:	"//	bne wa =b_tbt gta9a else fail if not a table (sgd02)",
	5291	:	"//	mov -(xs) xr  replace tbblk pointer on stack",
	5292	:	"//	zer xr   signal first pass",
	5293	:	"//	zer wb   zero non-null element count",
	5294	:	"//gtar1	mov xl (xs)  point to table",
	5295	:	"//	add xl tblen(xl)  point past last bucket",
	5296	:	"//	sub xl *tbbuk  set first bucket offset",
	5297	:	"//	mov wa xl  copy adjusted pointer",
	5298	:	"//gtar2	mov xl wa  copy bucket pointer",
	5299	:	"//	dca wa   decrement bucket pointer",
	5300	:	"//gtar3	mov xl tenxt(xl)  point to next teblk",
	5301	:	"//	beq xl (xs) gtar6 jump if chain end (tbblk ptr)",
	5302	:	"//	mov cnvtp xl  else save teblk pointer",
	5303	:	"//gtar4	mov xl teval(xl)  load value",
	5304	:	"//	beq (xl) =b_trt gtar4 loop till value found",
	5305	:	"//	mov wc xl  copy value",
	5306	:	"//	mov xl cnvtp  restore teblk pointer",
	5307	:	"//	beq wc =nulls gtar3 loop back to ignore null value",
	5308	:	"//	bnz xr gtar5  jump if second pass",
	5309	:	"//	icv wb   for the first pass, bump count",
	5310	:	"//	brn gtar3   and loop back for next teblk",
	5311	:	"//gtar5	bze gtawa gta5a  jump if address wanted",
	5312	:	"//	mov (xr)+ tesub(xl)  store subscript name",
	5313	:	"//	mov (xr)+ wc  store value in arblk",
	5314	:	"//	brn gtar3   loop back for next teblk",
	5315	:	"//gta5a	mov (xr)+ xl  store teblk address in name",
	5316	:	"//	mov (xr)+ xl  and value slots",
	5317	:	"//	brn gtar3   loop back for next teblk",
	5318	:	"//gtar6	bne wa (xs) gtar2 loop back if more buckets to go",
	5319	:	"//	bnz xr gtar7  else jump if second pass",
	5320	:	"//	bze wb gtar9  fail if no non-null elements",
	5321	:	"//	mov wa wb  else copy count",
	5322	:	"//	add wa wb  double (two words/element)",
	5323	:	"//	add wa =arvl2  add space for standard fields",
	5324	:	"//	wtb wa   convert length to bytes",
	5325	:	"//	bgt wa mxlen gta9b error if too long for array",
	5326	:	"//	jsr alloc   else allocate space for arblk",
	5327	:	"//	mov (xr) =b_art  store type word",
	5328	:	"//	zer idval(xr)   zero id for the moment",
	5329	:	"//	mov arlen(xr) wa  store length",
	5330	:	"//	mov arndm(xr) =num02  set dimensions = 2",
	5331	:	"//	ldi 4,intv1   get integer one",
	5332	:	"//	sti arlbd(xr)   store as lbd 1",
	5333	:	"//	sti arlb2(xr)   store as lbd 2",
	5334	:	"//	ldi 4,intv2   load integer two",
	5335	:	"//	sti ardm2(xr)   store as dim 2",
	5336	:	"//	mti wb   get element count as integer",
	5337	:	"//	sti ardim(xr)   store as dim 1",
	5338	:	"//	zer arpr2(xr)   zero prototype field for now",
	5339	:	"//	mov arofs(xr) *arpr2  set offset field (signal pass 2)",
	5340	:	"//	mov wb xr  save arblk pointer",
	5341	:	"//	add xr *arvl2  point to first element location",
	5342	:	"//	brn gtar1   jump back to fill in elements",
	5343	:	"//gtar7	mov xr wb  restore arblk pointer",
	5344	:	"//	mov (xs) wb  store as result",
	5345	:	"//	ldi ardim(xr)   get number of elements (nn)",
	5346	:	"//	mli 4,intvh   multiply by 100",
	5347	:	"//	adi 4,intv2   add 2 (nn02)",
	5348	:	"//	jsr icbld   build integer",
	5349	:	"//	mov -(xs) xr  store ptr for gtstg",
	5350	:	"//	jsr gtstg   convert to string",
	5351	:	"//	mov xl xr  copy string pointer",
	5352	:	"//	mov xr (xs)+  reload arblk pointer",
	5353	:	"//	mov arpr2(xr) xl  store prototype ptr (nn02)",
	5354	:	"//	sub wa =num02  adjust length to point to zero",
	5355	:	"//	psc xl wa  point to zero",
	5356	:	"//	mov wb =ch_cm  load a comma",
	5357	:	"//	sch wb (xl)  store a comma over the zero",
	5358	:	"//	csc xl   complete store characters",
	5359	:	"//gtar8	exi    return to caller",
	5360	:	"//gtar9	mov xr (xs)+  restore stack for conv err (sgd02)",
	5361	:	"//	exi 1   return",
	5362	:	"//gta9a	exi 2   return",
	5363	:	"//gta9b	erb 260 conversion array size exceeds maximum permitted  ",
	5364	:	"//gtcod	prc e 1  entry point",
	5365	:	"//	beq (xr) =b_cds gtcd1 jump if already code",
	5366	:	"//	beq (xr) =b_cdc gtcd1 jump if already code",
	5367	:	"//	mov -(xs) xr  stack argument for gtstg",
	5368	:	"//	jsr gtstg   convert argument to string",
	5369	:	"//	mov gtcef flptr  save fail ptr in case of error",
	5370	:	"//	mov r_gtc r_cod  also save code ptr",
	5371	:	"//	mov r_cim xr  else set image pointer",
	5372	:	"//	mov scnil wa  set image length",
	5373	:	"//	zer scnpt   set scan pointer",
	5374	:	"//	mov stage =stgxc  set stage for execute compile",
	5375	:	"//	mov lstsn cmpsn  in case listr called",
	5376	:	"//	icv cmpln   bump line number",
	5377	:	"//	jsr cmpil   compile string",
	5378	:	"//	mov stage =stgxt  reset stage for execute time",
	5379	:	"//	zer r_cim   clear image",
	5380	:	"//gtcd1	exi    give normal gtcod return",
	5381	:	"//gtcd2	exi 1   give error return",
	5382	:	"//gtexp	prc e 1  entry point",
	5383	:	"//	blo (xr) =b_e__ gtex1 jump if already an expression",
	5384	:	"//	mov -(xs) xr  store argument for gtstg",
	5385	:	"//	jsr gtstg   convert argument to string",
	5386	:	"//	mov xl xr  copy input string pointer",
	5387	:	"//	plc xl wa  point one past the string end",
	5388	:	"//	lch xl -(xl)  fetch the last character",
	5389	:	"//	beq xl =ch_cl gtex2 error if it is a semicolon",
	5390	:	"//	beq xl =ch_sm gtex2 or if it is a colon",
	5391	:	"//	mov r_cim xr  set input image pointer",
	5392	:	"//	zer scnpt   set scan pointer",
	5393	:	"//	mov scnil wa  set input image length",
	5394	:	"//	mov -(xs) wb  save value/name flag",
	5395	:	"//	zer wb   set code for normal scan",
	5396	:	"//	mov gtcef flptr  save fail ptr in case of error",
	5397	:	"//	mov r_gtc r_cod  also save code ptr",
	5398	:	"//	mov stage =stgev  adjust stage for compile",
	5399	:	"//	mov scntp =t_uok  indicate unary operator acceptable",
	5400	:	"//	jsr expan   build tree for expression",
	5401	:	"//	zer scnrs   reset rescan flag",
	5402	:	"//	mov wa (xs)+  restore value/name flag",
	5403	:	"//	bne scnpt scnil gtex2 error if not end of image",
	5404	:	"//	zer wb   set ok value for cdgex call",
	5405	:	"//	mov xl xr  copy tree pointer",
	5406	:	"//	jsr cdgex   build expression block",
	5407	:	"//	zer r_cim   clear pointer",
	5408	:	"//	mov stage =stgxt  restore stage for execute time",
	5409	:	"//gtex1	exi    return to gtexp caller",
	5410	:	"//gtex2	exi 1   take error exit",
	5411	:	"//gtint	prc e 1  entry point",
	5412	:	"//	beq (xr) =b_icl gtin2 jump if already an integer",
	5413	:	"//	mov gtina wa  else save wa",
	5414	:	"//	mov gtinb wb  save wb",
	5415	:	"//	jsr gtnum   convert to numeric",
	5416	:	"//	beq wa =b_icl gtin1 jump if integer",
	5417	:	"//	ldr rcval(xr)   load real value",
	5418	:	"//	rti gtin3   convert to integer (err if ovflow)",
	5419	:	"//	jsr icbld   if ok build icblk",
	5420	:	"//gtin1	mov wa gtina  restore wa",
	5421	:	"//	mov wb gtinb  restore wb",
	5422	:	"//gtin2	exi    return to gtint caller",
	5423	:	"//gtin3	exi 1   take convert error exit",
	5424	:	"//gtnum	prc e 1  entry point",
	5425	:	"//	mov wa (xr)  load first word of block",
	5426	:	"//	beq wa =b_icl gtn34 jump if integer (no conversion)",
	5427	:	"//	beq wa =b_rcl gtn34 jump if real (no conversion)",
	5428	:	"//	mov -(xs) xr  stack argument in case convert err",
	5429	:	"//	mov -(xs) xr  stack argument for gtstg",
	5430	:	"//	jsr gtstg   convert argument to string",
	5431	:	"//	ldi 4,intv0   initialize integer result to zero",
	5432	:	"//	bze wa gtn32  jump to exit with zero if null",
	5433	:	"//	lct wa wa  set bct counter for following loops",
	5434	:	"//	zer gtnnf   tentatively indicate result +",
	5435	:	"//	sti gtnex   initialise exponent to zero",
	5436	:	"//	zer gtnsc   zero scale in case real",
	5437	:	"//	zer gtndf   reset flag for dec point found",
	5438	:	"//	zer gtnrd   reset flag for digits found",
	5439	:	"//	ldr 4,reav0   zero real accum in case real",
	5440	:	"//	plc xr   point to argument characters",
	5441	:	"//gtn01	lch wb (xr)+  load first character",
	5442	:	"//	blt wb =ch_d0 gtn02 jump if not digit",
	5443	:	"//	ble wb =ch_d9 gtn06 jump if first char is a digit",
	5444	:	"//gtn02	bne wb =ch_bl gtn03 jump if non-blank",
	5445	:	"//gtna2	bct wa gtn01  else decr count and loop back",
	5446	:	"//	brn gtn07   jump to return zero if all blanks",
	5447	:	"//gtn03	beq wb =ch_pl gtn04 jump if plus sign",
	5448	:	"//	beq wb =ch_ht gtna2 horizontal tab equiv to blank",
	5449	:	"//	bne wb =ch_mn gtn12 jump if not minus (may be real)",
	5450	:	"//	mnz gtnnf   if minus sign, set negative flag",
	5451	:	"//gtn04	bct wa gtn05  jump if chars left",
	5452	:	"//	brn gtn36   else error",
	5453	:	"//gtn05	lch wb (xr)+  load next character",
	5454	:	"//	blt wb =ch_d0 gtn08 jump if not a digit",
	5455	:	"//	bgt wb =ch_d9 gtn08 jump if not a digit",
	5456	:	"//gtn06	sti gtnsi   save current value",
	5457	:	"//	cvm gtn35   current*10-(new dig) jump if ovflow",
	5458	:	"//	mnz gtnrd   set digit read flag",
	5459	:	"//	bct wa gtn05  else loop back if more chars",
	5460	:	"//gtn07	bnz gtnnf gtn32  jump if negative (all set)",
	5461	:	"//	ngi    else negate",
	5462	:	"//	ino gtn32   jump if no overflow",
	5463	:	"//	brn gtn36   else signal error",
	5464	:	"//gtn08	beq wb =ch_bl gtna9 jump if a blank",
	5465	:	"//	beq wb =ch_ht gtna9 jump if horizontal tab",
	5466	:	"//	itr    else convert integer to real",
	5467	:	"//	ngr    negate to get positive value",
	5468	:	"//	brn gtn12   jump to try for real",
	5469	:	"//gtn09	lch wb (xr)+  get next char",
	5470	:	"//	beq wb =ch_ht gtna9 jump if horizontal tab",
	5471	:	"//	bne wb =ch_bl gtn36 error if non-blank",
	5472	:	"//gtna9	bct wa gtn09  loop back if more chars to check",
	5473	:	"//	brn gtn07   return integer if all blanks",
	5474	:	"//gtn10	lch wb (xr)+  load next character",
	5475	:	"//	blt wb =ch_d0 gtn12 jump if non-numeric",
	5476	:	"//	bgt wb =ch_d9 gtn12 jump if non-numeric",
	5477	:	"//gtn11	sub wb =ch_d0  convert digit to number",
	5478	:	"//	mlr 4,reavt   multiply real by 10.0",
	5479	:	"//	rov gtn36   convert error if overflow",
	5480	:	"//	str gtnsr   save result",
	5481	:	"//	mti wb   get new digit as integer",
	5482	:	"//	itr    convert new digit to real",
	5483	:	"//	adr gtnsr   add to get new total",
	5484	:	"//	add gtnsc gtndf  increment scale if after dec point",
	5485	:	"//	mnz gtnrd   set digit found flag",
	5486	:	"//	bct wa gtn10  loop back if more chars",
	5487	:	"//	brn gtn22   else jump to scale",
	5488	:	"//gtn12	bne wb =ch_dt gtn13 jump if not dec point",
	5489	:	"//	bnz gtndf gtn36  if dec point, error if one already",
	5490	:	"//	mov gtndf =num01  else set flag for dec point",
	5491	:	"//	bct wa gtn10  loop back if more chars",
	5492	:	"//	brn gtn22   else jump to scale",
	5493	:	"//gtn13	beq wb =ch_le gtn15 jump if e for exponent",
	5494	:	"//	beq wb =ch_ld gtn15 jump if d for exponent",
	5495	:	"//gtn14	beq wb =ch_bl gtnb4 jump if blank",
	5496	:	"//	beq wb =ch_ht gtnb4 jump if horizontal tab",
	5497	:	"//	brn gtn36   error if non-blank",
	5498	:	"//gtnb4	lch wb (xr)+  get next character",
	5499	:	"//	bct wa gtn14  loop back to check if more",
	5500	:	"//	brn gtn22   else jump to scale",
	5501	:	"//gtn15	zer gtnes   set exponent sign positive",
	5502	:	"//	ldi 4,intv0   initialize exponent to zero",
	5503	:	"//	mnz gtndf   reset no dec point indication",
	5504	:	"//	bct wa gtn16  jump skipping past e or d",
	5505	:	"//	brn gtn36   error if null exponent",
	5506	:	"//gtn16	lch wb (xr)+  load first exponent character",
	5507	:	"//	beq wb =ch_pl gtn17 jump if plus sign",
	5508	:	"//	bne wb =ch_mn gtn19 else jump if not minus sign",
	5509	:	"//	mnz gtnes   set sign negative if minus sign",
	5510	:	"//gtn17	bct wa gtn18  jump if chars left",
	5511	:	"//	brn gtn36   else error",
	5512	:	"//gtn18	lch wb (xr)+  load next character",
	5513	:	"//gtn19	blt wb =ch_d0 gtn20 jump if not digit",
	5514	:	"//	bgt wb =ch_d9 gtn20 jump if not digit",
	5515	:	"//	cvm gtn36   else current*10, subtract new digit",
	5516	:	"//	bct wa gtn18  loop back if more chars",
	5517	:	"//	brn gtn21   jump if exponent field is exhausted",
	5518	:	"//gtn20	beq wb =ch_bl gtnc0 jump if blank",
	5519	:	"//	beq wb =ch_ht gtnc0 jump if horizontal tab",
	5520	:	"//	brn gtn36   error if non-blank",
	5521	:	"//gtnc0	lch wb (xr)+  get next character",
	5522	:	"//	bct wa gtn20  loop back till all blanks scanned",
	5523	:	"//gtn21	sti gtnex   save collected exponent",
	5524	:	"//	bnz gtnes gtn22  jump if it was negative",
	5525	:	"//	ngi    else complement",
	5526	:	"//	iov gtn36   error if overflow",
	5527	:	"//	sti gtnex   and store positive exponent",
	5528	:	"//gtn22	bze gtnrd gtn36  error if not digits collected",
	5529	:	"//	bze gtndf gtn36  error if no exponent or dec point",
	5530	:	"//	mti gtnsc   else load scale as integer",
	5531	:	"//	sbi gtnex   subtract exponent",
	5532	:	"//	iov gtn36   error if overflow",
	5533	:	"//	ilt gtn26   jump if we must scale up",
	5534	:	"//	mfi wa gtn36  load scale factor, err if ovflow",
	5535	:	"//gtn23	ble wa =num10 gtn24 jump if 10 or less to go",
	5536	:	"//	dvr 4,reatt   else divide by 10**10",
	5537	:	"//	sub wa =num10  decrement scale",
	5538	:	"//	brn gtn23   and loop back",
	5539	:	"//gtn24	bze wa gtn30  jump if scaled",
	5540	:	"//	lct wb =cfp_r  else get indexing factor",
	5541	:	"//	mov xr =reav1  point to powers of ten table",
	5542	:	"//	wtb wa   convert remaining scale to byte ofs",
	5543	:	"//gtn25	add xr wa  bump pointer",
	5544	:	"//	bct wb gtn25  once for each value word",
	5545	:	"//	dvr (xr)   scale down as required",
	5546	:	"//	brn gtn30   and jump",
	5547	:	"//gtn26	ngi    get absolute value of exponent",
	5548	:	"//	iov gtn36   error if overflow",
	5549	:	"//	mfi wa gtn36  acquire scale, error if ovflow",
	5550	:	"//gtn27	ble wa =num10 gtn28 jump if 10 or less to go",
	5551	:	"//	mlr 4,reatt   else multiply by 10**10",
	5552	:	"//	rov gtn36   error if overflow",
	5553	:	"//	sub wa =num10  else decrement scale",
	5554	:	"//	brn gtn27   and loop back",
	5555	:	"//gtn28	bze wa gtn30  jump if scaled",
	5556	:	"//	lct wb =cfp_r  else get indexing factor",
	5557	:	"//	mov xr =reav1  point to powers of ten table",
	5558	:	"//	wtb wa   convert remaining scale to byte ofs",
	5559	:	"//gtn29	add xr wa  bump pointer",
	5560	:	"//	bct wb gtn29  once for each word in value",
	5561	:	"//	mlr (xr)   scale up",
	5562	:	"//	rov gtn36   error if overflow",
	5563	:	"//gtn30	bze gtnnf gtn31  jump if positive",
	5564	:	"//	ngr    else negate",
	5565	:	"//gtn31	jsr rcbld   build real block",
	5566	:	"//	brn gtn33   merge to exit",
	5567	:	"//gtn32	jsr icbld   build icblk",
	5568	:	"//gtn33	mov wa (xr)  load first word of result block",
	5569	:	"//	ica xs   pop argument off stack",
	5570	:	"//gtn34	exi    return to gtnum caller",
	5571	:	"//gtn35	lch wb -(xr)  reload current character",
	5572	:	"//	lch wb (xr)+  bump character pointer",
	5573	:	"//	ldi gtnsi   reload integer so far",
	5574	:	"//	itr    convert to real",
	5575	:	"//	ngr    make value positive",
	5576	:	"//	brn gtn11   merge with real circuit",
	5577	:	"//gtn36	mov xr (xs)+  reload original argument",
	5578	:	"//	exi 1   take convert-error exit",
	5579	:	"//gtnvr	prc e 1  entry point",
	5580	:	"//	bne (xr) =b_nml gnv02 jump if not name",
	5581	:	"//	mov xr nmbas(xr)  else load name base if name",
	5582	:	"//	blo xr state gnv07 skip if vrblk (in static region)",
	5583	:	"//gnv01	exi 1   take convert-error exit",
	5584	:	"//gnv02	mov gnvsa wa  save wa",
	5585	:	"//	mov gnvsb wb  save wb",
	5586	:	"//	mov -(xs) xr  stack argument for gtstg",
	5587	:	"//	jsr gtstg   convert argument to string",
	5588	:	"//	bze wa gnv01  null string is an error",
	5589	:	"//	mov -(xs) xl  save xl",
	5590	:	"//	mov -(xs) xr  stack string ptr for later",
	5591	:	"//	mov wb xr  copy string pointer",
	5592	:	"//	add wb *schar  point to characters of string",
	5593	:	"//	mov gnvst wb  save pointer to characters",
	5594	:	"//	mov wb wa  copy length",
	5595	:	"//	ctw wb 0  get number of words in name",
	5596	:	"//	mov gnvnw wb  save for later",
	5597	:	"//	jsr hashs   compute hash index for string",
	5598	:	"//	rmi hshnb   compute hash offset by taking mod",
	5599	:	"//	mfi wc   get as offset",
	5600	:	"//	wtb wc   convert offset to bytes",
	5601	:	"//	add wc hshtb  point to proper hash chain",
	5602	:	"//	sub wc *vrnxt  subtract offset to merge into loop",
	5603	:	"//gnv03	mov xl wc  copy hash chain pointer",
	5604	:	"//	mov xl vrnxt(xl)  point to next vrblk on chain",
	5605	:	"//	bze xl gnv08  jump if end of chain",
	5606	:	"//	mov wc xl  save pointer to this vrblk",
	5607	:	"//	bnz vrlen(xl) gnv04  jump if not system variable",
	5608	:	"//	mov xl vrsvp(xl)  else point to svblk",
	5609	:	"//	sub xl *vrsof  adjust offset for merge",
	5610	:	"//gnv04	bne wa vrlen(xl) gnv03 back for next vrblk if lengths ne",
	5611	:	"//	add xl *vrchs  else point to chars of chain entry",
	5612	:	"//	lct wb gnvnw  get word counter to control loop",
	5613	:	"//	mov xr gnvst  point to chars of new name",
	5614	:	"//gnv05	cne (xr) (xl) gnv03 jump if no match for next vrblk",
	5615	:	"//	ica xr   bump new name pointer",
	5616	:	"//	ica xl   bump vrblk in chain name pointer",
	5617	:	"//	bct wb gnv05  else loop till all compared",
	5618	:	"//	mov xr wc  we have found a match, get vrblk",
	5619	:	"//gnv06	mov wa gnvsa  restore wa",
	5620	:	"//	mov wb gnvsb  restore wb",
	5621	:	"//	ica xs   pop string pointer",
	5622	:	"//	mov xl (xs)+  restore xl",
	5623	:	"//gnv07	exi    return to gtnvr caller",
	5624	:	"//gnv08	zer xr   clear garbage xr pointer",
	5625	:	"//	mov gnvhe wc  save ptr to end of hash chain",
	5626	:	"//	bgt wa =num09 gnv14 cannot be system var if length gt 9",
	5627	:	"//	mov xl wa  else copy length",
	5628	:	"//	wtb xl   convert to byte offset",
	5629	:	"//	mov xl 14,vsrch(xl)  point to first svblk of this length",
	5630	:	"//gnv09	mov gnvsp xl  save table pointer",
	5631	:	"//	mov wc (xl)+  load svbit bit string",
	5632	:	"//	mov wb (xl)+  load length from table entry",
	5633	:	"//	bne wa wb gnv14 jump if end of right length entries",
	5634	:	"//	lct wb gnvnw  get word counter to control loop",
	5635	:	"//	mov xr gnvst  point to chars of new name",
	5636	:	"//gnv10	cne (xr) (xl) gnv11 jump if name mismatch",
	5637	:	"//	ica xr   else bump new name pointer",
	5638	:	"//	ica xl   bump svblk pointer",
	5639	:	"//	bct wb gnv10  else loop until all checked",
	5640	:	"//	zer wc   set vrlen value zero",
	5641	:	"//	mov wa *vrsi_  set standard size",
	5642	:	"//	brn gnv15   jump to build vrblk",
	5643	:	"//gnv11	ica xl   bump past word of chars",
	5644	:	"//	bct wb gnv11  loop back if more to go",
	5645	:	"//	rsh wc svnbt  remove uninteresting bits",
	5646	:	"//gnv12	mov wb 4,bits1  load bit to test",
	5647	:	"//	anb wb wc  test for word present",
	5648	:	"//	zrb wb gnv13  jump if not present",
	5649	:	"//	ica xl   else bump table pointer",
	5650	:	"//gnv13	rsh wc 1  remove bit already processed",
	5651	:	"//	nzb wc gnv12  loop back if more bits to test",
	5652	:	"//	brn gnv09   else loop back for next svblk",
	5653	:	"//gnv14	mov wc wa  copy vrlen value",
	5654	:	"//	mov wa =vrchs  load standard size -chars",
	5655	:	"//	add wa gnvnw  adjust for chars of name",
	5656	:	"//	wtb wa   convert length to bytes",
	5657	:	"//gnv15	jsr alost   allocate space for vrblk (static)",
	5658	:	"//	mov wb xr  save vrblk pointer",
	5659	:	"//	mov xl =stnvr  point to model variable block",
	5660	:	"//	mov wa *vrlen  set length of standard fields",
	5661	:	"//	mvw    set initial fields of new block",
	5662	:	"//	mov xl gnvhe  load pointer to end of hash chain",
	5663	:	"//	mov vrnxt(xl) wb  add new block to end of chain",
	5664	:	"//	mov (xr)+ wc  set vrlen field, bump ptr",
	5665	:	"//	mov wa gnvnw  get length in words",
	5666	:	"//	wtb wa   convert to length in bytes",
	5667	:	"//	bze wc gnv16  jump if system variable",
	5668	:	"//	mov xl (xs)  point back to string name",
	5669	:	"//	add xl *schar  point to chars of name",
	5670	:	"//	mvw    move characters into place",
	5671	:	"//	mov xr wb  restore vrblk pointer",
	5672	:	"//	brn gnv06   jump back to exit",
	5673	:	"//gnv16	mov xl gnvsp  load pointer to svblk",
	5674	:	"//	mov (xr) xl  set svblk ptr in vrblk",
	5675	:	"//	mov xr wb  restore vrblk pointer",
	5676	:	"//	mov wb svbit(xl)  load bit indicators",
	5677	:	"//	add xl *svchs  point to characters of name",
	5678	:	"//	add xl wa  point past characters",
	5679	:	"//	mov wc 4,btknm  load test bit",
	5680	:	"//	anb wc wb  and to test",
	5681	:	"//	zrb wc gnv17  jump if no keyword number",
	5682	:	"//	ica xl   else bump pointer",
	5683	:	"//gnv17	mov wc 4,btfnc  get test bit",
	5684	:	"//	anb wc wb  and to test",
	5685	:	"//	zrb wc gnv18  skip if no system function",
	5686	:	"//	mov vrfnc(xr) xl  else point vrfnc to svfnc field",
	5687	:	"//	add xl *num02  and bump past svfnc, svnar fields",
	5688	:	"//gnv18	mov wc 4,btlbl  get test bit",
	5689	:	"//	anb wc wb  and to test",
	5690	:	"//	zrb wc gnv19  jump if bit is off (no system labl)",
	5691	:	"//	mov vrlbl(xr) xl  else point vrlbl to svlbl field",
	5692	:	"//	ica xl   bump past svlbl field",
	5693	:	"//gnv19	mov wc 4,btval  load test bit",
	5694	:	"//	anb wc wb  and to test",
	5695	:	"//	zrb wc gnv06  all done if no value",
	5696	:	"//	mov vrval(xr) (xl)  else set initial value",
	5697	:	"//	mov vrsto(xr) =b_vre  set error store access",
	5698	:	"//	brn gnv06   merge back to exit to caller",
	5699	:	"//gtpat	prc e 1  entry point",
	5700	:	"//	bhi (xr) =p_aaa gtpt5 jump if pattern already",
	5701	:	"//	mov gtpsb wb  save wb",
	5702	:	"//	mov -(xs) xr  stack argument for gtstg",
	5703	:	"//	jsr gtstg   convert argument to string",
	5704	:	"//	bnz wa gtpt1  jump if non-null",
	5705	:	"//	mov xr =ndnth  point to nothen node",
	5706	:	"//	brn gtpt4   jump to exit",
	5707	:	"//gtpt1	mov wb =p_str  load pcode for multi-char string",
	5708	:	"//	bne wa =num01 gtpt3 jump if multi-char string",
	5709	:	"//	plc xr   point to character",
	5710	:	"//	lch wa (xr)  load character",
	5711	:	"//	mov xr wa  set as parm1",
	5712	:	"//	mov wb =p_ans  point to pcode for 1-char any",
	5713	:	"//	brn gtpt3   jump to build node",
	5714	:	"//gtpt2	mov wb =p_exa  set pcode for expression in case",
	5715	:	"//	blo (xr) =b_e__ gtpt3 jump to build node if expression",
	5716	:	"//	exi 1   take convert error exit",
	5717	:	"//gtpt3	jsr pbild   call routine to build pattern node",
	5718	:	"//gtpt4	mov wb gtpsb  restore wb",
	5719	:	"//gtpt5	exi    return to gtpat caller",
	5720	:	"//gtrea	prc e 1  entry point",
	5721	:	"//	mov wa (xr)  get first word of block",
	5722	:	"//	beq wa =b_rcl gtre2 jump if real",
	5723	:	"//	jsr gtnum   else convert argument to numeric",
	5724	:	"//	beq wa =b_rcl gtre2 jump if real was returned",
	5725	:	"//gtre1	ldi icval(xr)   load integer",
	5726	:	"//	itr    convert to real",
	5727	:	"//	jsr rcbld   build rcblk",
	5728	:	"//gtre2	exi    return to gtrea caller",
	5729	:	"//gtre3	exi 1   take convert error exit",
	5730	:	"//gtsmi	prc n 2  entry point",
	5731	:	"//	mov xr (xs)+  load argument",
	5732	:	"//	beq (xr) =b_icl gtsm1 skip if already an integer",
	5733	:	"//	jsr gtint   convert argument to integer",
	5734	:	"//gtsm1	ldi icval(xr)   load integer value",
	5735	:	"//	mfi wc gtsm3  move as one word, jump if ovflow",
	5736	:	"//	bgt wc mxlen gtsm3 or if too large",
	5737	:	"//	mov xr wc  copy result to xr",
	5738	:	"//	exi    return to gtsmi caller",
	5739	:	"//gtsm2	exi 1   take non-integer error exit",
	5740	:	"//gtsm3	exi 2   take out-of-range error exit",
	5741	:	"//gtstg	prc n 1  entry point",
	5742	:	"//	mov xr (xs)+  load argument, pop stack",
	5743	:	"//	beq (xr) =b_scl gts30 jump if already a string",
	5744	:	"//gts01	mov -(xs) xr  restack argument in case error",
	5745	:	"//	mov -(xs) xl  save xl",
	5746	:	"//	mov gtsvb wb  save wb",
	5747	:	"//	mov gtsvc wc  save wc",
	5748	:	"//	mov wa (xr)  load first word of block",
	5749	:	"//	beq wa =b_icl gts05 jump to convert integer",
	5750	:	"//	beq wa =b_rcl gts10 jump to convert real",
	5751	:	"//	beq wa =b_nml gts03 jump to convert name",
	5752	:	"//gts02	mov xl (xs)+  restore xl",
	5753	:	"//	mov xr (xs)+  reload input argument",
	5754	:	"//	exi 1   take convert error exit",
	5755	:	"//gts03	mov xl nmbas(xr)  load name base",
	5756	:	"//	bhi xl state gts02 error if not natural var (static)",
	5757	:	"//	add xl *vrsof  else point to possible string name",
	5758	:	"//	mov wa sclen(xl)  load length",
	5759	:	"//	bnz wa gts04  jump if not system variable",
	5760	:	"//	mov xl vrsvo(xl)  else point to svblk",
	5761	:	"//	mov wa svlen(xl)  and load name length",
	5762	:	"//gts04	zer wb   set offset to zero",
	5763	:	"//	jsr sbstr   use sbstr to copy string",
	5764	:	"//	brn gts29   jump to exit",
	5765	:	"//gts05	ldi icval(xr)   load integer value",
	5766	:	"//	mov gtssf =num01  set sign flag negative",
	5767	:	"//	ilt gts06   skip if integer is negative",
	5768	:	"//	ngi    else negate integer",
	5769	:	"//	zer gtssf   and reset negative flag",
	5770	:	"//gts06	mov xr gtswk  point to result work area",
	5771	:	"//	mov wb =nstmx  initialize counter to max length",
	5772	:	"//	psc xr wb  prepare to store (right-left)",
	5773	:	"//gts07	cvd    convert one digit into wa",
	5774	:	"//	sch wa -(xr)  store in work area",
	5775	:	"//	dcv wb   decrement counter",
	5776	:	"//	ine gts07   loop if more digits to go",
	5777	:	"//	csc xr   complete store characters",
	5778	:	"//gts08	mov wa =nstmx  get max number of characters",
	5779	:	"//	sub wa wb  compute length of result",
	5780	:	"//	mov xl wa  remember length for move later on",
	5781	:	"//	add wa gtssf  add one for negative sign if needed",
	5782	:	"//	jsr alocs   allocate string for result",
	5783	:	"//	mov wc xr  save result pointer for the moment",
	5784	:	"//	psc xr   point to chars of result block",
	5785	:	"//	bze gtssf gts09  skip if positive",
	5786	:	"//	mov wa =ch_mn  else load negative sign",
	5787	:	"//	sch wa (xr)+  and store it",
	5788	:	"//	csc xr   complete store characters",
	5789	:	"//gts09	mov wa xl  recall length to move",
	5790	:	"//	mov xl gtswk  point to result work area",
	5791	:	"//	plc xl wb  point to first result character",
	5792	:	"//	mvc    move chars to result string",
	5793	:	"//	mov xr wc  restore result pointer",
	5794	:	"//	brn gts29   jump to exit",
	5795	:	"//gts10	ldr rcval(xr)   load real",
	5796	:	"//	zer gtssf   reset negative flag",
	5797	:	"//	req gts31   skip if zero",
	5798	:	"//	rge gts11   jump if real is positive",
	5799	:	"//	mov gtssf =num01  else set negative flag",
	5800	:	"//	ngr    and get absolute value of real",
	5801	:	"//gts11	ldi 4,intv0   initialize exponent to zero",
	5802	:	"//gts12	str gtsrs   save real value",
	5803	:	"//	sbr 4,reap1   subtract 0.1 to compare",
	5804	:	"//	rge gts13   jump if scale up not required",
	5805	:	"//	ldr gtsrs   else reload value",
	5806	:	"//	mlr 4,reatt   multiply by 10**10",
	5807	:	"//	sbi 4,intvt   decrement exponent by 10",
	5808	:	"//	brn gts12   loop back to test again",
	5809	:	"//gts13	ldr gtsrs   reload value",
	5810	:	"//	sbr 4,reav1   subtract 1.0",
	5811	:	"//	rlt gts17   jump if no scale down required",
	5812	:	"//	ldr gtsrs   else reload value",
	5813	:	"//gts14	sbr 4,reatt   subtract 10**10 to compare",
	5814	:	"//	rlt gts15   jump if large step not required",
	5815	:	"//	ldr gtsrs   else restore value",
	5816	:	"//	dvr 4,reatt   divide by 10**10",
	5817	:	"//	str gtsrs   store new value",
	5818	:	"//	adi 4,intvt   increment exponent by 10",
	5819	:	"//	brn gts14   loop back",
	5820	:	"//gts15	mov xr =reav1  point to powers of ten table",
	5821	:	"//gts16	ldr gtsrs   reload value",
	5822	:	"//	adi 4,intv1   increment exponent",
	5823	:	"//	add xr *cfp_r  point to next entry in table",
	5824	:	"//	sbr (xr)   subtract it to compare",
	5825	:	"//	rge gts16   loop till we find a larger entry",
	5826	:	"//	ldr gtsrs   then reload the value",
	5827	:	"//	dvr (xr)   and complete scaling",
	5828	:	"//	str gtsrs   store value",
	5829	:	"//gts17	ldr gtsrs   get value again",
	5830	:	"//	adr gtsrn   add rounding factor",
	5831	:	"//	str gtsrs   store result",
	5832	:	"//	sbr 4,reav1   subtract 1.0 to compare",
	5833	:	"//	rlt gts18   skip if ok",
	5834	:	"//	adi 4,intv1   else increment exponent",
	5835	:	"//	ldr gtsrs   reload value",
	5836	:	"//	dvr 4,reavt   divide by 10.0 to rescale",
	5837	:	"//	brn gts19   jump to merge",
	5838	:	"//gts18	ldr gtsrs   reload rounded value",
	5839	:	"//gts19	mov xl =cfp_s  set num dec digits = cfp_s",
	5840	:	"//	mov gtses =ch_mn  set exponent sign negative",
	5841	:	"//	ilt gts21   all set if exponent is negative",
	5842	:	"//	mfi wa   else fetch exponent",
	5843	:	"//	ble wa =cfp_s gts20 skip if we can use special format",
	5844	:	"//	mti wa   else restore exponent",
	5845	:	"//	ngi    set negative for cvd",
	5846	:	"//	mov gtses =ch_pl  set plus sign for exponent sign",
	5847	:	"//	brn gts21   jump to generate exponent",
	5848	:	"//gts20	sub xl wa  compute digits after decimal point",
	5849	:	"//	ldi 4,intv0   reset exponent to zero",
	5850	:	"//gts21	mov xr gtswk  point to work area",
	5851	:	"//	mov wb =nstmx  set character ctr to max length",
	5852	:	"//	psc xr wb  prepare to store (right to left)",
	5853	:	"//	ieq gts23   skip exponent if it is zero",
	5854	:	"//gts22	cvd    convert a digit into wa",
	5855	:	"//	sch wa -(xr)  store in work area",
	5856	:	"//	dcv wb   decrement counter",
	5857	:	"//	ine gts22   loop back if more digits to go",
	5858	:	"//	mov wa gtses  load exponent sign",
	5859	:	"//	sch wa -(xr)  store in work area",
	5860	:	"//	mov wa =ch_le  get character letter e",
	5861	:	"//	sch wa -(xr)  store in work area",
	5862	:	"//	sub wb =num02  decrement counter for sign and e",
	5863	:	"//gts23	mlr gtssc   convert real to integer (10**cfp_s)",
	5864	:	"//	rti    get integer (overflow impossible)",
	5865	:	"//	ngi    negate as required by cvd",
	5866	:	"//gts24	bze xl gts27  jump if no digits left to do",
	5867	:	"//	cvd    else convert one digit",
	5868	:	"//	bne wa =ch_d0 gts26 jump if not a zero",
	5869	:	"//	dcv xl   decrement counter",
	5870	:	"//	brn gts24   loop back for next digit",
	5871	:	"//gts25	cvd    convert a digit into wa",
	5872	:	"//gts26	sch wa -(xr)  store digit",
	5873	:	"//	dcv wb   decrement counter",
	5874	:	"//	dcv xl   decrement counter",
	5875	:	"//	bnz xl gts25  loop back if more to go",
	5876	:	"//gts27	mov wa =ch_dt  load decimal point",
	5877	:	"//	sch wa -(xr)  store in work area",
	5878	:	"//	dcv wb   decrement counter",
	5879	:	"//gts28	cvd    convert a digit into wa",
	5880	:	"//	sch wa -(xr)  store in work area",
	5881	:	"//	dcv wb   decrement counter",
	5882	:	"//	ine gts28   loop back if more to go",
	5883	:	"//	csc xr   complete store characters",
	5884	:	"//	brn gts08   else jump back to exit",
	5885	:	"//gts29	mov xl (xs)+  restore xl",
	5886	:	"//	ica xs   pop argument",
	5887	:	"//	mov wb gtsvb  restore wb",
	5888	:	"//	mov wc gtsvc  restore wc",
	5889	:	"//gts30	mov wa sclen(xr)  load string length",
	5890	:	"//	exi    return to caller",
	5891	:	"//gts31	mov xl =scre0  point to string",
	5892	:	"//	mov wa =num02  2 chars",
	5893	:	"//	zer wb   zero offset",
	5894	:	"//	jsr sbstr   copy string",
	5895	:	"//	brn gts29   return",
	5896	:	"//gtvar	prc e 1  entry point",
	5897	:	"//	bne (xr) =b_nml gtvr2 jump if not a name",
	5898	:	"//	mov wa nmofs(xr)  else load name offset",
	5899	:	"//	mov xl nmbas(xr)  load name base",
	5900	:	"//	beq (xl) =b_evt gtvr1 error if expression variable",
	5901	:	"//	bne (xl) =b_kvt gtvr3 all ok if not keyword variable",
	5902	:	"//gtvr1	exi 1   take convert error exit",
	5903	:	"//gtvr2	mov gtvrc wc  save wc",
	5904	:	"//	jsr gtnvr   locate vrblk if possible",
	5905	:	"//	mov xl xr  else copy vrblk name base",
	5906	:	"//	mov wa *vrval  and set offset",
	5907	:	"//	mov wc gtvrc  restore wc",
	5908	:	"//gtvr3	bhi xl state gtvr4 all ok if not natural variable",
	5909	:	"//	beq vrsto(xl) =b_vre gtvr1 error if protected variable",
	5910	:	"//gtvr4	exi    return to caller",
	5911	:	"//hashs	prc e 0  entry point",
	5912	:	"//	mov wc =e_hnw  get number of words to use",
	5913	:	"//	bze wc hshsa  branch if one character per word",
	5914	:	"//	mov wc sclen(xr)  load string length in characters",
	5915	:	"//	mov wb wc  initialize with length",
	5916	:	"//	bze wc hshs3  jump if null string",
	5917	:	"//	zgb wb   correct byte ordering if necessary",
	5918	:	"//	ctw wc 0  get number of words of chars",
	5919	:	"//	add xr *schar  point to characters of string",
	5920	:	"//	blo wc =e_hnw hshs1 use whole string if short",
	5921	:	"//	mov wc =e_hnw  else set to involve first e_hnw wds",
	5922	:	"//hshs1	lct wc wc  set counter to control loop",
	5923	:	"//hshs2	xob wb (xr)+  exclusive or next word of chars",
	5924	:	"//	bct wc hshs2  loop till all processed",
	5925	:	"//hshs3	zgb wb   zeroise undefined bits",
	5926	:	"//	anb wb 4,bitsm  ensure in range 0 to cfp_m",
	5927	:	"//	mti wb   move result as integer",
	5928	:	"//	zer xr   clear garbage value in xr",
	5929	:	"//	exi    return to hashs caller",
	5930	:	"//hshsa	mov wc sclen(xr)  load string length in characters",
	5931	:	"//	mov wb wc  initialize with length",
	5932	:	"//	bze wc hshs3  jump if null string",
	5933	:	"//	zgb wb   correct byte ordering if necessary",
	5934	:	"//	ctw wc 0  get number of words of chars",
	5935	:	"//	plc xr   ",
	5936	:	"//	mov -(xs) xl  save xl",
	5937	:	"//	mov xl wc  load length for branch",
	5938	:	"//	bge xl =num25 hsh24 use first characters if longer",
	5939	:	"//	bsw xl 25  merge to compute hash",
	5940	:	"//hsh24	lch wc (xr)+  load next character",
	5941	:	"//	lsh wc 24  shift for hash",
	5942	:	"//	xob wb wc  hash character",
	5943	:	"//hsh23	lch wc (xr)+  load next character",
	5944	:	"//	lsh wc 16  shift for hash",
	5945	:	"//	xob wb wc  hash character",
	5946	:	"//hsh22	lch wc (xr)+  load next character",
	5947	:	"//	lsh wc 8  shift for hash",
	5948	:	"//	xob wb wc  hash character",
	5949	:	"//hsh21	lch wc (xr)+  load next character",
	5950	:	"//	xob wb wc  hash character",
	5951	:	"//hsh20	lch wc (xr)+  load next character",
	5952	:	"//	lsh wc 24  shift for hash",
	5953	:	"//	xob wb wc  hash character",
	5954	:	"//hsh19	lch wc (xr)+  load next character",
	5955	:	"//	lsh wc 16  shift for hash",
	5956	:	"//	xob wb wc  hash character",
	5957	:	"//hsh18	lch wc (xr)+  load next character",
	5958	:	"//	lsh wc 8  shift for hash",
	5959	:	"//	xob wb wc  hash character",
	5960	:	"//hsh17	lch wc (xr)+  load next character",
	5961	:	"//	xob wb wc  hash character",
	5962	:	"//hsh16	lch wc (xr)+  load next character",
	5963	:	"//	lsh wc 24  shift for hash",
	5964	:	"//	xob wb wc  hash character",
	5965	:	"//hsh15	lch wc (xr)+  load next character",
	5966	:	"//	lsh wc 16  shift for hash",
	5967	:	"//	xob wb wc  hash character",
	5968	:	"//hsh14	lch wc (xr)+  load next character",
	5969	:	"//	lsh wc 8  shift for hash",
	5970	:	"//	xob wb wc  hash character",
	5971	:	"//hsh13	lch wc (xr)+  load next character",
	5972	:	"//	xob wb wc  hash character",
	5973	:	"//hsh12	lch wc (xr)+  load next character",
	5974	:	"//	lsh wc 24  shift for hash",
	5975	:	"//	xob wb wc  hash character",
	5976	:	"//hsh11	lch wc (xr)+  load next character",
	5977	:	"//	lsh wc 16  shift for hash",
	5978	:	"//	xob wb wc  hash character",
	5979	:	"//hsh10	lch wc (xr)+  load next character",
	5980	:	"//	lsh wc 8  shift for hash",
	5981	:	"//	xob wb wc  hash character",
	5982	:	"//hsh09	lch wc (xr)+  load next character",
	5983	:	"//	xob wb wc  hash character",
	5984	:	"//hsh08	lch wc (xr)+  load next character",
	5985	:	"//	lsh wc 24  shift for hash",
	5986	:	"//	xob wb wc  hash character",
	5987	:	"//hsh07	lch wc (xr)+  load next character",
	5988	:	"//	lsh wc 16  shift for hash",
	5989	:	"//	xob wb wc  hash character",
	5990	:	"//hsh06	lch wc (xr)+  load next character",
	5991	:	"//	lsh wc 8  shift for hash",
	5992	:	"//	xob wb wc  hash character",
	5993	:	"//hsh05	lch wc (xr)+  load next character",
	5994	:	"//	xob wb wc  hash character",
	5995	:	"//hsh04	lch wc (xr)+  load next character",
	5996	:	"//	lsh wc 24  shift for hash",
	5997	:	"//	xob wb wc  hash character",
	5998	:	"//hsh03	lch wc (xr)+  load next character",
	5999	:	"//	lsh wc 16  shift for hash",
	6000	:	"//	xob wb wc  hash character",
	6001	:	"//hsh02	lch wc (xr)+  load next character",
	6002	:	"//	lsh wc 8  shift for hash",
	6003	:	"//	xob wb wc  hash character",
	6004	:	"//hsh01	lch wc (xr)+  load next character",
	6005	:	"//	xob wb wc  hash character",
	6006	:	"//hsh00	mov xl (xs)+  restore xl",
	6007	:	"//	brn hshs3   merge to complete hash",
	6008	:	"//icbld	prc e 0  entry point",
	6009	:	"//	mfi xr icbl1  copy small integers",
	6010	:	"//	ble xr =num02 icbl3 jump if 0,1 or 2",
	6011	:	"//icbl1	mov xr dnamp  load pointer to next available loc",
	6012	:	"//	add xr *icsi_  point past new icblk",
	6013	:	"//	blo xr dname icbl2 jump if there is room",
	6014	:	"//	mov wa *icsi_  else load length of icblk",
	6015	:	"//	jsr alloc   use standard allocator to get block",
	6016	:	"//	add xr wa  point past block to merge",
	6017	:	"//icbl2	mov dnamp xr  set new pointer",
	6018	:	"//	sub xr *icsi_  point back to start of block",
	6019	:	"//	mov (xr) =b_icl  store type word",
	6020	:	"//	sti icval(xr)   store integer value in icblk",
	6021	:	"//	exi    return to icbld caller",
	6022	:	"//icbl3	wtb xr   convert integer to offset",
	6023	:	"//	mov xr 14,intab(xr)  point to pre-built icblk",
	6024	:	"//	exi    return",
	6025	:	"//ident	prc e 1  entry point",
	6026	:	"//	beq xr xl iden7 jump if same pointer (ident)",
	6027	:	"//	mov wc (xr)  else load arg 1 type word",
	6028	:	"//	bne wc (xl) iden1 differ if arg 2 type word differ",
	6029	:	"//	beq wc =b_scl iden2 jump if strings",
	6030	:	"//	beq wc =b_icl iden4 jump if integers",
	6031	:	"//	beq wc =b_rcl iden5 jump if reals",
	6032	:	"//	beq wc =b_nml iden6 jump if names",
	6033	:	"//iden1	exi    take differ exit",
	6034	:	"//iden2	mov wc sclen(xr)  load arg 1 length",
	6035	:	"//	bne wc sclen(xl) iden1 differ if lengths differ",
	6036	:	"//idn2a	add xr *schar  point to chars of arg 1",
	6037	:	"//	add xl *schar  point to chars of arg 2",
	6038	:	"//	ctw wc 0  get number of words in strings",
	6039	:	"//	lct wc wc  set loop counter",
	6040	:	"//iden3	cne (xr) (xl) iden8 differ if chars do not match",
	6041	:	"//	ica xr   else bump arg one pointer",
	6042	:	"//	ica xl   bump arg two pointer",
	6043	:	"//	bct wc iden3  loop back till all checked",
	6044	:	"//	zer xl   clear garbage value in xl",
	6045	:	"//	zer xr   clear garbage value in xr",
	6046	:	"//	exi 1   take ident exit",
	6047	:	"//iden4	ldi icval(xr)   load arg 1",
	6048	:	"//	sbi icval(xl)   subtract arg 2 to compare",
	6049	:	"//	iov iden1   differ if overflow",
	6050	:	"//	ine iden1   differ if result is not zero",
	6051	:	"//	exi 1   take ident exit",
	6052	:	"//iden5	ldr rcval(xr)   load arg 1",
	6053	:	"//	sbr rcval(xl)   subtract arg 2 to compare",
	6054	:	"//	rov iden1   differ if overflow",
	6055	:	"//	rne iden1   differ if result is not zero",
	6056	:	"//	exi 1   take ident exit",
	6057	:	"//iden6	bne nmofs(xr) nmofs(xl) iden1 differ if different offset",
	6058	:	"//	bne nmbas(xr) nmbas(xl) iden1 differ if different base",
	6059	:	"//iden7	exi 1   take ident exit",
	6060	:	"//iden8	zer xr   clear garbage ptr in xr",
	6061	:	"//	zer xl   clear garbage ptr in xl",
	6062	:	"//	exi    return to caller (differ)",
	6063	:	"//inout	prc e 0  entry point",
	6064	:	"//	mov -(xs) wb  stack trblk type",
	6065	:	"//	mov wa sclen(xl)  get name length",
	6066	:	"//	zer wb   point to start of name",
	6067	:	"//	jsr sbstr   build a proper scblk",
	6068	:	"//	jsr gtnvr   build vrblk",
	6069	:	"//	mov wc xr  save vrblk pointer",
	6070	:	"//	mov wb (xs)+  get trter field",
	6071	:	"//	zer xl   zero trfpt",
	6072	:	"//	jsr trbld   build trblk",
	6073	:	"//	mov xl wc  recall vrblk pointer",
	6074	:	"//	mov trter(xr) vrsvp(xl)  store svblk pointer",
	6075	:	"//	mov vrval(xl) xr  store trblk ptr in vrblk",
	6076	:	"//	mov vrget(xl) =b_vra  set trapped access",
	6077	:	"//	mov vrsto(xl) =b_vrv  set trapped store",
	6078	:	"//	exi    return to caller",
	6079	:	"//insta	prc e 0  entry point",
	6080	:	"//	mov wc prlen  no. of chars in print bfr",
	6081	:	"//	mov prbuf xr  print bfr is put at static start",
	6082	:	"//	mov (xr)+ =b_scl  store string type code",
	6083	:	"//	mov (xr)+ wc  and string length",
	6084	:	"//	ctw wc 0  get number of words in buffer",
	6085	:	"//	mov prlnw wc  store for buffer clear",
	6086	:	"//	lct wc wc  words to clear",
	6087	:	"//inst1	mov (xr)+ 4,nullw  store blank",
	6088	:	"//	bct wc inst1  loop",
	6089	:	"//	mov wa =nstmx  get max num chars in output number",
	6090	:	"//	ctb wa scsi_  no of bytes needed",
	6091	:	"//	mov gtswk xr  store bfr adrs",
	6092	:	"//	add xr wa  bump for work bfr",
	6093	:	"//	mov kvalp xr  save alphabet pointer",
	6094	:	"//	mov (xr) =b_scl  string blk type",
	6095	:	"//	mov wc =cfp_a  no of chars in alphabet",
	6096	:	"//	mov sclen(xr) wc  store as string length",
	6097	:	"//	mov wb wc  copy char count",
	6098	:	"//	ctb wb scsi_  no. of bytes needed",
	6099	:	"//	add wb xr  current end address for static",
	6100	:	"//	mov wa wb  save adrs past alphabet string",
	6101	:	"//	lct wc wc  loop counter",
	6102	:	"//	psc xr   point to chars of string",
	6103	:	"//	zer wb   set initial character value",
	6104	:	"//inst2	sch wb (xr)+  store next code",
	6105	:	"//	icv wb   bump code value",
	6106	:	"//	bct wc inst2  loop till all stored",
	6107	:	"//	csc xr   complete store characters",
	6108	:	"//	mov xr wa  return current static ptr",
	6109	:	"//	exi    return to caller",
	6110	:	"//iofcb	prc n 3  entry point",
	6111	:	"//	jsr gtstg   get arg as string",
	6112	:	"//	mov xl xr  copy string ptr",
	6113	:	"//	jsr gtnvr   get as natural variable",
	6114	:	"//	mov wb xl  copy string pointer again",
	6115	:	"//	mov xl xr  copy vrblk ptr for return",
	6116	:	"//	zer wa   in case no trblk found",
	6117	:	"//iofc1	mov xr vrval(xr)  get possible trblk ptr",
	6118	:	"//	bne (xr) =b_trt iofc4 fail if end of chain",
	6119	:	"//	bne trtyp(xr) =trtfc iofc1 loop if not file arg trblk",
	6120	:	"//	mov wa trfpt(xr)  get fcblk ptr",
	6121	:	"//	mov xr wb  copy arg",
	6122	:	"//	exi    return",
	6123	:	"//iofc2	exi 1   fail",
	6124	:	"//iofc3	exi 2   null arg return",
	6125	:	"//iofc4	exi 3   file not found return",
	6126	:	"//ioppf	prc n 0  entry point",
	6127	:	"//	zer wb   to count fields extracted",
	6128	:	"//iopp1	mov xl =iodel  get delimiter",
	6129	:	"//	mov wc xl  copy it",
	6130	:	"//	zer wa   retain leading blanks in filearg2",
	6131	:	"//	jsr xscan   get next field",
	6132	:	"//	mov -(xs) xr  stack it",
	6133	:	"//	icv wb   increment count",
	6134	:	"//	bnz wa iopp1  loop",
	6135	:	"//	mov wc wb  count of fields",
	6136	:	"//	mov wb ioptt  i/o marker",
	6137	:	"//	mov wa r_iof  fcblk ptr or 0",
	6138	:	"//	mov xr r_io2  file arg2 ptr",
	6139	:	"//	mov xl r_io1  filearg1",
	6140	:	"//	exi    return",
	6141	:	"//ioput	prc n 7  entry point",
	6142	:	"//	zer r_iot   in case no trtrf block used",
	6143	:	"//	zer r_iof   in case no fcblk alocated",
	6144	:	"//	zer r_iop   in case sysio fails",
	6145	:	"//	mov ioptt wb  store i/o trace type",
	6146	:	"//	jsr xscni   prepare to scan filearg2",
	6147	:	"//iopa0	mov r_io2 xr  keep file arg2",
	6148	:	"//	mov xl wa  copy length",
	6149	:	"//	jsr gtstg   convert filearg1 to string",
	6150	:	"//	mov r_io1 xr  keep filearg1 ptr",
	6151	:	"//	jsr gtnvr   convert to natural variable",
	6152	:	"//	brn iop04   jump to process non-null args",
	6153	:	"//iop00	bze xl iop01  skip if both args null",
	6154	:	"//	jsr ioppf   process filearg2",
	6155	:	"//	jsr sysfc   call for filearg2 check",
	6156	:	"//	brn iop11   complete file association",
	6157	:	"//iop01	mov wb ioptt  get trace type",
	6158	:	"//	mov xr r_iot  get 0 or trtrf ptr",
	6159	:	"//	jsr trbld   build trblk",
	6160	:	"//	mov wc xr  copy trblk pointer",
	6161	:	"//	mov xr (xs)+  get variable from stack",
	6162	:	"//	mov -(xs) wc  make trblk collectable",
	6163	:	"//	jsr gtvar   point to variable",
	6164	:	"//	mov wc (xs)+  recover trblk pointer",
	6165	:	"//	mov r_ion xl  save name pointer",
	6166	:	"//	mov xr xl  copy name pointer",
	6167	:	"//	add xr wa  point to variable",
	6168	:	"//	sub xr *vrval  subtract offset,merge into loop",
	6169	:	"//iop02	mov xl xr  copy blk ptr",
	6170	:	"//	mov xr vrval(xr)  load ptr to next trblk",
	6171	:	"//	bne (xr) =b_trt iop03 jump if not trapped",
	6172	:	"//	bne trtyp(xr) ioptt iop02 loop if not same assocn",
	6173	:	"//	mov xr trnxt(xr)  get value and delete old trblk",
	6174	:	"//iop03	mov vrval(xl) wc  link to this trblk",
	6175	:	"//	mov xl wc  copy pointer",
	6176	:	"//	mov trnxt(xl) xr  store value in trblk",
	6177	:	"//	mov xr r_ion  restore possible vrblk pointer",
	6178	:	"//	mov wb wa  keep offset to name",
	6179	:	"//	jsr setvr   if vrblk, set vrget,vrsto",
	6180	:	"//	mov xr r_iot  get 0 or trtrf ptr",
	6181	:	"//	bnz xr iop19  jump if trtrf block exists",
	6182	:	"//	exi    return to caller",
	6183	:	"//iop04	zer wa   in case no fcblk found",
	6184	:	"//iop05	mov wb xr  remember blk ptr",
	6185	:	"//	mov xr vrval(xr)  chain along",
	6186	:	"//	bne (xr) =b_trt iop06 jump if end of trblk chain",
	6187	:	"//	bne trtyp(xr) =trtfc iop05 loop if more to go",
	6188	:	"//	mov r_iot xr  point to file arg1 trblk",
	6189	:	"//	mov wa trfpt(xr)  get fcblk ptr from trblk",
	6190	:	"//iop06	mov r_iof wa  keep possible fcblk ptr",
	6191	:	"//	mov r_iop wb  keep preceding blk ptr",
	6192	:	"//	jsr ioppf   process filearg2",
	6193	:	"//	jsr sysfc   see if fcblk required",
	6194	:	"//	bze wa iop12  skip if no new fcblk wanted",
	6195	:	"//	blt wc =num02 iop6a jump if fcblk in dynamic",
	6196	:	"//	jsr alost   get it in static",
	6197	:	"//	brn iop6b   skip",
	6198	:	"//iop6a	jsr alloc   get space for fcblk",
	6199	:	"//iop6b	mov xl xr  point to fcblk",
	6200	:	"//	mov wb wa  copy its length",
	6201	:	"//	btw wb   get count as words (sgd apr80)",
	6202	:	"//	lct wb wb  loop counter",
	6203	:	"//iop07	zer (xr)+   clear a word",
	6204	:	"//	bct wb iop07  loop",
	6205	:	"//	beq wc =num02 iop09 skip if in static - dont set fields",
	6206	:	"//	mov (xl) =b_xnt  store xnblk code in case",
	6207	:	"//	mov num01(xl) wa  store length",
	6208	:	"//	bnz wc iop09  jump if xnblk wanted",
	6209	:	"//	mov (xl) =b_xrt  xrblk code requested",
	6210	:	"//iop09	mov xr r_iot  get possible trblk ptr",
	6211	:	"//	mov r_iof xl  store fcblk ptr",
	6212	:	"//	bnz xr iop10  jump if trblk already found",
	6213	:	"//	mov wb =trtfc  trtyp for fcblk trap blk",
	6214	:	"//	jsr trbld   make the block",
	6215	:	"//	mov r_iot xr  copy trtrf ptr",
	6216	:	"//	mov xl r_iop  point to preceding blk",
	6217	:	"//	mov vrval(xr) vrval(xl)  copy value field to trblk",
	6218	:	"//	mov vrval(xl) xr  link new trblk into chain",
	6219	:	"//	mov xr xl  point to predecessor blk",
	6220	:	"//	jsr setvr   set trace intercepts",
	6221	:	"//	mov xr vrval(xr)  recover trblk ptr",
	6222	:	"//	brn iop1a   store fcblk ptr",
	6223	:	"//iop10	zer r_iop   do not release if sysio fails",
	6224	:	"//iop1a	mov trfpt(xr) r_iof  store fcblk ptr",
	6225	:	"//iop11	mov wa r_iof  copy fcblk ptr or 0",
	6226	:	"//	mov wb ioptt  get input/output flag",
	6227	:	"//	mov xr r_io2  get file arg2",
	6228	:	"//	mov xl r_io1  get file arg1",
	6229	:	"//	jsr sysio   associate to the file",
	6230	:	"//	bnz r_iot iop01  not std input if non-null trtrf blk",
	6231	:	"//	bnz ioptt iop01  jump if output",
	6232	:	"//	bze wc iop01  no change to standard read length",
	6233	:	"//	mov cswin wc  store new read length for std file",
	6234	:	"//	brn iop01   merge to finish the task",
	6235	:	"//iop12	bnz xl iop09  jump if private fcblk",
	6236	:	"//	brn iop11   finish the association",
	6237	:	"//iop13	exi 1   3rd arg not a string",
	6238	:	"//iop14	exi 2   2nd arg unsuitable",
	6239	:	"//iop15	ica xs   discard trblk pointer",
	6240	:	"//	exi 3   1st arg unsuitable",
	6241	:	"//iop16	exi 4   file spec wrong",
	6242	:	"//iop26	exi 7   fcblk in use",
	6243	:	"//iop17	mov xr r_iop  is there a trblk to release",
	6244	:	"//	bze xr iopa7  if not",
	6245	:	"//	mov xl vrval(xr)  point to trblk",
	6246	:	"//	mov vrval(xr) vrval(xl)  unsplice it",
	6247	:	"//	jsr setvr   adjust trace intercepts",
	6248	:	"//iopa7	exi 5   i/o file does not exist",
	6249	:	"//iop18	mov xr r_iop  is there a trblk to release",
	6250	:	"//	bze xr iopa7  if not",
	6251	:	"//	mov xl vrval(xr)  point to trblk",
	6252	:	"//	mov vrval(xr) vrval(xl)  unsplice it",
	6253	:	"//	jsr setvr   adjust trace intercepts",
	6254	:	"//iopa8	exi 6   i/o file cannot be read/written",
	6255	:	"//iop19	mov wc r_ion  wc = name base, wb = name offset",
	6256	:	"//iop20	mov xr trtrf(xr)  next link of chain",
	6257	:	"//	bze xr iop21  not found",
	6258	:	"//	bne wc ionmb(xr) iop20 no match",
	6259	:	"//	beq wb ionmo(xr) iop22 exit if matched",
	6260	:	"//	brn iop20   loop",
	6261	:	"//iop21	mov wa *num05  space needed",
	6262	:	"//	jsr alloc   get it",
	6263	:	"//	mov (xr) =b_xrt  store xrblk code",
	6264	:	"//	mov num01(xr) wa  store length",
	6265	:	"//	mov ionmb(xr) wc  store name base",
	6266	:	"//	mov ionmo(xr) wb  store name offset",
	6267	:	"//	mov xl r_iot  point to trtrf blk",
	6268	:	"//	mov wa trtrf(xl)  get ptr field contents",
	6269	:	"//	mov trtrf(xl) xr  store ptr to new block",
	6270	:	"//	mov trtrf(xr) wa  complete the linking",
	6271	:	"//iop22	bze r_iof iop25  skip if no fcblk",
	6272	:	"//	mov xl r_fcb  ptr to head of existing chain",
	6273	:	"//iop23	bze xl iop24  not on if end of chain",
	6274	:	"//	beq num03(xl) r_iof iop25 dont duplicate if find it",
	6275	:	"//	mov xl num02(xl)  get next link",
	6276	:	"//	brn iop23   loop",
	6277	:	"//iop24	mov wa *num04  space needed",
	6278	:	"//	jsr alloc   get it",
	6279	:	"//	mov (xr) =b_xrt  store block code",
	6280	:	"//	mov num01(xr) wa  store length",
	6281	:	"//	mov num02(xr) r_fcb  store previous link in this node",
	6282	:	"//	mov num03(xr) r_iof  store fcblk ptr",
	6283	:	"//	mov r_fcb xr  insert node into fcblk chain",
	6284	:	"//iop25	exi    return to caller",
	6285	:	"//ktrex	prc r 0  entry point (recursive)",
	6286	:	"//	bze xl ktrx3  immediate exit if keyword untraced",
	6287	:	"//	bze kvtra ktrx3  immediate exit if trace = 0",
	6288	:	"//	dcv kvtra   else decrement trace",
	6289	:	"//	mov -(xs) xr  save xr",
	6290	:	"//	mov xr xl  copy trblk pointer",
	6291	:	"//	mov xl trkvr(xr)  load vrblk pointer (nmbas)",
	6292	:	"//	mov wa *vrval  set name offset",
	6293	:	"//	bze trfnc(xr) ktrx1  jump if print trace",
	6294	:	"//	jsr trxeq   else execute full trace",
	6295	:	"//	brn ktrx2   and jump to exit",
	6296	:	"//ktrx1	mov -(xs) xl  stack vrblk ptr for kwnam",
	6297	:	"//	mov -(xs) wa  stack offset for kwnam",
	6298	:	"//	jsr prtsn   print statement number",
	6299	:	"//	mov wa =ch_am  load ampersand",
	6300	:	"//	jsr prtch   print ampersand",
	6301	:	"//	jsr prtnm   print keyword name",
	6302	:	"//	mov xr =tmbeb  point to blank-equal-blank",
	6303	:	"//	jsr prtst   print blank-equal-blank",
	6304	:	"//	jsr kwnam   get keyword pseudo-variable name",
	6305	:	"//	mov dnamp xr  reset ptr to delete kvblk",
	6306	:	"//	jsr acess   get keyword value",
	6307	:	"//	jsr prtvl   print keyword value",
	6308	:	"//	jsr prtnl   terminate print line",
	6309	:	"//ktrx2	mov xr (xs)+  restore entry xr",
	6310	:	"//ktrx3	exi    return to ktrex caller",
	6311	:	"//kwnam	prc n 0  entry point",
	6312	:	"//	ica xs   ignore name offset",
	6313	:	"//	mov xr (xs)+  load name base",
	6314	:	"//	bge xr state kwnm1 jump if not natural variable name",
	6315	:	"//	bnz vrlen(xr) kwnm1  error if not system variable",
	6316	:	"//	mov xr vrsvp(xr)  else point to svblk",
	6317	:	"//	mov wa svbit(xr)  load bit mask",
	6318	:	"//	anb wa 4,btknm  and with keyword bit",
	6319	:	"//	zrb wa kwnm1  error if no keyword association",
	6320	:	"//	mov wa svlen(xr)  else load name length in characters",
	6321	:	"//	ctb wa svchs  compute offset to field we want",
	6322	:	"//	add xr wa  point to svknm field",
	6323	:	"//	mov wb (xr)  load svknm value",
	6324	:	"//	mov wa *kvsi_  set size of kvblk",
	6325	:	"//	jsr alloc   allocate kvblk",
	6326	:	"//	mov (xr) =b_kvt  store type word",
	6327	:	"//	mov kvnum(xr) wb  store keyword number",
	6328	:	"//	mov kvvar(xr) =trbkv  set dummy trblk pointer",
	6329	:	"//	mov xl xr  copy kvblk pointer",
	6330	:	"//	mov wa *kvvar  set proper offset",
	6331	:	"//	exi    return to kvnam caller",
	6332	:	"//kwnm1	erb 251 keyword operand is not name of defined keyword  ",
	6333	:	"//lcomp	prc n 5  entry point",
	6334	:	"//	jsr gtstg   convert second arg to string",
	6335	:	"//	mov xl xr  else save pointer",
	6336	:	"//	mov wc wa  and length",
	6337	:	"//	jsr gtstg   convert first argument to string",
	6338	:	"//	mov wb wa  save arg 1 length",
	6339	:	"//	plc xr   point to chars of arg 1",
	6340	:	"//	plc xl   point to chars of arg 2",
	6341	:	"//	blo wa wc lcmp1 jump if arg 1 length is smaller",
	6342	:	"//	mov wa wc  else set arg 2 length as smaller",
	6343	:	"//lcmp1	bze wa lcmp7  if null string, compare lengths",
	6344	:	"//	cmc lcmp4 lcmp3  compare strings, jump if unequal",
	6345	:	"//lcmp7	bne wb wc lcmp2 if equal, jump if lengths unequal",
	6346	:	"//	exi 4   else identical strings, leq exit",
	6347	:	"//lcmp2	bhi wb wc lcmp4 jump if arg 1 length gt arg 2 leng",
	6348	:	"//lcmp3	exi 3   take llt exit",
	6349	:	"//lcmp4	exi 5   take lgt exit",
	6350	:	"//lcmp5	exi 1   take bad first arg exit",
	6351	:	"//lcmp6	exi 2   take bad second arg error exit",
	6352	:	"//listr	prc e 0  entry point",
	6353	:	"//	bnz cnttl list5  jump if -title or -stitl",
	6354	:	"//	bnz lstpf list4  immediate exit if already listed",
	6355	:	"//	bge lstlc lstnp list6 jump if no room",
	6356	:	"//list0	mov xr r_cim  load pointer to current image",
	6357	:	"//	bze xr list4  jump if no image to print",
	6358	:	"//	plc xr   point to characters",
	6359	:	"//	lch wa (xr)  load first character",
	6360	:	"//	mov xr lstsn  load statement number",
	6361	:	"//	bze xr list2  jump if no statement number",
	6362	:	"//	mti xr   else get stmnt number as integer",
	6363	:	"//	bne stage =stgic list1 skip if execute time",
	6364	:	"//	beq wa =ch_as list2 no stmnt number list if comment",
	6365	:	"//	beq wa =ch_mn list2 no stmnt no. if control card",
	6366	:	"//list1	jsr prtin   else print statement number",
	6367	:	"//	zer lstsn   and clear for next time in",
	6368	:	"//list2	mov xr lstid  include depth of image",
	6369	:	"//	bze xr list8  if not from an include file",
	6370	:	"//	mov wa =stnpd  position for start of statement",
	6371	:	"//	sub wa =num03  position to place include depth",
	6372	:	"//	mov profs wa  set as starting position",
	6373	:	"//	mti xr   include depth as integer",
	6374	:	"//	jsr prtin   print include depth",
	6375	:	"//list8	mov profs =stnpd  point past statement number",
	6376	:	"//	mov xr r_cim  load pointer to current image",
	6377	:	"//	jsr prtst   print it",
	6378	:	"//	icv lstlc   bump line counter",
	6379	:	"//	bnz erlst list3  jump if error copy to int.ch.",
	6380	:	"//	jsr prtnl   terminate line",
	6381	:	"//	bze cswdb list3  jump if -single mode",
	6382	:	"//	jsr prtnl   else add a blank line",
	6383	:	"//	icv lstlc   and bump line counter",
	6384	:	"//list3	mnz lstpf   set flag for line printed",
	6385	:	"//list4	exi    return to listr caller",
	6386	:	"//list5	zer cnttl   clear flag",
	6387	:	"//list6	jsr prtps   eject",
	6388	:	"//	bze prich list7  skip if listing to regular printer",
	6389	:	"//	beq r_ttl =nulls list0 terminal listing omits null title",
	6390	:	"//list7	jsr listt   list title",
	6391	:	"//	brn list0   merge",
	6392	:	"//listt	prc e 0  entry point",
	6393	:	"//	mov xr r_ttl  point to source listing title",
	6394	:	"//	jsr prtst   print title",
	6395	:	"//	mov profs lstpo  set offset",
	6396	:	"//	mov xr =lstms  set page message",
	6397	:	"//	jsr prtst   print page message",
	6398	:	"//	icv lstpg   bump page number",
	6399	:	"//	mti lstpg   load page number as integer",
	6400	:	"//	jsr prtin   print page number",
	6401	:	"//	jsr prtnl   terminate title line",
	6402	:	"//	add lstlc =num02  count title line and blank line",
	6403	:	"//	mov xr r_stl  load pointer to sub-title",
	6404	:	"//	bze xr lstt1  jump if no sub-title",
	6405	:	"//	jsr prtst   else print sub-title",
	6406	:	"//	jsr prtnl   terminate line",
	6407	:	"//	icv lstlc   bump line count",
	6408	:	"//lstt1	jsr prtnl   print a blank line",
	6409	:	"//	exi    return to caller",
	6410	:	"//newfn	prc e 0  entry point",
	6411	:	"//	mov -(xs) xr  save new name",
	6412	:	"//	mov xl r_sfc  load previous name",
	6413	:	"//	jsr ident   check for equality",
	6414	:	"//	mov xr (xs)+  different, restore name",
	6415	:	"//	mov r_sfc xr  record current file name",
	6416	:	"//	mov wb cmpsn  get current statement",
	6417	:	"//	mti wb   convert to integer",
	6418	:	"//	jsr icbld   build icblk for stmt number",
	6419	:	"//	mov xl r_sfn  file name table",
	6420	:	"//	mnz wb   lookup statement number by name",
	6421	:	"//	jsr tfind   allocate new teblk",
	6422	:	"//	mov teval(xl) r_sfc  record file name as entry value",
	6423	:	"//	exi    ",
	6424	:	"//nwfn1	ica xs   pop stack",
	6425	:	"//	exi    ",
	6426	:	"//nexts	prc e 0  entry point",
	6427	:	"//	bze cswls nxts2  jump if -nolist",
	6428	:	"//	mov xr r_cim  point to image",
	6429	:	"//	bze xr nxts2  jump if no image",
	6430	:	"//	plc xr   get char ptr",
	6431	:	"//	lch wa (xr)  get first char",
	6432	:	"//	bne wa =ch_mn nxts1 jump if not ctrl card",
	6433	:	"//	bze cswpr nxts2  jump if -noprint",
	6434	:	"//nxts1	jsr listr   list line",
	6435	:	"//nxts2	mov xr r_cni  point to next image",
	6436	:	"//	mov r_cim xr  set as next image",
	6437	:	"//	mov rdcln rdnln  set as current line number",
	6438	:	"//	mov lstid cnind  set as current include depth",
	6439	:	"//	zer r_cni   clear next image pointer",
	6440	:	"//	mov wa sclen(xr)  get input image length",
	6441	:	"//	mov wb cswin  get max allowable length",
	6442	:	"//	blo wa wb nxts3 skip if not too long",
	6443	:	"//	mov wa wb  else truncate",
	6444	:	"//nxts3	mov scnil wa  use as record length",
	6445	:	"//	zer scnse   reset scnse",
	6446	:	"//	zer lstpf   set line not listed yet",
	6447	:	"//	exi    return to nexts caller",
	6448	:	"//patin	prc n 2  entry point",
	6449	:	"//	mov xl wa  preserve expression arg pcode",
	6450	:	"//	jsr gtsmi   try to convert arg as small integer",
	6451	:	"//ptin1	jsr pbild   build pattern node",
	6452	:	"//	exi    return to caller",
	6453	:	"//ptin2	mov wb xl  copy expr arg case pcode",
	6454	:	"//	blo (xr) =b_e__ ptin1 all ok if expression arg",
	6455	:	"//	exi 1   else take error exit for wrong type",
	6456	:	"//ptin3	exi 2   take out-of-range error exit",
	6457	:	"//patst	prc n 1  entry point",
	6458	:	"//	jsr gtstg   convert argument as string",
	6459	:	"//	bze wa pats7  jump if null string (catspaw)",
	6460	:	"//	bne wa =num01 pats2 jump if not one char string",
	6461	:	"//	bze wb pats2  treat as multi-char if evals call",
	6462	:	"//	plc xr   point to character",
	6463	:	"//	lch xr (xr)  load character",
	6464	:	"//pats1	jsr pbild   call routine to build node",
	6465	:	"//	exi    return to patst caller",
	6466	:	"//pats2	mov -(xs) xl  save multi-char pcode",
	6467	:	"//	mov wc ctmsk  load current mask bit",
	6468	:	"//	beq xr r_cts pats6 jump if same as last string c3.738",
	6469	:	"//	mov -(xs) xr  save string pointer",
	6470	:	"//	lsh wc 1  shift to next position",
	6471	:	"//	nzb wc pats4  skip if position left in this tbl",
	6472	:	"//	mov wa *ctsi_  set size of ctblk",
	6473	:	"//	jsr alloc   allocate ctblk",
	6474	:	"//	mov r_ctp xr  store ptr to new ctblk",
	6475	:	"//	mov (xr)+ =b_ctt  store type code, bump ptr",
	6476	:	"//	lct wb =cfp_a  set number of words to clear",
	6477	:	"//	mov wc 4,bits0  load all zero bits",
	6478	:	"//pats3	mov (xr)+ wc  move word of zero bits",
	6479	:	"//	bct wb pats3  loop till all cleared",
	6480	:	"//	mov wc 4,bits1  set initial bit position",
	6481	:	"//pats4	mov ctmsk wc  save parm2 (new bit position)",
	6482	:	"//	mov xl (xs)+  restore pointer to argument string",
	6483	:	"//	mov r_cts xl  save for next time   c3.738",
	6484	:	"//	mov wb sclen(xl)  load string length",
	6485	:	"//	bze wb pats6  jump if null string case",
	6486	:	"//	lct wb wb  else set loop counter",
	6487	:	"//	plc xl   point to characters in argument",
	6488	:	"//pats5	lch wa (xl)+  load next character",
	6489	:	"//	wtb wa   convert to byte offset",
	6490	:	"//	mov xr r_ctp  point to ctblk",
	6491	:	"//	add xr wa  point to ctblk entry",
	6492	:	"//	mov wa wc  copy bit mask",
	6493	:	"//	orb wa ctchs(xr)  or in bits already set",
	6494	:	"//	mov ctchs(xr) wa  store resulting bit string",
	6495	:	"//	bct wb pats5  loop till all bits set",
	6496	:	"//pats6	mov xr r_ctp  load ctblk ptr as parm1 for pbild",
	6497	:	"//	zer xl   clear garbage ptr in xl",
	6498	:	"//	mov wb (xs)+  load pcode for multi-char str case",
	6499	:	"//	brn pats1   back to exit (wc=bitstring=parm2)",
	6500	:	"//pats7	mov wb wc  set pcode for expression argument",
	6501	:	"//	blo (xr) =b_e__ pats1 jump to exit if expression arg",
	6502	:	"//	exi 1   else take wrong type error exit",
	6503	:	"//pbild	prc e 0  entry point",
	6504	:	"//	mov -(xs) xr  stack possible parm1",
	6505	:	"//	mov xr wb  copy pcode",
	6506	:	"//	lei xr   load entry point id (bl_px)",
	6507	:	"//	beq xr =bl_p1 pbld1 jump if one parameter",
	6508	:	"//	beq xr =bl_p0 pbld3 jump if no parameters",
	6509	:	"//	mov wa *pcsi_  set size of p2blk",
	6510	:	"//	jsr alloc   allocate block",
	6511	:	"//	mov parm2(xr) wc  store second parameter",
	6512	:	"//	brn pbld2   merge with one parm case",
	6513	:	"//pbld1	mov wa *pbsi_  set size of p1blk",
	6514	:	"//	jsr alloc   allocate node",
	6515	:	"//pbld2	mov parm1(xr) (xs)  store first parameter",
	6516	:	"//	brn pbld4   merge with no parameter case",
	6517	:	"//pbld3	mov wa *pasi_  set size of p0blk",
	6518	:	"//	jsr alloc   allocate node",
	6519	:	"//pbld4	mov (xr) wb  store pcode",
	6520	:	"//	ica xs   pop first parameter",
	6521	:	"//	mov pthen(xr) =ndnth  set nothen successor pointer",
	6522	:	"//	exi    return to pbild caller",
	6523	:	"//pconc	prc e 0  entry point",
	6524	:	"//	zer -(xs)   make room for one entry at bottom",
	6525	:	"//	mov wc xs  store pointer to start of list",
	6526	:	"//	mov -(xs) =ndnth  stack nothen node as old node",
	6527	:	"//	mov -(xs) xl  store right arg as copy of nothen",
	6528	:	"//	mov xt xs  initialize pointer to stack entries",
	6529	:	"//	jsr pcopy   copy first node of left arg",
	6530	:	"//	mov num02(xt) wa  store as result under list",
	6531	:	"//pcnc1	beq xt xs pcnc2 jump if all entries processed",
	6532	:	"//	mov xr -(xt)  else load next old address",
	6533	:	"//	mov xr pthen(xr)  load pointer to successor",
	6534	:	"//	jsr pcopy   copy successor node",
	6535	:	"//	mov xr -(xt)  load pointer to new node (copy)",
	6536	:	"//	mov pthen(xr) wa  store ptr to new successor",
	6537	:	"//	bne (xr) =p_alt pcnc1 loop back if not",
	6538	:	"//	mov xr parm1(xr)  else load pointer to alternative",
	6539	:	"//	jsr pcopy   copy it",
	6540	:	"//	mov xr (xt)  restore ptr to new node",
	6541	:	"//	mov parm1(xr) wa  store ptr to copied alternative",
	6542	:	"//	brn pcnc1   loop back for next entry",
	6543	:	"//pcnc2	mov xs wc  restore stack pointer",
	6544	:	"//	mov xr (xs)+  load pointer to copy",
	6545	:	"//	exi    return to pconc caller",
	6546	:	"//pcopy	prc n 0  entry point",
	6547	:	"//	mov wb xt  save xt",
	6548	:	"//	mov xt wc  point to start of list",
	6549	:	"//pcop1	dca xt   point to next entry on list",
	6550	:	"//	beq xr (xt) pcop2 jump if match",
	6551	:	"//	dca xt   else skip over copied address",
	6552	:	"//	bne xt xs pcop1 loop back if more to test",
	6553	:	"//	mov wa (xr)  load first word of block",
	6554	:	"//	jsr blkln   get length of block",
	6555	:	"//	mov xl xr  save pointer to old node",
	6556	:	"//	jsr alloc   allocate space for copy",
	6557	:	"//	mov -(xs) xl  store old address on list",
	6558	:	"//	mov -(xs) xr  store new address on list",
	6559	:	"//	chk    check for stack overflow",
	6560	:	"//	mvw    move words from old block to copy",
	6561	:	"//	mov wa (xs)  load pointer to copy",
	6562	:	"//	brn pcop3   jump to exit",
	6563	:	"//pcop2	mov wa -(xt)  load address of copy from list",
	6564	:	"//pcop3	mov xt wb  restore xt",
	6565	:	"//	exi    return to pcopy caller",
	6566	:	"//prflr	prc e 0  ",
	6567	:	"//	bze pfdmp prfl4  no printing if no profiling done",
	6568	:	"//	mov -(xs) xr  preserve entry xr",
	6569	:	"//	mov pfsvw wb  and also wb",
	6570	:	"//	jsr prtpg   eject",
	6571	:	"//	mov xr =pfms1  load msg /program profile/",
	6572	:	"//	jsr prtst   and print it",
	6573	:	"//	jsr prtnl   followed by newline",
	6574	:	"//	jsr prtnl   and another",
	6575	:	"//	mov xr =pfms2  point to first hdr",
	6576	:	"//	jsr prtst   print it",
	6577	:	"//	jsr prtnl   new line",
	6578	:	"//	mov xr =pfms3  second hdr",
	6579	:	"//	jsr prtst   print it",
	6580	:	"//	jsr prtnl   new line",
	6581	:	"//	jsr prtnl   and another blank line",
	6582	:	"//	zer wb   initial stmt count",
	6583	:	"//	mov xr pftbl  point to table origin",
	6584	:	"//	add xr *xndta  bias past xnblk header (sgd07)",
	6585	:	"//prfl1	icv wb   bump stmt nr",
	6586	:	"//	ldi (xr)   load nr of executions",
	6587	:	"//	ieq prfl3   no printing if zero",
	6588	:	"//	mov profs =pfpd1  point where to print",
	6589	:	"//	jsr prtin   and print it",
	6590	:	"//	zer profs   back to start of line",
	6591	:	"//	mti wb   load stmt nr",
	6592	:	"//	jsr prtin   print it there",
	6593	:	"//	mov profs =pfpd2  and pad past count",
	6594	:	"//	ldi cfp_i(xr)   load total exec time",
	6595	:	"//	jsr prtin   print that too",
	6596	:	"//	ldi cfp_i(xr)   reload time",
	6597	:	"//	mli 4,intth   convert to microsec",
	6598	:	"//	iov prfl2   omit next bit if overflow",
	6599	:	"//	dvi (xr)   divide by executions",
	6600	:	"//	mov profs =pfpd3  pad last print",
	6601	:	"//	jsr prtin   and print mcsec/execn",
	6602	:	"//prfl2	jsr prtnl   thats another line",
	6603	:	"//prfl3	add xr *pf_i2  bump index ptr (sgd07)",
	6604	:	"//	blt wb pfnte prfl1 loop if more stmts",
	6605	:	"//	mov xr (xs)+  restore callers xr",
	6606	:	"//	mov wb pfsvw  and wb too",
	6607	:	"//prfl4	exi    return",
	6608	:	"//prflu	prc e 0  ",
	6609	:	"//	bnz pffnc pflu4  skip if just entered function",
	6610	:	"//	mov -(xs) xr  preserve entry xr",
	6611	:	"//	mov pfsvw wa  save wa (sgd07)",
	6612	:	"//	bnz pftbl pflu2  branch if table allocated",
	6613	:	"//	sub pfnte =num01  adjust for extra count (sgd07)",
	6614	:	"//	mti 4,pfi2a   convrt entry size to int",
	6615	:	"//	sti pfste   and store safely for later",
	6616	:	"//	mti pfnte   load table length as integer",
	6617	:	"//	mli pfste   multiply by entry size",
	6618	:	"//	mfi wa   get back address-style",
	6619	:	"//	add wa =num02  add on 2 word overhead",
	6620	:	"//	wtb wa   convert the whole lot to bytes",
	6621	:	"//	jsr alost   gimme the space",
	6622	:	"//	mov pftbl xr  save block pointer",
	6623	:	"//	mov (xr)+ =b_xnt  put block type and ...",
	6624	:	"//	mov (xr)+ wa  ... length into header",
	6625	:	"//	mfi wa   get back nr of wds in data area",
	6626	:	"//	lct wa wa  load the counter",
	6627	:	"//pflu1	zer (xr)+   blank a word",
	6628	:	"//	bct wa pflu1  and alllllll the rest",
	6629	:	"//pflu2	mti kvstn   load nr of stmt just ended",
	6630	:	"//	sbi 4,intv1   make into index offset",
	6631	:	"//	mli pfste   make offset of table entry",
	6632	:	"//	mfi wa   convert to address",
	6633	:	"//	wtb wa   get as baus",
	6634	:	"//	add wa *num02  offset includes table header",
	6635	:	"//	mov xr pftbl  get table start",
	6636	:	"//	bge wa num01(xr) pflu3 if out of table, skip it",
	6637	:	"//	add xr wa  else point to entry",
	6638	:	"//	ldi (xr)   get nr of executions so far",
	6639	:	"//	adi 4,intv1   nudge up one",
	6640	:	"//	sti (xr)   and put back",
	6641	:	"//	jsr systm   get time now",
	6642	:	"//	sti pfetm   stash ending time",
	6643	:	"//	sbi pfstm   subtract start time",
	6644	:	"//	adi cfp_i(xr)   add cumulative time so far",
	6645	:	"//	sti cfp_i(xr)   and put back new total",
	6646	:	"//	ldi pfetm   load end time of this stmt ...",
	6647	:	"//	sti pfstm   ... which is start time of next",
	6648	:	"//pflu3	mov xr (xs)+  restore callers xr",
	6649	:	"//	mov wa pfsvw  restore saved reg",
	6650	:	"//	exi    and return",
	6651	:	"//pflu4	zer pffnc   reset the condition flag",
	6652	:	"//	exi    and immediate return",
	6653	:	"//prpar	prc e 0  entry point",
	6654	:	"//	bnz wc prpa8  jump to associate terminal",
	6655	:	"//	jsr syspp   get print parameters",
	6656	:	"//	bnz wb prpa1  jump if lines/page specified",
	6657	:	"//	mov wb mxint  else use a large value",
	6658	:	"//	rsh wb 1  but not too large",
	6659	:	"//prpa1	mov lstnp wb  store number of lines/page",
	6660	:	"//	mov lstlc wb  pretend page is full initially",
	6661	:	"//	zer lstpg   clear page number",
	6662	:	"//	mov wb prlen  get prior length if any",
	6663	:	"//	bze wb prpa2  skip if no length",
	6664	:	"//	bgt wa wb prpa3 skip storing if too big",
	6665	:	"//prpa2	mov prlen wa  store value",
	6666	:	"//prpa3	mov wb 4,bits3  bit 3 mask",
	6667	:	"//	anb wb wc  get -nolist bit",
	6668	:	"//	zrb wb prpa4  skip if clear",
	6669	:	"//	zer cswls   set -nolist",
	6670	:	"//prpa4	mov wb 4,bits1  bit 1 mask",
	6671	:	"//	anb wb wc  get bit",
	6672	:	"//	mov erich wb  store int. chan. error flag",
	6673	:	"//	mov wb 4,bits2  bit 2 mask",
	6674	:	"//	anb wb wc  get bit",
	6675	:	"//	mov prich wb  flag for std printer on int. chan.",
	6676	:	"//	mov wb 4,bits4  bit 4 mask",
	6677	:	"//	anb wb wc  get bit",
	6678	:	"//	mov cpsts wb  flag for compile stats suppressn.",
	6679	:	"//	mov wb 4,bits5  bit 5 mask",
	6680	:	"//	anb wb wc  get bit",
	6681	:	"//	mov exsts wb  flag for exec stats suppression",
	6682	:	"//	mov wb 4,bits6  bit 6 mask",
	6683	:	"//	anb wb wc  get bit",
	6684	:	"//	mov precl wb  extended/compact listing flag",
	6685	:	"//	sub wa =num08  point 8 chars from line end",
	6686	:	"//	zrb wb prpa5  jump if not extended",
	6687	:	"//	mov lstpo wa  store for listing page headings",
	6688	:	"//prpa5	mov wb 4,bits7  bit 7 mask",
	6689	:	"//	anb wb wc  get bit 7",
	6690	:	"//	mov cswex wb  set -noexecute if non-zero",
	6691	:	"//	mov wb 4,bit10  bit 10 mask",
	6692	:	"//	anb wb wc  get bit 10",
	6693	:	"//	mov headp wb  pretend printed to omit headers",
	6694	:	"//	mov wb 4,bits9  bit 9 mask",
	6695	:	"//	anb wb wc  get bit 9",
	6696	:	"//	mov prsto wb  keep it as std listing option",
	6697	:	"//	mov wb 4,bit12  bit 12 mask",
	6698	:	"//	anb wb wc  get bit 12",
	6699	:	"//	mov cswer wb  keep it as errors/noerrors option",
	6700	:	"//	zrb wb prpa6  skip if clear",
	6701	:	"//	mov wa prlen  get print buffer length",
	6702	:	"//	sub wa =num08  point 8 chars from line end",
	6703	:	"//	mov lstpo wa  store page offset",
	6704	:	"//prpa6	mov wb 4,bit11  bit 11 mask",
	6705	:	"//	anb wb wc  get bit 11",
	6706	:	"//	mov cswpr wb  set -print if non-zero",
	6707	:	"//	anb wc 4,bits8  see if terminal to be activated",
	6708	:	"//	bnz wc prpa8  jump if terminal required",
	6709	:	"//	bze initr prpa9  jump if no terminal to detach",
	6710	:	"//	mov xl =v_ter  ptr to /terminal/",
	6711	:	"//	jsr gtnvr   get vrblk pointer",
	6712	:	"//	mov vrval(xr) =nulls  clear value of terminal",
	6713	:	"//	jsr setvr   remove association",
	6714	:	"//	brn prpa9   return",
	6715	:	"//prpa8	mnz initr   note terminal associated",
	6716	:	"//	bze dnamb prpa9  cant if memory not organised",
	6717	:	"//	mov xl =v_ter  point to terminal string",
	6718	:	"//	mov wb =trtou  output trace type",
	6719	:	"//	jsr inout   attach output trblk to vrblk",
	6720	:	"//	mov -(xs) xr  stack trblk ptr",
	6721	:	"//	mov xl =v_ter  point to terminal string",
	6722	:	"//	mov wb =trtin  input trace type",
	6723	:	"//	jsr inout   attach input trace blk",
	6724	:	"//	mov vrval(xr) (xs)+  add output trblk to chain",
	6725	:	"//prpa9	exi    return",
	6726	:	"//prtch	prc e 0  entry point",
	6727	:	"//	mov -(xs) xr  save xr",
	6728	:	"//	bne profs prlen prch1 jump if room in buffer",
	6729	:	"//	jsr prtnl   else print this line",
	6730	:	"//prch1	mov xr prbuf  point to print buffer",
	6731	:	"//	psc xr profs  point to next character location",
	6732	:	"//	sch wa (xr)  store new character",
	6733	:	"//	csc xr   complete store characters",
	6734	:	"//	icv profs   bump pointer",
	6735	:	"//	mov xr (xs)+  restore entry xr",
	6736	:	"//	exi    return to prtch caller",
	6737	:	"//prtic	prc e 0  entry point",
	6738	:	"//	mov -(xs) xr  save xr",
	6739	:	"//	mov xr prbuf  point to buffer",
	6740	:	"//	mov wa profs  no of chars",
	6741	:	"//	jsr syspi   print",
	6742	:	"//prtc1	mov xr (xs)+  restore xr",
	6743	:	"//	exi    return",
	6744	:	"//prtc2	zer erich   prevent looping",
	6745	:	"//	erb 252 error on printing to interactive channel  ",
	6746	:	"//	brn prtc1   return",
	6747	:	"//prtis	prc e 0  entry point",
	6748	:	"//	bnz prich prts1  jump if standard printer is int.ch.",
	6749	:	"//	bze erich prts1  skip if not doing int. error reps.",
	6750	:	"//	jsr prtic   print to interactive channel",
	6751	:	"//prts1	jsr prtnl   print to standard printer",
	6752	:	"//	exi    return",
	6753	:	"//prtin	prc e 0  entry point",
	6754	:	"//	mov -(xs) xr  save xr",
	6755	:	"//	jsr icbld   build integer block",
	6756	:	"//	blo xr dnamb prti1 jump if icblk below dynamic",
	6757	:	"//	bhi xr dnamp prti1 jump if above dynamic",
	6758	:	"//	mov dnamp xr  immediately delete it",
	6759	:	"//prti1	mov -(xs) xr  stack ptr for gtstg",
	6760	:	"//	jsr gtstg   convert to string",
	6761	:	"//	mov dnamp xr  reset pointer to delete scblk",
	6762	:	"//	jsr prtst   print integer string",
	6763	:	"//	mov xr (xs)+  restore entry xr",
	6764	:	"//	exi    return to prtin caller",
	6765	:	"//prtmi	prc e 0  entry point",
	6766	:	"//	jsr prtst   print string message",
	6767	:	"//	mov profs =prtmf  set column offset",
	6768	:	"//	jsr prtin   print integer",
	6769	:	"//	jsr prtnl   print line",
	6770	:	"//	exi    return to prtmi caller",
	6771	:	"//prtmm	prc e 0  ",
	6772	:	"//	mov wa dnamp  next available loc",
	6773	:	"//	sub wa statb  minus start",
	6774	:	"//	mti wa   convert to integer",
	6775	:	"//	mov xr =encm1  point to /memory used (words)/",
	6776	:	"//	jsr prtmi   print message",
	6777	:	"//	mov wa dname  end of memory",
	6778	:	"//	sub wa dnamp  minus next available loc",
	6779	:	"//	mti wa   convert to integer",
	6780	:	"//	mov xr =encm2  point to /memory available (words)/",
	6781	:	"//	jsr prtmi   print line",
	6782	:	"//	exi    return to prtmm caller",
	6783	:	"//prtmx	prc e 0  entry point",
	6784	:	"//	jsr prtst   print string message",
	6785	:	"//	mov profs =prtmf  set column offset",
	6786	:	"//	jsr prtin   print integer",
	6787	:	"//	jsr prtis   print line",
	6788	:	"//	exi    return",
	6789	:	"//prtnl	prc r 0  entry point",
	6790	:	"//	bnz headp prnl0  were headers printed",
	6791	:	"//	jsr prtps   no - print them",
	6792	:	"//prnl0	mov -(xs) xr  save entry xr",
	6793	:	"//	mov prtsa wa  save wa",
	6794	:	"//	mov prtsb wb  save wb",
	6795	:	"//	mov xr prbuf  load pointer to buffer",
	6796	:	"//	mov wa profs  load number of chars in buffer",
	6797	:	"//	jsr syspr   call system print routine",
	6798	:	"//	lct wa prlnw  load length of buffer in words",
	6799	:	"//	add xr *schar  point to chars of buffer",
	6800	:	"//	mov wb 4,nullw  get word of blanks",
	6801	:	"//prnl1	mov (xr)+ wb  store word of blanks, bump ptr",
	6802	:	"//	bct wa prnl1  loop till all blanked",
	6803	:	"//	mov wb prtsb  restore wb",
	6804	:	"//	mov wa prtsa  restore wa",
	6805	:	"//	mov xr (xs)+  restore entry xr",
	6806	:	"//	zer profs   reset print buffer pointer",
	6807	:	"//	exi    return to prtnl caller",
	6808	:	"//prnl2	bnz prtef prnl3  jump if not first time",
	6809	:	"//	mnz prtef   mark first occurrence",
	6810	:	"//	erb 253 print limit exceeded on standard output channel  ",
	6811	:	"//prnl3	mov wb =nini8  ending code",
	6812	:	"//	mov wa kvstn  statement number",
	6813	:	"//	mov xl r_fcb  get fcblk chain head",
	6814	:	"//	jsr sysej   stop",
	6815	:	"//prtnm	prc r 0  entry point (recursive, see prtvl)",
	6816	:	"//	mov -(xs) wa  save wa (offset is collectable)",
	6817	:	"//	mov -(xs) xr  save entry xr",
	6818	:	"//	mov -(xs) xl  save name base",
	6819	:	"//	bhi xl state prn02 jump if not natural variable",
	6820	:	"//	mov xr xl  point to vrblk",
	6821	:	"//	jsr prtvn   print name of variable",
	6822	:	"//prn01	mov xl (xs)+  restore name base",
	6823	:	"//	mov xr (xs)+  restore entry value of xr",
	6824	:	"//	mov wa (xs)+  restore wa",
	6825	:	"//	exi    return to prtnm caller",
	6826	:	"//prn02	mov wb wa  copy name offset",
	6827	:	"//	bne (xl) =b_pdt prn03 jump if array or table",
	6828	:	"//	mov xr pddfp(xl)  load pointer to dfblk",
	6829	:	"//	add xr wa  add name offset",
	6830	:	"//	mov xr pdfof(xr)  load vrblk pointer for field",
	6831	:	"//	jsr prtvn   print field name",
	6832	:	"//	mov wa =ch_pp  load left paren",
	6833	:	"//	jsr prtch   print character",
	6834	:	"//prn03	bne (xl) =b_tet prn04 jump if we got there (or not te)",
	6835	:	"//	mov xl tenxt(xl)  else move out on chain",
	6836	:	"//	brn prn03   and loop back",
	6837	:	"//prn04	mov xr prnmv  point to vrblk we found last time",
	6838	:	"//	mov wa hshtb  point to hash table in case not",
	6839	:	"//	brn prn07   jump into search for special check",
	6840	:	"//prn05	mov xr wa  copy slot pointer",
	6841	:	"//	ica wa   bump slot pointer",
	6842	:	"//	sub xr *vrnxt  introduce standard vrblk offset",
	6843	:	"//prn06	mov xr vrnxt(xr)  point to next vrblk on hash chain",
	6844	:	"//prn07	mov wc xr  copy vrblk pointer",
	6845	:	"//	bze wc prn09  jump if chain end (or prnmv zero)",
	6846	:	"//prn08	mov xr vrval(xr)  load value",
	6847	:	"//	beq (xr) =b_trt prn08 loop if that was a trblk",
	6848	:	"//	beq xr xl prn10 jump if this matches the name base",
	6849	:	"//	mov xr wc  else point back to that vrblk",
	6850	:	"//	brn prn06   and loop back",
	6851	:	"//prn09	blt wa hshte prn05 loop back if more to go",
	6852	:	"//	mov xr xl  else not found, copy value pointer",
	6853	:	"//	jsr prtvl   print value",
	6854	:	"//	brn prn11   and merge ahead",
	6855	:	"//prn10	mov xr wc  copy vrblk pointer",
	6856	:	"//	mov prnmv xr  save for next time in",
	6857	:	"//	jsr prtvn   print variable name",
	6858	:	"//prn11	mov wc (xl)  load first word of name base",
	6859	:	"//	bne wc =b_pdt prn13 jump if not program defined",
	6860	:	"//	mov wa =ch_rp  load right paren, merge",
	6861	:	"//prn12	jsr prtch   print final character",
	6862	:	"//	mov wa wb  restore name offset",
	6863	:	"//	brn prn01   merge back to exit",
	6864	:	"//prn13	mov wa =ch_bb  load left bracket",
	6865	:	"//	jsr prtch   and print it",
	6866	:	"//	mov xl (xs)  restore block pointer",
	6867	:	"//	mov wc (xl)  load type word again",
	6868	:	"//	bne wc =b_tet prn15 jump if not table",
	6869	:	"//	mov xr tesub(xl)  load subscript value",
	6870	:	"//	mov xl wb  save name offset",
	6871	:	"//	jsr prtvl   print subscript value",
	6872	:	"//	mov wb xl  restore name offset",
	6873	:	"//prn14	mov wa =ch_rb  load right bracket",
	6874	:	"//	brn prn12   merge back to print it",
	6875	:	"//prn15	mov wa wb  copy name offset",
	6876	:	"//	btw wa   convert to words",
	6877	:	"//	beq wc =b_art prn16 jump if arblk",
	6878	:	"//	sub wa =vcvlb  adjust for standard fields",
	6879	:	"//	mti wa   move to integer accum",
	6880	:	"//	jsr prtin   print linear subscript",
	6881	:	"//	brn prn14   merge back for right bracket",
	6882	:	"//prn16	mov wc arofs(xl)  load length of bounds info",
	6883	:	"//	ica wc   adjust for arpro field",
	6884	:	"//	btw wc   convert to words",
	6885	:	"//	sub wa wc  get linear zero-origin subscript",
	6886	:	"//	mti wa   get integer value",
	6887	:	"//	lct wa arndm(xl)  set num of dimensions as loop count",
	6888	:	"//	add xl arofs(xl)  point past bounds information",
	6889	:	"//	sub xl *arlbd  set ok offset for proper ptr later",
	6890	:	"//prn17	sub xl *ardms  point to next set of bounds",
	6891	:	"//	sti prnsi   save current offset",
	6892	:	"//	rmi ardim(xl)   get remainder on dividing by dimens",
	6893	:	"//	mfi -(xs)   store on stack (one word)",
	6894	:	"//	ldi prnsi   reload argument",
	6895	:	"//	dvi ardim(xl)   divide to get quotient",
	6896	:	"//	bct wa prn17  loop till all stacked",
	6897	:	"//	zer xr   set offset to first set of bounds",
	6898	:	"//	lct wb arndm(xl)  load count of dims to control loop",
	6899	:	"//	brn prn19   jump into print loop",
	6900	:	"//prn18	mov wa =ch_cm  load a comma",
	6901	:	"//	jsr prtch   print it",
	6902	:	"//prn19	mti (xs)+   load subscript offset as integer",
	6903	:	"//	add xl xr  point to current lbd",
	6904	:	"//	adi arlbd(xl)   add lbd to get signed subscript",
	6905	:	"//	sub xl xr  point back to start of arblk",
	6906	:	"//	jsr prtin   print subscript",
	6907	:	"//	add xr *ardms  bump offset to next bounds",
	6908	:	"//	bct wb prn18  loop back till all printed",
	6909	:	"//	brn prn14   merge back to print right bracket",
	6910	:	"//prtnv	prc e 0  entry point",
	6911	:	"//	jsr prtnm   print argument name",
	6912	:	"//	mov -(xs) xr  save entry xr",
	6913	:	"//	mov -(xs) wa  save name offset (collectable)",
	6914	:	"//	mov xr =tmbeb  point to blank equal blank",
	6915	:	"//	jsr prtst   print it",
	6916	:	"//	mov xr xl  copy name base",
	6917	:	"//	add xr wa  point to value",
	6918	:	"//	mov xr (xr)  load value pointer",
	6919	:	"//	jsr prtvl   print value",
	6920	:	"//	jsr prtnl   terminate line",
	6921	:	"//	mov wa (xs)+  restore name offset",
	6922	:	"//	mov xr (xs)+  restore entry xr",
	6923	:	"//	exi    return to caller",
	6924	:	"//prtpg	prc e 0  entry point",
	6925	:	"//	beq stage =stgxt prp01 jump if execution time",
	6926	:	"//	bze lstlc prp06  return if top of page already",
	6927	:	"//	zer lstlc   clear line count",
	6928	:	"//prp01	mov -(xs) xr  preserve xr",
	6929	:	"//	bnz prstd prp02  eject if flag set",
	6930	:	"//	bnz prich prp03  jump if interactive listing channel",
	6931	:	"//	bze precl prp03  jump if compact listing",
	6932	:	"//prp02	jsr sysep   eject",
	6933	:	"//	brn prp04   merge",
	6934	:	"//prp03	mov xr headp  remember headp",
	6935	:	"//	mnz headp   set to avoid repeated prtpg calls",
	6936	:	"//	jsr prtnl   print blank line",
	6937	:	"//	jsr prtnl   print blank line",
	6938	:	"//	jsr prtnl   print blank line",
	6939	:	"//	mov lstlc =num03  count blank lines",
	6940	:	"//	mov headp xr  restore header flag",
	6941	:	"//prp04	bnz headp prp05  jump if header listed",
	6942	:	"//	mnz headp   mark headers printed",
	6943	:	"//	mov -(xs) xl  keep xl",
	6944	:	"//	mov xr =headr  point to listing header",
	6945	:	"//	jsr prtst   place it",
	6946	:	"//	jsr sysid   get system identification",
	6947	:	"//	jsr prtst   append extra chars",
	6948	:	"//	jsr prtnl   print it",
	6949	:	"//	mov xr xl  extra header line",
	6950	:	"//	jsr prtst   place it",
	6951	:	"//	jsr prtnl   print it",
	6952	:	"//	jsr prtnl   print a blank",
	6953	:	"//	jsr prtnl   and another",
	6954	:	"//	add lstlc =num04  four header lines printed",
	6955	:	"//	mov xl (xs)+  restore xl",
	6956	:	"//prp05	mov xr (xs)+  restore xr",
	6957	:	"//prp06	exi    return",
	6958	:	"//prtps	prc e 0  entry point",
	6959	:	"//	mov prstd prsto  copy option flag",
	6960	:	"//	jsr prtpg   print page",
	6961	:	"//	zer prstd   clear flag",
	6962	:	"//	exi    return",
	6963	:	"//prtsn	prc e 0  entry point",
	6964	:	"//	mov -(xs) xr  save entry xr",
	6965	:	"//	mov prsna wa  save entry wa",
	6966	:	"//	mov xr =tmasb  point to asterisks",
	6967	:	"//	jsr prtst   print asterisks",
	6968	:	"//	mov profs =num04  point into middle of asterisks",
	6969	:	"//	mti kvstn   load statement number as integer",
	6970	:	"//	jsr prtin   print integer statement number",
	6971	:	"//	mov profs =prsnf  point past asterisks plus blank",
	6972	:	"//	mov xr kvfnc  get fnclevel",
	6973	:	"//	mov wa =ch_li  set letter i",
	6974	:	"//prsn1	bze xr prsn2  jump if all set",
	6975	:	"//	jsr prtch   else print an i",
	6976	:	"//	dcv xr   decrement counter",
	6977	:	"//	brn prsn1   loop back",
	6978	:	"//prsn2	mov wa =ch_bl  get blank",
	6979	:	"//	jsr prtch   print blank",
	6980	:	"//	mov wa prsna  restore entry wa",
	6981	:	"//	mov xr (xs)+  restore entry xr",
	6982	:	"//	exi    return to prtsn caller",
	6983	:	"//prtst	prc r 0  entry point",
	6984	:	"//	bnz headp prst0  were headers printed",
	6985	:	"//	jsr prtps   no - print them",
	6986	:	"//prst0	mov prsva wa  save wa",
	6987	:	"//	mov prsvb wb  save wb",
	6988	:	"//	zer wb   set chars printed count to zero",
	6989	:	"//prst1	mov wa sclen(xr)  load string length",
	6990	:	"//	sub wa wb  subtract count of chars already out",
	6991	:	"//	bze wa prst4  jump to exit if none left",
	6992	:	"//	mov -(xs) xl  else stack entry xl",
	6993	:	"//	mov -(xs) xr  save argument",
	6994	:	"//	mov xl xr  copy for eventual move",
	6995	:	"//	mov xr prlen  load print buffer length",
	6996	:	"//	sub xr profs  get chars left in print buffer",
	6997	:	"//	bnz xr prst2  skip if room left on this line",
	6998	:	"//	jsr prtnl   else print this line",
	6999	:	"//	mov xr prlen  and set full width available",
	7000	:	"//prst2	blo wa xr prst3 jump if room for rest of string",
	7001	:	"//	mov wa xr  else set to fill line",
	7002	:	"//prst3	mov xr prbuf  point to print buffer",
	7003	:	"//	plc xl wb  point to location in string",
	7004	:	"//	psc xr profs  point to location in buffer",
	7005	:	"//	add wb wa  bump string chars count",
	7006	:	"//	add profs wa  bump buffer pointer",
	7007	:	"//	mov prsvc wb  preserve char counter",
	7008	:	"//	mvc    move characters to buffer",
	7009	:	"//	mov wb prsvc  recover char counter",
	7010	:	"//	mov xr (xs)+  restore argument pointer",
	7011	:	"//	mov xl (xs)+  restore entry xl",
	7012	:	"//	brn prst1   loop back to test for more",
	7013	:	"//prst4	mov wb prsvb  restore entry wb",
	7014	:	"//	mov wa prsva  restore entry wa",
	7015	:	"//	exi    return to prtst caller",
	7016	:	"//prttr	prc e 0  entry point",
	7017	:	"//	mov -(xs) xr  save xr",
	7018	:	"//	jsr prtic   print buffer contents",
	7019	:	"//	mov xr prbuf  point to print bfr to clear it",
	7020	:	"//	lct wa prlnw  get buffer length",
	7021	:	"//	add xr *schar  point past scblk header",
	7022	:	"//	mov wb 4,nullw  get blanks",
	7023	:	"//prtt1	mov (xr)+ wb  clear a word",
	7024	:	"//	bct wa prtt1  loop",
	7025	:	"//	zer profs   reset profs",
	7026	:	"//	mov xr (xs)+  restore xr",
	7027	:	"//	exi    return",
	7028	:	"//prtvl	prc r 0  entry point, recursive",
	7029	:	"//	mov -(xs) xl  save entry xl",
	7030	:	"//	mov -(xs) xr  save argument",
	7031	:	"//	chk    check for stack overflow",
	7032	:	"//prv01	mov prvsi idval(xr)  copy idval (if any)",
	7033	:	"//	mov xl (xr)  load first word of block",
	7034	:	"//	lei xl   load entry point id",
	7035	:	"//	bsw xl bl__t prv02 switch on block type",
	7036	:	"//prv02	jsr dtype   get datatype name",
	7037	:	"//	jsr prtst   print datatype name",
	7038	:	"//prv03	mov xr (xs)+  reload argument",
	7039	:	"//	mov xl (xs)+  restore xl",
	7040	:	"//	exi    return to prtvl caller",
	7041	:	"//prv04	mov xr trval(xr)  load real value",
	7042	:	"//	brn prv01   and loop back",
	7043	:	"//prv05	mov xl xr  preserve argument",
	7044	:	"//	mov xr =scarr  point to datatype name (array)",
	7045	:	"//	jsr prtst   print it",
	7046	:	"//	mov wa =ch_pp  load left paren",
	7047	:	"//	jsr prtch   print left paren",
	7048	:	"//	add xl arofs(xl)  point to prototype",
	7049	:	"//	mov xr (xl)  load prototype",
	7050	:	"//	jsr prtst   print prototype",
	7051	:	"//prv06	mov wa =ch_rp  load right paren",
	7052	:	"//	jsr prtch   print right paren",
	7053	:	"//prv07	mov wa =ch_bl  load blank",
	7054	:	"//	jsr prtch   print it",
	7055	:	"//	mov wa =ch_nm  load number sign",
	7056	:	"//	jsr prtch   print it",
	7057	:	"//	mti prvsi   get idval",
	7058	:	"//	jsr prtin   print id number",
	7059	:	"//	brn prv03   back to exit",
	7060	:	"//prv08	mov -(xs) xr  stack argument for gtstg",
	7061	:	"//	jsr gtstg   convert to string",
	7062	:	"//	jsr prtst   print the string",
	7063	:	"//	mov dnamp xr  delete garbage string from storage",
	7064	:	"//	brn prv03   back to exit",
	7065	:	"//prv09	mov xl nmbas(xr)  load name base",
	7066	:	"//	mov wa (xl)  load first word of block",
	7067	:	"//	beq wa =b_kvt prv02 just print name if keyword",
	7068	:	"//	beq wa =b_evt prv02 just print name if expression var",
	7069	:	"//	mov wa =ch_dt  else get dot",
	7070	:	"//	jsr prtch   and print it",
	7071	:	"//	mov wa nmofs(xr)  load name offset",
	7072	:	"//	jsr prtnm   print name",
	7073	:	"//	brn prv03   back to exit",
	7074	:	"//prv10	jsr dtype   get datatype name",
	7075	:	"//	jsr prtst   print datatype name",
	7076	:	"//	brn prv07   merge back to print id",
	7077	:	"//prv11	mov wa =ch_sq  load single quote",
	7078	:	"//	jsr prtch   print quote",
	7079	:	"//	jsr prtst   print string value",
	7080	:	"//	jsr prtch   print another quote",
	7081	:	"//	brn prv03   back to exit",
	7082	:	"//prv12	mov wa =ch_as  load asterisk",
	7083	:	"//	jsr prtch   print asterisk",
	7084	:	"//	mov xr sevar(xr)  load variable pointer",
	7085	:	"//	jsr prtvn   print variable name",
	7086	:	"//	brn prv03   jump back to exit",
	7087	:	"//prv13	mov xl xr  preserve argument",
	7088	:	"//	jsr dtype   get datatype name",
	7089	:	"//	jsr prtst   print datatype name",
	7090	:	"//	mov wa =ch_pp  load left paren",
	7091	:	"//	jsr prtch   print left paren",
	7092	:	"//	mov wa tblen(xl)  load length of block (=vclen)",
	7093	:	"//	btw wa   convert to word count",
	7094	:	"//	sub wa =tbsi_  allow for standard fields",
	7095	:	"//	beq (xl) =b_tbt prv14 jump if table",
	7096	:	"//	add wa =vctbd  for vcblk, adjust size",
	7097	:	"//prv14	mti wa   move as integer",
	7098	:	"//	jsr prtin   print integer prototype",
	7099	:	"//	brn prv06   merge back for rest",
	7100	:	"//prtvn	prc e 0  entry point",
	7101	:	"//	mov -(xs) xr  stack vrblk pointer",
	7102	:	"//	add xr *vrsof  point to possible string name",
	7103	:	"//	bnz sclen(xr) prvn1  jump if not system variable",
	7104	:	"//	mov xr vrsvo(xr)  point to svblk with name",
	7105	:	"//prvn1	jsr prtst   print string name of variable",
	7106	:	"//	mov xr (xs)+  restore vrblk pointer",
	7107	:	"//	exi    return to prtvn caller",
	7108	:	"//rcbld	prc e 0  entry point",
	7109	:	"//	mov xr dnamp  load pointer to next available loc",
	7110	:	"//	add xr *rcsi_  point past new rcblk",
	7111	:	"//	blo xr dname rcbl1 jump if there is room",
	7112	:	"//	mov wa *rcsi_  else load rcblk length",
	7113	:	"//	jsr alloc   use standard allocator to get block",
	7114	:	"//	add xr wa  point past block to merge",
	7115	:	"//rcbl1	mov dnamp xr  set new pointer",
	7116	:	"//	sub xr *rcsi_  point back to start of block",
	7117	:	"//	mov (xr) =b_rcl  store type word",
	7118	:	"//	str rcval(xr)   store real value in rcblk",
	7119	:	"//	exi    return to rcbld caller",
	7120	:	"//readr	prc e 0  entry point",
	7121	:	"//	mov xr r_cni  get ptr to next image",
	7122	:	"//	bnz xr read3  exit if already read",
	7123	:	"//	bnz cnind reada  if within include file",
	7124	:	"//	bne stage =stgic read3 exit if not initial compile",
	7125	:	"//reada	mov wa cswin  max read length",
	7126	:	"//	zer xl   clear any dud value in xl",
	7127	:	"//	jsr alocs   allocate buffer",
	7128	:	"//	jsr sysrd   read input image",
	7129	:	"//	icv rdnln   increment next line number",
	7130	:	"//	dcv polct   test if time to poll interface",
	7131	:	"//	bnz polct read0  not yet",
	7132	:	"//	zer wa   =0 for poll",
	7133	:	"//	mov wb rdnln  line number",
	7134	:	"//	jsr syspl   allow interactive access",
	7135	:	"//	mov polcs wa  new countdown start value",
	7136	:	"//	mov polct wa  new counter value",
	7137	:	"//read0	ble sclen(xr) cswin read1 use smaller of string lnth ...",
	7138	:	"//	mov sclen(xr) cswin  ... and xxx of -inxxx",
	7139	:	"//read1	mnz wb   set trimr to perform trim",
	7140	:	"//	jsr trimr   trim trailing blanks",
	7141	:	"//read2	mov r_cni xr  store copy of pointer",
	7142	:	"//read3	exi    return to readr caller",
	7143	:	"//read4	bze sclen(xr) read5  jump if true end of file",
	7144	:	"//	zer wb   new source file name",
	7145	:	"//	mov rdnln wb  restart line counter for new file",
	7146	:	"//	jsr trimr   remove unused space in block",
	7147	:	"//	jsr newfn   record new file name",
	7148	:	"//	brn reada   now reissue read for record data",
	7149	:	"//read5	mov dnamp xr  pop unused scblk",
	7150	:	"//	bze cnind read6  jump if not within an include file",
	7151	:	"//	zer xl   eof within include file",
	7152	:	"//	jsr sysif   switch stream back to previous file",
	7153	:	"//	mov wa cnind  restore prev line number, file name",
	7154	:	"//	add wa =vcvlb  vector offset in words",
	7155	:	"//	wtb wa   convert to bytes",
	7156	:	"//	mov xr r_ifa  file name array",
	7157	:	"//	add xr wa  ptr to element",
	7158	:	"//	mov r_sfc (xr)  change source file name",
	7159	:	"//	mov (xr) =nulls  release scblk",
	7160	:	"//	mov xr r_ifl  line number array",
	7161	:	"//	add xr wa  ptr to element",
	7162	:	"//	mov xl (xr)  icblk containing saved line number",
	7163	:	"//	ldi icval(xl)   line number integer",
	7164	:	"//	mfi rdnln   change source line number",
	7165	:	"//	mov (xr) =inton  release icblk",
	7166	:	"//	dcv cnind   decrement nesting level",
	7167	:	"//	mov wb cmpsn  current statement number",
	7168	:	"//	icv wb   anticipate end of previous stmt",
	7169	:	"//	mti wb   convert to integer",
	7170	:	"//	jsr icbld   build icblk for stmt number",
	7171	:	"//	mov xl r_sfn  file name table",
	7172	:	"//	mnz wb   lookup statement number by name",
	7173	:	"//	jsr tfind   allocate new teblk",
	7174	:	"//	mov teval(xl) r_sfc  record file name as entry value",
	7175	:	"//	beq stage =stgic reada if initial compile, reissue read",
	7176	:	"//	bnz cnind reada  still reading from include file",
	7177	:	"//	mov xl r_ici  restore code argument string",
	7178	:	"//	zer r_ici   release original string",
	7179	:	"//	mov wa cnsil  get length of string",
	7180	:	"//	mov wb cnspt  offset of characters left",
	7181	:	"//	sub wa wb  number of characters left",
	7182	:	"//	mov scnil wa  set new scan length",
	7183	:	"//	zer scnpt   scan from start of substring",
	7184	:	"//	jsr sbstr   create substring of remainder",
	7185	:	"//	mov r_cim xr  set scan image",
	7186	:	"//	brn read2   return",
	7187	:	"//read6	zer xr   zero ptr as result",
	7188	:	"//	brn read2   merge",
	7189	:	"//sbstr	prc e 0  entry point",
	7190	:	"//	bze wa sbst2  jump if null substring",
	7191	:	"//	jsr alocs   else allocate scblk",
	7192	:	"//	mov wa wc  move number of characters",
	7193	:	"//	mov wc xr  save ptr to new scblk",
	7194	:	"//	plc xl wb  prepare to load chars from old blk",
	7195	:	"//	psc xr   prepare to store chars in new blk",
	7196	:	"//	mvc    move characters to new string",
	7197	:	"//	mov xr wc  then restore scblk pointer",
	7198	:	"//sbst1	zer xl   clear garbage pointer in xl",
	7199	:	"//	exi    return to sbstr caller",
	7200	:	"//sbst2	mov xr =nulls  set null string as result",
	7201	:	"//	brn sbst1   return",
	7202	:	"//stgcc	prc e 0  ",
	7203	:	"//	mov wa polcs  assume no profiling or stcount tracing",
	7204	:	"//	mov wb =num01  poll each time polcs expires",
	7205	:	"//	ldi kvstl   get stmt limit",
	7206	:	"//	bnz kvpfl stgc1  jump if profiling enabled",
	7207	:	"//	ilt stgc3   no stcount tracing if negative",
	7208	:	"//	bze r_stc stgc2  jump if not stcount tracing",
	7209	:	"//stgc1	mov wb wa  count polcs times within stmg",
	7210	:	"//	mov wa =num01  break out of stmgo on each stmt",
	7211	:	"//	brn stgc3   ",
	7212	:	"//stgc2	mti wa   breakout count start value",
	7213	:	"//	sbi kvstl   proposed stmcs minus stmt limit",
	7214	:	"//	ile stgc3   jump if stmt count does not limit",
	7215	:	"//	ldi kvstl   stlimit limits breakcount count",
	7216	:	"//	mfi wa   use it instead",
	7217	:	"//stgc3	mov stmcs wa  update breakout count start value",
	7218	:	"//	mov stmct wa  reset breakout counter",
	7219	:	"//	mov polct wb  ",
	7220	:	"//	exi    ",
	7221	:	"//tfind	prc e 1  entry point",
	7222	:	"//	mov -(xs) wb  save name/value indicator",
	7223	:	"//	mov -(xs) xr  save subscript value",
	7224	:	"//	mov -(xs) xl  save table pointer",
	7225	:	"//	mov wa tblen(xl)  load length of tbblk",
	7226	:	"//	btw wa   convert to word count",
	7227	:	"//	sub wa =tbbuk  get number of buckets",
	7228	:	"//	mti wa   convert to integer value",
	7229	:	"//	sti tfnsi   save for later",
	7230	:	"//	mov xl (xr)  load first word of subscript",
	7231	:	"//	lei xl   load block entry id (bl_xx)",
	7232	:	"//	bsw xl bl__d tfn00 switch on block type",
	7233	:	"//tfn00	mov wa 1(xr)  load second word",
	7234	:	"//tfn01	mti wa   convert to integer",
	7235	:	"//	brn tfn06   jump to merge",
	7236	:	"//tfn02	ldi 1(xr)   load value as hash source",
	7237	:	"//	ige tfn06   ok if positive or zero",
	7238	:	"//	ngi    make positive",
	7239	:	"//	iov tfn06   clear possible overflow",
	7240	:	"//	brn tfn06   merge",
	7241	:	"//tfn03	mov wa (xr)  load first word as hash source",
	7242	:	"//	brn tfn01   merge back",
	7243	:	"//tfn04	mov wa nmofs(xr)  load offset as hash source",
	7244	:	"//	brn tfn01   merge back",
	7245	:	"//tfn05	jsr hashs   call routine to compute hash",
	7246	:	"//tfn06	rmi tfnsi   compute hash index by remaindering",
	7247	:	"//	mfi wc   get as one word integer",
	7248	:	"//	wtb wc   convert to byte offset",
	7249	:	"//	mov xl (xs)  get table ptr again",
	7250	:	"//	add xl wc  point to proper bucket",
	7251	:	"//	mov xr tbbuk(xl)  load first teblk pointer",
	7252	:	"//	beq xr (xs) tfn10 jump if no teblks on chain",
	7253	:	"//tfn07	mov wb xr  save teblk pointer",
	7254	:	"//	mov xr tesub(xr)  load subscript value",
	7255	:	"//	mov xl 1(xs)  load input argument subscript val",
	7256	:	"//	jsr ident   compare them",
	7257	:	"//	mov xl wb  restore teblk pointer",
	7258	:	"//	mov xr tenxt(xl)  point to next teblk on chain",
	7259	:	"//	bne xr (xs) tfn07 jump if there is one",
	7260	:	"//	mov wc *tenxt  set offset to link field (xl base)",
	7261	:	"//	brn tfn11   jump to merge",
	7262	:	"//tfn08	mov xl wb  restore teblk pointer",
	7263	:	"//	mov wa *teval  set teblk name offset",
	7264	:	"//	mov wb 2(xs)  restore name/value indicator",
	7265	:	"//	bnz wb tfn09  jump if called by name",
	7266	:	"//	jsr acess   else get value",
	7267	:	"//	zer wb   restore name/value indicator",
	7268	:	"//tfn09	add xs *num03  pop stack entries",
	7269	:	"//	exi    return to tfind caller",
	7270	:	"//tfn10	add wc *tbbuk  get offset to bucket ptr",
	7271	:	"//	mov xl (xs)  set tbblk ptr as base",
	7272	:	"//tfn11	mov xr (xs)  tbblk pointer",
	7273	:	"//	mov xr tbinv(xr)  load default value in case",
	7274	:	"//	mov wb 2(xs)  load name/value indicator",
	7275	:	"//	bze wb tfn09  exit with default if value call",
	7276	:	"//	mov wb xr  copy default value",
	7277	:	"//	mov wa *tesi_  set size of teblk",
	7278	:	"//	jsr alloc   allocate teblk",
	7279	:	"//	add xl wc  point to hash link",
	7280	:	"//	mov (xl) xr  link new teblk at end of chain",
	7281	:	"//	mov (xr) =b_tet  store type word",
	7282	:	"//	mov teval(xr) wb  set default as initial value",
	7283	:	"//	mov tenxt(xr) (xs)+  set tbblk ptr to mark end of chain",
	7284	:	"//	mov tesub(xr) (xs)+  store subscript value",
	7285	:	"//	mov wb (xs)+  restore name/value indicator",
	7286	:	"//	mov xl xr  copy teblk pointer (name base)",
	7287	:	"//	mov wa *teval  set offset",
	7288	:	"//	exi    return to caller with new teblk",
	7289	:	"//tfn12	exi 1   alternative return",
	7290	:	"//tmake	prc e 0  ",
	7291	:	"//	mov wa wc  copy number of headers",
	7292	:	"//	add wa =tbsi_  adjust for standard fields",
	7293	:	"//	wtb wa   convert length to bytes",
	7294	:	"//	jsr alloc   allocate space for tbblk",
	7295	:	"//	mov wb xr  copy pointer to tbblk",
	7296	:	"//	mov (xr)+ =b_tbt  store type word",
	7297	:	"//	zer (xr)+   zero id for the moment",
	7298	:	"//	mov (xr)+ wa  store length (tblen)",
	7299	:	"//	mov (xr)+ xl  store initial lookup value",
	7300	:	"//	lct wc wc  set loop counter (num headers)",
	7301	:	"//tma01	mov (xr)+ wb  store tbblk ptr in bucket header",
	7302	:	"//	bct wc tma01  loop till all stored",
	7303	:	"//	mov xr wb  recall pointer to tbblk",
	7304	:	"//	exi    ",
	7305	:	"//vmake	prc e 1  entry point",
	7306	:	"//	lct wb wa  copy elements for loop later on",
	7307	:	"//	add wa =vcsi_  add space for standard fields",
	7308	:	"//	wtb wa   convert length to bytes",
	7309	:	"//	bgt wa mxlen vmak2 fail if too large",
	7310	:	"//	jsr alloc   allocate space for vcblk",
	7311	:	"//	mov (xr) =b_vct  store type word",
	7312	:	"//	zer idval(xr)   initialize idval",
	7313	:	"//	mov vclen(xr) wa  set length",
	7314	:	"//	mov wc xl  copy default value",
	7315	:	"//	mov xl xr  copy vcblk pointer",
	7316	:	"//	add xl *vcvls  point to first element value",
	7317	:	"//vmak1	mov (xl)+ wc  store one value",
	7318	:	"//	bct wb vmak1  loop till all stored",
	7319	:	"//	exi    success return",
	7320	:	"//vmak2	exi 1   fail return",
	7321	:	"//scane	prc e 0  entry point",
	7322	:	"//	zer scnbl   reset blanks flag",
	7323	:	"//	mov scnsa wa  save wa",
	7324	:	"//	mov scnsb wb  save wb",
	7325	:	"//	mov scnsc wc  save wc",
	7326	:	"//	bze scnrs scn03  jump if no rescan",
	7327	:	"//	mov xl scntp  set previous returned scan type",
	7328	:	"//	mov xr r_scp  set previous returned pointer",
	7329	:	"//	zer scnrs   reset rescan switch",
	7330	:	"//	brn scn13   jump to exit",
	7331	:	"//scn01	jsr readr   read next image",
	7332	:	"//	mov wb *dvubs  set wb for not reading name",
	7333	:	"//	bze xr scn30  treat as semi-colon if none",
	7334	:	"//	plc xr   else point to first character",
	7335	:	"//	lch wc (xr)  load first character",
	7336	:	"//	beq wc =ch_dt scn02 jump if dot for continuation",
	7337	:	"//	bne wc =ch_pl scn30 else treat as semicolon unless plus",
	7338	:	"//scn02	jsr nexts   acquire next source image",
	7339	:	"//	mov scnpt =num01  set scan pointer past continuation",
	7340	:	"//	mnz scnbl   set blanks flag",
	7341	:	"//scn03	mov wa scnpt  load current offset",
	7342	:	"//	beq wa scnil scn01 check continuation if end",
	7343	:	"//	mov xl r_cim  point to current line",
	7344	:	"//	plc xl wa  point to current character",
	7345	:	"//	mov scnse wa  set start of element location",
	7346	:	"//	mov wc =opdvs  point to operator dv list",
	7347	:	"//	mov wb *dvubs  set constant for operator circuit",
	7348	:	"//	brn scn06   start scanning",
	7349	:	"//scn05	bze wb scn10  jump if trailing",
	7350	:	"//	icv scnse   increment start of element",
	7351	:	"//	beq wa scnil scn01 jump if end of image",
	7352	:	"//	mnz scnbl   note blanks seen",
	7353	:	"//scn06	lch xr (xl)+  get next character",
	7354	:	"//	icv wa   bump scan offset",
	7355	:	"//	mov scnpt wa  store offset past char scanned",
	7356	:	"//	bsw xr cfp_u scn07 switch on scanned character",
	7357	:	"//scn07	bze wb scn10  jump if scanning name or constant",
	7358	:	"//	erb 230 syntax error: illegal character  ",
	7359	:	"//scn08	bze wb scn09  keep scanning if name/constant",
	7360	:	"//	zer wc   else set flag for scanning constant",
	7361	:	"//scn09	beq wa scnil scn11 jump if end of image",
	7362	:	"//	zer wb   set flag for scanning name/const",
	7363	:	"//	brn scn06   merge back to continue scan",
	7364	:	"//scn10	dcv wa   reset offset to point to delimiter",
	7365	:	"//scn11	mov scnpt wa  store updated scan offset",
	7366	:	"//	mov wb scnse  point to start of element",
	7367	:	"//	sub wa wb  get number of characters",
	7368	:	"//	mov xl r_cim  point to line image",
	7369	:	"//	bnz wc scn15  jump if name",
	7370	:	"//	jsr sbstr   get string for constant",
	7371	:	"//	mov dnamp xr  delete from storage (not needed)",
	7372	:	"//	jsr gtnum   convert to numeric",
	7373	:	"//scn12	mov xl =t_con  set result type of constant",
	7374	:	"//scn13	mov wa scnsa  restore wa",
	7375	:	"//	mov wb scnsb  restore wb",
	7376	:	"//	mov wc scnsc  restore wc",
	7377	:	"//	mov r_scp xr  save xr in case rescan",
	7378	:	"//	mov scntp xl  save xl in case rescan",
	7379	:	"//	zer scngo   reset possible goto flag",
	7380	:	"//	exi    return to scane caller",
	7381	:	"//scn14	erb 231 syntax error: invalid numeric item  ",
	7382	:	"//scn15	jsr sbstr   build string name of variable",
	7383	:	"//	bnz scncc scn13  return if cncrd call",
	7384	:	"//	jsr gtnvr   locate/build vrblk",
	7385	:	"//	mov xl =t_var  set type as variable",
	7386	:	"//	brn scn13   back to exit",
	7387	:	"//scn16	bze wb scn10  terminator if scanning name or cnst",
	7388	:	"//	mov wb =ch_sq  set terminator as single quote",
	7389	:	"//	brn scn18   merge",
	7390	:	"//scn17	bze wb scn10  terminator if scanning name or cnst",
	7391	:	"//	mov wb =ch_dq  set double quote terminator, merge",
	7392	:	"//scn18	beq wa scnil scn19 error if end of image",
	7393	:	"//	lch wc (xl)+  else load next character",
	7394	:	"//	icv wa   bump offset",
	7395	:	"//	bne wc wb scn18 loop back if not terminator",
	7396	:	"//	mov wb scnpt  point to first character",
	7397	:	"//	mov scnpt wa  save offset past final quote",
	7398	:	"//	dcv wa   point back past last character",
	7399	:	"//	sub wa wb  get number of characters",
	7400	:	"//	mov xl r_cim  point to input image",
	7401	:	"//	jsr sbstr   build substring value",
	7402	:	"//	brn scn12   back to exit with constant result",
	7403	:	"//scn19	mov scnpt wa  set updated scan pointer",
	7404	:	"//	erb 232 syntax error: unmatched string quote  ",
	7405	:	"//scn20	mov xr =t_fgo  set return code for fail goto",
	7406	:	"//	brn scn22   jump to merge",
	7407	:	"//scn21	mov xr =t_sgo  set success goto as return code",
	7408	:	"//scn22	bze scngo scn09  treat as normal letter if not goto",
	7409	:	"//scn23	bze wb scn10  jump if end of name/constant",
	7410	:	"//	mov xl xr  else copy code",
	7411	:	"//	brn scn13   and jump to exit",
	7412	:	"//scn24	bze wb scn09  part of name if scanning name",
	7413	:	"//	brn scn07   else illegal",
	7414	:	"//scn25	mov xr =t_lpr  set left paren return code",
	7415	:	"//	bnz wb scn23  return left paren unless name",
	7416	:	"//	bze wc scn10  delimiter if scanning constant",
	7417	:	"//	mov wb scnse  point to start of name",
	7418	:	"//	mov scnpt wa  set pointer past left paren",
	7419	:	"//	dcv wa   point back past last char of name",
	7420	:	"//	sub wa wb  get name length",
	7421	:	"//	mov xl r_cim  point to input image",
	7422	:	"//	jsr sbstr   get string name for function",
	7423	:	"//	jsr gtnvr   locate/build vrblk",
	7424	:	"//	mov xl =t_fnc  set code for function call",
	7425	:	"//	brn scn13   back to exit",
	7426	:	"//scn26	mov xr =t_rpr  right paren, set code",
	7427	:	"//	brn scn23   take special character exit",
	7428	:	"//scn27	mov xr =t_rbr  right bracket, set code",
	7429	:	"//	brn scn23   take special character exit",
	7430	:	"//scn28	mov xr =t_lbr  left bracket, set code",
	7431	:	"//	brn scn23   take special character exit",
	7432	:	"//scn29	mov xr =t_col  colon, set code",
	7433	:	"//	brn scn23   take special character exit",
	7434	:	"//scn30	mov xr =t_smc  semi-colon, set code",
	7435	:	"//	brn scn23   take special character exit",
	7436	:	"//scn31	mov xr =t_cma  comma, set code",
	7437	:	"//	brn scn23   take special character exit",
	7438	:	"//scn32	bze wb scn09  dot can be part of name or constant",
	7439	:	"//	add wc wb  else bump pointer",
	7440	:	"//scn33	bze wc scn09  plus can be part of constant",
	7441	:	"//	bze wb scn48  plus cannot be part of name",
	7442	:	"//	add wc wb  else bump pointer",
	7443	:	"//scn34	bze wc scn09  minus can be part of constant",
	7444	:	"//	bze wb scn48  minus cannot be part of name",
	7445	:	"//	add wc wb  else bump pointer",
	7446	:	"//scn35	add wc wb  not",
	7447	:	"//scn36	add wc wb  dollar",
	7448	:	"//scn37	add wc wb  exclamation",
	7449	:	"//scn38	add wc wb  percent",
	7450	:	"//scn39	add wc wb  asterisk",
	7451	:	"//scn40	add wc wb  slash",
	7452	:	"//scn41	add wc wb  number sign",
	7453	:	"//scn42	add wc wb  at sign",
	7454	:	"//scn43	add wc wb  vertical bar",
	7455	:	"//scn44	add wc wb  ampersand",
	7456	:	"//scn45	add wc wb  question mark",
	7457	:	"//scn46	bze wb scn10  operator terminates name/constant",
	7458	:	"//	mov xr wc  else copy dv pointer",
	7459	:	"//	lch wc (xl)  load next character",
	7460	:	"//	mov xl =t_bop  set binary op in case",
	7461	:	"//	beq wa scnil scn47 should be binary if image end",
	7462	:	"//	beq wc =ch_bl scn47 should be binary if followed by blk",
	7463	:	"//	beq wc =ch_ht scn47 jump if horizontal tab",
	7464	:	"//	beq wc =ch_sm scn47 semicolon can immediately follow =",
	7465	:	"//	beq wc =ch_cl scn47 colon can immediately follow =",
	7466	:	"//	beq wc =ch_rp scn47 right paren can immediately follow =",
	7467	:	"//	beq wc =ch_rb scn47 right bracket can immediately follow =",
	7468	:	"//	beq wc =ch_cb scn47 right bracket can immediately follow =",
	7469	:	"//	add xr *dvbs_  point to dv for unary op",
	7470	:	"//	mov xl =t_uop  set type for unary operator",
	7471	:	"//	ble scntp =t_uok scn13 ok unary if ok preceding element",
	7472	:	"//scn47	bnz scnbl scn13  all ok if preceding blanks, exit",
	7473	:	"//scn48	erb 233 syntax error: invalid use of operator  ",
	7474	:	"//scn49	bze wb scn10  end of name if scanning name",
	7475	:	"//	beq wa scnil scn39 not ** if * at image end",
	7476	:	"//	mov xr wa  else save offset past first *",
	7477	:	"//	mov scnof wa  save another copy",
	7478	:	"//	lch wa (xl)+  load next character",
	7479	:	"//	bne wa =ch_as scn50 not ** if next char not *",
	7480	:	"//	icv xr   else step offset past second *",
	7481	:	"//	beq xr scnil scn51 ok exclam if end of image",
	7482	:	"//	lch wa (xl)  else load next character",
	7483	:	"//	beq wa =ch_bl scn51 exclamation if blank",
	7484	:	"//	beq wa =ch_ht scn51 exclamation if horizontal tab",
	7485	:	"//scn50	mov wa scnof  recover stored offset",
	7486	:	"//	mov xl r_cim  point to line again",
	7487	:	"//	plc xl wa  point to current char",
	7488	:	"//	brn scn39   merge with unary *",
	7489	:	"//scn51	mov scnpt xr  save scan pointer past 2nd *",
	7490	:	"//	mov wa xr  copy scan pointer",
	7491	:	"//	brn scn37   merge with exclamation",
	7492	:	"//scngf	prc e 0  entry point",
	7493	:	"//	jsr scane   scan initial element",
	7494	:	"//	beq xl =t_lpr scng1 skip if left paren (normal goto)",
	7495	:	"//	beq xl =t_lbr scng2 skip if left bracket (direct goto)",
	7496	:	"//	erb 234 syntax error: goto field incorrect  ",
	7497	:	"//scng1	mov wb =num01  set expan flag for normal goto",
	7498	:	"//	jsr expan   analyze goto field",
	7499	:	"//	mov wa =opdvn  point to opdv for complex goto",
	7500	:	"//	ble xr statb scng3 jump if not in static (sgd15)",
	7501	:	"//	blo xr state scng4 jump to exit if simple label name",
	7502	:	"//	brn scng3   complex goto - merge",
	7503	:	"//scng2	mov wb =num02  set expan flag for direct goto",
	7504	:	"//	jsr expan   scan goto field",
	7505	:	"//	mov wa =opdvd  set opdv pointer for direct goto",
	7506	:	"//scng3	mov -(xs) wa  stack operator dv pointer",
	7507	:	"//	mov -(xs) xr  stack pointer to expression tree",
	7508	:	"//	jsr expop   pop operator off",
	7509	:	"//	mov xr (xs)+  reload new expression tree pointer",
	7510	:	"//scng4	exi    return to caller",
	7511	:	"//setvr	prc e 0  entry point",
	7512	:	"//	bhi xr state setv1 exit if not natural variable",
	7513	:	"//	mov xl xr  copy vrblk pointer",
	7514	:	"//	mov vrget(xr) =b_vrl  store normal get value",
	7515	:	"//	beq vrsto(xr) =b_vre setv1 skip if protected variable",
	7516	:	"//	mov vrsto(xr) =b_vrs  store normal store value",
	7517	:	"//	mov xl vrval(xl)  point to next entry on chain",
	7518	:	"//	bne (xl) =b_trt setv1 jump if end of trblk chain",
	7519	:	"//	mov vrget(xr) =b_vra  store trapped routine address",
	7520	:	"//	mov vrsto(xr) =b_vrv  set trapped routine address",
	7521	:	"//setv1	exi    return to setvr caller",
	7522	:	"//sorta	prc n 1  entry point",
	7523	:	"//	mov srtsr wa  sort/rsort indicator",
	7524	:	"//	mov srtst *num01  default stride of 1",
	7525	:	"//	zer srtof   default zero offset to sort key",
	7526	:	"//	mov srtdf =nulls  clear datatype field name",
	7527	:	"//	mov r_sxr (xs)+  unstack argument 2",
	7528	:	"//	mov xr (xs)+  get first argument",
	7529	:	"//	mnz wa   use key/values of table entries",
	7530	:	"//	jsr gtarr   convert to array",
	7531	:	"//	mov -(xs) xr  stack ptr to resulting key array",
	7532	:	"//	mov -(xs) xr  another copy for copyb",
	7533	:	"//	jsr copyb   get copy array for sorting into",
	7534	:	"//	mov -(xs) xr  stack pointer to sort array",
	7535	:	"//	mov xr r_sxr  get second arg",
	7536	:	"//	mov xl num01(xs)  get ptr to key array",
	7537	:	"//	bne (xl) =b_vct srt02 jump if arblk",
	7538	:	"//	beq xr =nulls srt01 jump if null second arg",
	7539	:	"//	jsr gtnvr   get vrblk ptr for it",
	7540	:	"//	mov srtdf xr  store datatype field name vrblk",
	7541	:	"//srt01	mov wc *vclen  offset to a(0)",
	7542	:	"//	mov wb *vcvls  offset to first item",
	7543	:	"//	mov wa vclen(xl)  get block length",
	7544	:	"//	sub wa *vcsi_  get no. of entries, n (in bytes)",
	7545	:	"//	brn srt04   merge",
	7546	:	"//srt02	ldi ardim(xl)   get possible dimension",
	7547	:	"//	mfi wa   convert to short integer",
	7548	:	"//	wtb wa   further convert to baus",
	7549	:	"//	mov wb *arvls  offset to first value if one",
	7550	:	"//	mov wc *arpro  offset before values if one dim.",
	7551	:	"//	beq arndm(xl) =num01 srt04 jump in fact if one dim.",
	7552	:	"//	bne arndm(xl) =num02 srt16 fail unless two dimens",
	7553	:	"//	ldi arlb2(xl)   get lower bound 2 as default",
	7554	:	"//	beq xr =nulls srt03 jump if default second arg",
	7555	:	"//	jsr gtint   convert to integer",
	7556	:	"//	ldi icval(xr)   get actual integer value",
	7557	:	"//srt03	sbi arlb2(xl)   subtract low bound",
	7558	:	"//	iov srt17   fail if overflow",
	7559	:	"//	ilt srt17   fail if below low bound",
	7560	:	"//	sbi ardm2(xl)   check against dimension",
	7561	:	"//	ige srt17   fail if too large",
	7562	:	"//	adi ardm2(xl)   restore value",
	7563	:	"//	mfi wa   get as small integer",
	7564	:	"//	wtb wa   offset within row to key",
	7565	:	"//	mov srtof wa  keep offset",
	7566	:	"//	ldi ardm2(xl)   second dimension is row length",
	7567	:	"//	mfi wa   convert to short integer",
	7568	:	"//	mov xr wa  copy row length",
	7569	:	"//	wtb wa   convert to bytes",
	7570	:	"//	mov srtst wa  store as stride",
	7571	:	"//	ldi ardim(xl)   get number of rows",
	7572	:	"//	mfi wa   as a short integer",
	7573	:	"//	wtb wa   convert n to baus",
	7574	:	"//	mov wc arlen(xl)  offset past array end",
	7575	:	"//	sub wc wa  adjust, giving space for n offsets",
	7576	:	"//	dca wc   point to a(0)",
	7577	:	"//	mov wb arofs(xl)  offset to word before first item",
	7578	:	"//	ica wb   offset to first item",
	7579	:	"//srt04	ble wa *num01 srt15 return if only a single item",
	7580	:	"//	mov srtsn wa  store number of items (in baus)",
	7581	:	"//	mov srtso wc  store offset to a(0)",
	7582	:	"//	mov wc arlen(xl)  length of array or vec (=vclen)",
	7583	:	"//	add wc xl  point past end of array or vector",
	7584	:	"//	mov srtsf wb  store offset to first row",
	7585	:	"//	add xl wb  point to first item in key array",
	7586	:	"//srt05	mov xr (xl)  get an entry",
	7587	:	"//srt06	bne (xr) =b_trt srt07 jump out if not trblk",
	7588	:	"//	mov xr trval(xr)  get value field",
	7589	:	"//	brn srt06   loop",
	7590	:	"//srt07	mov (xl)+ xr  store as array entry",
	7591	:	"//	blt xl wc srt05 loop if not done",
	7592	:	"//	mov xl (xs)  get adrs of sort array",
	7593	:	"//	mov xr srtsf  initial offset to first key",
	7594	:	"//	mov wb srtst  get stride",
	7595	:	"//	add xl srtso  offset to a(0)",
	7596	:	"//	ica xl   point to a(1)",
	7597	:	"//	mov wc srtsn  get n",
	7598	:	"//	btw wc   convert from bytes",
	7599	:	"//	mov srtnr wc  store as row count",
	7600	:	"//	lct wc wc  loop counter",
	7601	:	"//srt08	mov (xl)+ xr  store an offset",
	7602	:	"//	add xr wb  bump offset by stride",
	7603	:	"//	bct wc srt08  loop through rows",
	7604	:	"//srt09	mov wa srtsn  get n",
	7605	:	"//	mov wc srtnr  get number of rows",
	7606	:	"//	rsh wc 1  i = n / 2 (wc=i, index into array)",
	7607	:	"//	wtb wc   convert back to bytes",
	7608	:	"//srt10	jsr sorth   sorth(i,n)",
	7609	:	"//	dca wc   i = i - 1",
	7610	:	"//	bnz wc srt10  loop if i gt 0",
	7611	:	"//	mov wc wa  i = n",
	7612	:	"//srt11	dca wc   i = i - 1 (n - 1 initially)",
	7613	:	"//	bze wc srt12  jump if done",
	7614	:	"//	mov xr (xs)  get sort array address",
	7615	:	"//	add xr srtso  point to a(0)",
	7616	:	"//	mov xl xr  a(0) address",
	7617	:	"//	add xl wc  a(i) address",
	7618	:	"//	mov wb num01(xl)  copy a(i+1)",
	7619	:	"//	mov num01(xl) num01(xr)  move a(1) to a(i+1)",
	7620	:	"//	mov num01(xr) wb  complete exchange of a(1), a(i+1)",
	7621	:	"//	mov wa wc  n = i for sorth",
	7622	:	"//	mov wc *num01  i = 1 for sorth",
	7623	:	"//	jsr sorth   sorth(1,n)",
	7624	:	"//	mov wc wa  restore wc",
	7625	:	"//	brn srt11   loop",
	7626	:	"//srt12	mov xr (xs)  base adrs of key array",
	7627	:	"//	mov wc xr  copy it",
	7628	:	"//	add wc srtso  offset of a(0)",
	7629	:	"//	add xr srtsf  adrs of first row of sort array",
	7630	:	"//	mov wb srtst  get stride",
	7631	:	"//srt13	ica wc   adrs of next of sorted offsets",
	7632	:	"//	mov xl wc  copy it for access",
	7633	:	"//	mov xl (xl)  get offset",
	7634	:	"//	add xl num01(xs)  add key array base adrs",
	7635	:	"//	mov wa wb  get count of characters in row",
	7636	:	"//	mvw    copy a complete row",
	7637	:	"//	dcv srtnr   decrement row count",
	7638	:	"//	bnz srtnr srt13  repeat till all rows done",
	7639	:	"//srt15	mov xr (xs)+  pop result array ptr",
	7640	:	"//	ica xs   pop key array ptr",
	7641	:	"//	zer r_sxl   clear junk",
	7642	:	"//	zer r_sxr   clear junk",
	7643	:	"//	exi    return",
	7644	:	"//srt16	erb 256 sort/rsort 1st arg not suitable array or table  ",
	7645	:	"//srt17	erb 258 sort/rsort 2nd arg out of range or non-integer  ",
	7646	:	"//srt18	exi 1   return indication of null table",
	7647	:	"//sortc	prc e 1  entry point",
	7648	:	"//	mov srts1 wa  save offset 1",
	7649	:	"//	mov srts2 wb  save offset 2",
	7650	:	"//	mov srtsc wc  save wc",
	7651	:	"//	add xl srtof  add offset to comparand field",
	7652	:	"//	mov xr xl  copy base + offset",
	7653	:	"//	add xl wa  add key1 offset",
	7654	:	"//	add xr wb  add key2 offset",
	7655	:	"//	mov xl (xl)  get key1",
	7656	:	"//	mov xr (xr)  get key2",
	7657	:	"//	bne srtdf =nulls src12 jump if datatype field name used",
	7658	:	"//src01	mov wc (xl)  get type code",
	7659	:	"//	bne wc (xr) src02 skip if not same datatype",
	7660	:	"//	beq wc =b_scl src09 jump if both strings",
	7661	:	"//	beq wc =b_icl src14 jump if both integers",
	7662	:	"//src02	mov r_sxl xl  keep arg1",
	7663	:	"//	mov r_sxr xr  keep arg2",
	7664	:	"//	beq wc =b_scl src11 do not allow conversion to number",
	7665	:	"//	beq (xr) =b_scl src11 if either arg is a string",
	7666	:	"//src14	mov -(xs) xl  stack",
	7667	:	"//	mov -(xs) xr  args",
	7668	:	"//	jsr acomp   compare objects",
	7669	:	"//src03	bnz srtsr src06  jump if rsort",
	7670	:	"//src04	mov wc srtsc  restore wc",
	7671	:	"//	exi 1   return",
	7672	:	"//src05	bnz srtsr src04  jump if rsort",
	7673	:	"//src06	mov wc srtsc  restore wc",
	7674	:	"//	exi    return",
	7675	:	"//src07	blt xl xr src03 item first created is less",
	7676	:	"//	bgt xl xr src05 addresses rise in order of creation",
	7677	:	"//src08	blt srts1 srts2 src04 test offsets or key addrss instead",
	7678	:	"//	brn src06   offset 1 greater",
	7679	:	"//src09	mov -(xs) xl  stack",
	7680	:	"//	mov -(xs) xr  args",
	7681	:	"//	jsr lcomp   compare objects",
	7682	:	"//src10	mov xl r_sxl  get arg1",
	7683	:	"//	mov xr r_sxr  get arg2",
	7684	:	"//	mov wc (xl)  get type of key1",
	7685	:	"//	beq wc (xr) src07 jump if keys of same type",
	7686	:	"//src11	mov xl wc  get block type word",
	7687	:	"//	mov xr (xr)  get block type word",
	7688	:	"//	lei xl   entry point id for key1",
	7689	:	"//	lei xr   entry point id for key2",
	7690	:	"//	bgt xl xr src05 jump if key1 gt key2",
	7691	:	"//	brn src03   key1 lt key2",
	7692	:	"//src12	jsr sortf   call routine to find field 1",
	7693	:	"//	mov -(xs) xl  stack item pointer",
	7694	:	"//	mov xl xr  get key2",
	7695	:	"//	jsr sortf   find field 2",
	7696	:	"//	mov xr xl  place as key2",
	7697	:	"//	mov xl (xs)+  recover key1",
	7698	:	"//	brn src01   merge",
	7699	:	"//sortf	prc e 0  entry point",
	7700	:	"//	bne (xl) =b_pdt srtf3 return if not pdblk",
	7701	:	"//	mov -(xs) xr  keep xr",
	7702	:	"//	mov xr srtfd  get possible former dfblk ptr",
	7703	:	"//	bze xr srtf4  jump if not",
	7704	:	"//	bne xr pddfp(xl) srtf4 jump if not right datatype",
	7705	:	"//	bne srtdf srtff srtf4 jump if not right field name",
	7706	:	"//	add xl srtfo  add offset to required field",
	7707	:	"//srtf1	mov xl (xl)  get item from field",
	7708	:	"//srtf2	mov xr (xs)+  restore xr",
	7709	:	"//srtf3	exi    return",
	7710	:	"//srtf4	mov xr xl  copy original pointer",
	7711	:	"//	mov xr pddfp(xr)  point to dfblk",
	7712	:	"//	mov srtfd xr  keep a copy",
	7713	:	"//	mov wc fargs(xr)  get number of fields",
	7714	:	"//	wtb wc   convert to bytes",
	7715	:	"//	add xr dflen(xr)  point past last field",
	7716	:	"//srtf5	dca wc   count down",
	7717	:	"//	dca xr   point in front",
	7718	:	"//	beq (xr) srtdf srtf6 skip out if found",
	7719	:	"//	bnz wc srtf5  loop",
	7720	:	"//	brn srtf2   return - not found",
	7721	:	"//srtf6	mov srtff (xr)  keep field name ptr",
	7722	:	"//	add wc *pdfld  add offset to first field",
	7723	:	"//	mov srtfo wc  store as field offset",
	7724	:	"//	add xl wc  point to field",
	7725	:	"//	brn srtf1   return",
	7726	:	"//sorth	prc n 0  entry point",
	7727	:	"//	mov srtsn wa  save n",
	7728	:	"//	mov srtwc wc  keep wc",
	7729	:	"//	mov xl (xs)  sort array base adrs",
	7730	:	"//	add xl srtso  add offset to a(0)",
	7731	:	"//	add xl wc  point to a(j)",
	7732	:	"//	mov srtrt (xl)  get offset to root",
	7733	:	"//	add wc wc  double j - cant exceed n",
	7734	:	"//srh01	bgt wc srtsn srh03 done if j gt n",
	7735	:	"//	beq wc srtsn srh02 skip if j equals n",
	7736	:	"//	mov xr (xs)  sort array base adrs",
	7737	:	"//	mov xl num01(xs)  key array base adrs",
	7738	:	"//	add xr srtso  point to a(0)",
	7739	:	"//	add xr wc  adrs of a(j)",
	7740	:	"//	mov wa num01(xr)  get a(j+1)",
	7741	:	"//	mov wb (xr)  get a(j)",
	7742	:	"//	jsr sortc   compare keys - lt(a(j+1),a(j))",
	7743	:	"//	ica wc   point to greater son, a(j+1)",
	7744	:	"//srh02	mov xl num01(xs)  key array base adrs",
	7745	:	"//	mov xr (xs)  get sort array address",
	7746	:	"//	add xr srtso  adrs of a(0)",
	7747	:	"//	mov wb xr  copy this adrs",
	7748	:	"//	add xr wc  adrs of greater son, a(j)",
	7749	:	"//	mov wa (xr)  get a(j)",
	7750	:	"//	mov xr wb  point back to a(0)",
	7751	:	"//	mov wb srtrt  get root",
	7752	:	"//	jsr sortc   compare them - lt(a(j),root)",
	7753	:	"//	mov xr (xs)  get sort array adrs",
	7754	:	"//	add xr srtso  point to a(0)",
	7755	:	"//	mov xl xr  copy it",
	7756	:	"//	mov wa wc  copy j",
	7757	:	"//	btw wc   convert to words",
	7758	:	"//	rsh wc 1  get j/2",
	7759	:	"//	wtb wc   convert back to bytes",
	7760	:	"//	add xl wa  point to a(j)",
	7761	:	"//	add xr wc  adrs of a(j/2)",
	7762	:	"//	mov (xr) (xl)  a(j/2) = a(j)",
	7763	:	"//	mov wc wa  recover j",
	7764	:	"//	aov wc wc srh03 j = j*2. done if too big",
	7765	:	"//	brn srh01   loop",
	7766	:	"//srh03	btw wc   convert to words",
	7767	:	"//	rsh wc 1  j = j/2",
	7768	:	"//	wtb wc   convert back to bytes",
	7769	:	"//	mov xr (xs)  sort array adrs",
	7770	:	"//	add xr srtso  adrs of a(0)",
	7771	:	"//	add xr wc  adrs of a(j/2)",
	7772	:	"//	mov (xr) srtrt  a(j/2) = root",
	7773	:	"//	mov wa srtsn  restore wa",
	7774	:	"//	mov wc srtwc  restore wc",
	7775	:	"//	exi    return",
	7776	:	"//trace	prc n 2  entry point",
	7777	:	"//	jsr gtstg   get trace type string",
	7778	:	"//	plc xr   else point to string",
	7779	:	"//	lch wa (xr)  load first character",
	7780	:	"//	mov xr (xs)  load name argument",
	7781	:	"//	mov (xs) xl  stack trblk ptr or zero",
	7782	:	"//	mov wc =trtac  set trtyp for access trace",
	7783	:	"//	beq wa =ch_la trc10 jump if a (access)",
	7784	:	"//	mov wc =trtvl  set trtyp for value trace",
	7785	:	"//	beq wa =ch_lv trc10 jump if v (value)",
	7786	:	"//	beq wa =ch_bl trc10 jump if blank (value)",
	7787	:	"//	beq wa =ch_lf trc01 jump if f (function)",
	7788	:	"//	beq wa =ch_lr trc01 jump if r (return)",
	7789	:	"//	beq wa =ch_ll trc03 jump if l (label)",
	7790	:	"//	beq wa =ch_lk trc06 jump if k (keyword)",
	7791	:	"//	bne wa =ch_lc trc15 else error if not c (call)",
	7792	:	"//trc01	jsr gtnvr   point to vrblk for name",
	7793	:	"//	ica xs   pop stack",
	7794	:	"//	mov xr vrfnc(xr)  point to function block",
	7795	:	"//	bne (xr) =b_pfc trc17 error if not program function",
	7796	:	"//	beq wa =ch_lr trc02 jump if r (return)",
	7797	:	"//	mov pfctr(xr) xl  set/reset call trace",
	7798	:	"//	beq wa =ch_lc exnul exit with null if c (call)",
	7799	:	"//trc02	mov pfrtr(xr) xl  set/reset return trace",
	7800	:	"//	exi    return",
	7801	:	"//trc03	jsr gtnvr   point to vrblk",
	7802	:	"//	mov xl vrlbl(xr)  load label pointer",
	7803	:	"//	bne (xl) =b_trt trc04 jump if no old trace",
	7804	:	"//	mov xl trlbl(xl)  else delete old trace association",
	7805	:	"//trc04	beq xl =stndl trc16 error if undefined label",
	7806	:	"//	mov wb (xs)+  get trblk ptr again",
	7807	:	"//	bze wb trc05  jump if stoptr case",
	7808	:	"//	mov vrlbl(xr) wb  else set new trblk pointer",
	7809	:	"//	mov vrtra(xr) =b_vrt  set label trace routine address",
	7810	:	"//	mov xr wb  copy trblk pointer",
	7811	:	"//	mov trlbl(xr) xl  store real label in trblk",
	7812	:	"//	exi    return",
	7813	:	"//trc05	mov vrlbl(xr) xl  store label ptr back in vrblk",
	7814	:	"//	mov vrtra(xr) =b_vrg  store normal transfer address",
	7815	:	"//	exi    return",
	7816	:	"//trc06	jsr gtnvr   point to vrblk",
	7817	:	"//	bnz vrlen(xr) trc16  error if not system var",
	7818	:	"//	ica xs   pop stack",
	7819	:	"//	bze xl trc07  jump if stoptr case",
	7820	:	"//	mov trkvr(xl) xr  store vrblk ptr in trblk for ktrex",
	7821	:	"//trc07	mov xr vrsvp(xr)  point to svblk",
	7822	:	"//	beq xr =v_ert trc08 jump if errtype",
	7823	:	"//	beq xr =v_stc trc09 jump if stcount",
	7824	:	"//	bne xr =v_fnc trc17 else error if not fnclevel",
	7825	:	"//	mov r_fnc xl  set/reset fnclevel trace",
	7826	:	"//	exi    return",
	7827	:	"//trc08	mov r_ert xl  set/reset errtype trace",
	7828	:	"//	exi    return",
	7829	:	"//trc09	mov r_stc xl  set/reset stcount trace",
	7830	:	"//	jsr stgcc   update countdown counters",
	7831	:	"//	exi    return",
	7832	:	"//trc10	jsr gtvar   locate variable",
	7833	:	"//	mov wb (xs)+  get new trblk ptr again",
	7834	:	"//	add wa xl  point to variable location",
	7835	:	"//	mov xr wa  copy variable pointer",
	7836	:	"//trc11	mov xl (xr)  point to next entry",
	7837	:	"//	bne (xl) =b_trt trc13 jump if not trblk",
	7838	:	"//	blt wc trtyp(xl) trc13 jump if too far out on chain",
	7839	:	"//	beq wc trtyp(xl) trc12 jump if this matches our type",
	7840	:	"//	add xl *trnxt  else point to link field",
	7841	:	"//	mov xr xl  copy pointer",
	7842	:	"//	brn trc11   and loop back",
	7843	:	"//trc12	mov xl trnxt(xl)  get ptr to next block or value",
	7844	:	"//	mov (xr) xl  store to delete this trblk",
	7845	:	"//trc13	bze wb trc14  jump if stoptr case",
	7846	:	"//	mov (xr) wb  else link new trblk in",
	7847	:	"//	mov xr wb  copy trblk pointer",
	7848	:	"//	mov trnxt(xr) xl  store forward pointer",
	7849	:	"//	mov trtyp(xr) wc  store appropriate trap type code",
	7850	:	"//trc14	mov xr wa  recall possible vrblk pointer",
	7851	:	"//	sub xr *vrval  point back to vrblk",
	7852	:	"//	jsr setvr   set fields if vrblk",
	7853	:	"//	exi    return",
	7854	:	"//trc15	exi 2   take bad trace type error exit",
	7855	:	"//trc16	ica xs   pop stack",
	7856	:	"//trc17	exi 1   take bad name error exit",
	7857	:	"//trbld	prc e 0  entry point",
	7858	:	"//	mov -(xs) xr  stack trtag (or trfnm)",
	7859	:	"//	mov wa *trsi_  set size of trblk",
	7860	:	"//	jsr alloc   allocate trblk",
	7861	:	"//	mov (xr) =b_trt  store first word",
	7862	:	"//	mov trfnc(xr) xl  store trfnc (or trfpt)",
	7863	:	"//	mov trtag(xr) (xs)+  store trtag (or trfnm)",
	7864	:	"//	mov trtyp(xr) wb  store type",
	7865	:	"//	mov trval(xr) =nulls  for now, a null value",
	7866	:	"//	exi    return to caller",
	7867	:	"//trimr	prc e 0  entry point",
	7868	:	"//	mov xl xr  copy string pointer",
	7869	:	"//	mov wa sclen(xr)  load string length",
	7870	:	"//	bze wa trim2  jump if null input",
	7871	:	"//	plc xl wa  else point past last character",
	7872	:	"//	bze wb trim3  jump if no trim",
	7873	:	"//	mov wc =ch_bl  load blank character",
	7874	:	"//trim0	lch wb -(xl)  load next character",
	7875	:	"//	beq wb =ch_ht trim1 jump if horizontal tab",
	7876	:	"//	bne wb wc trim3 jump if non-blank found",
	7877	:	"//trim1	dcv wa   else decrement character count",
	7878	:	"//	bnz wa trim0  loop back if more to check",
	7879	:	"//trim2	mov dnamp xr  wipe out input string block",
	7880	:	"//	mov xr =nulls  load null result",
	7881	:	"//	brn trim5   merge to exit",
	7882	:	"//trim3	mov sclen(xr) wa  set new length",
	7883	:	"//	mov xl xr  copy string pointer",
	7884	:	"//	psc xl wa  ready for storing blanks",
	7885	:	"//	ctb wa schar  get length of block in bytes",
	7886	:	"//	add wa xr  point past new block",
	7887	:	"//	mov dnamp wa  set new top of storage pointer",
	7888	:	"//	lct wa =cfp_c  get count of chars in word",
	7889	:	"//	zer wc   set zero char",
	7890	:	"//trim4	sch wc (xl)+  store zero character",
	7891	:	"//	bct wa trim4  loop back till all stored",
	7892	:	"//	csc xl   complete store characters",
	7893	:	"//trim5	zer xl   clear garbage xl pointer",
	7894	:	"//	exi    return to caller",
	7895	:	"//trxeq	prc r 0  entry point (recursive)",
	7896	:	"//	mov wc r_cod  load code block pointer",
	7897	:	"//	scp wb   get current code pointer",
	7898	:	"//	sub wb wc  make code pointer into offset",
	7899	:	"//	mov -(xs) kvtra  stack trace keyword value",
	7900	:	"//	mov -(xs) xr  stack trblk pointer",
	7901	:	"//	mov -(xs) xl  stack name base",
	7902	:	"//	mov -(xs) wa  stack name offset",
	7903	:	"//	mov -(xs) wc  stack code block pointer",
	7904	:	"//	mov -(xs) wb  stack code pointer offset",
	7905	:	"//	mov -(xs) flptr  stack old failure pointer",
	7906	:	"//	zer -(xs)   set dummy fail offset",
	7907	:	"//	mov flptr xs  set new failure pointer",
	7908	:	"//	zer kvtra   reset trace keyword to zero",
	7909	:	"//	mov wc =trxdc  load new (dummy) code blk pointer",
	7910	:	"//	mov r_cod wc  set as code block pointer",
	7911	:	"//	lcp wc   and new code pointer",
	7912	:	"//	mov wb wa  save name offset",
	7913	:	"//	mov wa *nmsi_  load nmblk size",
	7914	:	"//	jsr alloc   allocate space for nmblk",
	7915	:	"//	mov (xr) =b_nml  set type word",
	7916	:	"//	mov nmbas(xr) xl  store name base",
	7917	:	"//	mov nmofs(xr) wb  store name offset",
	7918	:	"//	mov xl 6(xs)  reload pointer to trblk",
	7919	:	"//	mov -(xs) xr  stack nmblk pointer (1st argument)",
	7920	:	"//	mov -(xs) trtag(xl)  stack trace tag (2nd argument)",
	7921	:	"//	mov xl trfnc(xl)  load trace vrblk pointer",
	7922	:	"//	mov xl vrfnc(xl)  load trace function pointer",
	7923	:	"//	beq xl =stndf trxq2 jump if not a defined function",
	7924	:	"//	mov wa =num02  set number of arguments to two",
	7925	:	"//	brn cfunc   jump to call function",
	7926	:	"//trxq1	mov xs flptr  point back to our stack entries",
	7927	:	"//	ica xs   pop off garbage fail offset",
	7928	:	"//	mov flptr (xs)+  restore old failure pointer",
	7929	:	"//	mov wb (xs)+  reload code offset",
	7930	:	"//	mov wc (xs)+  load old code base pointer",
	7931	:	"//	mov xr wc  copy cdblk pointer",
	7932	:	"//	mov kvstn cdstm(xr)  restore stmnt no",
	7933	:	"//	mov wa (xs)+  reload name offset",
	7934	:	"//	mov xl (xs)+  reload name base",
	7935	:	"//	mov xr (xs)+  reload trblk pointer",
	7936	:	"//	mov kvtra (xs)+  restore trace keyword value",
	7937	:	"//	add wb wc  recompute absolute code pointer",
	7938	:	"//	lcp wb   restore code pointer",
	7939	:	"//	mov r_cod wc  and code block pointer",
	7940	:	"//	exi    return to trxeq caller",
	7941	:	"//trxq2	erb 197 trace fourth arg is not function name or null  ",
	7942	:	"//xscan	prc e 0  entry point",
	7943	:	"//	mov xscwb wb  preserve wb",
	7944	:	"//	mov -(xs) wa  record blank skip flag",
	7945	:	"//	mov -(xs) wa  and second copy",
	7946	:	"//	mov xr r_xsc  point to argument string",
	7947	:	"//	mov wa sclen(xr)  load string length",
	7948	:	"//	mov wb xsofs  load current offset",
	7949	:	"//	sub wa wb  get number of remaining characters",
	7950	:	"//	bze wa xscn3  jump if no characters left",
	7951	:	"//	plc xr wb  point to current character",
	7952	:	"//xscn1	lch wb (xr)+  load next character",
	7953	:	"//	beq wb wc xscn4 jump if delimiter one found",
	7954	:	"//	beq wb xl xscn5 jump if delimiter two found",
	7955	:	"//	bze (xs) xscn2  jump if not skipping blanks",
	7956	:	"//	icv xsofs   assume blank and delete it",
	7957	:	"//	beq wb =ch_ht xscn2 jump if horizontal tab",
	7958	:	"//	beq wb =ch_bl xscn2 jump if blank",
	7959	:	"//	dcv xsofs   undelete non-blank character",
	7960	:	"//	zer (xs)   and discontinue blank checking",
	7961	:	"//xscn2	dcv wa   decrement count of chars left",
	7962	:	"//	bnz wa xscn1  loop back if more chars to go",
	7963	:	"//xscn3	mov xl r_xsc  point to string block",
	7964	:	"//	mov wa sclen(xl)  get string length",
	7965	:	"//	mov wb xsofs  load offset",
	7966	:	"//	sub wa wb  get substring length",
	7967	:	"//	zer r_xsc   clear string ptr for collector",
	7968	:	"//	zer xscrt   set zero (runout) return code",
	7969	:	"//	brn xscn7   jump to exit",
	7970	:	"//xscn4	mov xscrt =num01  set return code",
	7971	:	"//	brn xscn6   jump to merge",
	7972	:	"//xscn5	mov xscrt =num02  set return code",
	7973	:	"//xscn6	mov xl r_xsc  reload pointer to string",
	7974	:	"//	mov wc sclen(xl)  get original length of string",
	7975	:	"//	sub wc wa  minus chars left = chars scanned",
	7976	:	"//	mov wa wc  move to reg for sbstr",
	7977	:	"//	mov wb xsofs  set offset",
	7978	:	"//	sub wa wb  compute length for sbstr",
	7979	:	"//	icv wc   adjust new cursor past delimiter",
	7980	:	"//	mov xsofs wc  store new offset",
	7981	:	"//xscn7	zer xr   clear garbage character ptr in xr",
	7982	:	"//	jsr sbstr   build sub-string",
	7983	:	"//	ica xs   remove copy of blank flag",
	7984	:	"//	mov wb (xs)+  original blank skip/trim flag",
	7985	:	"//	bze sclen(xr) xscn8  cannot trim the null string",
	7986	:	"//	jsr trimr   trim trailing blanks if requested",
	7987	:	"//xscn8	mov wa xscrt  load return code",
	7988	:	"//	mov wb xscwb  restore wb",
	7989	:	"//	exi    return to xscan caller",
	7990	:	"//xscni	prc n 2  entry point",
	7991	:	"//	jsr gtstg   fetch argument as string",
	7992	:	"//	mov r_xsc xr  else store scblk ptr for xscan",
	7993	:	"//	zer xsofs   set offset to zero",
	7994	:	"//	bze wa xsci2  jump if null string",
	7995	:	"//	exi    return to xscni caller",
	7996	:	"//xsci1	exi 1   take not-string error exit",
	7997	:	"//xsci2	exi 2   take null-string error exit",
	7998	:	"//	sec    start of stack overflow section",
	7999	:	"//	add errft =num04  force conclusive fatal error",
	8000	:	"//	mov xs flptr  pop stack to avoid more fails",
	8001	:	"//	bnz gbcfl stak1  jump if garbage collecting",
	8002	:	"//	erb 246 stack overflow  ",
	8003	:	"//stak1	mov xr =endso  point to message",
	8004	:	"//	zer kvdmp   memory is undumpable",
	8005	:	"//	brn stopr   give up",
	8006	:	"//	sec    start of error section",
	8007	:	"//error	beq r_cim =cmlab cmple jump if error in scanning label",
	8008	:	"//	mov kvert wa  save error code",
	8009	:	"//	zer scnrs   reset rescan switch for scane",
	8010	:	"//	zer scngo   reset goto switch for scane",
	8011	:	"//	mov polcs =num01  reset poll count",
	8012	:	"//	mov polct =num01  reset poll count",
	8013	:	"//	mov xr stage  load current stage",
	8014	:	"//	bsw xr stgno  jump to appropriate error circuit",
	8015	:	"//err01	mov xs cmpxs  reset stack pointer",
	8016	:	"//	ssl cmpss   restore s-r stack ptr for cmpil",
	8017	:	"//	bnz errsp err03  jump if error suppress flag set",
	8018	:	"//	mov wc cmpsn  current statement",
	8019	:	"//	jsr filnm   obtain file name for this statement",
	8020	:	"//	mov wb scnse  column number",
	8021	:	"//	mov wc rdcln  line number",
	8022	:	"//	mov xr stage  ",
	8023	:	"//	jsr sysea   advise system of error",
	8024	:	"//	mov -(xs) xr  save any provided print message",
	8025	:	"//	mov erlst erich  set flag for listr",
	8026	:	"//	jsr listr   list line",
	8027	:	"//	jsr prtis   terminate listing",
	8028	:	"//	zer erlst   clear listr flag",
	8029	:	"//	mov wa scnse  load scan element offset",
	8030	:	"//	bze wa err02  skip if not set",
	8031	:	"//	lct wb wa  loop counter",
	8032	:	"//	icv wa   increase for ch_ex",
	8033	:	"//	mov xl r_cim  point to bad statement",
	8034	:	"//	jsr alocs   string block for error flag",
	8035	:	"//	mov wa xr  remember string ptr",
	8036	:	"//	psc xr   ready for character storing",
	8037	:	"//	plc xl   ready to get chars",
	8038	:	"//erra1	lch wc (xl)+  get next char",
	8039	:	"//	beq wc =ch_ht erra2 skip if tab",
	8040	:	"//	mov wc =ch_bl  get a blank",
	8041	:	"//erra2	sch wc (xr)+  store char",
	8042	:	"//	bct wb erra1  loop",
	8043	:	"//	mov xl =ch_ex  exclamation mark",
	8044	:	"//	sch xl (xr)  store at end of error line",
	8045	:	"//	csc xr   end of sch loop",
	8046	:	"//	mov profs =stnpd  allow for statement number",
	8047	:	"//	mov xr wa  point to error line",
	8048	:	"//	jsr prtst   print error line",
	8049	:	"//err02	jsr prtis   print blank line",
	8050	:	"//	mov xr (xs)+  restore any sysea message",
	8051	:	"//	bze xr erra0  did sysea provide message to print",
	8052	:	"//	jsr prtst   print sysea message",
	8053	:	"//erra0	jsr ermsg   generate flag and error message",
	8054	:	"//	add lstlc =num03  bump page ctr for blank, error, blk",
	8055	:	"//erra3	zer xr   in case of fatal error",
	8056	:	"//	bhi errft =num03 stopr pack up if several fatals",
	8057	:	"//	icv cmerc   bump error count",
	8058	:	"//	add noxeq cswer  inhibit xeq if -noerrors",
	8059	:	"//	bne stage =stgic cmp10 special return if after end line",
	8060	:	"//err03	mov xr r_cim  point to start of image",
	8061	:	"//	plc xr   point to first char",
	8062	:	"//	lch xr (xr)  get first char",
	8063	:	"//	beq xr =ch_mn cmpce jump if error in control card",
	8064	:	"//	zer scnrs   clear rescan flag",
	8065	:	"//	mnz errsp   set error suppress flag",
	8066	:	"//	jsr scane   scan next element",
	8067	:	"//	bne xl =t_smc err03 loop back if not statement end",
	8068	:	"//	zer errsp   clear error suppress flag",
	8069	:	"//	mov cwcof *cdcod  reset offset in ccblk",
	8070	:	"//	mov wa =ocer_  load compile error call",
	8071	:	"//	jsr cdwrd   generate it",
	8072	:	"//	mov cmsoc(xs) cwcof  set success fill in offset",
	8073	:	"//	mnz cmffc(xs)   set failure fill in flag",
	8074	:	"//	jsr cdwrd   generate succ. fill in word",
	8075	:	"//	brn cmpse   merge to generate error as cdfal",
	8076	:	"//err04	bge errft =num03 labo1 abort if too many fatal errors",
	8077	:	"//	beq kvert =nm320 err06 treat user interrupt specially",
	8078	:	"//	zer r_ccb   forget garbage code block",
	8079	:	"//	mov cwcof *cccod  set initial offset (mbe catspaw)",
	8080	:	"//	ssl iniss   restore main prog s-r stack ptr",
	8081	:	"//	jsr ertex   get fail message text",
	8082	:	"//	dca xs   ensure stack ok on loop start",
	8083	:	"//erra4	ica xs   pop stack",
	8084	:	"//	beq xs flprt errc4 jump if prog defined fn call found",
	8085	:	"//	bne xs gtcef erra4 loop if not eval or code call yet",
	8086	:	"//	mov stage =stgxt  re-set stage for execute",
	8087	:	"//	mov r_cod r_gtc  recover code ptr",
	8088	:	"//	mov flptr xs  restore fail pointer",
	8089	:	"//	zer r_cim   forget possible image",
	8090	:	"//	zer cnind   forget possible include",
	8091	:	"//errb4	bnz kverl err07  jump if errlimit non-zero",
	8092	:	"//	brn exfal   fail",
	8093	:	"//errc4	mov xs flptr  restore stack from flptr",
	8094	:	"//	brn errb4   merge",
	8095	:	"//err05	ssl iniss   restore main prog s-r stack ptr",
	8096	:	"//	bnz dmvch err08  jump if in mid-dump",
	8097	:	"//err06	bze kverl labo1  abort if errlimit is zero",
	8098	:	"//	jsr ertex   get fail message text",
	8099	:	"//err07	bge errft =num03 labo1 abort if too many fatal errors",
	8100	:	"//	dcv kverl   decrement errlimit",
	8101	:	"//	mov xl r_ert  load errtype trace pointer",
	8102	:	"//	jsr ktrex   generate errtype trace if required",
	8103	:	"//	mov wa r_cod  get current code block",
	8104	:	"//	mov r_cnt wa  set cdblk ptr for continuation",
	8105	:	"//	scp wb   current code pointer",
	8106	:	"//	sub wb wa  offset within code block",
	8107	:	"//	mov stxoc wb  save code ptr offset for scontinue",
	8108	:	"//	mov xr flptr  set ptr to failure offset",
	8109	:	"//	mov stxof (xr)  save failure offset for continue",
	8110	:	"//	mov xr r_sxc  load setexit cdblk pointer",
	8111	:	"//	bze xr lcnt1  continue if no setexit trap",
	8112	:	"//	zer r_sxc   else reset trap",
	8113	:	"//	mov stxvr =nulls  reset setexit arg to null",
	8114	:	"//	mov xl (xr)  load ptr to code block routine",
	8115	:	"//	bri xl   execute first trap statement",
	8116	:	"//err08	mov xr dmvch  chain head for affected vrblks",
	8117	:	"//	bze xr err06  done if zero",
	8118	:	"//	mov dmvch (xr)  set next link as chain head",
	8119	:	"//	jsr setvr   restore vrget field",
	8120	:	"//s_yyy	brn err08   loop through chain",
}
